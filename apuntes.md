# programaciondam2526

**Author:** Jose Vicente Carratala Sanchis

## Table of contents

- [Identificación de los elementos de un programa informático](#identificacion-de-los-elementos-de-un-programa-informatico)
  - [Estructura y bloques fundamentales](#estructura-y-bloques-fundamentales)
  - [Variables](#variables)
  - [Tipos de datos](#tipos-de-datos)
  - [Literales](#literales)
  - [Constantes](#constantes)
  - [Operadores y expresiones](#operadores-y-expresiones)
  - [Ejercicio de final de unidad](#ejercicio-de-final-de-unidad)
- [Utilización de objetos](#utilizacion-de-objetos)
  - [Características de los objetos](#caracteristicas-de-los-objetos)
  - [Instanciación de objetos](#instanciacion-de-objetos)
  - [Utilización de métodos. Parámetros](#utilizacion-de-metodos-parametros)
  - [Utilización de propiedades](#utilizacion-de-propiedades)
  - [Utilización de métodos estáticos](#utilizacion-de-metodos-estaticos)
  - [Constructores](#constructores)
  - [Destrucción de objetos y liberación de memoria](#destruccion-de-objetos-y-liberacion-de-memoria)
  - [Ejercicio de final de unidad](#ejercicio-de-final-de-unidad-1)
- [Uso de estructuras de control](#uso-de-estructuras-de-control)
  - [Estructuras de selección](#estructuras-de-seleccion)
  - [Estructuras de repetición](#estructuras-de-repeticion)
  - [Estructuras de salto](#estructuras-de-salto)
  - [Control de excepciones](#control-de-excepciones)
  - [Aserciones](#aserciones)
  - [Prueba, depuración y documentación de la aplicación](#prueba-depuracion-y-documentacion-de-la-aplicacion)
  - [Ejercicio](#ejercicio)
  - [Ejercicio de final de unidad](#ejercicio-de-final-de-unidad-2)
- [Desarrollo de clases](#desarrollo-de-clases)
  - [Concepto de clase](#concepto-de-clase)
  - [Estructura y miembros de una clase. Visibilidad](#estructura-y-miembros-de-una-clase-visibilidad)
  - [Creación de propiedades](#creacion-de-propiedades)
  - [Creación de métodos](#creacion-de-metodos)
  - [Creación de constructores](#creacion-de-constructores)
  - [Utilización de clases y objetos](#utilizacion-de-clases-y-objetos)
  - [Utilización de clases heredadas](#utilizacion-de-clases-heredadas)
  - [Ejercicio de final de unidad](#ejercicio-de-final-de-unidad-3)
- [Lectura y escritura de información](#lectura-y-escritura-de-informacion)
  - [Flujos. Tipos bytes y caracteres. Clases relacionadas](#flujos-tipos-bytes-y-caracteres-clases-relacionadas)
  - [Ficheros de datos. Registros](#ficheros-de-datos-registros)
  - [Apertura y cierre de ficheros. Modos de acceso. Escritura y lectura de información en ficheros](#apertura-y-cierre-de-ficheros-modos-de-acceso-escritura-y-lectura-de-informacion-en-ficheros)
  - [Utilización de los sistemas de ficheros.](#utilizacion-de-los-sistemas-de-ficheros)
  - [Creación y eliminación de ficheros y directorios](#creacion-y-eliminacion-de-ficheros-y-directorios)
  - [Entrada desde teclado. Salida a pantalla. Formatos de visualización](#entrada-desde-teclado-salida-a-pantalla-formatos-de-visualizacion)
  - [Interfaces gráficas](#interfaces-graficas)
  - [Concepto de evento](#concepto-de-evento)
  - [Creación de controladores de eventos](#creacion-de-controladores-de-eventos)
  - [- Simulacro examen miercoles](#simulacro-examen-miercoles)
  - [Ejercicio de final de unidad](#ejercicio-de-final-de-unidad-4)
  - [Examen final](#examen-final)
  - [Carpeta sin título](#carpeta-sin-titulo)
- [Aplicación de las estructuras de almacenamiento](#aplicacion-de-las-estructuras-de-almacenamiento)
  - [Estructuras estáticas y dinámicas](#estructuras-estaticas-y-dinamicas)
  - [Creación de matrices (arrays)](#creacion-de-matrices-arrays)
  - [Matrices (arrays) multidimensionales](#matrices-arrays-multidimensionales)
  - [Genericidad](#genericidad)
  - [Cadenas de caracteres. Expresiones regulares](#cadenas-de-caracteres-expresiones-regulares)
  - [Colecciones Listas, Conjuntos y Diccionarios](#colecciones-listas-conjuntos-y-diccionarios)
  - [Operaciones agregadas filtrado, reducción y recolección](#operaciones-agregadas-filtrado-reduccion-y-recoleccion)
- [Utilización avanzada de clases](#utilizacion-avanzada-de-clases)
  - [Repaso](#repaso)
  - [Composición de clases](#composicion-de-clases)
  - [Herencia y polimorfismo](#herencia-y-polimorfismo)
  - [Jerarquía de clases Superclases y subclases](#jerarquia-de-clases-superclases-y-subclases)
  - [Clases y métodos abstractos y finales](#clases-y-metodos-abstractos-y-finales)
  - [Interfaces](#interfaces)
  - [Sobreescritura de métodos](#sobreescritura-de-metodos)
  - [Constructores y herencia](#constructores-y-herencia)
- [Mantenimiento de la persistencia de los objetos](#mantenimiento-de-la-persistencia-de-los-objetos)
  - [Bases de datos orientadas a objetos](#bases-de-datos-orientadas-a-objetos)
  - [Características de las bases de datos orientadas a objetos](#caracteristicas-de-las-bases-de-datos-orientadas-a-objetos)
  - [Instalación del gestor de bases de datos](#instalacion-del-gestor-de-bases-de-datos)
  - [Creación de bases de datos](#creacion-de-bases-de-datos)
  - [Mecanismos de consulta](#mecanismos-de-consulta)
  - [El lenguaje de consultas sintaxis, expresiones, operadores](#el-lenguaje-de-consultas-sintaxis-expresiones-operadores)
  - [Recuperación, modificación y borrado de información](#recuperacion-modificacion-y-borrado-de-informacion)
  - [Tipos de datos objeto; atributos y métodos](#tipos-de-datos-objeto-atributos-y-metodos)
  - [Tipos de datos colección](#tipos-de-datos-coleccion)
- [Gestión de bases de datos](#gestion-de-bases-de-datos)
  - [Acceso a bases de datos. Estándares. Características](#acceso-a-bases-de-datos-estandares-caracteristicas)
  - [Establecimiento de conexiones](#establecimiento-de-conexiones)
  - [Almacenamiento, recuperación, actualización y eliminación de información en bases de datos](#almacenamiento-recuperacion-actualizacion-y-eliminacion-de-informacion-en-bases-de-datos)
- [Programación en el lado del servidor](#programacion-en-el-lado-del-servidor)
  - [Fundamentos](#fundamentos)
  - [get y post](#get-y-post)
  - [Persistencia](#persistencia)
  - [Proyecto Ana](#proyecto-ana)
  - [includes](#includes)
  - [Repasito de cosas de GitHub](#repasito-de-cosas-de-github)
  - [Bloques](#bloques)
  - [Sesiones en PHP](#sesiones-en-php)
  - [Implantacion crud](#implantacion-crud)
- [.git](#git)
  - [branches](#branches)
  - [hooks](#hooks)
  - [info](#info)
  - [logs](#logs)
  - [objects](#objects)
  - [refs](#refs)

---

<a id="identificacion-de-los-elementos-de-un-programa-informatico"></a>
# Identificación de los elementos de un programa informático

<a id="estructura-y-bloques-fundamentales"></a>
## Estructura y bloques fundamentales

### Introducción a los ejercicios

En esta sección de ejercicios, centraremos nuestra atención en el concepto básico pero fundamental del "Hola Mundo" en Python. Este ejercicio simple te permitirá familiarizarte con la estructura básica de un programa informático y cómo imprimir texto en la consola, lo cual es uno de los primeros pasos en cualquier lenguaje de programación. A través de este ejercicio, practicarás la importancia del formato correcto del código y cómo utilizar una función integrada para mostrar mensajes en pantalla. Este tipo de ejercicios son cruciales para establecer una base sólida antes de pasar a estructuras más complejas.

### Holamundo
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código es muy sencillo y básico, pero importante para entender cómo funcionan los programas en Python. La línea de código `print("Hola mundo desde Python")` hace que el programa muestre o imprima el texto "Hola mundo desde Python" en la pantalla cuando se ejecuta. Aquí, `print()` es una función incorporada en Python que toma lo que le das entre paréntesis y lo muestra por pantalla. En este caso, estamos pasando a la función un mensaje en formato de cadena (entre comillas) que queremos ver impreso.

Este ejercicio "Hola mundo" sirve como punto de partida para aprender cualquier nuevo lenguaje de programación porque demuestra cómo interactuar con el entorno de desarrollo y cómo ejecutar programas simples. Es fundamental entender este concepto antes de pasar a programas más complejos.

`001-Holamundo.py`

```python
print("Hola mundo desde Python")
```

### Actividades propuestas

### Actividad 1: Bienvenida al Mundo de la Programación

**Descripción:** Los estudiantes deben escribir un programa sencillo que imprima su nombre en pantalla. Este ejercicio les permitirá familiarizarse con el concepto básico de cómo ejecutar código y entender la estructura básica de los programas en Python.

### Actividad 2: Mensajes Personalizados

**Descripción:** Se solicita a los estudiantes crear un programa que reciba un mensaje personalizado por teclado (input) y lo imprima en pantalla. Esto les ayudará a comprender el uso básico de la función `input()` y cómo manipular strings.

### Actividad 3: Introducción a las Variables

**Descripción:** Los alumnos deben crear un programa que almacene su nombre en una variable y luego imprima este nombre en lugar del texto estático "Hola mundo". Esta actividad introduce el concepto de variables y almacenamiento de datos.

### Actividad 4: Suma Básica de Números

**Descripción:** Los estudiantes deben desarrollar un programa que solicite dos números por teclado, los sume y muestre el resultado. Esto ayudará a entender cómo se trabajan con operaciones matemáticas básicas en Python.

### Actividad 5: Presentación Personalizada

**Descripción:** Se les pide a los estudiantes crear un programa que imprima una presentación completa (nombre, edad) solicitando esta información al usuario. Este ejercicio reforzará el uso de variables y concatenación de strings.

### Actividad 6: Condiciones Básicas

**Descripción:** Los alumnos deben escribir un programa que pida la edad del usuario y muestre un mensaje según si es mayor o menor de 18 años. Esto introduce conceptos básicos sobre estructuras condicionales (`if`).

### Actividad 7: Estructura de Datos Básica

**Descripción:** Se les pedirá a los estudiantes crear una lista con sus nombres favoritos y luego imprimir cada nombre en una línea diferente. Esta actividad ayudará a comprender cómo se trabaja con listas.

### Actividad 8: Ciclo For Sencillo

**Descripción:** Los alumnos deben desarrollar un programa que imprima números del 1 al 10 utilizando un ciclo `for`. Esto introduce el uso de bucles para repetir tareas en Python.

### Actividad 9: Suma de Números Consecutivos

**Descripción:** Se les solicitará a los estudiantes escribir un código que sume todos los números del 1 al número especificado por el usuario. Esta actividad profundiza en la comprensión de ciclos y acumuladores.

### Actividad 10: Menú Interactivo Simple

**Descripción:** Los alumnos deben crear un programa con un menú interactivo donde el usuario puede elegir entre varias opciones (por ejemplo, ver su nombre, edad o una suma) usando `if` para las diferentes elecciones. Esto ayudará a entender cómo estructurar programas más complejos y manejar múltiples rutas de ejecución.

Estas actividades están diseñadas para cubrir los fundamentos básicos del lenguaje Python y ayudar a los estudiantes a adquirir confianza en la programación, preparándolos gradualmente para conceptos más avanzados.


<a id="variables"></a>
## Variables

### Introducción a los ejercicios

Esta carpeta contiene una serie de ejercicios básicos en Python enfocados en la comprensión y uso correcto de las variables. Los estudiantes aprenderán a declarar e inicializar variables, imprimir sus valores y cómo cambiar el contenido de una variable durante la ejecución del programa. Además, se introducirán a los diferentes tipos de identificadores válidos para nombrar variables y se explicará la importancia y uso correcto de los comentarios en el código para mejorar su legibilidad y mantenimiento.

### variables
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código Python establece dos variables que representan información personal sobre una persona. La primera línea `nombre = "Jose Vicente"` crea una variable llamada `nombre` y la asigna con el valor de la cadena de texto `"Jose Vicente"`. Esto significa que cualquier lugar en el programa donde se use la variable `nombre`, será reemplazado por este nombre.

La segunda línea, `edad = 47`, hace lo mismo pero para una edad. Aquí, se crea una variable llamada `edad` y se le asigna el valor entero 47. Este tipo de variable es un número entero, en lugar de texto como en la primera declaración.

Estas líneas son fundamentales porque permiten al programa almacenar e interactuar con datos específicos sobre una persona, lo que puede ser útil para mostrar información personalizada o realizar cálculos basados en estos valores.

`002-variables.py`

```python
nombre = "Jose Vicente"
edad = 47
```

### salidas
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código Python muestra cómo se utiliza una variable para almacenar información y luego imprimir esa información en la pantalla. En primer lugar, se crea una variable llamada `nombre` que almacena el texto "Jose Vicente". Esta línea de código está asignando un valor específico a la variable `nombre`. Luego, la función `print()` es utilizada para mostrar en la consola o terminal la frase "Mi nombre es" seguida del contenido almacenado en la variable `nombre`, que sería "Jose Vicente".

Este tipo de código es importante porque demuestra cómo las variables permiten a los programadores guardar datos y luego manipularlos, como incluirlos dentro de una oración completa. Esto es fundamental para cualquier programa que necesite mostrar información al usuario de manera legible y estructurada.

`003-salidas.py`

```python
nombre = "Jose Vicente"
print("Mi nombre es",nombre)
```

### variar una variable
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código muestra cómo se pueden modificar y utilizar variables en Python. En primer lugar, la variable `nombre` se inicializa con el valor `"Jose Vicente"`. Luego, este valor se imprime utilizando la función `print`, que muestra por pantalla "Mi nombre es Jose Vicente".

Después, la misma variable `nombre` cambia su valor a `"Juan"`. Esto demuestra cómo las variables pueden ser reasignadas en cualquier momento dentro del programa. A continuación, el nuevo valor de `nombre` se imprime nuevamente con otra llamada a `print`, mostrando "Mi nombre es Juan".

Este código es importante porque ilustra la idea de que una variable puede contener diferentes valores en distintos momentos durante la ejecución de un programa y cómo estas modificaciones afectan al comportamiento del mismo.

`004-variar una variable.py`

```python
nombre = "Jose Vicente"
print("Mi nombre es",nombre)

nombre = "Juan"
print("Mi nombre es",nombre)
```

### identificadores permitidos
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código en Python muestra ejemplos de cómo se pueden nombrar variables correctamente y cuáles son las reglas para los identificadores permitidos. Aquí, `nombre` es una variable que almacena el nombre "Jose", y `nombre2` contiene "Vicente". El comentario `# 2nombre = "Jose Vicente"` indica que no se puede usar un número al principio del nombre de la variable. Luego, vemos cómo `nombre_completo` guarda el nombre completo como cadena. Los comentarios también muestran ejemplos de nombres de variables incorrectos: no puedes usar guiones medios (-) ni espacios en blanco dentro de los nombres de las variables.

El último ejemplo, `nombreCompleto = "Jose Vicente"`, muestra que es válido combinar letras y números (y el uso de mayúsculas al principio), pero se considera una mala práctica debido a la confusión con las constantes mayúsuclas en Python. Este código ayuda a entender qué tipos de nombres son válidos para variables en Python y cuáles no, lo que es crucial para escribir código legible y correcto.

`005-identificadores permitidos.py`

```python
nombre = "Jose"
nombre2 = "Vicente"
# 2nombre = "Jose Vicente"
nombre_completo = "Jose Vicente"
#nombre-completo = "Jose Vicente"
#nombre completo = "Jose Vicente"
nombreCompleto = "Jose Vicente" # Es legal pero no se recomienda
```

### comentarios
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código en Python está dedicado a mostrar cómo se usan los comentarios dentro del lenguaje. Los comentarios son líneas de texto que el programa ignora durante la ejecución y sirven principalmente para explicar qué hace un trozo específico de código, ayudando a otros programadores (y al mismo autor del código después de mucho tiempo) a entender mejor su propósito sin tener que profundizar en los detalles técnicos.

Hay dos tipos de comentarios presentes: uno es una línea simple que comienza con el símbolo `#`, y el otro es un bloque de comentario multi-línea rodeado por tres apóstrofes simples (`'''`) al inicio y al final. Ambos tipos sirven para documentar o explicar diferentes partes del código, siendo el bloque multi-línea útil cuando se necesita una descripción más detallada que abarca varias líneas.

Los comentarios son fundamentales en la programación porque hacen que el código sea más legible y fácil de mantener.

`006-comentarios.py`

```python
# Esto es un comentario de una única línea

'''
    Esto es un comentario
    Esto sigue siendo un comentario
    Y esto también lo es
'''
```

### Explicacion del codigo
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código en Python muestra cómo se declara e inicializa una variable llamada `edad`. En la línea `edad = 47`, estás creando una variable con el nombre `edad` y le estás asignando un valor numérico específico, que es el número 47. Aquí, `edad` es lo que se llama un identificador; es simplemente el nombre que usas para referirte a la variable en tu programa. El signo de igual (`=`) es el operador de asignación y su función principal es establecer una relación entre el valor a la derecha del signo (en este caso, 47) con la variable a la izquierda (aquí `edad`). Por último, el número 47 se considera un literal porque es un valor fijo que no cambia durante la ejecución del programa. Este código te muestra de manera simple cómo declarar variables en Python y cómo almacenar datos numéricos en ellas.

`007-Explicacion del codigo.py`

```python
edad = 47
# edad es el identificador
# = es el operador de asignación
# 47 es el valor literal que se es está asignando al identificador
```

### Actividades propuestas

1. **Identificación y Uso de Variables**
   - **Descripción:** Identifica las variables en diferentes ejemplos del código proporcionado y explica qué tipo de dato contiene cada variable (cadenas, números).
   - **Objetivo:** Familiarizar a los estudiantes con la identificación y el uso correcto de variables en Python.

2. **Salidas de Texto**
   - **Descripción:** Utiliza las instrucciones `print()` para mostrar información almacenada en variables al usuario.
   - **Objetivo:** Aprender cómo imprimir datos en consola desde un programa usando variables.

3. **Modificación de Variables**
   - **Descripción:** Modifica el valor de una variable existente y muestra la nueva asignación utilizando `print()`.
   - **Objetivo:** Comprender que las variables pueden cambiar su valor durante la ejecución del código.

4. **Reglas de Identificadores de Python**
   - **Descripción:** Investiga los ejemplos válidos e inválidos de nombres para variables y proporciona una lista de reglas sobre cómo nombrar variables en Python.
   - **Objetivo:** Aprender las convenciones de nomenclatura para variables en el lenguaje Python.

5. **Uso de Comentarios**
   - **Descripción:** Identifica los comentarios existentes y agrega uno nuevo explicando una parte específica del código.
   - **Objetivo:** Conocer cómo documentar un programa con comentarios para facilitar la comprensión futura del mismo.

6. **Explicación Detallada de Código**
   - **Descripción:** Escribe una breve descripción sobre los componentes (identificadores, operaciones, valores literales) presentes en el código y su función.
   - **Objetivo:** Desarrollar habilidades para la documentación interna del código.

7. **Uso de Variables en Expresiones**
   - **Descripción:** Crea una expresión que combine dos o más variables existentes y muestre el resultado por pantalla.
   - **Objetivo:** Aprender a manipular datos usando operadores matemáticos y lógicos con variables.

8. **Análisis de Código**
   - **Descripción:** Selecciona un código dado, identifica todas las líneas que no contribuyen al flujo del programa (comentarios) y extrae su significado.
   - **Objetivo:** Mejorar la habilidad para analizar código y entender los comentarios como parte del desarrollo de software.

9. **Nombres Descriptivos**
   - **Descripción:** Reescribe variables utilizando nombres descriptivos que reflejen mejor el contenido o propósito de cada variable.
   - **Objetivo:** Mejorar la legibilidad del código a través de buenas prácticas en nomenclatura.

10. **Comparación de Codificaciones**
    - **Descripción:** Compara diferentes ejemplos de codificación y destaca las diferencias en el uso de variables, comentarios y expresiones.
    - **Objetivo:** Aprender a discernir buenas prácticas de programación frente a malas.


<a id="tipos-de-datos"></a>
## Tipos de datos

### Introducción a los ejercicios

En esta carpeta, encontrarás una serie de ejercicios diseñados para familiarizarte con los tipos de datos y la entrada de datos en Python. Los ejercicios inician explicando cómo se manejan diferentes tipos de datos como cadenas, enteros, decimales y booleanos, luego pasan a mostrar cómo obtener información del usuario mediante entradas. El objetivo es que comprendas cómo almacenar e interactuar con diversos tipos de información en programas simples, así como aprender la importancia de convertir los datos de texto ingresados por el usuario a formatos numéricos cuando sea necesario para realizar cálculos. Estos ejercicios te ayudarán a practicar tus habilidades básicas de programación y entenderás mejor cómo Python maneja diferentes tipos de datos en contextos prácticos.

### Tipos de datos
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código en Python está dedicado a la creación y asignación de variables que representan diferentes tipos de datos básicos. Comenzamos con `nombre`, que es una variable de tipo cadena (string), almacenando el texto "Jose Vicente". Luego, tenemos `edad` que almacena un número entero (`int`) igual a 47, lo cual podría referirse a la edad de una persona en años. A continuación, encontramos `altura`, que es un valor decimal o punto flotante (`float`) con el valor 1.78, probablemente representando metros. Finalmente, tenemos `vivo` como una variable booleana que contiene el valor True, lo cual puede indicar si una persona está viva o no (en este caso, la persona está viva). Este código es fundamental para entender cómo Python maneja diferentes tipos de datos y cómo se pueden usar estas variables en programas más complejos.

`008-Tipos de datos.py`

```python
nombre = "Jose Vicente" # Cadena
edad = 47 # Entero
altura = 1.78 # Decimal
vivo = True # Booleano
```

### Entradas
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código te permite interactuar con el programa que estás creando, específicamente para pedirle al usuario que ingrese su nombre. La línea `nombre = input("Dime tu nombre: ")` muestra un mensaje en la pantalla ("Dime tu nombre:") y espera a que el usuario teclee algo y presione enter. Todo lo que el usuario escribe se guardará en una variable llamada `nombre`.

Luego, con la línea `print("Tu nombre es: ", nombre)`, el programa imprime o muestra en la pantalla un mensaje que indica "Tu nombre es:" seguido del contenido de la variable `nombre`. Esto demuestra cómo puedes recibir información del usuario (entradas) y luego utilizar esa información para hacer algo más, como mostrarla.

Este tipo de código es muy importante porque permite a los programas interactuar con el usuario, permitiendo una mayor interactividad y funcionalidad en tus aplicaciones.

`009-Entradas.py`

```python
nombre = input("Dime tu nombre: ")
print("Tu nombre es: ",nombre)
```

### Entrada y problema
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código en Python solicita al usuario que ingrese su edad y luego muestra por pantalla el doble de esa edad, aunque con un pequeño error. Primero, la función `input()` captura lo que el usuario teclea después de mostrar el mensaje "Dime tu edad: ". El valor ingresado se guarda como una cadena (string) en la variable `edad`. Luego, el código imprime "El doble de tu edad es: " seguido del contenido de la variable `edad`, sin hacer ningún cálculo. Es importante notar que para calcular realmente el doble de la edad, deberíamos convertir la cadena a un número (por ejemplo, usando `int()` o `float()`) y luego multiplicarlo por dos antes de imprimirlo.

`010-Entrada y problema.py`

```python
edad = input("Dime tu edad: ")
print("El doble de tu edad es: "+edad)
```

### Cambio de tipo de dato
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código solicita al usuario que ingrese su edad y luego realiza cálculos con ese dato. Primero, la función `input()` captura la entrada del usuario como una cadena de texto. Luego, el código convierte esa cadena en un número entero utilizando la función `int()`, lo cual es importante porque las operaciones matemáticas no pueden realizarse directamente sobre cadenas. Después, se calcula el doble de ese número entero y finalmente intenta mostrar este resultado por pantalla usando `print()`. Sin embargo, hay un error en la línea de `print()` ya que está tratando de concatenar un número con una cadena sin convertir primero el número a texto (usando `str()`), lo cual provocaría un error de ejecución.

Este código demuestra cómo es fundamental entender los tipos de datos y realizar conversiones adecuadas cuando se manejan entradas del usuario, ya que la mayoría de las operaciones necesitan trabajar con datos en formatos específicos.

`011-Cambio de tipo de dato.py`

```python
# Le pregunto al usuario por su edad
edad = input("Dime tu edad: ")
# Me aseguro de convertir la edad a un número entero
entero = int(edad)
# Calculo el doble de un número entero
doble = entero*2
# Saco el resultado por pantalla
print("El doble de tu edad es: "+doble)
```

### Actividades propuestas

### Actividad 1: Identificación y Uso de Tipos de Datos Básicos

**Descripción:** Los estudiantes deben identificar los tipos de datos utilizados en un programa proporcionado (cadenas, enteros, decimales, booleanos) y explicar su uso en contextos concretos. El objetivo es que comprendan cómo se declaran e inicializan variables de diferentes tipos.

### Actividad 2: Entrada de Datos

**Descripción:** Se les pide a los estudiantes crear un programa sencillo donde el usuario pueda introducir su nombre y la consola lo muestre por pantalla. El objetivo es familiarizarles con la función `input()` en Python y cómo imprimir datos usando `print()`.

### Actividad 3: Cálculo de Edad Doblegada

**Descripción:** Los estudiantes deben completar un programa que permita al usuario ingresar su edad, calcular el doble de esta y mostrarlo por pantalla. Se enfatiza la importancia de usar operaciones aritméticas con datos numéricos.

### Actividad 4: Conversión Manual de Tipos

**Descripción:** A partir del código existente, los estudiantes deberán corregir un programa que tiene errores al intentar sumar o multiplicar cadenas sin convertirlas primero a números enteros. El objetivo es entender cómo y por qué se deben hacer conversiones explícitas entre tipos de datos.

### Actividad 5: Combinación de Entradas y Cálculos

**Descripción:** Se les solicita que diseñen un programa donde el usuario ingrese su edad y altura, luego calcula e imprime la suma de ambas. Esta actividad combina entrada de datos y operaciones matemáticas.

### Actividad 6: Condiciones Básicas con Datos

**Descripción:** Los estudiantes deben incorporar una condición simple al código que comprueba si el usuario tiene más o menos de 18 años (mediante la edad introducida) e imprime un mensaje diferente para cada caso. Esta actividad introduce conceptos básicos sobre estructuras condicionales.

### Actividad 7: Programa de Conversión de Temperaturas

**Descripción:** Los estudiantes deben crear un programa que solicite al usuario una temperatura en grados Celsius y luego la convierta a Fahrenheit, mostrando el resultado por pantalla. Esto permite trabajar con cálculos matemáticos simples.

### Actividad 8: Manipulación de Texto e Introducción de Listas

**Descripción:** En esta actividad, los estudiantes deben introducir texto (como una frase) y luego mostrar cada palabra en mayúsculas o minúsculas. También pueden experimentar con listas para almacenar múltiples entradas del usuario.

### Actividad 9: Resolución de Problemas Concretos

**Descripción:** Proporciona un problema específico (por ejemplo, calcular el promedio de tres números introducidos por el usuario) y los estudiantes deben escribir código que resuelva este problema. Esto refuerza la comprensión del manejo básico de datos y funciones matemáticas.

### Actividad 10: Introducción a Variables Booleanas

**Descripción:** Los estudiantes deben crear un programa que use una variable booleana para controlar si el usuario desea continuar introduciendo datos o no. Esto introduce conceptos sobre la lógica en programación y cómo manejar ciclos basados en condiciones boleanas.


<a id="literales"></a>
## Literales

### Introducción a los ejercicios

En esta sección de ejercicios, los estudiantes aprenderán sobre literales en Python, que son las formas directas de representar valores como números o cadenas en un programa. Los ejercicios centrarse en identificar y clasificar diferentes tipos de literales, como cadenas (strings) y enteros (integers). A través de estos ejercicios, los estudiantes practicarán la creación de variables que almacenan literales específicos y aprenderán a distinguir entre distintos tipos de datos básicos en Python.

### literales
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código en Python establece dos variables con literales específicos. La primera línea `nombre = "Jose Vicente"` crea una variable llamada `nombre` que almacena la cadena de texto `"Jose Vicente"`. En este caso, `"Jose Vicente"` es un literal de tipo cadena (string), lo que significa que se trata de un conjunto de caracteres encerrados entre comillas dobles.

La segunda línea `edad = 47` crea una variable llamada `edad` que almacena el número entero `47`. Aquí, `47` es un literal del tipo entero (integer), lo que indica que se trata de un valor numérico sin decimales. Estos dos ejemplos ilustran cómo los literales pueden ser de diferentes tipos en Python: cadenas para texto y enteros para números, según su naturaleza y uso específico en el programa.

`012-literales.py`

```python
nombre = "Jose Vicente"
# Jose Vicente es el literal, y es de tipo cadena

edad = 47
# 47 es el literal, y es de tipo entero
```

### Actividades propuestas

### Actividad 1: Identificación de Literales en Python
**Descripción:** Los estudiantes deben identificar y clasificar los diferentes tipos de literales presentes en un código dado. Se espera que reconozcan las cadenas (str) y números enteros (int). **Objetivo:** Familiarizarse con la notación de literales en Python.

### Actividad 2: Crear Variables con Literales
**Descripción:** Los estudiantes deben escribir un breve código donde creen varias variables utilizando diferentes tipos de literales, incluyendo cadenas y números enteros. **Objetivo:** Practicar el uso de declaraciones para crear variables en Python.

### Actividad 3: Operaciones Básicas con Literales
**Descripción:** Los estudiantes deben realizar operaciones matemáticas básicas (suma, resta) utilizando literales numéricos. Se pide que impriman los resultados. **Objetivo:** Entender cómo funcionan las operaciones aritméticas en Python.

### Actividad 4: Formateo de Cadenas
**Descripción:** Los estudiantes deben crear una cadena que incluya variables con literales, utilizando métodos como `format()` para formatear texto. **Objetivo:** Aprender a manipular y presentar datos mediante el uso de cadenas.

### Actividad 5: Concatenación de Cadenas
**Descripción:** Los estudiantes deben concatenar diferentes cadenas que incluyen literales variables, añadiendo espacios o signos de puntuación como comillas. **Objetivo:** Practicar la operación de concatenación y manipulación de strings en Python.

### Actividad 6: Crear Funciones con Literales
**Descripción:** Los estudiantes deben crear funciones que tomen literales como argumentos y devuelvan resultados basados en ellos (por ejemplo, calcular el doble de un número entero). **Objetivo:** Aprender a definir funciones en Python utilizando parámetros y retornar valores.

### Actividad 7: Trabajar con Fechas Literales
**Descripción:** Los estudiantes deben utilizar literales de fecha para crear objetos `datetime` y realizar operaciones básicas. **Objetivo:** Familiarizarse con el manejo de fechas en Python usando literales.

### Actividad 8: Ejecución y Análisis de Código
**Descripción:** Los estudiantes recibirán un código que utiliza diversos tipos de literales y deben ejecutarlo para entender cómo funcionan. Luego, deben analizar los resultados e identificar cualquier error o problema potencial. **Objetivo:** Desarrollar habilidades de depuración básica en Python.

### Actividad 9: Uso de Literales Booleanos
**Descripción:** Los estudiantes deberán utilizar literales booleanos para controlar el flujo del programa mediante estructuras condicionales (if-else). **Objetivo:** Aprender a utilizar literales booleanos y estructuras condicionales en Python.

### Actividad 10: Documentación de Códigos con Literales
**Descripción:** Los estudiantes deben escribir comentarios explicativos para un código que utiliza diversos tipos de literales, proporcionando una guía clara sobre cada parte del código. **Objetivo:** Aprender la importancia y el uso correcto de la documentación en Python.


<a id="constantes"></a>
## Constantes

### Introducción a los ejercicios

En esta carpeta, se exploran los conceptos básicos de las constantes en programación utilizando Python. Los ejercicios te ayudarán a entender cómo declarar y utilizar constantes en tu código, así como la importancia de seguir convenciones para diferenciarlas de otras variables. Aprenderás que una constante se suele representar con letras mayúsculas y cómo su valor no debe cambiar durante la ejecución del programa, a pesar de que en Python técnicamente puedes reasignar el valor a una variable con mayúscula sin que el lenguaje te genere un error. Esto es crucial para mantener un código claro y fácil de entender.

### constantes
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código muestra cómo se pueden cambiar los valores en Python, incluso de lo que generalmente consideramos como constantes. Al principio, la variable `PI` es asignada el valor 3.1415 y luego se imprime este valor usando la función `print()`. A continuación, se cambia el valor de `PI` a 4 y vuelve a imprimirlo.

Es importante entender que en Python, aunque normalmente usamos mayúsculas para representar constantes (como aquí con `PI`) por convención, no es realmente una constante irreemplazable. El código demuestra que puedes cambiar el valor de `PI` como harías con cualquier otra variable. Sin embargo, según las buenas prácticas y la lógica del diseño, una vez definida `PI` como constante (en mayúsculas), deberíamos mantener su valor inmutable para evitar confusiones y errores en el código.

En resumen, este ejemplo te enseña sobre los cambios de valores en variables, la convención de nombres en Python (mayúsculas para constantes) y por qué es importante seguir estas convenciones para escribir un código más limpio y legible.

`013-constantes.py`

```python
PI = 3.1415

print("PI vale",PI)

PI = 4 # Le cambio el valor a PI

print("PI vale",PI)
# Las constantes deben formularse con mayúsculas
# Las variables deben formularse con minúsculas
```

### Diferencia
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código está mostrando la diferencia entre una constante y un valor literal en Python, aunque también contiene un error que ilustra un mal uso del lenguaje. En primer lugar, `PI` se define como una constante con el valor 3.1416, que es comúnmente utilizado para representar el número PI en cálculos aproximados debido a su simplicidad y precisión suficiente para muchos propósitos prácticos.

Sin embargo, más adelante, el código vuelve a asignar `PI` con un valor de tipo cadena ("unnumero"). Esto no es una buena práctica porque las constantes, por definición, deben mantener un valor inmutable a lo largo del programa. Al volver a definir `PI`, se está perdiendo la semántica y el propósito original de representar el número PI numéricamente.

Este código sirve para enseñar que es importante respetar las convenciones en la programación, especialmente cuando se trata de constantes, ya que su uso incorrecto puede llevar a errores difíciles de depurar y malas prácticas de codificación.

`014-Diferencia.py`

```python

# La constante es PI
# El literal es 3.1416

PI = 3.1416

PI = "unnumero"
```

### Actividades propuestas

### Actividad 1: Entendiendo la Diferencia entre Constantes y Variables
**Descripción:** Identifica las diferencias entre una constante y una variable en un código Python dado, y explica por qué se considera a PI como una constante. Esta actividad busca que los estudiantes comprendan el concepto de constantes y variables.

### Actividad 2: Creación de Constantes con Mayúsculas
**Descripción:** Escribe varios ejemplos donde declaras constantes usando solo mayúsculas para diferentes valores numéricos y textuales. La actividad pretende que los estudiantes aprendan a seguir las convenciones de nomenclatura en Python.

### Actividad 3: Modificación de Constantes
**Descripción:** Intenta modificar el valor de una constante declarada y observa el comportamiento del código. Los estudiantes deben aprender por qué es considerado un mal uso cambiar el valor de lo que se ha establecido como constante.

### Actividad 4: Uso de Literales vs Constantes
**Descripción:** Distingue entre literales numéricos, cadenas y constantes en un programa simple. Esta actividad busca que los estudiantes entiendan cuándo usar cada uno.

### Actividad 5: Comparación de Valores Constante y Literal
**Descripción:** Crea una función que compare el valor de una constante con diferentes literales numéricos. Los estudiantes deben aprender a trabajar con comparaciones y tipos de datos en Python.

### Actividad 6: Asignación Múltiple con Constantes
**Descripción:** Implementa la asignación múltiple para declarar varias constantes al mismo tiempo y observa cómo se comportan cuando intentas cambiar el valor de una. Se espera que los estudiantes comprendan las reglas de declaración y uso de constantes.

### Actividad 7: Uso de Constantes en Cálculos Matemáticos
**Descripción:** Escribe un programa donde utilices constantes matemáticas (como PI) para realizar cálculos geométricos. Se espera que los estudiantes entiendan cómo integrar las constantes en operaciones matemáticas.

### Actividad 8: Documentación de Constantes
**Descripción:** Añade comentarios a tu código explicando el propósito de cada constante y por qué es importante usar mayúsculas para declararlas. Esta actividad busca mejorar la habilidad de los estudiantes para documentar su código eficazmente.

### Actividad 9: Ejercicio Práctico con PI
**Descripción:** Crea un programa que calcule el área de un círculo utilizando PI como una constante y muestra cómo cambiar su valor afecta a la precisión del resultado. Los estudiantes deben entender la importancia de usar constantes correctas para mejorar la exactitud matemática.

### Actividad 10: Diferenciación entre Constante y Variable en Contexto
**Descripción:** Escribe un pequeño script que demuestre cómo una constante puede ser confundida con una variable por mal uso del código. Se espera que los estudiantes identifiquen el error y expliquen la importancia de mantener las convenciones al trabajar con constantes.


<a id="operadores-y-expresiones"></a>
## Operadores y expresiones

### Introducción a los ejercicios

En esta carpeta, se encuentran ejercicios que te ayudarán a familiarizarte con los operadores y expresiones en Python. Los problemas abordan diversos tipos de operaciones aritméticas, comparativas y booleanas, lo cual es fundamental para el desarrollo de programas básicos. Estos ejercicios te permitirán practicar la manipulación de datos mediante cálculos matemáticos, la realización de comparaciones lógicas entre valores y la combinación de resultados con operadores booleanos. Además, se incluye un ejercicio práctico de una calculadora de impuestos que pone en práctica lo aprendido sobre operadores aritméticos y de comparación para realizar cálculos más complejos y gestionar entradas del usuario.

### operadores aritmeticos
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código muestra ejemplos básicos de cómo usar operadores aritméticos en Python. Los operadores aritméticos son símbolos que realizan operaciones matemáticas simples, como sumar, restar, multiplicar y dividir números.

El primer `print(4+3)` suma los dos números 4 y 3, mostrando el resultado de la suma en pantalla. El segundo ejemplo, `print(4-3)`, resta el número 3 del número 4 y muestra el resultado de la resta. Luego, `print(4*3)` multiplica los números 4 y 3 entre sí.

El cuarto `print(4/3)` divide el número 4 por 3 y muestra el resultado de esta división, que es un número decimal. Finalmente, `print(4%3)` usa el operador módulo `%` para calcular el resto de la división entre 4 y 3.

Estos ejemplos son fundamentales porque ayudan a entender cómo realizar cálculos matemáticos básicos en Python, lo que es crucial cuando se empieza a programar.

`014-operadores aritmeticos.py`

```python
print(4+3)
print(4-3)
print(4*3)
print(4/3)
print(4%3)
```

### operadores de comparacion
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es una serie de comparaciones utilizando operadores de comparación en Python. Cada línea del código compara dos números (en este caso, siempre el número 4 y el número 3) usando diferentes tipos de operadores para ver si las condiciones son verdaderas o falsas.

El primer print muestra la comparación `4 < 3`, que comprueba si 4 es menor que 3. Como esto no es cierto, imprime `False`.

La línea siguiente, `print(4 <= 3)`, verifica si 4 es menor o igual a 3, también resultando en `False` ya que 4 no es ni menor ni igual a 3.

Luego, `print(4 > 3)` comprueba si 4 es mayor que 3. Como esto es cierto, imprime `True`.

La siguiente línea, `print(4 >= 3)`, verifica si 4 es mayor o igual a 3 y devuelve `True` ya que 4 es mayor que 3.

El código también incluye la comparación de igualdad con `print(4 == 3)`. Esta línea comprueba si 4 es exactamente igual a 3, lo cual es falso porque los números son diferentes, por lo que imprime `False`.

Por último, el operador de desigualdad se utiliza en `print(4 != 3)` para verificar si 4 no es igual a 3. Como esto es cierto, devuelve y muestra `True` en la consola.

Este código demuestra cómo funcionan los diferentes operadores de comparación en Python, lo cual es crucial para comprender cómo realizar evaluaciones condicionales en programas más complejos.

`015-operadores de comparacion.py`

```python
print(4 < 3)
print(4 <= 3)
print(4 > 3)
print(4 >= 3)
print(4 == 3)
print(4 != 3)
```

### operadores arimeticos abreviados
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código muestra cómo usar operadores aritméticos abreviados en Python para realizar cálculos con una variable llamada `edad`. El objetivo es modificar el valor de `edad` mediante diferentes operaciones matemáticas. Primero, se establece que la edad inicial es 47 años.

El código realiza cuatro tipos de operaciones: suma, resta, multiplicación y división, tanto con los operadores tradicionales (como `+`, `-`, `*`, `/`) como con sus versiones abreviadas que incluyen el símbolo del operador seguido por el signo igual (`+=`, `-=` , `*=`, `/=`). Estas últimas son una forma más concisa de realizar y asignar la misma operación en una línea.

Por ejemplo, al decir "edad = edad + 2" se suma dos a la variable `edad` y luego se actualiza su valor. Con la versión abreviada "edad += 2", el mismo resultado se obtiene con menos código. Esto es útil para simplificar el código y hacerlo más legible, especialmente cuando se realizan múltiples operaciones sobre una misma variable.

Estas operaciones son fundamentales en programación ya que permiten manipular fácilmente los datos numéricos dentro de un programa.

`016-operadores arimeticos abreviados.py`

```python
edad = 47
# Le quiero sumar dos unidades
edad = edad + 2
edad += 2
#Le quiero restar dos unidades
edad = edad - 2
edad -= 2
# Lo quiero multiplicar por dos
edad = edad * 2
edad *= 2
# Lo quiero dividir por dos
edad = edad / 2
edad /= 2
```

### operadores booleanos
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código en Python está utilizando operadores booleanos para evaluar expresiones y mostrar el resultado por pantalla. Los operadores booleanos que se utilizan aquí son `and` y `or`. 

El primer bloque de código compara tres condiciones usando el operador `and`, lo que significa que todas las comparaciones deben ser verdaderas para que el resultado final sea verdadero. Por ejemplo, en la primera línea del código, `4 == 4 and 3 == 3 and 2 == 2` evalúa a `True` porque todas las comparaciones son correctas.

En contraste, el segundo bloque utiliza el operador `or`, que requiere solo una condición verdadera para que toda la expresión sea verdadera. En este caso, se ven varios ejemplos donde algunas condiciones son falsas, pero como mínimo una es verdadera, el resultado final de cada línea será `True` con excepción del último ejemplo (`4 == 3 or 3 == 2 or 2 == 1`), que evalúa a `False`.

Este código es importante para comprender cómo funcionan los operadores lógicos en la programación y cómo pueden ser utilizados para tomar decisiones basadas en múltiples condiciones.

`017-operadores booleanos.py`

```python
print(4 == 4 and 3 == 3 and 2 == 2)
print(4 == 4 and 3 == 3 and 2 == 1)

print(4 == 4 or 3 == 3 or 2 == 1)
print(4 == 4 or 3 == 2 or 2 == 1)
print(4 == 3 or 3 == 2 or 2 == 1)
```

### Ejercicio1-Calculadora de impuestos
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es la introducción a un programa en Python llamado "Calculadora de Impuestos". La descripción indica que el objetivo del programa es calcular el IVA (Impuesto sobre Valor Añadido) y el total después de aplicar el impuesto, basándose en una base imponible proporcionada por el usuario. El autor del código es Jose Vicente Carratalá y la versión actual del programa es v0.1.

Este tipo de programas son importantes porque ayudan a entender cómo se calcula el IVA en transacciones comerciales, lo cual es crucial para estudiantes que necesitan aprender sobre los conceptos básicos de contabilidad y finanzas en su formación profesional. El código probablemente incluirá operadores aritméticos para realizar cálculos matemáticos y puede servir como un punto de partida para explorar más funciones y módulos en Python relacionados con operaciones financieras.

`018-Ejercicio1-Calculadora de impuestos.py`

```python
'''
    Calculadora de Impuestos
    v0.1 por Jose Vicente Carratalá
    Funcionamiento: Introduce una base imponible y se calcula IVA y total
'''
```

### Calculadora
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es el inicio de un programa en Python que funciona como una simple calculadora para calcular impuestos, específicamente el IVA. El objetivo del programa es permitir al usuario ingresar la base imponible de una factura y luego calcular el IVA y el total a pagar.

Al principio del código, se encuentran algunas líneas de comentario que describen brevemente qué hace el programa y quién lo creó. A continuación, se declaran tres variables: `base_imponible`, `total_iva` y `total_factura`. Estas variables almacenarán los valores necesarios para realizar los cálculos.

El código utiliza la función `input()` para solicitar al usuario que introduzca el valor de la base imponible. Esta entrada es asignada a la variable `base_imponible`, pero hay un detalle importante: por ahora, esta entrada se guarda como una cadena de texto (string), no como un número. Para realizar cálculos matemáticos, necesitarías convertir este dato en un tipo numérico, ya sea entero (`int`) o flotante (`float`).

Este es el punto inicial del programa y aún falta implementar la lógica para calcular el IVA y el total de la factura.

`019-Calculadora.py`

```python
'''
    Calculadora de Impuestos
    v0.1 por Jose Vicente Carratalá
    Funcionamiento: Introduce una base imponible y se calcula IVA y total
'''

# Este programa no tiene importaciones

# Creo variables
base_imponible = 0
total_iva = 0
total_factura = 0

# Aquí pondría las funciones/clases

# Ahora calculamos
base_imponible = input("Introduce la base imponible de la factura: ")
```

### Calculadora
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es el inicio de un programa en Python que sirve como una sencilla calculadora de impuestos. El objetivo principal del programa es permitir al usuario introducir una cantidad llamada "base imponible" y luego calcular tanto el IVA como el total de la factura incluyendo el IVA.

El código comienza con comentarios que describen brevemente a qué se dedica el programa, quién lo creó y cuál es su versión actual. Luego, se declaran tres variables: `base_imponible`, `total_iva` y `total_factura`. Estas variables son usadas para almacenar los valores de la base imponible introducida por el usuario, el IVA calculado y el total de la factura.

Después del bloque de variables, el programa imprime tres mensajes en pantalla. El primero informa al usuario sobre qué hace el programa, seguido de un mensaje con información sobre el autor y la versión. Finalmente, se pide al usuario que introduzca una base imponible para continuar con el cálculo.

Es importante destacar que este código es solo el principio del programa y no incluye aún la lógica para calcular el IVA ni el total de la factura. Para completarlo, sería necesario agregar funciones o bloques de código adicionales que tomen en cuenta las reglas específicas sobre cómo se calcula el IVA según la legislación fiscal aplicable.

`020-Calculadora.py`

```python
'''
    Calculadora de Impuestos
    v0.1 por Jose Vicente Carratalá
    Funcionamiento: Introduce una base imponible y se calcula IVA y total
'''

# Este programa no tiene importaciones

# Creo variables
base_imponible = 0
total_iva = 0
total_factura = 0

# Aquí pondría las funciones/clases

# Ahora calculamos
print("Programa calculadora de impuestos")
print("(c) 2025 Jose Vicente Carratalá")
print("Introduce una base y te calculo el IVA y el total")
base_imponible = input("Introduce la base imponible de la factura: ")
```

### Calculo de IVA
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código Python se trata de un programa simple que calcula el IVA (Impuesto sobre Valor Añadido) y el total de una factura basándose en la base imponible introducida por el usuario. La base imponible es el precio del producto o servicio antes del impuesto.

El programa comienza solicitando al usuario que ingrese la cantidad de la base imponible mediante `input()`, que luego convierte a un número decimal (float) con `float(input(...))`. A continuación, calcula el IVA aplicando una tasa fija del 21% (multiplicando la base imponible por 0.21), y determina el total de la factura sumando la base imponible más el IVA.

Finalmente, muestra en pantalla tanto el valor del IVA como el monto total, que es la suma de la base imponible y el IVA calculado. Este tipo de programa es útil para entender cómo se aplican las operaciones aritméticas básicas y la entrada/salida de datos en Python, además de proporcionar una base práctica sobre cómo calcular impuestos en situaciones cotidianas como compras o facturación.

`021-Calculo de IVA.py`

```python
'''
    Calculadora de Impuestos
    v0.1 por Jose Vicente Carratalá
    Funcionamiento: Introduce una base imponible y se calcula IVA y total
'''

# Este programa no tiene importaciones

# Creo variables
base_imponible = 0
total_iva = 0
total_factura = 0

# Aquí pondría las funciones/clases

# Ahora calculamos

# Primero pido una entrada
print("Programa calculadora de impuestos")
print("(c) 2025 Jose Vicente Carratalá")
print("Introduce una base y te calculo el IVA y el total")
base_imponible = float(input("Introduce la base imponible de la factura: "))

# Luego realizo cálculos
total_iva = base_imponible*0.21
total_factura = base_imponible + total_iva

# Por último expreso una salida
print("El IVA de la factura es: ",total_iva)
print("El total de la factura es: ",total_factura)
```

### Actividades propuestas

### Actividades Propuestas:

1. **Operadores Aritméticos**
   - Descripción: Los estudiantes deben escribir un programa que realice varias operaciones aritméticas (suma, resta, multiplicación y división) con dos números proporcionados por el usuario.
   - Objetivo: Familiarizar a los alumnos con la utilización de operadores aritméticos en Python.

2. **Operadores de Comparación**
   - Descripción: Los estudiantes deben crear un programa que compare dos valores ingresados por el usuario y muestre si son iguales, diferentes o cumplen otras relaciones comparativas.
   - Objetivo: Aprender a usar operadores de comparación para tomar decisiones en Python.

3. **Operadores de Asignación**
   - Descripción: Los estudiantes deben modificar un código existente que usa asignaciones simples (como `edad = edad + 2`) para utilizar los operadores abreviados (`+=`, `-=`, `*=`, `/=`).
   - Objetivo: Comprender la eficiencia y conveniencia de los operadores de asignación en Python.

4. **Operadores Lógicos**
   - Descripción: Los estudiantes deben escribir un programa que utilice operadores lógicos (`and`, `or`) para evaluar expresiones condicionales.
   - Objetivo: Aprender a combinar varias condiciones utilizando operadores lógicos.

5. **Calculadora de Impuestos Básica**
   - Descripción: Los estudiantes deben desarrollar una calculadora que pida al usuario la base imponible y calcule el IVA (21%) y el total.
   - Objetivo: Aprender a utilizar variables, operadores aritméticos y de asignación para realizar cálculos.

6. **Validación de Datos**
   - Descripción: Los estudiantes deben mejorar la calculadora de impuestos añadiendo validaciones básicas que aseguren que el usuario ingrese valores numéricos.
   - Objetivo: Aprender a manejar excepciones y validar datos en Python.

7. **Menú de Operaciones**
   - Descripción: Los estudiantes deben crear un menú interactivo donde el usuario pueda seleccionar entre diferentes operaciones (sumar, restar, multiplicar).
   - Objetivo: Practicar la estructura condicional `if-elif` y bucles en programas interactivos.

8. **Juego de Adivinanza Numérica**
   - Descripción: Los estudiantes deben desarrollar un juego donde el programa genera un número aleatorio entre 1 y 50, y el usuario debe adivinarlo.
   - Objetivo: Practicar la interacción con el usuario y la lógica condicional en programas más dinámicos.

Estas actividades están diseñadas para cubrir los aspectos fundamentales del uso de operadores y expresiones en Python, adaptándose al nivel y necesidades de los estudiantes de Formación Profesional.


<a id="ejercicio-de-final-de-unidad"></a>
## Ejercicio de final de unidad

### Introducción a los ejercicios

Esta carpeta contiene un conjunto de ejercicios diseñados para estudiantes de Formación Profesional que recién comienzan a aprender programación en Python. Los problemas abordan conceptos fundamentales como imprimir texto, declarar y manipular variables, utilizar entradas de usuario, trabajar con diferentes tipos de datos (cadenas, números enteros, decimales, booleanos), realizar operaciones aritméticas y lógicas, así como introducir comentarios en el código. A lo largo de estos ejercicios, los estudiantes aprenderán a identificar correctamente las partes constituyentes de un programa informático y a entender cómo se manipulan diferentes tipos de datos y estructuras básicas para resolver problemas simples.

### Holamundo
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código es muy sencillo y básico en la programación con Python. La función `print()` se utiliza para mostrar texto o datos en la pantalla. En este caso, el programa imprime la frase "Hola mundo desde Python". Esta línea de código es típica cuando se inicia con un nuevo lenguaje de programación porque ayuda a entender cómo ejecutar y visualizar el resultado de una instrucción básica.

El propósito principal del "Hola Mundo" es demostrar que has instalado correctamente tu entorno de desarrollo para Python y que puedes ejecutar programas simples. Este ejemplo te familiariza también con la sintaxis básica de Python, como las comillas que se utilizan para encerrar texto a imprimir.

Es importante porque sirve como punto de partida para ir aprendiendo conceptos más avanzados en programación, ayudándote a comprender cómo funciona el flujo del programa y cómo interactúa con el usuario a través de la salida por pantalla.

`001-Holamundo.py`

```python
print("Hola mundo desde Python")
```

### variables
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código Python crea dos variables y les asigna valores. La primera variable se llama `nombre` y le asigna un valor de tipo cadena (string), que es el nombre "Jose Vicente". Esta variable almacena información textual sobre una persona. La segunda variable, llamada `edad`, recibe un número entero (`47`) que representa la edad de esa misma persona en años. Estas variables permiten almacenar datos importantes para ser utilizados en operaciones más adelante en el programa o para mostrarlos al usuario. Son ejemplos simples de cómo se declaran y inicializan variables en Python, una práctica fundamental en programación para manejar información dinámica.

`002-variables.py`

```python
nombre = "Jose Vicente"
edad = 47
```

### salidas
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código Python muestra cómo imprimir texto y variables en la consola. Primero, se crea una variable llamada `nombre` que almacena el nombre de una persona como un conjunto de caracteres (una cadena). Luego, utiliza la función `print()` para mostrar el mensaje "Mi nombre es" seguido del valor almacenado en la variable `nombre`. Esto permite combinar texto y variables dentro de una misma línea de código, resultando en la salida: "Mi nombre es Jose Vicente". Este tipo de técnica es útil cuando deseas que tu programa genere un mensaje personalizado o informativo para el usuario.

`003-salidas.py`

```python
nombre = "Jose Vicente"
print("Mi nombre es",nombre)
```

### variar una variable
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código en Python muestra cómo se puede cambiar el valor de una variable durante la ejecución del programa. En este caso, la variable `nombre` almacena inicialmente el texto `"Jose Vicente"`. Luego, se imprime un mensaje que dice "Mi nombre es" seguido del contenido de la variable `nombre`, lo cual mostrará en pantalla "Mi nombre es Jose Vicente".

Después, en una segunda línea, la variable `nombre` cambia su valor a `"Juan"` y se vuelve a imprimir el mismo mensaje. Esto muestra en pantalla "Mi nombre es Juan". Este ejemplo demuestra que las variables pueden almacenar diferentes valores durante la ejecución del programa, lo que permite mucho más flexibilidad al diseñar programas.

Es importante entender este concepto porque te permitirá crear programas dinámicos donde los datos pueden cambiar mientras el programa se está ejecutando.

`004-variar una variable.py`

```python
nombre = "Jose Vicente"
print("Mi nombre es",nombre)

nombre = "Juan"
print("Mi nombre es",nombre)
```

### identificadores permitidos
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código ilustra cómo los nombres de las variables deben seguir ciertas reglas en Python. En este caso, el código muestra diferentes maneras de nombrar variables que son válidas y otras que no lo son. 

Primero, `nombre` y `nombre2` son ejemplos correctos de nombres de variable porque utilizan letras alfabéticas y los nombres comienzan con una letra, seguida o no por más letras, dígitos u "_". Luego, se muestra un comentario que indica que "2nombre" no es un nombre válido para una variable en Python ya que debe comenzar con una letra. A continuación, `nombre_completo` es un ejemplo correcto de uso de guiones bajos ("_") como separador entre palabras en variables con nombres compuestos (también conocido como "snake case").

El código también muestra ejemplos de nombres incorrectos para las variables: `#nombre-completo` y `#nombre completo`. La primera está mal porque usa un guion ("-"), lo que no es permitido. La segunda incluye un espacio en el nombre, lo cual tampoco es válido en Python. Finalmente, se muestra `nombreCompleto`, que aunque es legal, está escrito en mayúsculas y minúsculas juntas (también conocido como "camel case"), pero no es la convención recomendada para nombres de variables en Python.

Este ejercicio te ayuda a entender las reglas importantes sobre cómo nombrar variables en Python y por qué seguir estas reglas es crucial para escribir código legible y libre de errores.

`005-identificadores permitidos.py`

```python
nombre = "Jose"
nombre2 = "Vicente"
# 2nombre = "Jose Vicente"
nombre_completo = "Jose Vicente"
#nombre-completo = "Jose Vicente"
#nombre completo = "Jose Vicente"
nombreCompleto = "Jose Vicente" # Es legal pero no se recomienda
```

### comentarios
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código muestra dos tipos diferentes de comentarios en Python. Un comentario en programación es texto que se incluye en el código fuente pero no afecta a la ejecución del programa; sirve para documentar y explicar el código.

El primer tipo de comentario es un comentario simple, representado por el símbolo `#`. Todo lo que sigue después de este símbolo en la misma línea será ignorado por el intérprete de Python. En tu ejemplo, "Esto es un comentario de una única línea" se utiliza para proporcionar una breve descripción o nota sobre esa parte del código.

El segundo tipo de comentario mostrado es un bloque de comentarios múltiples líneas, representado entre tres comillas simples (`'''`) al inicio y al final. Esto permite escribir comentarios que ocupan varias líneas sin tener que poner el símbolo `#` en cada línea. En tu ejemplo, los bloques de texto "Esto es un comentario", "Esto sigue siendo un comentario" y "Y esto también lo es" están todos dentro del mismo bloque de comentario.

Los comentarios son fundamentales para la claridad y mantenibilidad del código, especialmente cuando trabajas en proyectos grandes o colaboras con otros programadores. Te ayudan a recordar el propósito de diferentes partes del programa y a explicar cómo funciona cierta lógica compleja.

`006-comentarios.py`

```python
# Esto es un comentario de una única línea

'''
    Esto es un comentario
    Esto sigue siendo un comentario
    Y esto también lo es
'''
```

### Explicacion del codigo
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es muy sencillo y fundamental para entender los conceptos básicos en programación. Primero, se define una variable llamada `edad` y se le asigna un valor numérico específico: 47. En este caso, `edad` es el nombre que elegimos para la variable; técnicamente, lo llamamos identificador porque nos ayuda a identificar y referirnos al dato almacenado en esa posición de memoria.

El símbolo `=` se conoce como operador de asignación y su función es tomar un valor (en este caso, el número 47) y colocarlo dentro del contenedor que hemos nombrado `edad`. El número 47 es lo que llamamos un valor literal porque es un dato numérico exacto sin referencia a ninguna otra variable o cálculo.

Este código ilustra cómo declarar una variable, asignarle un valor específico y entender la diferencia entre un identificador (nombre de la variable), el operador de asignación (`=`) que une el identificador con su valor, y el valor literal en sí mismo. Es importante comprender estos conceptos para manejar datos correctamente en tus programas.

`007-Explicacion del codigo.py`

```python
edad = 47
# edad es el identificador
# = es el operador de asignación
# 47 es el valor literal que se es está asignando al identificador
```

### Tipos de datos
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este bloque de código en Python está creando variables y asignándoles diferentes tipos de datos comunes. Primero, se declara una variable llamada `nombre` que contiene el texto "Jose Vicente". Este es un ejemplo de una cadena (string), que son secuencias de caracteres entrecomillados. Luego, hay una variable llamada `edad`, la cual almacena el número entero 47, lo que representa los años de edad de una persona. A continuación, se define `altura` con el valor decimal 1.78, representando la altura en metros. Finalmente, se declara una variable booleana llamada `vivo`, que contiene un valor verdadero (True), indicando si una condición es cierta o falsa.

Este código ilustra cómo almacenar diferentes tipos de información utilizando variables en Python: cadenas para nombres y texto, números enteros para contar cosas como la edad, números decimales (flotantes) para medir cantidades que requieren precisión decimal, y valores booleanos para representar estados verdaderos o falsos. Es importante entender estos tipos de datos porque permiten a los programas manejar información del mundo real de manera más efectiva.

`008-Tipos de datos.py`

```python
nombre = "Jose Vicente" # Cadena
edad = 47 # Entero
altura = 1.78 # Decimal
vivo = True # Booleano
```

### Entradas
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código te pide que ingreses tu nombre y luego muestra ese nombre en la pantalla. Primero, la línea `nombre = input("Dime tu nombre: ")` espera a que el usuario teclee su nombre y lo almacene en una variable llamada `nombre`. La función `input()` se usa para capturar información del usuario cuando ejecutas un programa en Python. Después de ingresar el nombre y presionar Enter, el programa continuará con la siguiente línea.

Luego, `print("Tu nombre es: ", nombre)` muestra en pantalla el mensaje "Tu nombre es: " seguido del valor que has ingresado para `nombre`. Esto demuestra cómo se pueden combinar cadenas de texto estáticas (escribidas entre comillas) con variables para formar un mensaje personalizado.

Este código es importante porque te enseña dos conceptos fundamentales en la programación: cómo recibir información del usuario a través del teclado y cómo mostrar esa información nuevamente. Estas habilidades son esenciales para interactuar con los usuarios cuando crees aplicaciones más grandes y complejas.

`009-Entradas.py`

```python
nombre = input("Dime tu nombre: ")
print("Tu nombre es: ",nombre)
```

### Entrada y problema
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código solicita al usuario que ingrese su edad y luego imprime el doble de esa edad. Primero, la línea `edad = input("Dime tu edad: ")` muestra un mensaje en la pantalla pidiendo al usuario que introduzca su edad. La entrada del usuario (que podría ser cualquier texto) se guarda en la variable llamada `edad`. Luego, la segunda línea `print("El doble de tu edad es: "+edad)` imprime una frase que indica el doble de la edad almacenada en la variable `edad`. Sin embargo, hay un problema con esta parte del código ya que no está realizando ninguna operación matemática para calcular realmente el doble de la edad; simplemente está imprimiendo dos veces la edad como cadena de texto. Para obtener el doble real de la edad, necesitarías convertir `edad` a un número y multiplicarlo por 2 antes de imprimirlo.

`010-Entrada y problema.py`

```python
edad = input("Dime tu edad: ")
print("El doble de tu edad es: "+edad)
```

### Cambio de tipo de dato
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código realiza una serie de pasos para interactuar con el usuario y realizar un cálculo simple. Primero, le pregunta al usuario su edad utilizando la función `input()`, que permite recibir información del usuario a través del teclado. La respuesta del usuario se guarda en la variable `edad` como texto (o cadena de caracteres).

Después, el código intenta convertir esa entrada de texto (que es una representación textual del número) en un número entero usando la función `int()`. Esto es importante porque inicialmente la edad que introduce el usuario está almacenada como una cadena y no se puede multiplicar directamente con otro número.

Finalmente, el código calcula el doble del número entero recién convertido y lo almacena en la variable `doble`. Sin embargo, hay un error en la última línea: para imprimir este resultado junto con texto, es necesario concatenarlo adecuadamente. La línea correcta debería ser `"El doble de tu edad es: "+str(doble)` para asegurarse de que el número se convierta nuevamente a una cadena antes de ser mostrado por pantalla, ya que no puedes combinar directamente cadenas con números enteros en la función `print()` sin convertir primero el entero a texto.

`011-Cambio de tipo de dato.py`

```python
# Le pregunto al usuario por su edad
edad = input("Dime tu edad: ")
# Me aseguro de convertir la edad a un número entero
entero = int(edad)
# Calculo el doble de un número entero
doble = entero*2
# Saco el resultado por pantalla
print("El doble de tu edad es: "+doble)
```

### literales
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código en Python muestra cómo se definen variables que almacenan literales. Un literal es simplemente una forma directa de escribir un valor específico dentro del código. En este caso, tienes dos variables: `nombre` y `edad`. La variable `nombre` contiene el texto `"Jose Vicente"`, lo cual es un literal de tipo cadena (string) porque representa una secuencia de caracteres entre comillas. Por otro lado, la variable `edad` almacena el número `47`, que es un literal de tipo entero (integer) ya que se trata de un valor numérico sin decimales.

Este código es importante porque ilustra cómo Python diferencia entre diferentes tipos de datos para almacenar información variada como texto y números. Comprender estos conceptos básico te permitirá manejar adecuadamente los datos en tus programas futuros, asegurándote de que cada variable contenga el tipo de dato correcto para su propósito.

`012-literales.py`

```python
nombre = "Jose Vicente"
# Jose Vicente es el literal, y es de tipo cadena

edad = 47
# 47 es el literal, y es de tipo entero
```

### constantes
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código en Python está diseñado para explicar el concepto de constante y variable, así como la importancia del estilo de codificación. En primer lugar, se define una constante llamada `PI` con un valor numérico de aproximadamente 3.1415. Una constante es un valor que no debería cambiar durante la ejecución del programa; sin embargo, en este caso, el código demuestra cómo a pesar de llamarla "constante" y usar mayúsculas para indicarlo (`PI`), puedes cambiar su valor igual que con cualquier otra variable.

El código imprime inicialmente el valor de `PI`, muestra que se ha cambiado el valor de `PI` a 4, e imprime este nuevo valor. Aunque en la práctica se recomienda no modificar un valor supuestamente constante para mantener clara y coherente la lógica del programa, esta demostración ilustra cómo Python permite cambiar los "valores constantes".

Finalmente, el código incluye comentarios que resaltan las buenas prácticas de codificación: se sugiere usar mayúsculas para nombrar constantes y minúsculas o combinaciones con subrayados para variables. Esto mejora la legibilidad del código y ayuda a otros programadores a entender más fácilmente qué tipo de entidades están involucradas en el programa.

`013-constantes.py`

```python
PI = 3.1415

print("PI vale",PI)

PI = 4 # Le cambio el valor a PI

print("PI vale",PI)
# Las constantes deben formularse con mayúsculas
# Las variables deben formularse con minúsculas
```

### Diferencia
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código se centra en la creación y modificación de una variable que representa el número π (pi). Al principio, se define la constante `PI` con un valor literal numérico, 3.1416, que es una aproximación común para π. Sin embargo, después de esto, se reasigna a `PI` con el valor "unnumero", lo cual convierte esta variable en una cadena de texto.

Lo importante aquí es entender que aunque inicialmente `PI` fue definida como un número (una constante), al redefinir la misma variable como una cadena de texto, se pierde su significado original como aproximación numérica a π. Este ejemplo ilustra cómo las variables en Python pueden cambiar su tipo durante la ejecución del programa, y también muestra que no existe un concepto estricto de "constante" en el sentido inmutable; cualquier variable puede ser reasignada con un valor de otro tipo.

Este código es una excelente forma de demostrar a los estudiantes cómo funciona la asignación y reasignación de variables, así como las implicaciones de cambiar el tipo de dato asociado con una misma variable.

`014-Diferencia.py`

```python

# La constante es PI
# El literal es 3.1416

PI = 3.1416

PI = "unnumero"
```

### operadores aritmeticos
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código en Python muestra cómo se utilizan los operadores aritméticos básicos para realizar cálculos matemáticos. El código imprime el resultado de cinco diferentes expresiones: suma, resta, multiplicación, división y módulo (el resto de la división entera). Cada línea calcula una operación con los números 4 y 3 y luego muestra el resultado en pantalla.

- La primera línea `print(4+3)` imprime el resultado de sumar 4 y 3, lo que da como resultado 7.
- La segunda línea `print(4-3)` resta 3 de 4, dando como resultado 1.
- La tercera línea `print(4*3)` multiplica 4 por 3 para obtener 12.
- La cuarta línea `print(4/3)` divide 4 entre 3 y devuelve un número decimal (1.3333).
- Finalmente, la quinta línea `print(4%3)` calcula el resto de dividir 4 entre 3, que es igual a 1.

Estos operadores son fundamentales en cualquier programa que realice cálculos matemáticos y es importante entender cómo funcionan para poder manipular números correctamente en Python.

ÚLTIMO PÁRRAFO: Este código cambia significativamente del archivo anterior porque ya no incluye la definición de una constante, ni usa literales o variables. En su lugar, introduce el uso práctico de los operadores aritméticos para realizar cálculos y muestra cómo obtener diferentes resultados matemáticos directamente en el código.

`014-operadores aritmeticos.py`

```python
print(4+3)
print(4-3)
print(4*3)
print(4/3)
print(4%3)
```

### operadores de comparacion
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código está utilizando operadores de comparación en Python para evaluar diferentes condiciones entre dos números. Los operadores de comparación se utilizan para determinar relaciones como "menor que", "mayor que", "igual a" y otros, generando un resultado booleano (verdadero o falso). En este caso, el código compara siempre el número 4 con el número 3 utilizando cada uno de los operadores disponibles: menor que (`<`), menor o igual que (`<=`), mayor que (`>`), mayor o igual que (`>=`), igual a (`==`) y diferente de (`!=`). Cada comparación se imprime en la pantalla mostrando si es verdadera (True) o falsa (False). Por ejemplo, `print(4 < 3)` imprimirá "False" porque 4 no es menor que 3. Este tipo de operaciones son fundamentales para controlar el flujo del programa basado en condiciones específicas.

`015-operadores de comparacion.py`

```python
print(4 < 3)
print(4 <= 3)
print(4 > 3)
print(4 >= 3)
print(4 == 3)
print(4 != 3)
```

### operadores arimeticos abreviados
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código muestra cómo se utilizan los operadores aritméticos abreviados en Python, que son una forma concisa de realizar cálculos sobre variables. La variable `edad` comienza con el valor de 47. El programa realiza varias operaciones matemáticas básicas (suma, resta, multiplicación y división) usando tanto los operadores estándar como las formas abreviadas de estos operadores.

Por ejemplo, en lugar de escribir `edad = edad + 2`, puedes usar la forma abreviada `edad += 2`. Esto hace que el código sea más corto y legible. De igual manera, para restar, multiplicar o dividir, se usan los símbolos `-=` , `*=` y `/=`, respectivamente.

Esta técnica es útil cuando deseas realizar operaciones directamente sobre una variable sin necesidad de escribir el nombre de la variable dos veces. Es importante conocer estos operadores porque pueden hacer que tu código sea más limpio y fácil de entender, especialmente en situaciones donde se realizan múltiples actualizaciones a variables basadas en cálculos matemáticos simples.

`016-operadores arimeticos abreviados.py`

```python
edad = 47
# Le quiero sumar dos unidades
edad = edad + 2
edad += 2
#Le quiero restar dos unidades
edad = edad - 2
edad -= 2
# Lo quiero multiplicar por dos
edad = edad * 2
edad *= 2
# Lo quiero dividir por dos
edad = edad / 2
edad /= 2
```

### operadores booleanos
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código utiliza operadores booleanos en Python para realizar evaluaciones lógicas y mostrar los resultados por pantalla. Los operadores booleanos son fundamentales porque permiten combinar múltiples condiciones y tomar decisiones basadas en si esas condiciones se cumplen o no.

El código primero evalúa tres afirmaciones usando el operador `and`, que devuelve `True` solo si todas las afirmaciones individuales son verdaderas. En la primera línea, todas las comparaciones (4 == 4, 3 == 3 y 2 == 2) son ciertas, así que imprime `True`. Sin embargo, en la segunda línea, una de las comparaciones es falsa (2 == 1), por lo que el resultado completo es `False`.

Después, el código utiliza el operador `or` para evaluar si al menos una afirmación individual dentro de cada expresión es verdadera. En la tercera y cuarta línea, hay al menos una comparación verdadera en cada una (4 == 4), por lo que ambas líneas imprimen `True`. La quinta línea no tiene ninguna comparación cierta (todas son falsas: 4 == 3, 3 == 2, y 2 == 1) por lo que imprime `False`.

Estos ejemplos ayudan a entender cómo los operadores booleanos combinados pueden ser utilizados para crear evaluaciones lógicas complejas en Python.

`017-operadores booleanos.py`

```python
print(4 == 4 and 3 == 3 and 2 == 2)
print(4 == 4 and 3 == 3 and 2 == 1)

print(4 == 4 or 3 == 3 or 2 == 1)
print(4 == 4 or 3 == 2 or 2 == 1)
print(4 == 3 or 3 == 2 or 2 == 1)
```

### Ejercicio1-Calculadora de impuestos
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es la cabecera o comentario inicial del archivo `Calculadora de impuestos.py`. En este bloque, se proporcionan detalles importantes sobre el programa como su nombre (`Calculadora de Impuestos`), la versión (`v0.1`) y el autor (`por Jose Vicente Carratalá`). Además, describe brevemente lo que hace el programa: permite al usuario introducir una cantidad base imponible y calcula tanto el IVA (Impuesto sobre el Valor Añadido) como el total incluyendo este impuesto.

Este tipo de comentarios iniciales es crucial para entender rápidamente la función del código y quién lo ha creado, facilitando su mantenimiento y colaboración en proyectos más grandes.

`018-Ejercicio1-Calculadora de impuestos.py`

```python
'''
    Calculadora de Impuestos
    v0.1 por Jose Vicente Carratalá
    Funcionamiento: Introduce una base imponible y se calcula IVA y total
'''
```

### Calculadora
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es el inicio de un programa en Python que sirve como una simple calculadora para calcular impuestos, específicamente el IVA y el total de una factura. El propósito del programa es solicitar al usuario que ingrese la base imponible de una factura, que es el valor original antes de aplicar cualquier impuesto.

El código comienza con un comentario que proporciona detalles sobre qué hace el programa, quién lo creó y su versión actual. A continuación, declara tres variables: `base_imponible`, `total_iva` y `total_factura`. Estas variables almacenarán respectivamente la base imponible de la factura (el monto original), el total del IVA calculado a partir de esa base imponible y el total de la factura (la suma de la base imponible más el IVA).

El código también incluye un comentario que señala dónde se colocarían las funciones o clases si las hubiera. Actualmente, ese espacio está vacío.

Finalmente, el programa solicita al usuario que introduzca el valor de la base imponible mediante una entrada del usuario (`input()`) y guarda ese valor en la variable `base_imponible`. Este paso es crucial porque establece el punto de partida para cualquier cálculo adicional, como calcular el IVA y el total. Sin embargo, en este fragmento de código no se incluyen los pasos para calcular realmente el IVA o el total de la factura.

`019-Calculadora.py`

```python
'''
    Calculadora de Impuestos
    v0.1 por Jose Vicente Carratalá
    Funcionamiento: Introduce una base imponible y se calcula IVA y total
'''

# Este programa no tiene importaciones

# Creo variables
base_imponible = 0
total_iva = 0
total_factura = 0

# Aquí pondría las funciones/clases

# Ahora calculamos
base_imponible = input("Introduce la base imponible de la factura: ")
```

### Calculadora
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código es un programa simple en Python que permite al usuario calcular el IVA y el total de una factura basándose en la base imponible introducida por el usuario. El programa comienza mostrando mensajes para presentar al usuario la función del programa y pedirle que ingrese la base imponible.

Las variables `base_imponible`, `total_iva` y `total_factura` se declaran al principio del código para almacenar los valores relevantes en diferentes pasos del cálculo. Sin embargo, el código proporcionado solo captura la entrada del usuario para la base imponible y no realiza ningún cálculo adicional sobre IVA o total.

Es importante destacar que este fragmento es solo el inicio de un programa más completo que debería incluir funciones adicionales para calcular el IVA y sumar los valores para obtener el total de la factura. El código también podría beneficiarse de mejoras en términos de validación de entrada para asegurar que el usuario introduzca un número válido como base imponible, así como de añadir comentarios claros explicando cada paso del proceso.

`020-Calculadora.py`

```python
'''
    Calculadora de Impuestos
    v0.1 por Jose Vicente Carratalá
    Funcionamiento: Introduce una base imponible y se calcula IVA y total
'''

# Este programa no tiene importaciones

# Creo variables
base_imponible = 0
total_iva = 0
total_factura = 0

# Aquí pondría las funciones/clases

# Ahora calculamos
print("Programa calculadora de impuestos")
print("(c) 2025 Jose Vicente Carratalá")
print("Introduce una base y te calculo el IVA y el total")
base_imponible = input("Introduce la base imponible de la factura: ")
```

### Calculo de IVA
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código Python se trata de un programa simple que calcula el IVA y el total de una factura a partir de la base imponible proporcionada por el usuario. El programa inicia mostrando un mensaje que identifica al creador del mismo y describe brevemente su función.

En primer lugar, define tres variables: `base_imponible`, `total_iva` y `total_factura`. Estas variables se utilizan para almacenar la base imponible ingresada por el usuario, el IVA calculado y el total de la factura respectivamente. 

El programa entonces solicita al usuario que introduzca el valor de la base imponible a través de la función `input()`, convirtiendo esta entrada en un número decimal (float) para poder realizar cálculos matemáticos sobre ella.

Una vez obtenida la base imponible, se calcula el IVA aplicando una tasa del 21% (multiplicando por 0.21), y luego se suma este valor al monto original para obtener el total de la factura.

Finalmente, muestra en pantalla tanto el IVA como el total de la factura utilizando la función `print()`. Este tipo de programa es fundamental para entender cómo interactuar con usuarios a través de entradas y salidas, así como para aplicar conceptos básicos de matemáticas en programación.

`021-Calculo de IVA.py`

```python
'''
    Calculadora de Impuestos
    v0.1 por Jose Vicente Carratalá
    Funcionamiento: Introduce una base imponible y se calcula IVA y total
'''

# Este programa no tiene importaciones

# Creo variables
base_imponible = 0
total_iva = 0
total_factura = 0

# Aquí pondría las funciones/clases

# Ahora calculamos

# Primero pido una entrada
print("Programa calculadora de impuestos")
print("(c) 2025 Jose Vicente Carratalá")
print("Introduce una base y te calculo el IVA y el total")
base_imponible = float(input("Introduce la base imponible de la factura: "))

# Luego realizo cálculos
total_iva = base_imponible*0.21
total_factura = base_imponible + total_iva

# Por último expreso una salida
print("El IVA de la factura es: ",total_iva)
print("El total de la factura es: ",total_factura)
```

### Actividades propuestas

### Actividad 1: Programa de Saludo Personalizado
**Descripción:** Los estudiantes deben crear un programa que imprima "¡Hola, [nombre del estudiante]!" en lugar de simplemente "Hola mundo". Se pretende que aprendan a utilizar variables y funciones básicas.

### Actividad 2: Gestión de Variables
**Descripción:** Diseñar una aplicación simple que cambie el valor de una variable y muestre su nuevo contenido. Los estudiantes aprenderán sobre la mutabilidad en Python y cómo cambiar los valores asignados a las variables durante la ejecución del programa.

### Actividad 3: Entrada/Salida Mejorada
**Descripción:** Crear un programa que pida al usuario ingresar su nombre y luego imprimirlo con una frase amigable. Este ejercicio ayuda a entender mejor el uso de funciones `input()` y `print()` en Python.

### Actividad 4: Conversión de Tipos de Datos
**Descripción:** Los estudiantes deben escribir un programa que solicite la edad del usuario (como cadena) e imprima el doble de su edad. El objetivo es aprender a convertir tipos de datos entre cadenas y números enteros para realizar operaciones aritméticas.

### Actividad 5: Operadores Aritméticos
**Descripción:** Implementar un programa que utilice diferentes operadores aritméticos (suma, resta, multiplicación, división) con dos números. Los estudiantes aprenderán a aplicar estos conceptos en situaciones prácticas.

### Actividad 6: Operadores de Comparación
**Descripción:** Desarrollar un programa que evalúe expresiones usando operadores de comparación (>, <, >=, <=, ==, !=) y muestre el resultado. Se espera que los estudiantes comprendan cómo funcionan estas operaciones en Python.

### Actividad 7: Operadores Aritméticos Abreviados
**Descripción:** Crear un programa que utiliza operadores de asignación como `+=`, `-=`, `*=`, `/=` para modificar el valor de una variable. Los estudiantes aprenderán sobre la eficiencia del código y las formas abreviadas de escribir instrucciones.

### Actividad 8: Operaciones Booleanas
**Descripción:** Implementar un programa que utilice operadores lógicos `and` y `or`. Se espera que los estudiantes comprendan cómo combinar varias condiciones en una sola expresión booleana para tomar decisiones en el código.

### Actividad 9: Calculadora de IVA Básica
**Descripción:** Crear un programa sencillo que calcule el valor del IVA y el total a partir de la base imponible introducida por el usuario. Los estudiantes aprenderán sobre entradas y cálculos en Python, así como cómo estructurar programas más complejos.

### Actividad 10: Mejora Estética e Información
**Descripción:** Añadir un encabezado con detalles del autor al programa de la calculadora del IVA (como se muestra en los ejemplos). Los estudiantes mejorarán sus habilidades de codificación y aprenderán sobre buenas prácticas en la escritura de código.



<a id="utilizacion-de-objetos"></a>
# Utilización de objetos

<a id="caracteristicas-de-los-objetos"></a>
## Características de los objetos

### Introducción a los ejercicios

En esta subunidad, nos enfocamos en comprender y utilizar objetos predefinidos en Python, específicamente centrándonos en cómo interactuar con ellos para resolver problemas comunes. Los ejercicios te ayudarán a familiarizarte con el uso del módulo `math` de Python, donde practicarás operaciones matemáticas avanzadas y manipulación de números utilizando funciones predefinidas como `sqrt`, `sin`, `cos` entre otras. Este conjunto de ejercicios te permitirá mejorar tus habilidades en la resolución de problemas que requieren cálculos matemáticos precisos, así como desarrollar una mayor confianza al utilizar bibliotecas estándar de Python.

### objeto math
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Parece que no has proporcionado el código específico del archivo `001-objeto math.py` para que lo explique. Por favor, proporcione el bloque de código en cuestión y estaré encantado de ayudarte a entenderlo.

`001-objeto math.py`

```python

```

### Actividades propuestas

### Actividad 1: Utilización del objeto `math`
**Descripción:** Los alumnos deben usar el módulo `math` de Python para realizar cálculos matemáticos más avanzados que no pueden hacerse con operaciones básicas. Se espera que aprendan a utilizar funciones como `sqrt`, `pow`, y `sin`.

### Actividad 2: Creación de un programa de conversión
**Descripción:** Los estudiantes deben crear un programa simple que convierta unidades utilizando el módulo `math`. Por ejemplo, convertir grados centígrados a Fahrenheit. Esto les ayudará a entender cómo aplicar las funciones matemáticas en situaciones reales.

### Actividad 3: Cálculo de áreas y volúmenes
**Descripción:** Los alumnos deben diseñar un programa que calcule el área y volumen de diferentes figuras geométricas utilizando funciones del módulo `math`. Esto les permitirá familiarizarse con las operaciones matemáticas avanzadas en Python.

### Actividad 4: Resolución de ecuaciones
**Descripción:** Los estudiantes deben escribir un programa que resuelva ecuaciones cuadráticas o lineales utilizando funciones del módulo `math`. Esto les ayudará a comprender cómo aplicar fórmulas matemáticas en Python.

### Actividad 5: Generación de números aleatorios
**Descripción:** Los alumnos deben usar el objeto `random` (asociado con `math`) para generar secuencias de números aleatorios y calcular estadísticas básicas como la media o la mediana. Esto les permitirá entender cómo combinar múltiples objetos en un solo programa.

### Actividad 6: Manipulación de radianes
**Descripción:** Los estudiantes deben crear funciones que conviertan grados a radianes y viceversa, utilizando las funciones del módulo `math`. Esto les ayudará a entender la manipulación de ángulos en programas matemáticos.

### Actividad 7: Cálculo de distancia entre puntos
**Descripción:** Los alumnos deben desarrollar un programa que calcule la distancia euclidiana entre dos puntos en el espacio bidimensional o tridimensional utilizando funciones del módulo `math`. Esto les permitirá aplicar conceptos geométricos en Python.

### Actividad 8: Implementación de algoritmos numéricos
**Descripción:** Los estudiantes deben implementar un algoritmo simple que use la clase `math` para calcular números aproximados, como el valor de Pi mediante métodos de integración. Esto les permitirá entender cómo se utilizan los objetos matemáticos en algoritmos más complejos.

Estas actividades están diseñadas para ayudar a los estudiantes a dominar el uso del objeto `math` y otras funciones predeterminadas en Python, aplicándolas en contextos prácticos y resolviendo problemas comunes de programación.


<a id="instanciacion-de-objetos"></a>
## Instanciación de objetos

### Introducción a los ejercicios

En esta subcarpeta, se enfatiza el uso y manipulación de objetos predefinidos en Python, específicamente aquellos que pertenecen a módulos incorporados como `math`. Los ejercicios están diseñados para que los estudiantes practiquen la importación de módulos, el acceso a sus funciones y atributos, así como entender cómo utilizar correctamente estos objetos existentes para resolver problemas matemáticos o lógicos. Este conjunto de ejercicios es crucial para desarrollar competencias en la utilización eficiente de la biblioteca estándar de Python, permitiendo a los estudiantes aplicar conceptos matemáticos avanzados y funciones específicas del módulo `math` en el desarrollo de algoritmos y soluciones prácticas.

### namespace
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es una importación simple en Python. La línea `import math` se utiliza para incluir el módulo `math` en tu programa. El módulo `math` contiene muchas funciones matemáticas útiles y constantes que no están disponibles por defecto, como la función para calcular raíces cuadradas (`sqrt()`), valores trigonométricos como seno y coseno (`sin()`, `cos()`), y otras operaciones matemáticas avanzadas. Al importar este módulo, puedes utilizar todas estas funciones en tu programa para realizar cálculos más complejos o precisos que los proporcionados por las operaciones básicas de Python.

Es importante destacar que al escribir `import math`, estás incluyendo todo el contenido del módulo. Si solo necesitas algunas funciones específicas, podrías importarlas individualmente para mantener tu código limpio y eficiente.

`002-namespace.py`

```python
import math
```

### Actividades propuestas

### Actividad 1: Uso Básico de Nombres Espaciales (Namespaces) con Math

**Descripción:** Los estudiantes deben importar el módulo `math` en Python y utilizar algunas funciones básicas como `sqrt`, `sin`, o `cos`. Se espera que comprendan cómo se utiliza el espacio de nombres para acceder a las funciones matemáticas predefinidas.

### Actividad 2: Cálculo de Áreas con Math

**Descripción:** Los alumnos deben calcular áreas de diferentes figuras geométricas (círculos, triángulos) utilizando funciones del módulo `math`. Se busca reforzar el uso de constantes y funciones matemáticas predefinidas.

### Actividad 3: Conversión de Ángulos

**Descripción:** Los estudiantes deben escribir un programa que convierta grados a radianes y viceversa, utilizando las funciones adecuadas del módulo `math`. Se pretende que comprendan la importancia de usar unidades correctas en cálculos matemáticos.

### Actividad 4: Operaciones con Números Complejos

**Descripción:** Los alumnos deben realizar operaciones básicas (suma, resta, multiplicación) con números complejos utilizando el módulo `cmath` del espacio de nombres. Se busca que dominen la manipulación de tipos numéricos avanzados en Python.

### Actividad 5: Cálculo de Raíces y Potencias

**Descripción:** Los estudiantes deben calcular raíces cuadradas y cubicas, así como potencias elevando un número a otra. Se pretende que practiquen el uso del módulo `math` para resolver problemas matemáticos cotidianos.

### Actividad 6: Generación de Secuencias Numéricas

**Descripción:** Los alumnos deben generar secuencias numéricas utilizando la función `range()` y operaciones con arrays. Se busca que comprendan cómo crear iterables complejos para cálculos matemáticos más avanzados.

### Actividad 7: Comparación de Números Reales

**Descripción:** Los estudiantes deben escribir un programa que compare números reales utilizando el módulo `math` y operadores relacionales. Se pretende que practiquen la manipulación precisa de valores numéricos en Python.

### Actividad 8: Ejecución de Algoritmos Matemáticos Simples

**Descripción:** Los alumnos deben implementar algoritmos matemáticos simples (como el cálculo del máximo común divisor) utilizando funciones del módulo `math`. Se busca que practiquen la resolución de problemas matemáticos con funciones predefinidas en Python.

### Actividad 9: Visualización Básica de Gráficas

**Descripción:** Los estudiantes deben crear gráficas simples (como una función seno) utilizando bibliotecas como `matplotlib` que se importan a través del espacio de nombres. Se pretende que dominen la integración de herramientas visuales con cálculos matemáticos.

### Actividad 10: Resolución de Problemas Prácticos

**Descripción:** Los alumnos deben resolver problemas prácticos (como calcular áreas bajo curvas) utilizando funciones del módulo `math`. Se busca que apliquen conocimientos teóricos en contextos aplicados y realistas.


<a id="utilizacion-de-metodos-parametros"></a>
## Utilización de métodos. Parámetros

### Introducción a los ejercicios

Esta carpeta contiene ejercicios enfocados en la utilización y llamada a métodos de objetos predefinidos en Python, específicamente haciendo uso de la biblioteca `math`. Los ejercicios buscan que los estudiantes comprendan cómo importar módulos, llamar a sus métodos y utilizarlos para realizar operaciones matemáticas básicas. Se enfatiza el manejo de parámetros y el entendimiento del retorno de valores, lo cual es crucial para desarrollar habilidades en la manipulación de objetos y métodos en Python.

### llamada a metodos
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código está importando una biblioteca de Python llamada `math` con un alias, lo que significa que le estamos dando un nombre diferente para usarla en nuestro programa. En este caso, la biblioteca `math` se importa como `matematicas`. Luego, el programa utiliza una función específica de esta biblioteca: `ceil`, que redondea un número hacia arriba al entero más cercano. Aquí, se está aplicando `ceil` a 7.2, lo que hace que el resultado sea 8 porque es el siguiente entero mayor después de 7.2.

Este tipo de código es importante cuando necesitas realizar cálculos matemáticos precisos en tu programa, como redondear números o calcular otras funciones matemáticas complejas. Usar un alias para bibliotecas te permite hacer que tus importaciones sean más claras y cortas, facilitando la lectura del código.

En resumen, este fragmento demuestra cómo usar una función de redondeo hacia arriba desde la biblioteca `math`, con un nombre alternativo para simplificar el uso futuro en el programa.

`003-llamada a metodos.py`

```python
import math as matematicas

print(matematicas.ceil(7.2))
```

### sparse is better than dense
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código es una demostración sencilla de cómo se utiliza la función `ceil` del módulo `math`, que en este caso se ha importado con el alias `matematicas`. La variable `numero` almacena un número decimal, 7.2. Luego, se aplica la función `ceil` a esta variable para redondear hacia arriba al siguiente entero más cercano y el resultado es guardado en la variable `redondeo`. Finalmente, el programa imprime este valor redondeado. En resumen, muestra cómo importar funciones matemáticas específicas e implementarlas para manipular números decimales de manera precisa.

Es importante entender esto porque te permite realizar cálculos numéricos más precisos en tu código, especialmente cuando necesitas trabajar con conceptos como el redondeo hacia arriba.

`004-sparse is better than dense.py`

```python
import math as matematicas

numero = 7.2
redondeo = matematicas.ceil(numero)
print(redondeo)
```

### sparse
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es una versión simplificada del anterior y su objetivo es mostrar cómo se puede utilizar la función `ceil` del módulo `math`, que ya hemos importado con el alias `matematicas`. La función `ceil` (que significa "cuerpo celeste" en inglés, pero en contexto matemático se refiere a "redondeo hacia arriba") toma un número decimal y devuelve el entero más cercano que es mayor o igual al número dado. En este caso, se está utilizando directamente la función `ceil` con el número 7.2 como argumento sin almacenar primero el resultado en una variable intermedia.

La diferencia principal entre el código actual y el anterior es que aquí no se utiliza ninguna variable para guardar el valor redondeado obtenido mediante `matematicas.ceil(7.2)`. En lugar de eso, la función se llama directamente dentro del comando `print`, lo cual simplifica el código y hace que sea más conciso, eliminando la necesidad de una línea adicional de código para almacenar temporalmente el resultado.

En resumen, este cambio simplifica el proceso de redondeo hacia arriba de un número decimal a una sola línea de código que directamente muestra el resultado por pantalla.

`004-sparse.py`

```python
import math as matematicas

print(matematicas.ceil(7.2))
```

### Actividades propuestas

### Actividad 1: Llamada a Métodos de Matemáticas Básicos
**Descripción:** Los estudiantes deben utilizar el módulo `math` en Python para llamar a distintos métodos, como `ceil`, `floor`, y `sqrt`. Se espera que comprendan cómo importar un módulo e invocar sus funciones.

### Actividad 2: Redondeo de Números
**Descripción:** Los estudiantes deben crear una función que redondee números hacia arriba utilizando el método `math.ceil` con diferentes valores numéricos. El objetivo es entender cómo aplicar operaciones matemáticas en Python para manipular datos.

### Actividad 3: Creación de Objetos y Acceso a Métodos
**Descripción:** Los estudiantes deben aprender a crear objetos desde módulos importados, como `math`, y acceder a métodos específicos. Se enfatiza la importancia de entender cómo trabajar con bibliotecas estándar.

### Actividad 4: Uso de Variables Intermedias en Métodos
**Descripción:** Los estudiantes deben usar una variable para almacenar el resultado de un método como `math.ceil` antes de imprimirlo. Esto ayudará a comprender la importancia del manejo adecuado de variables y cómo se integran con los métodos.

### Actividad 5: Documentación y Comentarios
**Descripción:** Los estudiantes deben añadir documentación y comentarios al código para explicar qué hace cada parte, especialmente cuando se llaman a métodos. Se pretende mejorar sus habilidades en la documentación de código.

### Actividad 6: Comparación entre Métodos Matemáticos
**Descripción:** Los estudiantes deben escribir un programa que utilice tanto `math.ceil` como `math.floor`, y luego comparar los resultados para diferentes números decimales. El objetivo es entender las diferencias en el comportamiento de distintos métodos matemáticos.

### Actividad 7: Uso de Métodos con Variables Dinámicas
**Descripción:** Los estudiantes deben crear un programa que solicite al usuario un número decimal y luego use ese valor para llamar a `math.ceil` o `math.floor`. Esto ayuda en el manejo de entrada de datos y métodos matemáticos.

### Actividad 8: Aplicación Práctica de Métodos Matemáticos
**Descripción:** Los estudiantes deben desarrollar un pequeño programa que resuelva un problema real utilizando métodos del módulo `math`, como calcular áreas, volúmenes o resolver ecuaciones. Se espera que apliquen lo aprendido en contextos prácticos.

### Actividad 9: Creación de Subrutinas con Métodos Matemáticos
**Descripción:** Los estudiantes deben crear funciones personalizadas que utilicen métodos del módulo `math`. Esto mejorará sus habilidades en la creación de subrutinas y modularización de código.

### Actividad 10: Evaluación Comparativa entre Métodos Propios y Módulos Externos
**Descripción:** Los estudiantes deben comparar el uso de métodos matemáticos directamente programados contra los proporcionados por módulos como `math`. Se espera que entiendan las ventajas y desventajas de cada enfoque.


<a id="utilizacion-de-propiedades"></a>
## Utilización de propiedades

### Introducción a los ejercicios

En esta subunidad, se enfatiza la comprensión y el uso de objetos predeterminados en Python, específicamente aquellos que ya existen en bibliotecas estándar como `math`. Los ejercicios te guiarán a través del proceso de importar módulos, acceder a constantes y métodos definidos por estos módulos, así como la manipulación de propiedades matemáticas fundamentales. El objetivo es que los estudiantes adquieran competencias en la utilización eficiente de objetos integrados para resolver problemas comunes en programación.

A través de estos ejercicios, se practicarán habilidades como el manejo de módulos de biblioteca estándar y la aplicación de propiedades y métodos existentes para realizar cálculos matemáticos o manipulaciones de datos básicas.

### propiedades
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código en Python muestra cómo importar un módulo y acceder a uno de sus valores. En primer lugar, se importa el módulo `math` con el alias `matematicas`. Esto significa que puedes referirte al módulo `math` como `matematicas`, lo cual puede hacer el código más legible para quienes trabajen en un proyecto donde este alias haya sido establecido.

Luego, se guarda el valor de la constante `pi` del módulo `matematicas` en una variable llamada `PI`. En matemáticas y programación, π (pi) es una constante importante que representa la relación entre el circunferencia de un círculo y su diámetro.

Finalmente, se imprime el valor de `PI`, lo que mostrará el número 3.141592653589793 en la consola o terminal. Este código es útil para cuando necesites usar el valor de π en tus cálculos matemáticos dentro de un programa, ya que te permite acceder a este valor preciso sin tener que escribirlo tú mismo.

`005-propiedades.py`

```python
import math as matematicas

PI = matematicas.pi
print(PI)
```

### Actividades propuestas

### Actividad 1: Utilización de Propiedades Matemáticas Básicas
**Descripción:** Los estudiantes deberán utilizar la biblioteca `math` para imprimir varias constantes y funciones matemáticas. Esta actividad busca que los alumnos comprendan cómo acceder a propiedades predefinidas en Python.

### Actividad 2: Creación de Objetos Matemáticos Simples
**Descripción:** Se les pide a los estudiantes que creen objetos utilizando la biblioteca `math` y muestren sus propiedades, como constantes matemáticas o resultados de funciones. Esta actividad se centra en el uso práctico de las propiedades.

### Actividad 3: Operaciones Matemáticas Concretas
**Descripción:** Los alumnos deben realizar operaciones matemáticas básicas utilizando métodos y propiedades proporcionadas por la biblioteca `math`. Este ejercicio tiene como objetivo reforzar la comprensión de cómo se utilizan estas herramientas en cálculos.

### Actividad 4: Comparación de Valores Matemáticos
**Descripción:** Los estudiantes compararán valores numéricos utilizando las propiedades y métodos proporcionados por `math`. Esta actividad busca mejorar sus habilidades en la manipulación de datos matemáticos con objetos predeterminados.

### Actividad 5: Uso del Valor Pi para Cálculos Circulares
**Descripción:** Utilizando el valor pi (`PI`) desde `math`, los alumnos calcularán áreas y perímetros de círculos. Esta tarea refuerza el uso práctico de propiedades matemáticas en situaciones cotidianas.

### Actividad 6: Creación de una Clase que Utilice Propiedades Matemáticas
**Descripción:** Los estudiantes crearán una clase simple que importe y utilice propiedades del módulo `math`. Esta actividad busca que comprendan cómo integrar objetos matemáticos en estructuras más complejas.

### Actividad 7: Resolución de Problemas con Propiedades Matemáticas
**Descripción:** A los alumnos se les presentará un problema real y deben resolverlo utilizando las propiedades y métodos proporcionados por `math`. Esta actividad fomenta el pensamiento lógico y la aplicación práctica del conocimiento.

### Actividad 8: Documentación de Propiedades Matemáticas
**Descripción:** Los estudiantes revisarán documentación oficial sobre el módulo `math` y describirán las propiedades y métodos que más les hayan interesado. Esta actividad busca mejorar sus habilidades en la búsqueda de información técnica.

### Actividad 9: Ejecución de Cálculos Avanzados
**Descripción:** Los alumnos ejecutarán cálculos avanzados como factoriales, potencias, logaritmos y raíces cuadradas utilizando `math`. Este ejercicio reforzará su confianza en el manejo de propiedades matemáticas complejas.

### Actividad 10: Resolución de Ejercicios Propuestos
**Descripción:** Los estudiantes resolverán una serie de ejercicios propuestos que utilizan diferentes aspectos del módulo `math`. Esta actividad permite evaluar la comprensión global y la aplicación práctica del conocimiento adquirido.


<a id="utilizacion-de-metodos-estaticos"></a>
## Utilización de métodos estáticos

### Introducción a los ejercicios

En esta subunidad, se centran en la utilización de métodos estáticos en objetos y clases predefinidas del lenguaje Python. Los ejercicios no involucran la creación de nuevas clases desde cero sino que trabajan con las características ya establecidas dentro de los objetos matemáticos y otras estructuras existentes en el entorno de programación. Se practica cómo invocar métodos estáticos y compararlos con llamadas a métodos no estáticos, destacando la importancia del uso correcto de decoradores como `@staticmethod` para definir comportamientos que pertenecen a la clase en sí misma más que a una instancia específica.

### Gato
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código Python crea una clase llamada `Gato` que simula las características básicas de un gato. La clase tiene dos partes importantes: el método especial `__init__`, que se utiliza para inicializar los atributos del objeto, y un método estático llamado `maulla`. Sin embargo, hay un error en la definición del método `maulla` porque no debe ser estático si va a interactuar con las propiedades de una instancia específica de gato. En el código proporcionado, el método `maulla()` debería recibir `self` como parámetro para poder acceder al nombre del gato y otros atributos de la instancia.

Además, se crean dos instancias de la clase `Gato`, llamadas `gato1` y `gato2`, cada una con su propio nombre. El método `maulla()` debería ser invocado en estas instancias para que puedan emitir el sonido "miau", pero no está siendo utilizado correctamente debido a la falta del parámetro `self`. Es importante corregir esto para que los métodos de instancia funcionen adecuadamente.

En resumen, este código tiene potencial para enseñar sobre cómo crear y utilizar clases en Python, así como la importancia de definir correctamente los métodos de instancia en lugar de usar funciones estáticas cuando necesitas acceder a las propiedades del objeto.

`001-Gato.py`

```python
class Gato():
  def __init__(self):
    self.nombre = ""
  def maulla():
    return "miau"
    
gato1 = Gato()
gato1.nombre = "Micifu"

gato2 = Gato()
gato2.nombre = "Belcebú"
```

### Matematicas
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código crea una clase llamada `Matematicas` en Python. Dentro de esta clase, se define un método especial llamado `__init__`, que se ejecuta automáticamente cada vez que creamos una nueva instancia (o objeto) de la clase. En este caso, el método inicializa una variable de instancia llamada `self.numero` a 0.

La clase también tiene otro método llamado `suma`, que toma dos argumentos (`a` y `b`) y devuelve su suma. Este método se utiliza para sumar dos números proporcionados como entrada.

Después, en el código principal (fuera de la clase), creamos dos instancias diferentes de la clase `Matematicas`: una llamada `operacion1` y otra llamada `operacion2`. Luego, utilizamos cada instancia para llamar al método `suma`, pasándole dos números distintos. Finalmente, imprimimos en pantalla el resultado de estas operaciones.

Es importante notar que aunque la clase tiene un método `suma` útil, este no es estático (no se define con `@staticmethod`). Esto significa que para usarlo, necesitamos crear una instancia de la clase primero. El código muestra cómo hacer eso y luego utiliza el objeto para realizar cálculos matemáticos.

`002-Matematicas.py`

```python
class Matematicas():
  def __init__(self):
    self.numero = 0
  def suma(self,a,b):
    return a+b
    
operacion1 = Matematicas()
print(operacion1.suma(4,3))

operacion2 = Matematicas()
print(operacion2.suma(6,7))
```

### metodo pseudoestatico
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

El código que se muestra intenta llamar a un método llamado `suma` en una clase llamada `Matematicas`. Sin embargo, hay un problema con cómo este método es llamado. El método `suma` está definido dentro de la clase `Matematicas`, pero para poder acceder directamente a él sin crear una instancia de la clase (es decir, como si fuera un método estático), debería ser declarado específicamente como tal usando el decorador `@staticmethod`. 

En este código, cuando intenta llamar a `Matematicas.suma(6,7)`, Python genera un error porque el método `suma` requiere una instancia de la clase (`self`) como primer argumento y no está diseñado para ser llamado sin crear primero un objeto de tipo `Matematicas`.

Para corregir este código, puedes declarar el método `suma` como estático usando `@staticmethod`. Esto permitirá llamar al método directamente desde la definición de la clase sin necesidad de instanciarla. Aquí hay una versión correcta del código:

```python
class Matematicas():
  def __init__(self):
    self.numero = 0

  @staticmethod
  def suma(a, b):
    return a + b
    
print(Matematicas.suma(6,7))
```

Este cambio convierte `suma` en un método estático que no requiere una instancia de la clase para ser llamado y puede trabajar con cualquier par de números enteros proporcionados.

`003-metodo pseudoestatico.py`

```python
class Matematicas():
  def __init__(self):
    self.numero = 0
  def suma(self,a,b):
    return a+b
    
print(Matematicas.suma(6,7))
```

### metodo estatico
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código define una clase llamada `Matematicas` en Python. Dentro de la clase, se inicializa un método especial llamado `__init__`, que es como el constructor de la clase y establece un atributo `numero` con un valor predeterminado de 0 cada vez que se crea un nuevo objeto de esta clase.

Lo más interesante aquí es el método estático `suma(a, b)`. Un método estático es una función dentro de una clase que no necesita acceso a ninguna instancia específica de la clase para funcionar. En este caso, `suma` toma dos parámetros (`a` y `b`) y simplemente devuelve su suma.

Finalmente, el código llama a este método estático `Matematicas.suma(6, 7)` directamente desde la clase `Matematicas`, sin necesidad de crear una instancia (objeto) de esta clase. Esto imprime en pantalla el resultado de sumar 6 y 7, que es 13.

Este ejemplo demuestra cómo los métodos estáticos pueden ser útiles para encapsular funciones relacionadas con un concepto (como operaciones matemáticas), sin tener que crear objetos o acceder a propiedades particulares de estos.

`004-metodo estatico.py`

```python
class Matematicas():
  def __init__(self):
    self.numero = 0
  @staticmethod
  def suma(a,b):
    return a+b
    
print(Matematicas.suma(6,7))
```

### Actividades propuestas

### Actividades Propuestas

1. **Utilización de Métodos Estáticos en Clases**
   - **Descripción:** Los estudiantes deben modificar la clase `Matematicas` para que sus métodos operativos sean estáticos y luego ejecutarlas sin necesidad de instanciar objetos.
   - **Objetivo:** Aprender a definir y utilizar métodos estáticos en una clase.

2. **Comparación entre Métodos Instancia y Estáticos**
   - **Descripción:** Los estudiantes deben comparar la implementación y uso de un método de instancia con uno estático, explicando las diferencias.
   - **Objetivo:** Comprender los beneficios y limitaciones de cada tipo de métodos en una clase.

3. **Clase Gato Mejorada**
   - **Descripción:** Los estudiantes deben modificar la clase `Gato` para que el método `maulla()` sea estático, luego instanciar dos objetos y llamar al método.
   - **Objetivo:** Aprender a utilizar métodos estáticos en clases con lógica común.

4. **Creación de Métodos Estáticos Propios**
   - **Descripción:** Los estudiantes deben crear una clase llamada `Tiempo` con un método estático que devuelva la hora actual.
   - **Objetivo:** Practicar la implementación y uso de métodos estáticos para tareas generales.

5. **Comparativa entre Métodos Instancia y Pseudoestáticos**
   - **Descripción:** Los estudiantes deben crear una clase con métodos pseudoestáticos (llamados directamente en la clase) y compararlas con métodos de instancia.
   - **Objetivo:** Comprender las ventajas y desventajas del uso de métodos pseudoestáticos frente a métodos estáticos.

6. **Documentación Metodológica**
   - **Descripción:** Los estudiantes deben documentar cada método en la clase `Matematicas` con comentarios explicando su propósito.
   - **Objetivo:** Mejorar las habilidades de documentación y creación de código legible.

7. **Uso de Métodos Estáticos en Funciones Externas**
   - **Descripción:** Los estudiantes deben crear una función externa que llame a un método estático de la clase `Matematicas` para realizar cálculos matemáticos.
   - **Objetivo:** Aprender a integrar métodos estáticos con funciones externas del programa.

8. **Aplicación en Problemas Prácticos**
   - **Descripción:** Los estudiantes deben diseñar una clase que utilice métodos estáticos para resolver un problema práctico, como calcular el IVA.
   - **Objetivo:** Aprender a aplicar la programación orientada a objetos en soluciones reales.

9. **Refactorización de Código**
   - **Descripción:** Los estudiantes deben refactorizar el código existente (clase `Gato`) para mejorar su eficiencia y claridad, utilizando métodos estáticos cuando sea apropiado.
   - **Objetivo:** Mejorar las habilidades de análisis y mejora del código existente.

10. **Implementación de Clases Complementarias**
    - **Descripción:** Los estudiantes deben diseñar una clase adicional que interactúe con la clase `Matematicas` utilizando métodos estáticos para realizar operaciones matemáticas.
    - **Objetivo:** Aprender a crear y vincular clases en un contexto más amplio.


<a id="constructores"></a>
## Constructores

### Introducción a los ejercicios

En esta carpeta, se encuentran ejercicios que te ayudarán a comprender y utilizar objetos de fechas en Python. Los problemas abordan el manejo de la clase `date` del módulo `datetime`, permitiéndote trabajar con diferentes propiedades y métodos para obtener información detallada sobre una fecha específica, como año, mes, día y día de la semana. A través de estos ejercicios, mejorarás tus habilidades en el uso de objetos predefinidos del lenguaje, lo que es fundamental para cualquier proyecto que requiera manipulación de fechas y tiempo.

### fechas en python
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código está utilizando el módulo `datetime` de Python para trabajar con fechas. En primer lugar, se importa el módulo `datetime` con un alias (`as fechas`) lo que permite utilizar el nombre "fechas" en su lugar de `datetime`. Esto puede hacer que el código sea más claro y fácil de leer.

Luego, se crea una instancia de la clase `date` del módulo `fechas`, pasando los parámetros año (2025), mes (9) y día (11). Esta línea crea un objeto de fecha que representa al 11 de septiembre de 2025. La variable `hoy` guarda esta fecha.

Finalmente, se imprime el valor de la variable `hoy`, lo cual muestra en pantalla "2025-09-11", representando el formato por defecto que utiliza Python para mostrar objetos de tipo fecha.

Este código es importante porque demuestra cómo crear y utilizar objetos de fechas en Python, lo cual es una habilidad útil para trabajar con datos temporales.

`006-fechas en python.py`

```python
import datetime as fechas

hoy = fechas.date(2025, 9, 11)
print(hoy)
```

### propiedades de la fecha
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código en Python muestra cómo trabajar con objetos de fecha y extraer diferentes propiedades de ellos. En primer lugar, se importa el módulo `datetime` con un alias `fechas`. Luego, se crea una instancia de la clase `date` para representar una fecha específica del 11 de septiembre de 2025.

El código imprime esta fecha completa y también muestra cómo acceder a las propiedades individuales como el año, mes y día. Además, utiliza métodos para determinar qué día de la semana es según dos sistemas diferentes: `weekday()` y `isoweekday()`. Estos métodos devuelven un número entero que representa el día de la semana, donde 0 es lunes y 6 es domingo en el caso de `weekday()`, mientras que `isoweekday()` sigue el mismo formato pero se ajusta a las reglas del estándar ISO 8601.

Este tipo de código es importante para aprender cómo manipular fechas y comprender sus propiedades en Python, lo cual puede ser útil en muchos proyectos donde la gestión del tiempo es crucial.

`007-propiedades de la fecha.py`

```python
import datetime as fechas

hoy = fechas.date(2025, 9, 11)
print(hoy)

print(hoy.year)
print(hoy.month)
print(hoy.day)

diadelasemana = hoy.weekday()
print(diadelasemana)
diadelasemana = hoy.isoweekday()
print(diadelasemana)
```

### Actividades propuestas

### Actividad 1: Manipulación de Fechas Básica
**Descripción:** Los estudiantes deben crear un programa en Python que imprima la fecha actual del año 2025. Este ejercicio ayudará a familiarizarse con el módulo `datetime` y la creación de objetos date.

### Actividad 2: Acceso a Atributos de Fecha
**Descripción:** Los estudiantes deben escribir un programa que acceda a los atributos individuales (año, mes, día) de una fecha específica y los imprima por pantalla. Esta actividad les permitirá comprender cómo obtener diferentes partes de una fecha.

### Actividad 3: Creación de Objetos Fecha
**Descripción:** Los estudiantes tendrán que crear varios objetos `date` representando distintas fechas importantes del año (por ejemplo, aniversarios o festivos). Esto los ayudará a practicar la creación y manejo de múltiples objetos.

### Actividad 4: Día de la Semana
**Descripción:** Los estudiantes deben implementar un programa que determine el día de la semana correspondiente a una fecha dada (usando tanto `weekday` como `isoweekday`). Esto les enseñará a usar métodos para determinar características del calendario.

### Actividad 5: Comparación de Fechas
**Descripción:** Los estudiantes deben escribir un código que compare dos fechas diferentes y determine cuál es la más reciente. Esta actividad ayudará a entender los operadores relacionales en Python con objetos date.

### Actividad 6: Formateo de Fechas
**Descripción:** Se requiere que los estudiantes formatee una fecha dada en un formato específico (por ejemplo, "DD/MM/YYYY"). Esto les permitirá aprender cómo manipular la representación visual de las fechas.

### Actividad 7: Cálculo de Edad
**Descripción:** Los estudiantes deben crear un programa que calcule la edad basándose en una fecha de nacimiento proporcionada. Este ejercicio facilitará el uso del módulo `datetime` para cálculos temporales.

### Actividad 8: Eventos Futuros
**Descripción:** Los estudiantes tendrán que programar una lista de eventos con sus fechas correspondientes y determinar cuáles sucederán en los próximos meses. Esto les ayudará a manejar listas, bucles y condiciones lógicas.

### Actividad 9: Días Restantes
**Descripción:** Los estudiantes deben crear un programa que calcule el número de días restantes hasta una fecha futura dada. Esta actividad refuerza los conceptos de cálculo temporal con objetos date en Python.

### Actividad 10: Resumen Semanal
**Descripción:** Se les pide a los alumnos generar un resumen semanal que muestre todas las fechas y días correspondientes para una semana específica. Esto les permitirá combinar múltiples conceptos aprendidos sobre objetos date en un solo programa más complejo.


<a id="destruccion-de-objetos-y-liberacion-de-memoria"></a>
## Destrucción de objetos y liberación de memoria

### Introducción a los ejercicios

Esta carpeta contiene una serie de ejercicios diseñados para que comprendas cómo se manejan y eliminan objetos en Python, centrando la atención en la importancia de liberar memoria. Los ejercicios trabajan con conceptos como la creación de objetos, el acceso a sus propiedades y métodos, así como la gestión adecuada de su vida útil y eliminación para evitar fugas de memoria. Aunque algunos archivos contienen código incompleto o inadecuado relacionado con un problema de caballos en cuadras, el objetivo principal sigue siendo entender cómo funcionan los objetos en Python y cómo liberar memoria una vez que ya no se necesitan estos objetos.

### destruccion de objetos
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código muestra cómo trabajar con fechas en Python utilizando el módulo `datetime`. Primero, se importa la parte del módulo que maneja las fechas bajo el alias `fechas` para facilitar su uso. Luego, se crea un objeto de fecha llamado `hoy`, que representa el 11 de septiembre de 2025.

El código imprime varias características de esta fecha: el año (2025), el mes (9) y el día del mes (11). También calcula el número del día en la semana utilizando dos métodos diferentes: `weekday()` y `isoweekday()`, que proporcionan valores numéricos para representar el día de la semana.

Finalmente, se utiliza la instrucción `del hoy` para eliminar completamente el objeto `hoy` de la memoria. Sin embargo, al intentar imprimir `hoy` después de esta operación, obtendrás un error porque ya no existe ese objeto en tu programa. Este ejercicio demuestra cómo liberar la memoria ocupada por objetos que ya no son necesarios para evitar problemas relacionados con el uso excesivo de recursos.

`008-destruccion de objetos.py`

```python
import datetime as fechas

hoy = fechas.date(2025, 9, 11)
print(hoy)

print(hoy.year)
print(hoy.month)
print(hoy.day)

diadelasemana = hoy.weekday()
print(diadelasemana)
diadelasemana = hoy.isoweekday()
print(diadelasemana)

del hoy
print(hoy)
```

### caballos en la cuadra
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento es el encabezado o comentario inicial del archivo de Python llamado `caballos_en_la_cuadra.py`. El encabezado proporciona información sobre qué hace el programa y quién lo creó. En este caso, el programa se llama "Calculadora de cuadras" y su versión es la v0.1, creada en el año 2025 por Jose Vicente Carratalá.

El objetivo del programa es calcular el número de cuadras necesarias para albergar un cierto número de caballos. Este tipo de comentario inicial es importante porque ayuda a los demás programadores (o incluso a ti mismo si vuelves a este código después de tiempo) a entender rápidamente qué hace el programa sin tener que leer todo el código.

Este encabezado incluye detalles como la versión del programa, el autor y una breve descripción de su función, lo cual es una buena práctica en programación para mantener un código bien documentado y fácilmente manejable.

`009-caballos en la cuadra.py`

```python
''' 
    Calculadora de cuadras
    v0.1 (c) 2025 Jose Vicente Carratalá
    Programa que calcula número de cuadras a partir de los caballos
'''
```

### propiedades
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es el comienzo de un programa escrito en Python que se propone calcular el número de cuadras necesarias para alojar un cierto número de caballos. La documentación inicial indica que este programa, llamado "Calculadora de cuadras", está en su versión 0.1 y fue creado por Jose Vicente Carratalá en el año 2025.

En la parte central del código, se definen dos variables importantes: `caballos` e `cuadras`. Ambas son inicializadas a cero (`caballos = 0` y `cuadras = 0`). Estas líneas de código establecen el punto de partida para las operaciones que vendrán después, donde probablemente se calculará cuántas cuadras son necesarias dada la cantidad de caballos. Es importante inicializar estas variables a cero antes de usarlas en cualquier cálculo o entrada del usuario para garantizar que empiecen con un valor conocido y no causen errores en el programa.

Este código establece una base sólida para futuras implementaciones donde se podrán ingresar datos sobre caballos y calcular las cuadras necesarias, lo cual es útil tanto en contextos prácticos como educativos.

`010-propiedades.py`

```python
''' 
    Calculadora de cuadras
    v0.1 (c) 2025 Jose Vicente Carratalá
    Programa que calcula número de cuadras a partir de los caballos
'''

# Datos de inicio
caballos = 0
cuadras = 0
```

### entrada calculo y salida
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es un programa simple en Python que sirve como una calculadora para determinar el número de cuadras necesarias basándose en la cantidad de caballos. El programa comienza solicitando al usuario que introduzca el número de caballos a través del teclado. Luego, realiza un cálculo sencillo dividiendo el número de caballos por 3 para determinar cuántas cuadras son necesarias, asumiendo que cada cuadra puede alojar a tres caballos.

Finalmente, muestra en pantalla los resultados obtenidos: primero, repite la cantidad de caballos introducida; luego, explica el supuesto (tres caballos por cuadra); y finalmente, proporciona el número calculado de cuadras necesarias. Este programa es útil para aprender cómo capturar entrada del usuario en Python, realizar cálculos simples y mostrar resultados en pantalla.

Este tipo de código ayuda a entender conceptos básicos como la toma de datos por parte del usuario, la manipulación numérica simple y la salida de información formateada en el contexto práctico de resolver un problema cotidiano.

`011-entrada calculo y salida.py`

```python
''' 
    Calculadora de cuadras
    v0.1 (c) 2025 Jose Vicente Carratalá
    Programa que calcula número de cuadras a partir de los caballos
'''

# Datos de inicio
caballos = 0
cuadras = 0

# Entrada de información
caballos = int(input("Introduce el número de caballos: "))

# Realización de cálculos
cuadras = caballos / 3

# Salida de resultados
print("Si tienes",caballos,"caballos")
print("Y te caben tres caballos por cuadra")
print("En ese caso necesitas",cuadras,"cuadras")
```

### libreria matematica
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código es una pequeña calculadora que determina el número de cuadras necesarias para alojar un cierto número de caballos, dada la capacidad de cada cuadra. Comienza importando el módulo `math` con el alias `matematicas`, lo cual permite utilizar funciones matemáticas adicionales.

El programa inicia solicitando al usuario que introduzca dos valores: el número total de caballos y la cantidad máxima de caballos por cuadra. Luego, calcula el número de cuadras necesarias dividiendo el número total de caballos entre la capacidad de cada cuadra.

Para asegurar que no queden caballos sin alojamiento, se redondea hacia arriba (hacia un entero mayor) utilizando la función `ceil` del módulo matemático importado. Finalmente, muestra al usuario el resultado en forma de texto para una salida amigable y fácil de entender.

Este tipo de cálculo es importante porque ayuda a planificar recursos eficientemente, asegurándose de que todos los caballos tengan alojamiento adecuado sin sobrerreservar cuadras innecesariamente.

`012-libreria matematica.py`

```python
''' 
    Calculadora de cuadras
    v0.1 (c) 2025 Jose Vicente Carratalá
    Programa que calcula número de cuadras a partir de los caballos
'''

import math as matematicas

# Datos de inicio
caballos = 0
cuadras = 0
caballos_por_cuadra = 0

# Entrada de información
caballos_por_cuadra = int(input("Introduce el número de caballos por cuadra: "))
caballos = int(input("Introduce el número de caballos: "))

# Realización de cálculos
cuadras = caballos / caballos_por_cuadra
redondeoalza = matematicas.ceil(cuadras)

# Salida de resultados
print("Si tienes",caballos,"caballos")
print("Y te caben tres caballos por cuadra")
print("En ese caso necesitas",redondeoalza,"cuadras")
```

### Actividades propuestas

### Actividad 1: Utilización de Objetos de Fecha y Tiempo
**Descripción:** Los estudiantes deben crear un programa que utilice objetos de fecha para calcular el día del año en que se encuentran. El objetivo es aprender a manipular fechas utilizando la librería `datetime`.

---

### Actividad 2: Gestión de Recursos en Programación
**Descripción:** Esta actividad implica la creación y eliminación controlada de objetos, similares al ejemplo mostrado en el archivo "008-destruccion de objetos.py". Los estudiantes aprenderán a gestionar adecuadamente los recursos de memoria.

---

### Actividad 3: Análisis del Código Externo
**Descripción:** Los alumnos deben analizar y comprender un código dado (como el mostrado en archivos "009-caballos en la cuadra.py", "010-propiedades.py") que presenta lógicas incompletas o errores. Se espera que puedan identificar problemas de sintaxis, lógica y estructura del programa.

---

### Actividad 4: Implementación Avanzada de Cálculos
**Descripción:** Basándose en el código proporcionado para calcular cuadras necesarias para caballos ("011-entrada calculo y salida.py"), los estudiantes deben implementar una versión mejorada que incluya la entrada de más variables, como por ejemplo diferentes tipos de animales con diferente número de espacios requeridos.

---

### Actividad 5: Introducción a Librerías de Matemáticas
**Descripción:** Los estudiantes deberán utilizar librerías matemáticas en Python para realizar cálculos complejos. A partir del archivo "012-libreria matematica.py", se deben implementar funcionalidades adicionales que utilicen funciones avanzadas.

---

### Actividad 6: Pruebas Unitarias
**Descripción:** Los estudiantes aprenderán a escribir pruebas unitarias para los programas de cálculo de cuadras (como en "011-entrada calculo y salida.py" y "012-libreria matematica.py"). Se evaluará la capacidad de diseñar tests que cubran diferentes escenarios.

---

### Actividad 7: Manejo Eficiente de Excepciones
**Descripción:** Los alumnos deben mejorar el manejo de errores en los programas existentes, haciendo uso de excepciones para controlar posibles fallos en la entrada del usuario. Se basará en ejemplos como "011-entrada calculo y salida.py".

---

### Actividad 8: Documentación del Código
**Descripción:** Los estudiantes deben escribir documentación para los programas existentes (como "012-libreria matematica.py") siguiendo buenas prácticas. Esto incluirá descripciones de las funciones, parámetros y devoluciones.

---

Estas actividades están diseñadas para reforzar los conocimientos adquiridos sobre la creación y gestión de objetos en Python, así como su integración con librerías estándar del lenguaje.


<a id="ejercicio-de-final-de-unidad-1"></a>
## Ejercicio de final de unidad

### Introducción a los ejercicios

Este conjunto de ejercicios en Python está diseñado para proporcionar una introducción completa a los fundamentos del lenguaje. Los problemas abordan aspectos básicos como la impresión de texto, el uso de variables y tipos de datos, así como operaciones más avanzadas como entrada de usuario, cálculos con operadores aritméticos y comparación de valores. También se incluyen ejemplos que ilustran cómo manejar errores comunes en la programación, como malas prácticas en el uso de identificadores y problemas de tipo de dato. A través de estos ejercicios, los estudiantes practicarán sus habilidades para escribir código limpio, eficiente y libre de errores, preparándolos para proyectos más complejos.

### Holamundo
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código es un ejemplo muy básico en Python que se utiliza para mostrar cómo imprimir texto en la pantalla. La función `print()` es utilizada aquí para mostrar el mensaje "Hola mundo desde Python". Cuando ejecutas este programa, simplemente verás este texto impreso en la consola o terminal donde estés trabajando.

Es importante porque sirve como una introducción a la programación en Python; te ayuda a entender cómo escribir y ejecutar tu primer programa. Este tipo de código también demuestra el uso de funciones básicas del lenguaje, que son fundamentales para cualquier proyecto más grande o complejo.

`001-Holamundo.py`

```python
print("Hola mundo desde Python")
```

### variables
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código en Python establece dos variables con valores específicos. La primera línea `nombre = "Jose Vicente"` crea una variable llamada `nombre` y le asigna el valor "Jose Vicente", que es una cadena de texto o string. La segunda línea `edad = 47` hace lo mismo pero para un número entero, creando una variable `edad` con el valor 47.

Este código es importante porque muestra cómo declarar variables en Python y asignarles diferentes tipos de valores, como textos (strings) y números enteros. Las variables permiten almacenar datos que pueden ser usados o modificados durante la ejecución del programa.

`002-variables.py`

```python
nombre = "Jose Vicente"
edad = 47
```

### salidas
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código muestra cómo imprimir una cadena de texto que incluye el contenido de una variable en Python. Primero, se crea una variable llamada `nombre` y se le asigna el valor `"Jose Vicente"`. Luego, la función `print()` se utiliza para mostrar un mensaje que combina una frase estática ("Mi nombre es") con el valor almacenado en la variable `nombre`.

Esta técnica de mezclar texto estático con el contenido de las variables es muy útil cuando necesitas presentar información personalizada o dinámica al usuario. En este caso, el código ayuda a entender cómo combinar diferentes partes del mensaje para crear una salida coherente y fácil de leer.

`003-salidas.py`

```python
nombre = "Jose Vicente"
print("Mi nombre es",nombre)
```

### variar una variable
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código muestra cómo se puede cambiar el valor de una variable en Python. Primero, la variable `nombre` se inicializa con el valor `"Jose Vicente"`, y luego se imprime un mensaje que incluye ese valor usando la función `print`. Después, el valor de la variable `nombre` es cambiado a `"Juan"` y se vuelve a imprimir un mensaje con este nuevo valor.

Es importante destacar que en Python (y en muchos otros lenguajes de programación), las variables pueden cambiar su contenido durante la ejecución del programa. En este caso, cuando cambiamos el valor de `nombre` a `"Juan"`, cualquier línea de código posterior verá esta nueva asignación y no recordará el valor original `"Jose Vicente"`.

Este ejemplo es útil para entender que las variables son simplemente contenedores para datos cuyo contenido puede modificarse según sea necesario en un programa.

`004-variar una variable.py`

```python
nombre = "Jose Vicente"
print("Mi nombre es",nombre)

nombre = "Juan"
print("Mi nombre es",nombre)
```

### identificadores permitidos
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código en Python ilustra cómo deben llamarse las variables según las reglas del lenguaje. En primer lugar, se definen dos variables válidas: `nombre` y `nombre2`, que almacenan cadenas de texto con nombres ("Jose" y "Vicente"). Luego, hay varias líneas comentadas que muestran ejemplos de cómo no debes nombrar una variable en Python. Por ejemplo, el nombre de la variable no puede comenzar con un número (como "2nombre") ni contener caracteres especiales como guiones (-) o espacios ("nombre completo"). La última línea muestra un caso válido pero no recomendado: `nombreCompleto` utiliza mayúsculas dentro del nombre para separar palabras, lo cual es permitido por el lenguaje pero se considera una mala práctica porque Python usa `_` como convención para separar palabras en nombres de variables. En resumen, este código sirve para enseñarte cuáles son los criterios que debes seguir al nombrar las variables en Python para evitar errores y mantener el código legible.

`005-identificadores permitidos.py`

```python
nombre = "Jose"
nombre2 = "Vicente"
# 2nombre = "Jose Vicente"
nombre_completo = "Jose Vicente"
#nombre-completo = "Jose Vicente"
#nombre completo = "Jose Vicente"
nombreCompleto = "Jose Vicente" # Es legal pero no se recomienda
```

### comentarios
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código en Python te enseña cómo escribir comentarios, que son líneas o bloques de texto que el programa no ejecuta pero que ayudan a explicar y documentar el código. En este caso, hay dos tipos de comentarios:

1. **Comentarios de una sola línea**: Se inician con el carácter numeral `#`. Todo lo que esté después del `#` en esa misma línea será ignorado por el intérprete de Python. Los comentarios de una sola línea son útiles para explicar piezas individuales o detalles específicos dentro del código.

2. **Comentarios multilinea**: Se rodean con tres comillas simples (`'''`) al inicio y al final. Puedes escribir varias líneas entre estas marcas, y todo el contenido será ignorado por Python. Los comentarios de múltiples líneas son ideales para descripciones más extensas o documentación que necesitan explicar funciones completas, clases, o cualquier sección importante del código.

Los comentarios son esenciales en la programación ya que facilitan la comprensión y mantenimiento del código, especialmente cuando trabajas en equipo o vuelves a revisar tu propio código después de un tiempo.

`006-comentarios.py`

```python
# Esto es un comentario de una única línea

'''
    Esto es un comentario
    Esto sigue siendo un comentario
    Y esto también lo es
'''
```

### Explicacion del codigo
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código Python simplemente crea una variable llamada `edad` y le asigna el número 47. Aquí, `edad` es lo que en programación se conoce como un identificador; es básicamente cómo nos referimos a la variable para poder usarla más adelante en nuestro programa. El signo igual (`=`) que ves aquí no significa "igualdad" matemática, sino que indica una asignación: Python entiende esto como "toma el valor 47 y guárdalo asociado con el nombre `edad`". Finalmente, el número 47 es un valor literal; en este caso, estamos usando simplemente un número sin comillas. Esto significa que estamos trabajando con un valor numérico puro.

Este tipo de operación de asignación es fundamental en programación ya que permite almacenar datos en variables para su uso posterior, lo cual nos ayuda a organizar y manipular información de manera eficiente dentro del programa.

`007-Explicacion del codigo.py`

```python
edad = 47
# edad es el identificador
# = es el operador de asignación
# 47 es el valor literal que se es está asignando al identificador
```

### Tipos de datos
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es una introducción a los tipos básicos de datos en Python que se utilizan comúnmente: cadenas (strings), enteros (integers) y decimales (floats), además del tipo booleano. En este caso, se están declarando cuatro variables con diferentes tipos de datos:

1. `nombre` es una cadena de texto, también conocida como string en programación. Aquí, la variable `nombre` almacena el valor "Jose Vicente", que representa un nombre.

2. `edad` es un entero (integer), que se utiliza para almacenar números enteros sin decimales. En este caso, la edad de 47 años está siendo guardada en la variable `edad`.

3. `altura` es un número decimal o float, usado para representar valores con punto decimal como 1.78 metros.

4. `vivo` es una variable booleana que almacena el valor True (verdadero) o False (falso). En este caso, la variable `vivo` está establecida en True, lo cual podría indicar un estado de vida verdadero para una persona ficticia.

Es importante entender estos tipos de datos básicos porque te permiten trabajar con diferentes tipos de información que necesitas manipular y procesar en tus programas.

`008-Tipos de datos.py`

```python
nombre = "Jose Vicente" # Cadena
edad = 47 # Entero
altura = 1.78 # Decimal
vivo = True # Booleano
```

### Entradas
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código en Python te ayuda a interactuar con el usuario pidiéndole que ingrese su nombre. La primera línea utiliza la función `input()`, que espera una entrada del usuario cuando se ejecuta y almacena lo que el usuario teclea en la variable `nombre`. En este caso, el programa muestra el texto "Dime tu nombre: " para guiar al usuario sobre qué información debe ingresar.

La segunda línea es un ejemplo de cómo imprimir el contenido de una variable. La función `print()` se usa aquí para mostrar por pantalla "Tu nombre es: ", seguido del valor almacenado en la variable `nombre`. Esto permite que el programa muestre claramente lo que ha recibido como entrada, permitiéndote verificar fácilmente si el usuario proporcionó la información correcta. Este tipo de interacción básica entre el usuario y el programa es fundamental en la programación para recoger datos necesarios para continuar con las tareas del software.

`009-Entradas.py`

```python
nombre = input("Dime tu nombre: ")
print("Tu nombre es: ",nombre)
```

### Entrada y problema
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código Python solicita al usuario que ingrese su edad y luego muestra en pantalla el doble de esa edad. Sin embargo, hay un pequeño error en la implementación.

Primero, el programa utiliza la función `input()` para pedirle al usuario que introduzca su edad. La entrada del usuario se guarda en una variable llamada `edad`. Es importante notar que cualquier dato ingresado mediante `input()` es almacenado como texto (string) incluso si el usuario ingresa un número.

Luego, la función `print()` muestra el doble de la edad del usuario. Sin embargo, aquí hay un detalle: al sumar el string `"El doble de tu edad es: "` con la variable `edad`, que también es una cadena, no estamos haciendo un cálculo numérico. En su lugar, se está mostrando simplemente el texto "El doble de tu edad es:" seguido del valor de la edad tal cual fue ingresado por el usuario sin realizar ninguna operación matemática.

Para mostrar realmente el doble de la edad, primero tendríamos que convertir la entrada del usuario en un número entero y luego multiplicarlo por dos antes de imprimirlo.

`010-Entrada y problema.py`

```python
edad = input("Dime tu edad: ")
print("El doble de tu edad es: "+edad)
```

### Cambio de tipo de dato
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código te pide que ingreses tu edad como texto y luego la convierte en un número para realizar cálculos. Primero, el programa usa `input()` para solicitar tu edad, lo que significa que debes escribir tu edad cuando se te haga la pregunta y presionar Enter. El valor ingresado es una cadena de texto (texto entre comillas). Luego, el código utiliza la función `int()` para convertir esa cadena en un número entero, permitiendo realizar operaciones matemáticas con ella.

Después, el programa calcula el doble de tu edad convirtiéndola a un número y multiplicándolo por 2. Finalmente, intenta mostrar el resultado del doble de la edad utilizando `print()`, pero aquí hay un error: cuando concatenas cadenas en Python usando el operador `+`, todos los elementos deben ser strings (texto). Para solucionar esto, necesitas convertir `doble` nuevamente a una cadena antes de mostrarlo. La línea correcta sería:

```python
print("El doble de tu edad es: " + str(doble))
```

Este código ilustra cómo se pueden transformar tipos de datos entre cadenas y números para permitir la interacción del usuario y realizar cálculos en Python, lo cual es crucial cuando trabajas con entradas de texto que necesitan ser procesadas matemáticamente.

`011-Cambio de tipo de dato.py`

```python
# Le pregunto al usuario por su edad
edad = input("Dime tu edad: ")
# Me aseguro de convertir la edad a un número entero
entero = int(edad)
# Calculo el doble de un número entero
doble = entero*2
# Saco el resultado por pantalla
print("El doble de tu edad es: "+doble)
```

### literales
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código está introduciendo la noción de literales en Python. Un literal es simplemente una manera directa de representar un valor básico en un programa, como una cadena de texto o un número. En este caso, el código asigna dos valores a variables: `"Jose Vicente"` y `47`. 

El primer ejemplo `"Jose Vicente"` es un literal de tipo cadena (o string), que representa texto entre comillas. Se almacena en la variable llamada `nombre`, permitiendo almacenar información textual para su uso posterior en el programa.

Por otro lado, `47` es un literal de tipo entero (integer) y se asigna a la variable `edad`. Este valor numérico puede ser usado en cálculos o simplemente como dato informativo dentro del programa. Estos literales son fundamentales porque permiten inicializar variables con valores específicos desde el inicio del código, facilitando así la manipulación de datos básicos en programas más grandes y complejos.

`012-literales.py`

```python
nombre = "Jose Vicente"
# Jose Vicente es el literal, y es de tipo cadena

edad = 47
# 47 es el literal, y es de tipo entero
```

### constantes
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código te enseña cómo se manejan las "constantes" en Python, aunque es importante destacar que en realidad no existen verdaderas constantes inmutables en Python como en otros lenguajes. En el código, `PI` es una variable con un valor inicial de aproximadamente 3.1415, que es usualmente el número Pi. El programa imprime este valor original.

Luego, el código cambia el valor de `PI` a 4 y vuelve a imprimirlo para mostrar que el valor ha cambiado. Aunque la convención en Python es usar letras mayúsculas para nombrar constantes (como `PI = 3.1415`) para indicar que no debería cambiar su valor durante la ejecución del programa, esto no garantiza que realmente permanezca constante porque el programador puede modificarlo como se hace en este ejemplo.

Esta práctica ayuda a los desarrolladores a entender y mantener mejor el código al reconocer fácilmente cuáles son las variables destinadas a ser "constantes". Sin embargo, es importante recordar que en Python puedes cambiar el valor de cualquier variable, incluso si sigue la convención de usar mayúsculas para sugerir una constante.

`013-constantes.py`

```python
PI = 3.1415

print("PI vale",PI)

PI = 4 # Le cambio el valor a PI

print("PI vale",PI)
# Las constantes deben formularse con mayúsculas
# Las variables deben formularse con minúsculas
```

### Diferencia
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código ilustra cómo se pueden cambiar los tipos de datos asociados a una variable en Python, aunque no siempre es una buena práctica hacerlo. En primer lugar, se define la constante `PI` y se le asigna el valor numérico 3.1416. Este valor es un número real (float) que representa una aproximación del número matemático π. Luego, en la segunda línea, se cambia el tipo de dato de `PI`, reasignándole el valor "unnumero", que es una cadena de texto (string). Esto significa que ahora `PI` no almacena un número como estaba previsto inicialmente, sino simplemente una secuencia de caracteres. Es importante entender que aunque podemos cambiar el tipo de datos asociado a una variable en Python, esto puede causar errores si se utiliza la variable de manera inapropiada después del cambio.

`014-Diferencia.py`

```python

# La constante es PI
# El literal es 3.1416

PI = 3.1416

PI = "unnumero"
```

### operadores aritmeticos
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código en Python muestra cómo se utilizan los operadores aritméticos básicos para realizar cálculos simples. Los operadores que se usan aquí son la suma (+), resta (-), multiplicación (*), división (/) y el módulo (%). El programa imprime el resultado de cinco operaciones diferentes: primero, suma 4 y 3; segundo, resta 3 de 4; tercero, multiplica 4 por 3; cuarto, divide 4 entre 3; quinto, calcula el residuo o resto cuando se divide 4 entre 3. Estos ejemplos ilustran cómo cada operador funciona y son fundamentales para comprender los conceptos básicos de la aritmética en programación.

En comparación con el archivo anterior, que mostraba un ejemplo sobre literales y constantes cambiando el valor de una constante (PI), este nuevo código se centra exclusivamente en ejercitar diferentes operaciones matemáticas. La principal diferencia es que ahora estamos viendo cómo Python realiza cálculos directamente, en lugar de manipular valores asignados a variables como en el caso anterior con la constante PI.

`014-operadores aritmeticos.py`

```python
print(4+3)
print(4-3)
print(4*3)
print(4/3)
print(4%3)
```

### operadores de comparacion
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código muestra cómo se utilizan los operadores de comparación en Python. Los operadores de comparación nos permiten comparar dos valores y obtener un resultado booleano (True o False) dependiendo del resultado de la comparación.

El primer `print(4 < 3)` comprueba si el número 4 es menor que el número 3, lo cual no es cierto, por lo que imprimirá False. A continuación, `print(4 <= 3)` verifica si 4 es menor o igual a 3; de nuevo, esto también resulta falso.

Luego, con `print(4 > 3)`, se compara si el número 4 es mayor que 3, lo cual es cierto y por tanto imprimirá True. El siguiente, `print(4 >= 3)`, comprueba si 4 es mayor o igual a 3, otra vez resultando en True.

Finalmente, con `print(4 == 3)` se compara si los números son exactamente iguales (en este caso no lo son), por lo que imprime False. Por último, `print(4 != 3)` verifica si los dos números son diferentes, lo cual es cierto y devuelve True.

Estos operadores de comparación son fundamentales en la programación porque permiten tomar decisiones basadas en las comparaciones de valores, siendo muy útiles para controlar el flujo del programa.

`015-operadores de comparacion.py`

```python
print(4 < 3)
print(4 <= 3)
print(4 > 3)
print(4 >= 3)
print(4 == 3)
print(4 != 3)
```

### operadores arimeticos abreviados
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código muestra cómo se utilizan los operadores aritméticos en Python, con un enfoque especial en los operadores abreviados. El código comienza estableciendo la variable `edad` en 47. Luego, realiza varias operaciones matemáticas tanto usando las formas tradicionales (como `edad = edad + 2`) como utilizando los operadores aritméticos abreviados (`edad += 2`). Estos operadores simplifican el código al permitir la actualización de una variable en una sola línea, lo que hace que el código sea más legible y conciso. En este ejemplo, se realizan operaciones de suma, resta, multiplicación y división utilizando tanto las formas tradicionales como abreviadas.

Es importante destacar que los operadores abreviados no solo hacen que el código sea más corto y fácil de leer, sino también menos propenso a errores al evitar la posibilidad de cometer errores tipográficos o lógicos en el proceso de asignación.

`016-operadores arimeticos abreviados.py`

```python
edad = 47
# Le quiero sumar dos unidades
edad = edad + 2
edad += 2
#Le quiero restar dos unidades
edad = edad - 2
edad -= 2
# Lo quiero multiplicar por dos
edad = edad * 2
edad *= 2
# Lo quiero dividir por dos
edad = edad / 2
edad /= 2
```

### operadores booleanos
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código en Python utiliza operadores booleanos para evaluar expresiones lógicas y luego imprime el resultado. Los operadores booleanos principales que se utilizan aquí son `and` y `or`. 

El operador `and` devuelve `True` solo si todas las condiciones entre paréntesis son verdaderas. En cambio, el operador `or` devuelve `True` si al menos una de las condiciones es verdadera.

En la primera línea, por ejemplo, se compara si 4 es igual a 4 (`4 == 4`), y esto es cierto (o `True`). Luego, se verifica si 3 es igual a 3 (`3 == 3`) que también es cierto. Finalmente, se evalúa si 2 es igual a 2 (`2 == 2`), lo cual también es verdadero. Por tanto, la expresión completa devuelve `True`.

En las líneas siguientes, el código utiliza estas mismas condiciones pero con variaciones en los valores para demostrar cómo cambia el resultado cuando alguna condición es falsa. Esto ayuda a entender cómo funcionan estos operadores lógicos y cuándo se cumplirán las expresiones.

Estos ejemplos son importantes porque te permiten comprender la lógica detrás de las decisiones en programación, lo que es fundamental para el control del flujo en programas más complejos.

`017-operadores booleanos.py`

```python
print(4 == 4 and 3 == 3 and 2 == 2)
print(4 == 4 and 3 == 3 and 2 == 1)

print(4 == 4 or 3 == 3 or 2 == 1)
print(4 == 4 or 3 == 2 or 2 == 1)
print(4 == 3 or 3 == 2 or 2 == 1)
```

### Ejercicio1-Calculadora de impuestos
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es el encabezado o comentario inicial del archivo `Calculadora de impuestos.py`. Aquí, el autor, identificado como Jose Vicente Carratalá, proporciona información básica sobre la utilidad del programa. El propósito principal del script es calcular el IVA (Impuesto al Valor Agregado) y el total a partir de una base imponible que ingresa el usuario.

Este tipo de comentario es importante porque ayuda a entender rápidamente qué hace el código sin tener que profundizar en su estructura interna, lo cual facilita la colaboración entre programadores o personas que revisan el código. Además, proporciona detalles sobre la versión actual del programa (v0.1) y da crédito al autor.

En resumen, este encabezado ayuda a contextualizar el propósito del script y ofrece un punto de partida claro para quien quiera entender o modificar el código posteriormente.

`018-Ejercicio1-Calculadora de impuestos.py`

```python
'''
    Calculadora de Impuestos
    v0.1 por Jose Vicente Carratalá
    Funcionamiento: Introduce una base imponible y se calcula IVA y total
'''
```

### Calculadora
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es el inicio de un programa en Python que se propone calcular impuestos, específicamente el IVA (Impuesto al Valor Agregado) y el total de una factura. El programa comienza con comentarios explicativos sobre su propósito y cómo funciona: solicita al usuario que introduzca la base imponible de una factura y luego realizará cálculos relacionados con el impuesto.

Después, se definen tres variables vacías (inicializadas en 0) que almacenarán los valores de la base imponible, el total del IVA y el total de la factura. Estas variables servirán para guardar los datos introducidos por el usuario y para realizar las operaciones necesarias.

Finalmente, se utiliza la función `input()` para solicitar al usuario que ingrese el valor de la base imponible de una factura. Este valor es almacenado en la variable `base_imponible`. Es importante notar que el valor ingresado por el usuario será inicialmente un string (texto) y probablemente necesitará ser convertido a un número (por ejemplo, usando `float()` o `int()`) para poder realizar cálculos matemáticos con él.

`019-Calculadora.py`

```python
'''
    Calculadora de Impuestos
    v0.1 por Jose Vicente Carratalá
    Funcionamiento: Introduce una base imponible y se calcula IVA y total
'''

# Este programa no tiene importaciones

# Creo variables
base_imponible = 0
total_iva = 0
total_factura = 0

# Aquí pondría las funciones/clases

# Ahora calculamos
base_imponible = input("Introduce la base imponible de la factura: ")
```

### Calculadora
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es un programa en Python que sirve para calcular impuestos basándose en la base imponible que proporciona el usuario. El objetivo principal del programa es pedir al usuario que introduzca una cantidad como base imponible (por ejemplo, el precio antes del IVA), y luego el programa calculará tanto el IVA como el total a pagar.

El código comienza definiendo algunas variables importantes: `base_imponible`, que almacenará la base sobre la cual se calculará el impuesto; `total_iva`, para guardar el cálculo del IVA en sí mismo; y `total_factura`, para mantener el valor final que resulta de sumar la base imponible con el IVA.

Después, imprime algunas líneas informativas al usuario sobre el propósito del programa. Luego pide al usuario que introduzca la cantidad de la base imponible a través de una función `input()`. El valor ingresado por el usuario se almacenará en la variable `base_imponible`.

Es importante destacar que este código es solo un inicio y necesita más lógica para calcular efectivamente tanto el IVA como el total de la factura.

`020-Calculadora.py`

```python
'''
    Calculadora de Impuestos
    v0.1 por Jose Vicente Carratalá
    Funcionamiento: Introduce una base imponible y se calcula IVA y total
'''

# Este programa no tiene importaciones

# Creo variables
base_imponible = 0
total_iva = 0
total_factura = 0

# Aquí pondría las funciones/clases

# Ahora calculamos
print("Programa calculadora de impuestos")
print("(c) 2025 Jose Vicente Carratalá")
print("Introduce una base y te calculo el IVA y el total")
base_imponible = input("Introduce la base imponible de la factura: ")
```

### Calculo de IVA
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código es un programa en Python que calcula el IVA y el total de una factura basándose en la base imponible ingresada por el usuario. Al iniciar, muestra información sobre el autor del programa y sus funciones. Luego, solicita al usuario que introduzca la base imponible como entrada numérica (en formato decimal o entero). 

El programa realiza cálculos sencillos para determinar el IVA de la factura, utilizando un tipo de impuesto del 21% sobre la base imponible (`total_iva = base_imponible * 0.21`). Posteriormente, calcula el total de la factura sumando la base imponible y el IVA (`total_factura = base_imponible + total_iva`).

Finalmente, muestra al usuario los resultados del cálculo: el monto del IVA y el total de la factura, permitiendo así que el usuario sepa cuánto es el impuesto sobre la compra o servicio y qué cantidad total debe ser pagada. Este tipo de programa es útil para entender cómo calcular impuestos en transacciones comerciales básicas utilizando Python.

`021-Calculo de IVA.py`

```python
'''
    Calculadora de Impuestos
    v0.1 por Jose Vicente Carratalá
    Funcionamiento: Introduce una base imponible y se calcula IVA y total
'''

# Este programa no tiene importaciones

# Creo variables
base_imponible = 0
total_iva = 0
total_factura = 0

# Aquí pondría las funciones/clases

# Ahora calculamos

# Primero pido una entrada
print("Programa calculadora de impuestos")
print("(c) 2025 Jose Vicente Carratalá")
print("Introduce una base y te calculo el IVA y el total")
base_imponible = float(input("Introduce la base imponible de la factura: "))

# Luego realizo cálculos
total_iva = base_imponible*0.21
total_factura = base_imponible + total_iva

# Por último expreso una salida
print("El IVA de la factura es: ",total_iva)
print("El total de la factura es: ",total_factura)
```

### Actividades propuestas

### Actividades Propuestas para Estudiantes de Formación Profesional en Programación

1. **Introducción a Variables**
   - *Descripción:* Los estudiantes deberán crear una aplicación sencilla que solicite al usuario su nombre y edad, e imprima ambos datos por pantalla.
   - *Objetivo:* Aprender a declarar variables y utilizar funciones de entrada/salida en Python.

2. **Uso de Tipos de Datos**
   - *Descripción:* Los alumnos deben escribir un programa que pida al usuario su nombre, edad (como número entero) y altura (como número decimal), e imprima esta información.
   - *Objetivo:* Familiarizarse con diferentes tipos de datos en Python.

3. **Manejo de Entradas y Salidas**
   - *Descripción:* Se les pide que escriban un programa que solicite al usuario su edad, calcule el doble de esa edad y muestre el resultado.
   - *Objetivo:* Aprender a convertir tipos de datos (de cadena a entero) y realizar operaciones aritméticas.

4. **Operadores Lógicos**
   - *Descripción:* Crear un programa que utilice operadores lógicos (and, or) para comprobar si una edad es mayor o menor a ciertos valores.
   - *Objetivo:* Entender y aplicar operaciones booleanas en condiciones.

5. **Operadores Aritméticos**
   - *Descripción:* Diseñar un programa que permita al usuario ingresar dos números, luego realizar las cuatro operaciones básicas (+, -, *, /) e imprimir los resultados.
   - *Objetivo:* Practicar con diferentes tipos de operadores aritméticos.

6. **Cálculo de IVA**
   - *Descripción:* Elaborar una calculadora que calcule el IVA (21%) y el total de una factura basada en la base imponible ingresada por el usuario.
   - *Objetivo:* Aprender a realizar cálculos complejos e imprimir resultados formateados.

7. **Manejo de Errores**
   - *Descripción:* Crear un programa que solicite al usuario ingresar su edad como cadena, convierta esta entrada a número entero y maneje cualquier excepción que pueda surgir.
   - *Objetivo:* Aprender a trabajar con tipos de datos, conversiones y gestión de errores básicos.

8. **Entrada/Salida Mejorada**
   - *Descripción:* Diseñar un programa que presente una interfaz básica (como encabezado), solicite al usuario la base imponible e imprima el IVA y total.
   - *Objetivo:* Aprender a mejorar las salidas por pantalla para proporcionar información más estructurada.

9. **Uso de Comentarios**
   - *Descripción:* Los estudiantes deben escribir un pequeño programa que incluya múltiples comentarios explicando cada línea o bloque de código.
   - *Objetivo:* Aprender a documentar el código y añadir comentarios para mejorar la legibilidad y mantenimiento.

10. **Ejercicio Final: Calculadora Completa**
    - *Descripción:* Crear una calculadora que permita al usuario seleccionar diferentes operaciones (IVA, suma, resta, etc.), realizar cálculos según la opción elegida y mostrar resultados.
    - *Objetivo:* Integrar conocimientos de variables, entrada/salida, conversiones y operadores en un programa más complejo.



<a id="uso-de-estructuras-de-control"></a>
# Uso de estructuras de control

<a id="estructuras-de-seleccion"></a>
## Estructuras de selección

### Introducción a los ejercicios

En esta carpeta, encontrarás una serie de ejercicios que te ayudarán a comprender cómo usar estructuras de selección en Python para controlar el flujo del programa basado en condiciones. Los ejercicios abordan desde condicionales simples con `if` hasta casos más complejos que incluyen múltiples condiciones utilizando `elif` y anidación de estructuras `if`. Estos ejemplos te permitirán practicar la clasificación de datos según diferentes rangos y criterios, lo cual es fundamental en programación.

### Condicional
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código Python verifica si una persona es considerada joven basándose en su edad. La variable `edad` se inicializa con el valor 47. Luego, el programa utiliza una estructura de control llamada "if" para comprobar si esta edad es menor que 30. Si la condición dentro del "if" (es decir, `edad < 30`) resulta verdadera, se imprimirá en pantalla el mensaje "Eres un joven". Sin embargo, dado que en este caso `edad` es 47, la condición no se cumple y por lo tanto, el mensaje no se imprime. Esta estructura de control es muy útil para tomar decisiones basadas en condiciones específicas dentro del programa.

`001-Condicional.py`

```python
# El código solo se ejecuta si la expresión es verdadera
edad = 47

if edad < 30:
  print("Eres un joven")
```

### else
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código en Python utiliza una estructura de control llamada `if-else` para determinar y mostrar si una persona es considerada "joven" o no. En primer lugar, se define la variable `edad` con el valor 47. Luego, el programa compara este valor con la condición especificada en la línea del `if`, que evalúa si `edad` es menor a 30. Si esta condición es verdadera (lo cual no ocurre en este caso dado que 47 no es menor que 30), se imprimiría "Eres un joven". Sin embargo, ya que la condición es falsa, el código dentro del bloque `else` se ejecuta, imprimiendo "Ya no eres un joven" en pantalla. Esta estructura de control ayuda a tomar decisiones basadas en condiciones específicas y permite que el programa se comporte de diferentes maneras según los datos ingresados o definidos previamente.

`002-else.py`

```python
# El código solo se ejecuta si la expresión es verdadera
edad = 47

if edad < 30:
  print("Eres un joven")
else:
  print("Ya no eres un joven")
```

### varios if
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código utiliza dos estructuras `if` simples para determinar si una persona es considerada joven o no, basándose en su edad. La variable `edad` está establecida en 47 años.

El primer bloque `if` comprueba si la `edad` es menor que 30. En este caso, si se cumple esta condición (que no lo hace ya que la edad es 47), el programa imprimiría "Eres un joven". Sin embargo, como la condición no se satisface, este bloque de código simplemente pasa.

El segundo bloque `if` verifica si la `edad` es mayor que 30. Dado que la edad es 47, esta condición se cumple y por lo tanto el programa imprime "Ya no eres un joven".

Este tipo de estructuras son útiles cuando necesitas tomar decisiones en tu código basadas en ciertas condiciones, permitiendo que las acciones del programa cambien según los datos específicos con los que trabaja. En este ejemplo simple, se ilustra cómo las estructuras `if` pueden ser utilizadas para clasificar o categorizar información de acuerdo a reglas predefinidas.

`003-varios if.py`

```python
# El código solo se ejecuta si la expresión es verdadera
edad = 47

if edad < 30:
  print("Eres un joven")
  
if edad > 30:
  print("Ya no eres un joven")
```

### varios if
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

El código que has proporcionado es una secuencia de comprobaciones para determinar la categoría etaria de una persona basándose en su edad. Sin embargo, hay un error sintáctico en el código: en Python, la estructura `else if` se debe escribir como dos palabras separadas, `elif`. Además, falta un guion de cierre en uno de los mensajes `print`.

Aquí está cómo debería verse el código corregido:

```python
edad = 47

if edad < 10:
    print("Eres un niño")
elif edad >= 10 and edad < 20: # Ajuste de sintaxis para elif
    print("Eres un adolescente") # Corrección del guion faltante
elif edad >= 20 and edad < 30:
    print("Eres un joven")
else:
    print("Ya no eres un joven")
```

Este código funciona evaluando la variable `edad` y determina en qué categoría cae la persona basándose en los rangos especificados. Si la edad es menor que 10, el programa imprimirá "Eres un niño". Si la edad está entre 10 y 20 años (inclusive), imprime "Eres un adolescente". Para edades entre 20 y 30 años, muestra "Eres un joven". Y si la edad es mayor o igual a 30 años, el programa imprimirá "Ya no eres un joven".

Es importante entender cómo funcionan los `if`, `elif` (que son una combinación de `else if`) y `else` para controlar la fluidez del código cuando se necesitan múltiples condiciones para tomar decisiones.

`004-varios if.py`

```python
# El código solo se ejecuta si la expresión es verdadera
edad = 47

if edad < 10:
  print("Eres un niño")
else if edad >= 10 and edad < 20:
  print("Eres un adolescente)
else if edad >= 20 and edad < 30:
  print("Eres un joven")
else:
  print("Ya no eres un joven")
```

### particula elif
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código es una estructura de selección en Python que utiliza `if`, `elif` (que significa "else if") y `else`. El objetivo del programa es determinar la categoría de edad de una persona basándose en su año de nacimiento o edad. En este caso, se está utilizando una variable llamada `edad` cuyo valor es 47.

El código verifica la condición de cada bloque `if` y `elif` secuencialmente hasta que encuentra una expresión verdadera. Si ninguna de las condiciones en los bloques `elif` se cumple, entonces se ejecuta el bloque `else`. En este ejemplo:

- Primero, comprueba si `edad` es menor que 10; si lo es, imprime "Eres un niño".
- Luego, verifica si `edad` está entre 10 y 20 (no incluyendo 20); si es así, imprime "Eres un adolescente".
- Después, comprueba si `edad` está entre 20 y 30 (no incluyendo 30); si se cumple la condición, imprime "Eres un joven".
- Si ninguna de las condiciones anteriores se cumple, se ejecuta el bloque `else`, que imprimirá "Ya no eres un joven".

En resumen, este código categoriza la edad de una persona en diferentes grupos dependiendo del valor de la variable `edad`. Es importante para entender cómo usar múltiples condiciones (`elif`) y qué hacer cuando ninguna condición se cumple (`else`).

`005-particula elif.py`

```python
# El código solo se ejecuta si la expresión es verdadera
edad = 47

if edad < 10:
  print("Eres un niño")
elif edad >= 10 and edad < 20:
  print("Eres un adolescente")
elif edad >= 20 and edad < 30:
  print("Eres un joven")
else:
  print("Ya no eres un joven")
```

### anidacion
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código en Python utiliza estructuras de selección anidadas para determinar y mostrar la clasificación de una persona basada en su edad. La variable `edad` se establece en 47, pero el código podría aplicarse a cualquier valor.

Primero, el programa comprueba si la edad es menor que 30. Si esto es cierto, entra en un bloque anidado donde verifica si la edad es menor que 20. Dependiendo de esta segunda condición, imprime "Eres muuuuy joven" o "eres un joven".

Si la edad no es menor que 30 (es decir, es mayor o igual a 30), el programa revisa en otro bloque anidado si la edad está entre 30 y 40. Dependiendo del resultado de esta condición, imprime "Eres bastante poco joven" o "Ya no eres joven".

Esta estructura permite categorizar a las personas en diferentes grupos etarios con base en varios rangos de edad, ilustrando cómo pueden anidarse estructuras `if` para manejar múltiples condiciones.

`006-anidacion.py`

```python
# Esto no hay que hacerlo

edad = 47

if edad < 30:
  if edad < 20:
    print("Eres muuuuy joven")
  else:
    print("eres un joven")
else:
  if edad < 40:
    print("Eres bastante poco joven")
  else:
    print("Ya no eres joven")
```

### Ejercicio en clase
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código es un programa simple que clasifica a los jugadores de baloncesto según su edad. El programa comienza solicitando al usuario que introduzca su edad, y luego convierte ese valor de texto a número entero para poder compararlo con diferentes rangos.

El corazón del programa está en el bloque `if-elif-else`, donde se evalúa la edad del jugador para asignarle una categoría específica. Por ejemplo, si la edad es menor que 8 años, la categoría será "pre-mini". Si la edad es entre 12 y 15 años inclusive, entonces la categoría será "infantil", y así sucesivamente hasta el nivel senior.

Después de determinar la categoría del jugador, el programa imprime ambos valores: la edad introducida por el usuario y la categoría asignada. Además, incluye una condición adicional fuera del bloque `if-elif-else` que verifica si la edad es mayor a 40 años para clasificar al jugador como "Veterano con experiencia en la cancha". Esto añade un detalle extra para reconocer a los jugadores más mayores y experimentados.

Este tipo de programa es útil en deportes organizados donde las categorías o niveles dependen directamente del edad del participante, asegurando que los jugadores se enfrentan a rivales similares en términos de madurez y habilidades físicas.

`007-Ejercicio en clase.py`

```python
# Docstring
''' 
  Programa clasificador de baloncesto
  v0.1 Jose Vicente Carratala
  Este programa clasifica categorías por edades
'''

# Importaciones
# Este programa no requiere importaciones

# Declaración de variables globales
# Inicializamos las variables con valores vacíos

edad = 0
categoria = ""

# Funciones/clases
# En este programa no hay funciones o clases

# Función principal

edad = input("Introduce tu edad: ")
edad = int(edad) # Convierto la edad en un entero
if edad < 8:
  categoria = "pre-mini"
elif edad >= 8 and edad <= 11:
  categoria = "mini"
elif edad >= 12 and edad <=15:
  categoria = "infantil"
elif edad >= 16 and edad <=17:
  categoria = "cadete"
elif edad >= 18 and edad <=20:
  categoria = "junior"
else:
  categoria = "senior"
  
print("Tu edad es de",edad,"años y tu categoría es: ",categoria)  

if edad > 40:
  print("Veterano con experiencia en la cancha")
  
  
  
  
  
```

### Actividades propuestas

1. **Clasificación por Edad**
   - Descripción: Los estudiantes deben crear un programa que clasifique a una persona como "joven", "adulto" o "mayor" dependiendo de su edad. El objetivo es familiarizarse con el uso básico del condicional `if`.

2. **Jugando con Edades**
   - Descripción: Se pide escribir un programa que determine si una persona es menor, adulta o mayor según la edad ingresada por el usuario. Este ejercicio ayuda a entender los conceptos de lógica y comparación en Python.

3. **Clasificador de Estudiantes**
   - Descripción: Los alumnos deben desarrollar un programa que clasifique estudiantes basándose en su nivel académico (por ejemplo, primer año, segundo año, etc.). El ejercicio incluye el uso de múltiples condiciones `if`.

4. **Etapa Vital según Edad**
   - Descripción: Se requiere crear un programa que identifique la etapa vital del usuario basándose en su edad (niño, adolescente, adulto joven, adulto mayor). Esto enseña a los estudiantes a usar condicionales anidados y `elif`.

5. **Clasificador de Baloncesto**
   - Descripción: Los estudiantes deben replicar el programa proporcionado que clasifica jugadores de baloncesto según su edad en diferentes categorías (pre-mini, mini, infantil, etc.). Este ejercicio fomenta la comprensión del uso de múltiples condiciones anidadas.

6. **Determinación de Grupos**
   - Descripción: Los alumnos deben programar un sistema que clasifique a las personas en grupos según su puntaje en una prueba (por ejemplo, bajo rendimiento, rendimiento normal, alto rendimiento). Esto ayuda a entender el uso del condicional anidado y la importancia de los rangos.

7. **Controlador de Acceso**
   - Descripción: Los estudiantes deben crear un sistema simple que controle el acceso a una plataforma basándose en roles (por ejemplo, administrador, usuario normal). Este ejercicio ayuda a entender cómo las estructuras condicionales pueden ser utilizadas para controlar flujos de ejecución basados en diferentes condiciones.

8. **Recomendaciones por Edad**
   - Descripción: Los alumnos deben desarrollar un programa que recomiende actividades según la edad del usuario (por ejemplo, deportes para niños, estudios para adultos jóvenes). Este ejercicio permite a los estudiantes aplicar múltiples `if` y condiciones lógicas en sus programas.

9. **Determinación de Horario**
   - Descripción: Los estudiantes deben crear un programa que determine el horario adecuado para diferentes actividades (por ejemplo, hora de estudio, descanso). Este ejercicio ayuda a familiarizar con la anidación de condicionales y cómo se pueden usar en situaciones del mundo real.

10. **Clasificador de Riesgos**
    - Descripción: Los alumnos deben desarrollar un programa que clasifique proyectos según su nivel de riesgo (bajo, medio, alto). Esto ayuda a entender el uso de condiciones anidadas y la importancia de manejar múltiples casos con eficacia.


<a id="estructuras-de-repeticion"></a>
## Estructuras de repetición

### Introducción a los ejercicios

En esta carpeta encontrarás una serie de ejercicios que te ayudarán a comprender y practicar el uso de estructuras de repetición en Python, como los bucles `for` y `while`. Los ejercicios abordan desde la simple iteración sobre rangos numéricos hasta la anidación compleja de bucles para simular procesos más elaborados. Practicarás cómo contar días del mes utilizando diferentes métodos (eficientes e ineficientes), cómo manejar múltiples niveles de anidación en los bucles y cómo incrementar contadores dentro de un bucle `while`. También aprenderás a resolver problemas prácticos, como el conteo de patitos de goma producidos en una fábrica a lo largo del tiempo. Estos ejercicios te prepararán para la resolución de problemas que involucran secuencias temporales y conteos acumulativos en situaciones realistas.

### saltos
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código Python muestra cómo imprimir números pares desde 0 hasta 98. Utiliza un bucle `for` junto con la función `range()` para generar una secuencia de números. La función `range(0, 100, 2)` crea una serie que comienza en 0 y aumenta en pasos de dos hasta, pero no incluyendo, el número 100. Dentro del bucle, la variable `pares` toma cada valor de esta secuencia y lo imprime en pantalla. Este ejemplo es útil para entender cómo utilizar estructuras de control como los bucles `for` y cómo manipular rangos específicos de números usando la función `range()`.

`0005-saltos.py`

```python
# Cuento los días del mes
for pares in range(0,100,2):
  print(pares)
```

### ineficiente
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código en Python imprime una serie de mensajes que indican los días sucesivos de un mes. Cada línea utiliza la función `print` para mostrar cuál día del mes está siendo representado, comenzando desde el día 1 y continuando hasta cierto punto (en este caso, solo se muestran hasta el día 5). La estructura actual es ineficiente porque repite el mismo código para cada día que necesita ser impreso. En una implementación real, esta forma de contar los días sería poco práctica, especialmente si necesitas cubrir todo un mes con 30 o 31 días. Lo importante aquí es notar cómo la repetición manual del código puede llevar a errores y a códigos largos y difíciles de mantener. Es por esto que las estructuras de control como bucles `for` o `while` son muy útiles para simplificar este tipo de tareas, permitiendo escribir un bloque de código una vez y luego ejecutarlo múltiples veces hasta alcanzar la condición deseada (como imprimir hasta el día 31 del mes).

`001-ineficiente.py`

```python
# Cuento los días del mes
print("Hoy es el dia 1 del mes")
print("Hoy es el dia 2 del mes")
print("Hoy es el dia 3 del mes")
print("Hoy es el dia 4 del mes")
print("Hoy es el dia 5 del mes")
# ...
```

### estructura for
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código utiliza una estructura de repetición llamada `for` en Python para contar y mostrar los días del mes. Comienza estableciendo un rango que va desde el día 1 hasta el día 30 (el límite superior es excluido, por lo que incluye 30 pero no 31). En cada iteración del bucle `for`, la variable `dia` toma el valor de cada número en este rango, empezando por 1 y terminando por 30. Durante cada vuelta del ciclo, se imprime una frase que indica cuál es el día actual en ese momento dentro del mes.

Esta estructura de repetición es muy útil cuando sabes exactamente cuántas veces necesitas ejecutar un bloque de código y puedes definir un rango claro para ello. En este caso específico, permite mostrar fácilmente los números del 1 al 30, que representan días sucesivos en el mes.

`002-estructura for.py`

```python
# Cuento los días del mes
for dia in range(1,31):
  print("Hoy es el dia ",dia,"del mes")
```

### anidacion
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código utiliza dos bucles anidados para simular la cuenta de los días en un año. El primer bucle `for` recorre cada mes del año, desde el mes 1 hasta el mes 12. Dentro de este bucle, hay otro bucle `for` que se encarga de contar los días en cada mes, comenzando desde el día 1 y llegando al día 30.

Es importante notar que este código imprime todos los días del año considerando siempre un máximo de 30 días por mes, sin tener en cuenta meses con menos días como febrero o meses con hasta 31 días. La función `print` muestra la fecha en formato "Hoy es el día X del mes Y", donde X representa el número del día y Y el número del mes actual.

Este tipo de estructura anidada de bucles es útil para realizar tareas que requieren iterar sobre una serie de datos complejos, como los días en un año.

`003-anidacion.py`

```python
# Cuento los días del mes
for mes in range(1,13):
  for dia in range(1,31):
    print("Hoy es el dia ",dia,"del mes",mes)
```

### mas anidacion
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código muestra cómo se utilizan las estructuras `for` anidadas para recorrer diferentes niveles de iteración. En este caso, el programa está contando los días a través del tiempo, específicamente desde el año 1978 hasta el año 2025 (el rango va hasta 2026 pero no incluye ese año). Para cada año, recorre todos los meses posibles (del mes 1 al mes 12) y luego, para cada mes, cuenta hasta el día 30. Esto significa que imprime una línea por cada combinación de día, mes y año dentro del rango especificado.

Aunque el código es simple en su estructura, se hace un poco ineficiente porque asume que todos los meses tienen al menos 31 días, lo cual no siempre es correcto (por ejemplo, febrero tiene solo 28 o 29 días). Sin embargo, este ejercicio sirve para ilustrar cómo anidar bucles `for` y entender la secuencia de iteraciones en un programa.

`004-mas anidacion.py`

```python
# Cuento los días del mes
for anio in range(1978,2026):
  for mes in range(1,13):
    for dia in range(1,31):
      print("Hoy es el dia ",dia,"del mes",mes,"del año",anio)
```

### ahora los impares
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código utiliza una estructura de repetición llamada `for` para imprimir todos los números impares del 1 al 99. La función `range(1, 100, 2)` genera una secuencia de números que comienza en 1 y termina antes de alcanzar 100, incrementando de dos en dos. Esto significa que el código imprimirá cada número impar en ese rango, como 1, 3, 5, 7, etc., hasta llegar a 99. Esta estructura es útil para recorrer una secuencia específica de números y realizar operaciones solo con ciertos elementos, en este caso, los números impares.

`006-ahora los impares.py`

```python
# Cuento los días del mes
for pares in range(1,100,2):
  print(pares)
```

### while
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código muestra cómo usar un bucle `while` en Python para realizar una acción repetida hasta que se cumpla cierta condición. En este caso, la variable `dia` comienza con el valor de 1 y el programa imprimirá "hoy es el dia [valor de dia] del mes" mientras `dia` sea menor a 31.

El bucle continúa ejecutándose y aumentando el valor del día en cada iteración hasta que el número llega a ser 31 o más, momento en que la condición (`dia < 31`) ya no se cumple y el programa sale del bucle. Este tipo de estructura es útil cuando no conoces de antemano cuántas veces necesitarás repetir un bloque de código, pero puedes definir una condición para terminar la repetición.

Es importante entender este concepto porque los bucles son fundamentales en programación para automatizar tareas que requieren realizar acciones repetitivas hasta alcanzar un objetivo específico.

`007-while.py`

```python
dia = 1

while dia < 31:
  print("hoy es el dia",dia,"del mes")
```

### incremento
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código utiliza un bucle `while` para imprimir una frase que indica qué día del mes es, desde el primer hasta el trigésimo día. La variable `dia` comienza en 1 y se incrementa en 1 en cada iteración gracias a la línea `dia += 1`. El bucle continúa ejecutándose mientras `dia` sea menor que 31. Cada vez que se imprime, la frase cambia para reflejar el día actual del mes. Este tipo de estructura es útil cuando necesitas realizar una acción repetidamente y dependiendo de un contador específico.

`008-incremento.py`

```python
dia = 1

while dia < 31:
  print("hoy es el dia",dia,"del mes")
  dia += 1  # dia = dia + 1
```

### Actividades propuestas

### Actividad 1: Conteo de Días del Mes
**Descripción:** Los estudiantes deben crear un script que muestre los días del mes utilizando una estructura `for`. Se espera que aprendan a utilizar rangos y bucles `for` para iterar sobre un rango numérico específico.

### Actividad 2: Mejora de Códigos Ineficientes
**Descripción:** Los estudiantes deben convertir bloques de código ineficientes (que imprimen días del mes uno por uno) en una estructura de bucle `for`. Aprenderán a reemplazar la redundancia con control de flujo.

### Actividad 3: Anidación Básica
**Descripción:** Se pide a los estudiantes que realicen un ejercicio donde aniden dos ciclos `for` para recorrer días y meses. El objetivo es comprender cómo funcionan las estructuras anidadas en la programación.

### Actividad 4: Anidación Avanzada
**Descripción:** Los alumnos deben crear una estructura de bucles anidados que cubran años, meses y días. Esto ayudará a entender el uso de múltiples niveles de iteración y cómo manejar datos en tiempo largo.

### Actividad 5: Conteo Condicional (Pares/Impares)
**Descripción:** Los estudiantes deben escribir un script que cuente números pares o impares desde una lista dada, usando estructuras `for`. Aprenderán a usar condiciones dentro de los bucles para filtrar y contar elementos específicos.

### Actividad 6: Conversión de Bucle Ineficiente
**Descripción:** Los estudiantes tomarán un código que imprime días del mes sin utilizar ningún ciclo y lo convertirán en una versión eficiente usando `while`. El objetivo es mejorar su habilidad para optimizar el flujo controlado.

### Actividad 7: Incremento Manual En Ciclos
**Descripción:** Se les pide a los estudiantes que modifiquen un bucle `while` básico, añadiendo manualmente la actualización del contador. Esto fortalecerá su comprensión de cómo funcionan las variables de control en diferentes estructuras.

### Actividad 8: Simulación De Producción
**Descripción:** Los estudiantes deben desarrollar un programa que simule una fábrica produciendo patitos de goma a lo largo del tiempo. Utilizarán ciclos anidados para manejar años, meses y días y contar la producción diaria.

### Actividad 9: Resumen Mensual
**Descripción:** Los alumnos deben crear un programa que cuente los días del mes y muestre un resumen mensual al final de cada mes con el total de días contabilizados. Aprenderán a usar estructuras condicionales dentro de bucles para generar reportes.

### Actividad 10: Comparativa Bucle For vs While
**Descripción:** Los estudiantes deben escribir scripts que hagan lo mismo utilizando tanto `for` como `while`, y comparar las diferencias en términos de legibilidad y eficiencia. Esto les ayudará a decidir cuándo usar cada tipo de estructura.


<a id="estructuras-de-salto"></a>
## Estructuras de salto

### Introducción a los ejercicios

En esta carpeta, encontrarás ejercicios que te ayudarán a entender y practicar el uso de funciones en Python. Los ejercicios comienzan con la definición básica de una función y avanzan hacia la creación de funciones más complejas que incluyen parámetros, múltiples argumentos y el retorno de valores. El objetivo principal es familiarizarte con cómo declarar, llamar y utilizar funciones para realizar tareas específicas en tu código, como saludar a alguien o calcular la suma de dos números. Estos ejercicios te permitirán mejorar tus habilidades en la modularización del código, lo que es crucial para escribir programas más organizados y mantenibles.

### Funciones
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código define una función en Python llamada `diHola`. Una función es como una receta que realiza una tarea específica cuando se llama. En este caso, la función `diHola` imprime el mensaje "Te digo hola" cada vez que se ejecuta.

La función comienza con la palabra clave `def`, seguida del nombre de la función (`diHola`) y paréntesis vacíos, ya que no necesita recibir ningún dato adicional. Luego sigue un bloque de código indentado que contiene lo que la función hace cuando es llamada. En este caso, simplemente imprime el saludo en pantalla.

Es importante seguir las pautas de nomenclatura para funciones, como usar camelCase (escribir palabras compuestas sin espacios y con mayúsculas solo al principio de cada nueva palabra, excepto la primera) y elegir un nombre que describa lo que hace la función. En este ejemplo, `diHola` sigue estas reglas porque es fácil entender qué efecto tiene cuando se ejecuta.

`001-Funciones.py`

```python
# Deben escribirse con camelCase
# Deben tener un verbo (infinito o imperativo) y un objeto directo
# Deben tener un nombre descriptivo

def diHola():
  print("Te digo hola")
  
```

### uso de la funcion
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código en Python muestra cómo definir y utilizar una función simple. La función se llama `diHola` y está diseñada para imprimir el mensaje "Te digo hola" cada vez que es llamada. 

En primer lugar, la línea `def diHola():` indica la creación de una nueva función con el nombre `diHola`. Este nombre sigue las convenciones recomendadas en Python, utilizando camelCase (cada palabra empieza con mayúscula menos la primera). Dentro del bloque de la función, se encuentra la instrucción `print("Te digo hola")`, que es lo que la función ejecuta cuando se llama. Finalmente, `diHola()` sin nada antes del nombre indica una llamada a esta función, por lo que el mensaje se imprime en pantalla.

Esta pequeña función ilustra cómo encapsular un comportamiento específico dentro de una entidad reutilizable y claramente nombrada, haciendo así más fácil la organización y mantenimiento del código.

`002-uso de la funcion.py`

```python
# Deben escribirse con camelCase
# Deben tener un verbo (infinito o imperativo) y un objeto directo
# Deben tener un nombre descriptivo

def diHola():
  print("Te digo hola")
  
diHola()
```

### parametros
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código en Python define una función llamada `diHola` que toma un parámetro (que normalmente sería el nombre de la persona a quien se le desea saludar). La función imprime un mensaje que incluye el parámetro proporcionado. Sin embargo, hay un pequeño problema: cuando se llama a la función al final del código, no se proporciona ningún argumento. Esto provocará un error en Python porque la función `diHola` espera recibir un argumento pero no recibe ninguno.

Lo importante aquí es entender cómo definir y llamar a funciones en Python, así como la importancia de proporcionar los parámetros correctos cuando se llama a una función que requiere uno o varios. En este caso, para que el código funcione correctamente, debes llamar a `diHola` pasándole un argumento, por ejemplo: `diHola("Juan")`.

`003-parametros.py`

```python
# Deben escribirse con camelCase
# Deben tener un verbo (infinito o imperativo) y un objeto directo
# Deben tener un nombre descriptivo

def diHola(nombre):
  print("Hola,",nombre,"yo te saludo")
  
diHola()
```

### Llamada correcta
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código en Python muestra cómo se define y utiliza una función básica. La función se llama `diHola` y su propósito es imprimir un saludo personalizado para cualquier nombre que le pases como argumento.

La definición de la función comienza con `def diHola(nombre):`, donde "diHola" es el nombre de la función (que debe seguir las reglas mencionadas en los comentarios) y `nombre` es el parámetro, que actúa como una variable dentro de la función. Dentro del cuerpo de la función, se usa la instrucción `print("Hola,", nombre, "yo te saludo")` para mostrar un mensaje personalizado en la pantalla.

Después de definir la función, hay dos llamadas a esta función: `diHola("Jose Vicente")` y `diHola("Jorge")`. Estas líneas invocan la función con diferentes nombres como argumentos. Cuando el programa ejecuta estas líneas, se imprime un saludo para cada nombre proporcionado.

Este código es importante porque demuestra cómo encapsular una tarea específica en una función, lo que permite reutilizar ese fragmento de código sin necesidad de repetirlo siempre que quieras saludar a alguien por su nombre.

`004-Llamada correcta.py`

```python
# Deben escribirse con camelCase
# Deben tener un verbo (infinito o imperativo) y un objeto directo
# Deben tener un nombre descriptivo

def diHola(nombre):
  print("Hola,",nombre,"yo te saludo")
  
diHola("Jose Vicente")
diHola("Jorge")
```

### varios parametros
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código define una función en Python llamada `diHola` que utiliza dos parámetros: `nombre` y `edad`. La función imprime un mensaje personalizado en la consola, saludando a la persona cuyo nombre y edad se le proporcionan como argumentos. Por ejemplo, cuando se llama a la función con los valores "Jose Vicente" y 47, el programa mostrará: "Hola, Jose Vicente, tienes 47 años y yo te saludo". Luego de definir la función, se invoca dos veces pasándole diferentes nombres y edades para demostrar cómo funciona. Este código ilustra cómo utilizar funciones con parámetros en Python, lo que es una técnica fundamental en programación para reutilizar bloques de código y manejar datos variables de manera eficiente.

`005-varios parametros.py`

```python
# Deben escribirse con camelCase
# Deben tener un verbo (infinito o imperativo) y un objeto directo
# Deben tener un nombre descriptivo

def diHola(nombre,edad):
  print("Hola,",nombre,", tienes",edad," años y yo te saludo")
  
diHola("Jose Vicente",47)
diHola("Jorge",48)
```

### las funcione retornan
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código define y utiliza una función en Python llamada `diHola`. La función tiene dos parámetros: `nombre` y `edad`, que son los valores necesarios para personalizar el mensaje que la función genera. El propósito principal de esta función es formar un saludo personalizado que incluye el nombre del usuario y su edad.

La función utiliza la concatenación de cadenas (usando el signo más `+`) para construir una frase que comienza con "Hola," seguido por el nombre proporcionado, luego añade la edad convertida a cadena mediante `str(edad)`, y finalmente completa el mensaje con un saludo. El resultado de esta concatenación se devuelve desde la función gracias a la instrucción `return`.

Finalmente, en el código hay dos llamadas a la función `diHola` donde se especifican diferentes valores para los parámetros `nombre` e `edad`. Esto significa que cada vez que llamas a la función con estos datos, obtendrás un saludo personalizado basado en los argumentos proporcionados. Es importante destacar cómo el uso de funciones puede facilitar y organizar el código al permitirnos reutilizar bloques específicos de lógica simplemente llamándolos con diferentes entradas.

`006-las funcione retornan.py`

```python
# Deben escribirse con camelCase
# Deben tener un verbo (infinito o imperativo) y un objeto directo
# Deben tener un nombre descriptivo
# Parámetro es el valor que entra en la función
# Return es la forma limpia de sacar información de una función

def diHola(nombre,edad):
  return "Hola,"+nombre+", tienes"+str(edad)+" años y yo te saludo"
  
diHola("Jose Vicente",47)
diHola("Jorge",48)
```

### funcion de sumar
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código en Python muestra cómo se define y utiliza una función llamada `calculaSuma`. La función toma dos números como parámetros (`operando1` y `operando2`) y retorna la suma de estos dos valores. En resumen, lo que hace esta función es sumar dos números proporcionados por el usuario.

El código sigue las reglas establecidas en el comentario al principio del archivo: usa un nombre adecuado para la función (`calculaSuma`), tiene parámetros de entrada y retorna una salida con `return`. No utiliza comandos como `print()` dentro de la función, lo cual es una buena práctica ya que permite reutilizar esta función en diferentes partes del programa sin cambios.

Finalmente, después de definir la función, se llama a ella pasándole dos números (4 y 3) para calcular su suma. El resultado de llamar a `calculaSuma(4,3)` es impreso en pantalla mediante un `print`, aunque el cálculo en sí ocurre dentro de la función.

Este tipo de estructura de código es importante porque permite organizar el programa en partes manejables y reutilizables, mejorando así su legibilidad y mantenimiento.

`007-funcion de sumar.py`

```python
'''
 Funcion correcta:
 Nombre: Verbo imperativo (o infinitivo) + objeto directo
 Usa camelCase
 Debe tener parámetros de entrada
 Debe tener una salida con return
 Debemos evitar prints u otros recursos de salida dentro de la funcion
'''

def calculaSuma(operando1,operando2):
  resultado = operando1 + operando2
  return resultado
  
print(calculaSuma(4,3))
```

### llamada a la funcion de suma
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código está utilizando la función `calculaSuma` que se encuentra en otro archivo llamado `funcionsuma.py`. Lo primero que hace es importar esa función específica desde el archivo mencionado. Luego, imprime el resultado de llamar a la función `calculaSuma`, pasándole dos números como argumentos: 4 y 3.

La línea `print(calculaSuma(4,3))` realiza la llamada efectiva a la función que suma estos dos valores e imprime el resultado en pantalla. Es importante porque muestra cómo se integran las funciones definidas en un archivo diferente para reutilizar código y mantener el programa más organizado.

Este tipo de práctica es fundamental en programación ya que permite modularizar tu código, haciéndolo más manejable y fácil de entender.

`008-llamada a la funcion de suma.py`

```python
# from archivo import funcion,funcion2,funcion3

from funcionsuma import calculaSuma

print(calculaSuma(4,3))
```

### funcionsuma
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código define una función en Python llamada `calculaSuma` que se encarga de sumar dos números y devolver el resultado. La función recibe dos parámetros, `operando1` y `operando2`, que son los números que queremos sumar. Dentro de la función, se calcula la suma de estos dos operandos y se almacena en una variable llamada `resultado`. Finalmente, la función retorna este resultado.

Es importante destacar que esta implementación sigue buenas prácticas de programación en Python: utiliza parámetros de entrada, realiza un cálculo sin imprimir nada por pantalla (lo cual es útil para reutilizar la función en diferentes contextos), y devuelve el resultado usando `return`. Esto hace que la función sea modular y fácil de usar en otros lugares del programa.

`funcionsuma.py`

```python
'''
 Funcion correcta:
 Nombre: Verbo imperativo (o infinitivo) + objeto directo
 Usa camelCase
 Debe tener parámetros de entrada
 Debe tener una salida con return
 Debemos evitar prints u otros recursos de salida dentro de la funcion
'''

def calculaSuma(operando1,operando2):
  resultado = operando1 + operando2
  return resultado
```

### Actividades propuestas

### Actividad 1: Crear y Llamar Funciones Simples
**Descripción:** Escribe una función llamada `saludar` que imprima un saludo simple. A continuación, llama a esta función en tu código principal para ver cómo funciona. Este ejercicio te ayudará a entender la estructura básica de las funciones en Python.

### Actividad 2: Funciones con Parámetros
**Descripción:** Modifica la función `saludar` para que tome un parámetro (por ejemplo, el nombre del usuario) y use este parámetro dentro de la función para personalizar el saludo. Aprenderás a pasar datos a una función.

### Actividad 3: Funciones con Dos Parámetros
**Descripción:** Extiende tu función `saludar` para que acepte dos parámetros, uno para el nombre y otro para un mensaje adicional. Luego llama a la función varias veces con diferentes valores de entrada para ver cómo funciona.

### Actividad 4: Retorno de Valores
**Descripción:** Modifica una función existente (como `saludar`) para que devuelva un valor en lugar de imprimirlo directamente, utilizando el comando `return`. Aprenderás a manejar los valores retornados por las funciones.

### Actividad 5: Creación y Uso de Módulos
**Descripción:** Crea una función simple (`saludar`) en un archivo separado (por ejemplo, `funcion_saludo.py`). Luego, importa esta función desde otro script principal para utilizarla. Aprenderás cómo estructurar tu código en múltiples archivos y entender el concepto de módulos.

### Actividad 6: Desarrollo de una Función Matemática
**Descripción:** Escribe una función llamada `calcular_producto` que tome dos números como parámetros, calcule su producto, y devuelva el resultado. Luego llama a esta función desde tu código principal y muestra el resultado en pantalla.

### Actividad 7: Sumar Números con Funciones
**Descripción:** Desarrolla una función llamada `sumar_numeros` que tome dos números como argumentos, sume estos valores e imprima la suma. Aprenderás cómo definir funciones para realizar cálculos matemáticos.

### Actividad 8: Invocación de Funciones desde Archivo Separado
**Descripción:** Crea una función simple (`calcular_suma`) que realice la suma de dos números y devuelva el resultado en un archivo llamado `funcion_suma.py`. Luego, importa esta función desde otro script principal para realizar cálculos y mostrar resultados.

### Actividad 9: Mejoramiento de una Función Existente
**Descripción:** Toma la función `diHola` del ejercicio proporcionado y mejórala para que acepte opcionalmente un segundo parámetro (edad), mostrando este dato en el saludo si se proporciona. Aprenderás a manejar parámetros opcionales dentro de funciones.

### Actividad 10: Crear una Función Compleja
**Descripción:** Diseña y escribe una función llamada `calcular_promedio` que tome tres números como argumentos, calcule su promedio y devuelva este valor. Luego utiliza la función desde tu código principal para mostrar el resultado.


<a id="control-de-excepciones"></a>
## Control de excepciones

### Introducción a los ejercicios

Esta carpeta contiene una serie de ejercicios en Python que te enseñan cómo manejar y controlar excepciones en tus programas. Los problemas trabajados van desde simples bloques `try-except` para capturar errores básicos, como divisiones por cero, hasta casos más complejos donde se manejan múltiples tipos específicos de excepciones para proporcionar un feedback útil al usuario del programa. A través de estos ejercicios, practicarás la estructura y el uso eficiente de las cláusulas `try`, `except`, `else` y `finally`. Esto es fundamental para crear programas más robustos que puedan manejar situaciones inesperadas sin colapsar completamente.

### tryexcept
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código muestra cómo usar una estructura `try-except` en Python para manejar errores de forma eficiente. La función principal aquí es ejecutar un bloque de código dentro del `try`, que en este caso intenta imprimir la suma de 4 y 3. Si durante esta operación ocurre algún tipo de error (que no sucede en este ejemplo porque la suma es válida), el programa entra al bloque `except` e imprime "Ha ocurrido un error". Sin embargo, en este código específico, como la operación dentro del `try` se realiza correctamente sin provocar errores, el mensaje dentro del `except` no se ejecuta.

Es importante destacar que aunque la suma se realiza con éxito, el uso de la estructura `try-except` permite al programa continuar su ejecución después del bloque `try`, lo cual demuestra cómo manejar posibles fallos sin interrumpir completamente la operación del programa. Finalmente, independientemente de si hubo un error o no, el código imprime "Pero el programa continúa pase lo que pase", ilustrando que el flujo sigue adelante después del bloque `try-except`.

`001-tryexcept.py`

```python
try:
  print(4+3)
except:
  print("Ha ocurrido un error")
  
print("Pero el programa continúa pase lo que pase")
```

### error
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código muestra un error clásico en programación que se conoce como "división por cero". Cuando intentas dividir cualquier número entre cero, Python genera una excepción (un tipo de error) llamada `ZeroDivisionError`. En este caso, el programa ejecuta la línea `print(4/0)` y se detiene porque no puede realizar esta operación matemática. Aunque sigue habiendo otra instrucción después (`print("Y el programa continua")`), ésta nunca se ejecutará debido al error previo.

Es importante aprender a manejar este tipo de errores para hacer que tus programas sean más robustos y puedan seguir funcionando incluso cuando ocurran situaciones inesperadas. En lugar de simplemente imprimir un resultado, podrías rodear la línea que causa el problema con una estructura `try-except` para capturar el error y gestionarlo adecuadamente, permitiendo al programa continuar su ejecución después del fallo.

`002-error.py`

```python
print(4/0)

print("Y el programa continua")
```

### error con try except
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código muestra cómo manejar errores en Python utilizando las estructuras `try` y `except`. La parte dentro del bloque `try` intenta realizar una operación, que es dividir el número 4 entre 0. Esto no es posible matemáticamente y genera un error en tiempo de ejecución.

Cuando se produce este error, la ejecución salta inmediatamente al bloque `except`, que simplemente imprime el mensaje "No puedo ejecutar eso". Esto permite que el programa maneje correctamente el error sin interrumpirse completamente.

Finalmente, después del bloque `try-except`, se imprime un mensaje en pantalla indicando que "Y el programa continua", mostrando que el código puede continuar su ejecución incluso si hubo un error previo. Este tipo de control de excepciones es muy útil para hacer que los programas sean más robustos y capaces de lidiar con situaciones inesperadas sin fallar abruptamente.

`003-error con try except.py`

```python
try:
  print(4/0)
except:
  print("No puedo ejecutar eso")

print("Y el programa continua")
```

### pseudocodigo
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código muestra cómo manejar errores en Python usando la estructura `try-except`. La función principal de esta estructura es capturar cualquier error que pueda ocurrir dentro del bloque `try` y ejecutar el código dentro del bloque `except` si se produce un error.

En este caso, dentro del bloque `try`, intenta realizar una operación matemática no válida: dividir por cero (`print(4/0)`), lo que genera un error. Si esto ocurre, el programa salta al bloque `except`, donde imprime "No puedo ejecutar eso" y luego indica que guarda los datos en un archivo local temporal.

Es importante destacar que esta manera de manejar excepciones es general y captura todos los tipos de errores sin especificar cuál tipo de error está ocurriendo. En la práctica, es mejor ser más específico sobre el tipo de errores para poder tratarlos adecuadamente.

Finalmente, independientemente de si se produce un error o no en el bloque `try`, el programa continuará ejecutando las líneas que están fuera del bloque `try-except`, por lo que al final imprime "Y el programa continua".

`004-pseudocodigo.py`

```python
try:
  print(4/0)
  print("Intento conectarme a la base de datos")
  print("pero falla")
except:
  print("No puedo ejecutar eso")
  print("Pues por lo menos guardo los datos a un archivo local temporal")

print("Y el programa continua")
```

### Excepcion como e
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código ilustra cómo manejar errores en Python utilizando una estructura llamada `try-except`. Aquí, el programa intenta realizar una división entre dos variables: `dividendo` que vale 4 y `divisor` que es 0. Intentar dividir cualquier número por cero causa un error importante en matemáticas y en la mayoría de los lenguajes de programación.

El código envuelve esta operación potencialmente problemática dentro del bloque `try`. Si durante la ejecución del código Python detecta que algo va mal (es decir, si se produce una excepción como la división por cero), el programa salta al bloque `except` asociado. En este caso específico, cuando intenta dividir 4 entre 0 y se genera un error, el programa simplemente imprime "Hay un error" en lugar de detenerse completamente o mostrar un mensaje técnico de error.

Es importante manejar estos errores porque si no lo hiciéramos, nuestro programa podría fallar abruptamente sin proporcionar información útil sobre por qué falló. Manejar excepciones nos permite hacer que nuestros programas sean más robustos y amigables para el usuario al tratar con situaciones inesperadas de manera controlada.

`005-Excepcion como e.py`

```python
dividendo = 4
divisor = 0

try:
  division = dividendo/divisor
except:
  print("Hay un error")
```

### capturo el error
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código muestra cómo manejar errores en Python usando una estructura de control llamada `try-except`. La idea principal es evitar que el programa se detenga abruptamente si ocurre un problema durante la ejecución. En este caso, el código intenta dividir el número 4 (almacenado en la variable `dividendo`) entre 0 (almacenado en la variable `divisor`). 

La línea dentro del bloque `try` provocaría una excepción porque no es posible dividir por cero matemáticamente. Si ocurre esta situación, Python genera un error y el control se pasa al bloque `except`. Dentro de este bloque, el código imprime que "Hay un error" y luego muestra información sobre qué tipo de error ocurrió.

Este enfoque es importante porque permite hacer que los programas sean más robustos y amigables para el usuario. En lugar de finalizar abruptamente con un mensaje técnico y confuso, puedes ofrecer a tus usuarios mensajes claros y útiles acerca de lo que salió mal.

`006-capturo el error.py`

```python
dividendo = 4
divisor = 0

try:
  division = dividendo/divisor
except Exception as mierror:
  print("Hay un error")
  print(mierror)
```

### errores personalizados
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código está diseñado para mostrar cómo manejar errores en Python, específicamente cuando se intenta realizar una división entre cero. El programa establece dos variables: `dividendo` con el valor 4 y `divisor` con el valor 0. Luego, utiliza un bloque `try` para intentar dividir `dividendo` por `divisor`. Si ocurre un error debido a la división entre cero, que en Python se representa como una excepción `ZeroDivisionError`, el programa entra al primer bloque `except` y muestra el mensaje "Tienes un error de división por cero". Además, también hay un segundo bloque `except Exception as mierror` para capturar cualquier otro tipo de error que no sea la división entre cero, imprimiendo un mensaje general de error seguido del detalle del error. Este código es importante porque muestra cómo prevenir que el programa se bloquee debido a errores inesperados y proporciona retroalimentación al usuario sobre qué ha salido mal durante la ejecución del programa.

`007-errores personalizados.py`

```python
dividendo = 4
divisor = 0

try:
  division = dividendo/divisor
except ZeroDivisionError:
  print("Tienes un error de division por cero")
except Exception as mierror:
  print("Hay un error")
  print(mierror)
```

### todos los posibles
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código muestra cómo manejar diferentes tipos de errores en Python utilizando la estructura `try-except`. El objetivo es realizar una división entre dos variables, pero antes de hacerlo, el programa verifica y trata varios posibles problemas que podrían ocurrir durante la ejecución.

El código comienza estableciendo dos valores: `dividendo` con valor 4 y `divisor` con valor 0. Luego entra en un bloque `try`, donde intenta realizar una división entre estos dos números. Si el divisor es cero, Python genera automáticamente un error de tipo `ZeroDivisionError`.

Después del bloque `try`, hay varios bloques `except` que capturan diferentes tipos de excepciones. Cada bloque `except` está diseñado para manejar un tipo específico de error y proporciona un mensaje de error personalizado. Esto es importante porque ayuda al programador a entender rápidamente qué ha salido mal en su código.

Además, el último bloque `except Exception as e:` captura cualquier otro tipo de excepción que no haya sido específicamente manejada por los bloques anteriores y proporciona información sobre ese error. Finalmente, un bloque `finally` siempre se ejecuta al final, independientemente de si ocurrió un error o no, para indicar el fin del manejo de la excepción.

Este enfoque es crucial en programación ya que permite que los programas manejen errores de manera más robusta y proporcionen retroalimentación útil sobre cuál fue el problema específico.

`008-todos los posibles.py`

```python
dividendo = 4
divisor = 0

try:
    division = dividendo / divisor

except ZeroDivisionError:
    print("❌ Error: división por cero.")

except TypeError:
    print("❌ Error: tipos de datos incompatibles para la operación.")

except ValueError:
    print("❌ Error: valor no válido.")

except NameError:
    print("❌ Error: variable no definida.")

except IndexError:
    print("❌ Error: índice fuera de rango.")

except KeyError:
    print("❌ Error: clave inexistente en un diccionario.")

except AttributeError:
    print("❌ Error: atributo no encontrado en el objeto.")

except ImportError:
    print("❌ Error: problema al importar un módulo o función.")

except FileNotFoundError:
    print("❌ Error: archivo no encontrado.")

except PermissionError:
    print("❌ Error: permiso denegado al acceder a un recurso.")

except OSError:
    print("❌ Error del sistema operativo (archivos, rutas, etc.).")

except MemoryError:
    print("❌ Error: la memoria disponible se ha agotado.")

except RecursionError:
    print("❌ Error: recursión demasiado profunda.")

except Exception as e:
    print("⚠️  Error inesperado:")
    print(type(e).__name__, "-", e)

except BaseException as e:
    print("🛑 Error crítico del sistema:")
    print(type(e).__name__, "-", e)

else:
    print("✅ La operación se realizó correctamente.")

finally:
    print("🔚 Fin del bloque try-except.")
```

### atrapar dato en consola
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código utiliza una estructura `try-except-finally` en Python para manejar errores. En este caso, el código intenta convertir la cadena "hola" en un número entero usando la función `int()`. Sin embargo, esta conversión no es posible porque "hola" no representa ningún número.

Cuando se produce una excepción de tipo `ValueError` (porque no podemos convertir texto que no es numérico a un número), el programa ejecuta lo que está dentro del bloque `except ValueError`, imprimiendo un mensaje de error específico. Finalmente, independientemente de si ocurrió un error o no, el bloque `finally` se ejecutará para imprimir "🔚 Fin del bloque try-except.", asegurando que haya una conclusión clara y controlada del proceso.

Esta técnica es muy importante porque permite al programa manejar errores de manera adecuada sin interrumpir su ejecución bruscamente.

`009-atrapar dato en consola.py`

```python
try:
    numero = int("hola")  # Intentamos convertir texto no numérico a entero
    print("El número es:", numero)

except ValueError:
    print("❌ Error: valor no válido (no se puede convertir a número).")

finally:
    print("🔚 Fin del bloque try-except.")
```

### Actividades propuestas

### Actividad 1: Manejo Básico de Excepciones

**Descripción:** Implementa un programa que divida dos números proporcionados por el usuario. Utiliza una estructura `try-except` para manejar la excepción que ocurre cuando se intenta dividir entre cero. El objetivo es aprender a capturar y gestionar errores comunes.

### Actividad 2: Personalización de Mensajes de Error

**Descripción:** Modifica el código del ejercicio anterior para que, en lugar de un mensaje genérico, muestre un error personalizado cuando se produce una división por cero. El objetivo es aprender a mejorar la legibilidad y la amabilidad de los mensajes de error.

### Actividad 3: Gestión de Múltiples Excepciones

**Descripción:** Crea un programa que intente realizar varias operaciones (como dividir dos números, acceder a elementos inexistentes en una lista, etc.). Utiliza múltiples bloques `try-except` para manejar diferentes tipos de errores específicos. Aprenderás cómo estructurar código para manejar situaciones complejas.

### Actividad 4: Uso del Bloque `else`

**Descripción:** Desarrolla un programa que utilice una estructura `try-except-else`. El bloque `else` debe ejecutarse solo si no se produce ninguna excepción durante la división de dos números. Aprenderás a diferenciar el código que se ejecuta cuando todo sale bien del que se ejecuta en caso de errores.

### Actividad 5: Bloque `finally`

**Descripción:** Implementa un programa donde uses una estructura `try-except-finally`. El bloque `finally` debe contener acciones que deben realizarse independientemente de si ocurrió un error o no, como cerrar archivos o liberar recursos. Aprenderás a asegurar el estado final del programa.

### Actividad 6: Tratamiento de Excepciones Específicas

**Descripción:** Escribe una aplicación que capture y trate excepciones específicas (por ejemplo, `ZeroDivisionError`, `TypeError`) en un bloque `try-except`. Luego, utiliza un `except Exception` como último recurso para capturar errores no esperados. Aprenderás a ser más específico al manejar diferentes tipos de errores.

### Actividad 7: Tratamiento de Excepciones Personalizadas

**Descripción:** Diseña una aplicación que solicite al usuario ingresar dos números y realice operaciones matemáticas con ellos, utilizando excepciones personalizadas para manejar casos específicos como división por cero o entradas no numéricas. Aprenderás a crear mensajes de error más útiles y precisos.

### Actividad 8: Procesamiento de Datos Con Excepciones

**Descripción:** Crea un programa que lea datos desde una lista, intente realizar operaciones con ellos (como la división), y maneje excepciones como `IndexError` y `ZeroDivisionError`. El objetivo es aprender a gestionar errores en el contexto de manipulación de estructuras de datos.

### Actividad 9: Captura de Errores en Entrada del Usuario

**Descripción:** Desarrolla un programa que solicite al usuario ingresar una fecha en formato numérico y luego convierta esta entrada a un objeto `datetime`. Utiliza bloques `try-except` para manejar errores como `ValueError` si la entrada no es válida. Aprenderás a validar la entrada del usuario y proporcionar retroalimentación adecuada.

### Actividad 10: Integración de Excepciones en Procesos Complejos

**Descripción:** Implementa una aplicación más compleja que realice múltiples operaciones (como lectura y escritura de archivos, conexión a bases de datos) utilizando excepciones para manejar posibles errores. Aprenderás a diseñar programas robustos y resilientes frente a situaciones inesperadas.

Estas actividades están diseñadas para ayudarte a dominar el uso de estructuras de control en Python, con un enfoque especial en la gestión eficiente de excepciones.


<a id="aserciones"></a>
## Aserciones

### Introducción a los ejercicios

En esta carpeta de ejercicios, los estudiantes van a aprender y practicar el uso de aserciones en Python. Las aserciones son declaraciones que permiten verificar si una condición específica es cierta durante la ejecución del programa; sirven como un mecanismo para detectar errores lógicos en el código. A través de estos ejemplos, los estudiantes podrán entender cómo escribir y utilizar aserciones para mejorar la robustez y la legibilidad de sus programas. Además, se les enseñará cómo manejar excepciones generadas por aserciones que fallan, proporcionando una introducción a la gestión de errores en Python.

### chivato
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código utiliza una estructura llamada `assert` en Python, que sirve para verificar si una condición es verdadera durante la ejecución del programa. En este caso, el código está verificando que el número 3 sea igual a 3. Si esto no fuera cierto (aunque realmente siempre lo será), el programa generaría un error con el mensaje "Eso no es cierto". Esta estructura `assert` es útil para identificar errores en etapas tempranas del desarrollo y asegurar que las condiciones importantes en tu código se cumplen.

`001-chivato.py`

```python
assert 3 == 3 , "Eso no es cierto"
```

### el chivato salta
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código utiliza una sentencia llamada `assert` en Python, que se usa para verificar si una condición dada es verdadera. En este caso, la condición es `3 == 2`, lo cual obviamente es falso porque 3 no es igual a 2. Si esta condición no se cumple (es decir, es falsa), Python generará un error y mostrará el mensaje que le sigue a la comprobación (`"Eso no es cierto"`). La función `assert` es útil para detectar errores en el código durante la fase de desarrollo, asegurando que las suposiciones del programador sobre los datos son correctas antes de seguir con el flujo normal del programa. Es importante entender y usar adecuadamente `assert` porque ayuda a hacer que tu código sea más robusto y fácil de depurar.

`002-el chivato salta.py`

```python
assert 3 == 2 , "Eso no es cierto"
```

### ejemplo no tan traumatico
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código en Python utiliza la declaración `assert` para verificar que una condición específica sea cierta. En este caso, la variable `edad` se ha establecido con el valor 47. Luego, se usa `assert edad == 48`, lo cual significa que el programa está comprobando si `edad` es igual a 48. Si esto no es verdadero (es decir, si `edad` es diferente de 48), el programa generará un error con el mensaje "no es correcto".

La declaración `assert` sirve como una herramienta útil para verificar que ciertas condiciones se cumplen durante la ejecución del código y ayudar a detectar errores más temprano en el proceso de desarrollo. En este ejemplo, aunque sabemos que `edad` no será 48 porque ya está definida como 47, esta verificación podría ser parte de un escenario de prueba o una forma simple de asegurar que ciertos valores sean correctos antes de continuar con más código.

`003-ejemplo no tan traumatico.py`

```python
edad = 47

assert edad == 48, "no es correcto"
```

### combinacion
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código está utilizando una estructura llamada `assert` en Python, que se usa para verificar si una condición es verdadera. En este caso, la línea `assert edad == 48, "no es correcto"` intenta comprobar si la variable `edad`, que tiene el valor 47, es igual a 48. 

Si la afirmación (que en este caso es falsa porque 47 no es igual a 48) no se cumple, el programa genera un error y ejecuta lo que está dentro del bloque `except`. En este código, cuando la afirmación falla, simplemente imprime "Error determinado".

Es importante usar `assert` para ayudar en el proceso de desarrollo y depuración porque nos permite verificar rápidamente si ciertas condiciones son correctas durante la ejecución del programa. Sin embargo, hay que tener cuidado con cómo manejar los errores generados por las afirmaciones fallidas; aquí se captura cualquier error usando un bloque `except` genérico pero no es recomendable en producción ya que podría ocultar información valiosa sobre el problema real.

`004-combinacion.py`

```python
edad = 47
try:
  assert edad == 48, "no es correcto"
except:
  print("Error determinado")
```

### Actividades propuestas

### Actividad 1: Introducción a las Aserciones en Python

**Descripción:** 
Los estudiantes deben aprender cómo utilizar aserciones básicas para verificar condiciones de manera simple. Se les pedirá que añadan una serie de aserciones al código existente y observen el comportamiento del programa.

---

### Actividad 2: Creación Propia de Aserciones

**Descripción:** 
Los estudiantes deben crear un archivo Python con varias aserciones sobre diferentes tipos de datos, como números enteros, flotantes, cadenas y listas. Se les pedirá que intenten hacer fallar algunas aserciones.

---

### Actividad 3: Aserciones en Funciones

**Descripción:** 
Los estudiantes deben escribir una función simple que incluya al menos dos aserciones internamente. La función calculará un valor numérico y verificará si el resultado es correcto utilizando aserciones.

---

### Actividad 4: Manejo de Excepciones con Aserciones

**Descripción:** 
Basándose en ejemplos proporcionados, los estudiantes deben implementar una estructura `try-except` para capturar excepciones generadas por aserciones que fallan. Se espera que puedan documentar el error y continuar con la ejecución del programa.

---

### Actividad 5: Depuración de Código

**Descripción:** 
Los estudiantes recibirán un código con errores (como en el archivo "002-el chivato salta.py") y deberán encontrar, corregir y reemplazar las aserciones incorrectas por aquellas que funcionen correctamente.

---

### Actividad 6: Comparación de Aserciones

**Descripción:** 
Se les pedirá a los estudiantes que tomen un código donde se usan `if` para comprobar condiciones similares a aserciones y lo modifiquen para utilizar aserciones en su lugar. La actividad debe centrarse en entender la diferencia y el uso correcto de ambos.

---

### Actividad 7: Aserciones en Algoritmos Complejos

**Descripción:** 
Los estudiantes deben implementar un pequeño algoritmo matemático o lógico complejo que incluya varios pasos, cada uno verificado con aserciones para asegurar la correcta ejecución de las operaciones intermedias.

---

### Actividad 8: Documentación y Aserciones

**Descripción:** 
Los estudiantes deben escribir comentarios explicando por qué ciertas aserciones se han usado en el código. Se les pedirá que documenten cada línea de aserción para entender su propósito en el flujo del programa.

---

### Actividad 9: Pruebas Automáticas con Aserciones

**Descripción:** 
Basándose en un conjunto de datos proporcionados, los estudiantes deberán escribir pruebas automatizadas usando aserciones para verificar si diferentes condiciones se cumplen correctamente. El objetivo es asegurar la calidad del código a través de estas pruebas.

---

### Actividad 10: Integración de Aserciones con Funciones Existentes

**Descripción:** 
Los estudiantes deben seleccionar funciones existentes (proporcionadas o creadas por ellos mismos) y agregar aserciones al inicio y final de las funciones para verificar la entrada y salida. Esto ayudará a entender cómo integrar aserciones en el desarrollo habitual.

---

Estas actividades están diseñadas para proporcionar una base sólida en el uso y la implementación de aserciones en Python, asegurando que los estudiantes comprendan su importancia en la depuración y mantenimiento del código.


<a id="prueba-depuracion-y-documentacion-de-la-aplicacion"></a>
## Prueba, depuración y documentación de la aplicación

### Introducción a los ejercicios

Este conjunto de ejercicios está diseñado para ayudarte a comprender y practicar el uso correcto de estructuras de control en Python, así como la importancia de la prueba, depuración y documentación de aplicaciones. Los problemas que se trabajan van desde una función simple de división hasta un juego completo de tres en raya, pasando por la creación de funciones más robustas con manejo de errores y validación de tipos. A través de estos ejercicios, desarrollarás habilidades cruciales como identificar y corregir fallos en el código, mejorar la legibilidad del mismo mediante la adición de comentarios y documentación, y estructurar proyectos de manera efectiva importando y usando funciones desde diferentes módulos.

### funcion de division
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código define una función llamada `hazDivision` que toma dos parámetros: `dividendo` y `divisor`. La función calcula el resultado de la división entre estos dos valores y devuelve el resultado. Luego, se llama a esta función con los argumentos 4 y 3 para mostrar cómo funciona.

Después, en un bloque de código externo, hay un par de bucles anidados que iteran sobre una amplia gama de números (desde -100 hasta 99). En cada iteración del ciclo interno, la función `hazDivision` se invoca con los valores actuales de las variables `i` y `j`, lo que significa que se realizan miles de divisiones con diferentes combinaciones de números positivos y negativos. 

Finalmente, independientemente del resultado de todas estas operaciones, el código imprime "Todo ha ido correcto", aunque esto no es estrictamente cierto en casos donde `divisor` sea 0, ya que intentar dividir por cero provocaría un error en Python.

Es importante tener en cuenta que este código podría mejorar la gestión de errores para evitar que se produzcan excepciones no controladas (como la división por cero) y proporcionar una respuesta más precisa sobre el éxito o fracaso del proceso.

`001-funcion de division.py`

```python
def hazDivision(dividendo,divisor):
  resultado = dividendo/divisor
  return resultado
  
print(hazDivision(4,3))

for i in range(-100,100):
  for j in range(-100,100):
    hazDivision(i,j)

print("Todo ha ido correcto")
```

### mejora
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código define una función llamada `hazDivision` que toma dos parámetros: el dividendo y el divisor. La función intenta realizar la división del dividendo entre el divisor, pero antes verifica si el divisor es distinto de cero para evitar un error que se produce cuando se divide por cero.

Después de definir la función, el código llama a `hazDivision(4,3)` y muestra en pantalla el resultado de esta operación. Luego, utiliza dos bucles anidados (`for`) para recorrer una amplia gama de números (del -100 al 99) como posibles valores para dividendo e índice, llamando a la función `hazDivision` con cada combinación posible de estos valores.

Finalmente, si todos los cálculos se han realizado sin problemas, el programa imprime "Todo ha ido correcto". Esta parte del código es importante porque ayuda a verificar que la función `hazDivision` maneja correctamente todas las posibles entradas, incluyendo casos en los que el divisor podría ser cero o incluso negativo.

`002-mejora.py`

```python
def hazDivision(dividendo,divisor):
  if divisor != 0:
    resultado = dividendo/divisor
  else:
    resultado = 0
  return resultado
  
print(hazDivision(4,3))

for i in range(-100,100):
  for j in range(-100,100):
    hazDivision(i,j)

print("Todo ha ido correcto")
```

### nuevo fallo
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código define una función llamada `hazDivision` que toma dos parámetros: `dividendo` y `divisor`. La función se encarga de realizar la división entre estos dos valores, pero antes verifica si el divisor es diferente de cero para evitar un error matemático. Si el divisor no es cero, la función calcula el resultado de dividir el dividendo por el divisor. En caso contrario, establece el resultado en 0, lo cual no es técnicamente correcto porque una división entre cero no está definida y debería generar un error o advertencia.

La línea final del código llama a esta función pasando los argumentos `4` y `a`. Aquí surge un problema potencial: si la variable `a` no ha sido previamente inicializada en el programa, esto generará una excepción porque Python no reconoce `a` como un valor válido. Es importante asegurarse de que todas las variables utilizadas en funciones estén correctamente definidas antes de su uso para evitar errores.

Este código también ilustra la importancia de manejar adecuadamente los casos especiales y de error en tus programas, así como el peligro de asignar un valor arbitrario (como 0) cuando se debe controlar una condición que normalmente causa problemas.

`003-nuevo fallo.py`

```python
def hazDivision(dividendo,divisor):
  if divisor != 0:
    resultado = dividendo/divisor
  else:
    resultado = 0
  return resultado
  
print(hazDivision(4,a))
```

### nuevo fallo mas
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código define una función llamada `hazDivision` que toma dos parámetros: `dividendo` y `divisor`. La función tiene el objetivo de realizar la división entre estos dos valores, pero antes de hacerlo, verifica si los dos valores son números (ya sean enteros, flotantes o complejos) para asegurarse de que se puedan dividir. Si alguno de los parámetros no es un número, la función devuelve 0.

Además, la función también incluye una verificación adicional para comprobar si el divisor es igual a cero. Si esto ocurre, la división no puede realizarse (ya que matemáticamente dividir entre cero está prohibido) y por lo tanto, la función también devuelve 0 en este caso.

Finalmente, el código llama a esta función con los argumentos `4` y `"a"`, lo cual es inadecuado porque uno de ellos no es un número (la cadena "a"). Como resultado, la función devolverá 0, mostrando cómo la función maneja situaciones en las que se proporcionan parámetros incorrectos o inapropiados.

`004-nuevo fallo mas.py`

```python
def hazDivision(dividendo,divisor):
  # Comprobamos si son números
  if isinstance(dividendo, (int, float, complex)) and isinstance(divisor, (int, float, complex)):
    # Comprobamos que el divisor no es cero
    if divisor != 0:
      resultado = dividendo/divisor
    else:
      resultado = 0
    return resultado
  else:
    return 0
  
print(hazDivision(4,"a"))
```

### cadenas
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código define una función llamada `hazDivision` que toma dos parámetros: `dividendo` y `divisor`. La función tiene como objetivo realizar la división entre estos dos números, pero antes de hacerlo, realiza algunas comprobaciones importantes para asegurar que el cálculo sea correcto.

Primero, verifica si tanto `dividendo` como `divisor` son de tipo numérico (puede ser entero, flotante o complejo). Si alguno de los dos no es un número, la función retorna directamente 0. En segundo lugar, si ambos parámetros son números válidos, verifica que el divisor no sea cero para evitar una división por cero, lo cual sería matemáticamente incorrecto e impracticable en programación.

Si todas estas condiciones se cumplen, la función realiza la operación de división y devuelve el resultado. En caso contrario, o si el divisor es cero, la función devuelve 0.

El último renglón del código llama a esta función pasándole como argumentos el número 4 y una cadena "3", lo que resultará en un retorno de valor 0 porque "3" no se considera un tipo numérico válido para realizar operaciones matemáticas. Esto demuestra la importancia de validar los tipos de datos antes de realizar cálculos.

`005-cadenas.py`

```python
def hazDivision(dividendo,divisor):
  # Comprobamos si son números
  if isinstance(dividendo, (int, float, complex)) and isinstance(divisor, (int, float, complex)):
    # Comprobamos que el divisor no es cero
    if divisor != 0:
      resultado = dividendo/divisor
    else:
      resultado = 0
    return resultado
  else:
    return 0
  
print(hazDivision(4,"3"))
```

### mejoro cadenas
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código define una función llamada `hazDivision` que toma dos parámetros: `dividendo` y `divisor`. La función está diseñada para realizar la operación de división entre estos dos valores, pero antes de hacerlo, realiza varias comprobaciones importantes. 

Primero, verifica si tanto el dividendo como el divisor son números (ya sean enteros, flotantes o incluso números complejos). Si no lo son, intenta convertirlos a un tipo numérico compatible utilizando la función `float()`. Si esta conversión falla, la función devuelve 0 para evitar errores.

Además, la función asegura que el divisor no sea cero antes de realizar la división, ya que dividir por cero es matemáticamente indefinido y generaría un error en Python. En caso de que el divisor sea cero, también se retorna 0 como resultado para evitar problemas.

Esta función ayuda a manejar situaciones donde los datos pueden no ser perfectos o estar mal formateados, proporcionando una salida segura y coherente.

`006-mejoro cadenas.py`

```python
def hazDivision(dividendo,divisor):
  # Comprobamos si son números
  if isinstance(dividendo, (int, float, complex)) and isinstance(divisor, (int, float, complex)):
    # Comprobamos que el divisor no es cero
    if divisor != 0:
      resultado = dividendo/divisor
      return resultado
    else:
      resultado = 0
  else:
    try:
      # Vamos a intentar convertirlo a numeros
      dividendo = float(dividendo)
      divisor = float(divisor)
      resultado = dividendo/divisor
      return resultado
    except:
      return 0
  
print(hazDivision(4,"3"))
```

### depuracion
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código define una función en Python llamada `hazDivision` que toma dos parámetros: `dividendo` y `divisor`. La función tiene como objetivo realizar la división entre estos dos números. Primero, verifica si ambos parámetros son del tipo numérico (int, float o complex) para asegurarse de que sean válidos para una operación matemática. Si uno o ambos no son numéricos, intenta convertirlos a un número flotante usando la función `float()`. La función maneja el caso en que el divisor es cero, lo cual no está permitido en matemáticas, devolviendo 0 como resultado para indicar este error. Además, utiliza bloques de excepción (`try` y `except`) para atrapar cualquier error durante la conversión a número numérico, proporcionando un valor de retorno predeterminado de 0 si falla la conversión.

El código finalmente llama a esta función pasándole el dividendo como el número 4 y el divisor como la cadena "3", lo que resultará en una conversión de la cadena a un número antes de realizar la operación matemática. Esta práctica es útil para prevenir errores en aplicaciones reales, donde los datos pueden ser proporcionados en formatos no esperados o incorrectos.

`007-depuracion.py`

```python
def hazDivision(dividendo,divisor):
  # Comprobamos si son números
  print("Entramos en la funcion")
  if isinstance(dividendo, (int, float, complex)) and isinstance(divisor, (int, float, complex)):
    print("parece que los parametros son numeros")
    # Comprobamos que el divisor no es cero
    if divisor != 0:
      print("parece que los puedo dividir")
      resultado = dividendo/divisor
      return resultado
    else:
      print("No puedo dividir porque el divisor es cero")
      resultado = 0
  else:
    print("Los parametros no son numeros, pero voy a intentar convertirlos")
    try:
      print("Intento convertir a numeros con exito")
      # Vamos a intentar convertirlo a numeros
      dividendo = float(dividendo)
      divisor = float(divisor)
      resultado = dividendo/divisor
      return resultado
    except:
      print("He intentado convertir a numeros, pero no he podido")
      return 0
  
print(hazDivision(4,"3"))
```

### documentacion de la funcion
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código define una función llamada `hazDivision` que toma dos parámetros: `dividendo` y `divisor`. La función tiene como objetivo realizar la división entre estos dos valores, pero antes de hacerlo, realiza varias comprobaciones para asegurarse de que los datos proporcionados son válidos y evitar errores en el código.

Primero, verifica si ambos parámetros (`dividendo` y `divisor`) son números (de tipo entero, flotante o complejo). Si uno de ellos no es un número, intenta convertirlos a números utilizando una operación que puede lanzar excepciones si la conversión falla. Esto es importante porque evitará errores en tiempo de ejecución cuando se tratan con datos que podrían ser incorrectos.

Después de asegurarse de que los parámetros son válidos, la función verifica si el `divisor` no es cero para evitar una división por cero, lo cual generaría un error. Si todo está en orden, realiza la operación de división y devuelve el resultado. En caso contrario, imprime un mensaje indicativo del problema y retorna 0 como resultado de la función.

Esta función es crucial porque maneja correctamente los errores potenciales que pueden surgir al realizar una operación matemática compleja como la división, asegurando así que el programa pueda seguir funcionando sin interrupciones debido a un error.

`008-documentacion de la funcion.py`

```python
def hazDivision(dividendo,divisor):
  '''
    Función de división
    Entradas: dividendo y divisor que se espera que sean numéricos
    Salidas: resultado de la división como número (o cero si hay fallo)
    Capturas de error: 
      1.-Si es numérico
      2.-Si se puede convertir a número
      3.-Si no es división entre cero
  '''
  # Comprobamos si son números
  print("Entramos en la funcion")
  if isinstance(dividendo, (int, float, complex)) and isinstance(divisor, (int, float, complex)):
    print("parece que los parametros son numeros")
    # Comprobamos que el divisor no es cero
    if divisor != 0:
      print("parece que los puedo dividir")
      resultado = dividendo/divisor
      return resultado
    else:
      print("No puedo dividir porque el divisor es cero")
      resultado = 0
  else:
    print("Los parametros no son numeros, pero voy a intentar convertirlos")
    try:
      print("Intento convertir a numeros con exito")
      # Vamos a intentar convertirlo a numeros
      dividendo = float(dividendo)
      divisor = float(divisor)
      resultado = dividendo/divisor
      return resultado
    except:
      print("He intentado convertir a numeros, pero no he podido")
      return 0
  
print(hazDivision(4,"3"))
```

### extraccion de funcion
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es bastante sencillo y se compone de dos líneas. En la primera línea, el programa importa una función llamada `hazDivision` desde un archivo denominado `funciondivision.py`. Esta función probablemente realiza operaciones relacionadas con la división de números.

En la segunda línea, se llama a la función `hazDivision`, pasándole dos argumentos: el número 4 y la cadena de texto "3". La función intentará realizar alguna acción o cálculo utilizando estos valores. Dado que uno de los argumentos es un número (4) y el otro es una cadena de texto ("3"), esto podría causar un error en tiempo de ejecución si la función `hazDivision` no está preparada para manejar este tipo de entrada mixta.

Es importante entender cómo funciona la función `hazDivision` y asegurarse de que pueda manejar correctamente diferentes tipos de entradas, incluyendo combinaciones de números y cadenas de texto. Esto ayuda a prevenir errores en el programa.

`009-extraccion de funcion.py`

```python
from funciondivision import hazDivision
  
print(hazDivision(4,"3"))
```

### ejercicio propuesto
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

El fragmento de código proporcionado describe la implementación de una función llamada `raizSegura(numero)` en Python. Esta función tiene como objetivo calcular la raíz cuadrada segura del número que se le pasa, lo que significa que maneja errores y casos especiales de manera eficiente.

La función `raizSegura` comienza verificando si el parámetro recibido es un valor numérico (ya sea entero o flotante) y si ese valor es mayor o igual a cero. Si cumple con estas condiciones, la función calcula y devuelve su raíz cuadrada utilizando la librería `math`. Si no se puede convertir el parámetro en un número debido a que es una cadena inconvertible, o si el número es negativo, la función devuelve simplemente 0. Para manejar estos casos de manera adecuada, se utiliza una estructura try/except para capturar y tratar los errores que puedan surgir durante la conversión del tipo de dato o en el cálculo.

Además, la implementación incluye aserciones internas que garantizan que la salida siempre sea un número (ya sea entero o flotante) y que si la entrada es negativa, la salida debe ser exactamente 0. Esto ayuda a asegurar la integridad de los datos y prevenir errores en el programa.

Por último, se pide escribir documentación detallada para la función usando docstrings, lo cual explica claramente qué hace la función, cuáles son sus entradas y salidas, y cómo maneja los posibles errores. También se solicita crear un archivo `main.py` que importe y pruebe esta función con ejemplos específicos, así como un archivo `test_raiz.py` para realizar pruebas unitarias adicionales cubriendo diferentes casos de uso.

`010-ejercicio propuesto.py`

```python
Enunciado: Raíz cuadrada segura

Implementa una función raizSegura(numero) que cumpla:

Validación y manejo de errores

Si numero es un valor numérico (int o float) y es mayor o igual a 0 → devuelve su raíz cuadrada.

Si numero es una cadena, intenta convertirla a float y aplica la regla anterior.

Si la conversión falla, o si el número es negativo, la función debe devolver 0.

Usa try/except para capturar errores en la conversión o en el cálculo.

Aserciones

Usa al menos dos assert internos, por ejemplo:

que la salida siempre sea un número (int o float),

que si la entrada es negativa, la salida sea exactamente 0.

Documentación

Escribe un docstring que explique entradas, salidas y qué errores controla.

Estructura del proyecto

Guarda la función en funcionraiz.py.

Crea un archivo main.py que importe la función y realice 3 pruebas de ejemplo mostrando los resultados por pantalla.

Prueba unitaria pequeña

Crea un archivo test_raiz.py que contenga varios assert para verificar:

Caso correcto con número positivo.

Caso con cadena convertible.

Caso con número negativo.

Caso con cadena no convertible.

Caso con 0.
```

### tres en raya
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es una implementación básica del juego Tres en Raya (también conocido como Tic-Tac-Toe) para dos jugadores humanos. El programa inicia mostrando un tablero vacío con números que representan las casillas disponibles y luego entra en un bucle infinito (`while True`) donde se solicita repetidamente a los jugadores que hagan sus movimientos.

En cada iteración del bucle, el código imprime el estado actual del tablero usando variables `casilla1` hasta `casilla9`, las cuales contienen números o 'X'/'O' dependiendo de qué jugador ha hecho su movimiento en esa casilla. Luego, se pide al jugador actual que introduzca la casilla donde quiere hacer su jugada.

Si el número ingresado por el usuario corresponde a una casilla del tablero y es válida (no está ocupada), el programa cambia el valor de la variable correspondiente a 'X' o 'O', dependiendo del jugador actual. Después, se invierte el turno entre los dos jugadores.

Este código forma parte del aprendizaje sobre cómo gestionar turnos en juegos simples y cómo actualizar y mostrar gráficamente el estado de juego en una interfaz textual básica. Es importante notar que esta implementación no incluye ninguna lógica para determinar si un jugador ha ganado o si el tablero está lleno, lo cual sería un paso adicional importante para completar el juego.

`011-tres en raya.py`

```python
print("Tres en raya - 2 jugadores humanos")
print("(c) 2025 Jose Vicente Carratala")

jugador = 1
casilla1 = 1
casilla2 = 2
casilla3 = 3
casilla4 = 4
casilla5 = 5
casilla6 = 6
casilla7 = 7
casilla8 = 8
casilla9 = 9

while True:
  print(f'{casilla1}|{casilla2}|{casilla3}')
  print(f'------')
  print(f'{casilla4}|{casilla5}|{casilla6}')
  print(f'------')
  print(f'{casilla7}|{casilla8}|{casilla9}')
  tirada = input("Tirada del jugador "+str(jugador))
  if int(tirada) == 1:
    if jugador == 1:
      casilla1 = "X"
    else:
      casilla1 = "O"
  if int(tirada) == 2:
    if jugador == 1:
      casilla2 = "X"
    else:
      casilla2 = "O"
  if int(tirada) == 3:
    if jugador == 1:
      casilla3 = "X"
    else:
      casilla3 = "O"
  if int(tirada) == 4:
    if jugador == 1:
      casilla4 = "X"
    else:
      casilla4 = "O"
  if int(tirada) == 5:
    if jugador == 1:
      casilla5 = "X"
    else:
      casilla5 = "O"
  if int(tirada) == 6:
    if jugador == 1:
      casilla6 = "X"
    else:
      casilla6 = "O"
  if int(tirada) == 7:
    if jugador == 1:
      casilla7 = "X"
    else:
      casilla7 = "O"
  if int(tirada) == 8:
    if jugador == 1:
      casilla8 = "X"
    else:
      casilla8 = "O"
  if int(tirada) == 9:
    if jugador == 1:
      casilla9 = "X"
    else:
      casilla9 = "O"
  if jugador == 1:
    jugador = 2
  else:
    jugador = 1
  
```

### funciondivision
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código define una función llamada `hazDivision` que realiza la operación matemática de división entre dos números. La función toma dos parámetros: `dividendo` y `divisor`. Primero, verifica si ambos argumentos son numéricos (de tipo entero, flotante o complejo). Si no lo son, intenta convertirlos a un número de punto flotante. En caso de éxito en la conversión, realiza la división y devuelve el resultado.

Si alguno de los parámetros no puede ser convertido a un número o si el divisor es cero (lo cual no permitiría realizar la operación de división), la función maneja estos errores imprimiendo mensajes informativos y devolviendo `0` como resultado. Este enfoque ayuda a evitar que el programa se detenga debido a errores inesperados y proporciona una respuesta segura y manejable para los casos en los que no es posible realizar la división.

Este tipo de tratamiento de excepciones es importante porque permite al programa continuar funcionando incluso cuando los datos de entrada son incorrectos o imprevistos, mejorando así su robustez y fiabilidad.

`funciondivision.py`

```python
def hazDivision(dividendo,divisor):
  '''
    Función de división
    Entradas: dividendo y divisor que se espera que sean numéricos
    Salidas: resultado de la división como número (o cero si hay fallo)
    Capturas de error: 
      1.-Si es numérico
      2.-Si se puede convertir a número
      3.-Si no es división entre cero
  '''
  # Comprobamos si son números
  print("Entramos en la funcion")
  if isinstance(dividendo, (int, float, complex)) and isinstance(divisor, (int, float, complex)):
    print("parece que los parametros son numeros")
    # Comprobamos que el divisor no es cero
    if divisor != 0:
      print("parece que los puedo dividir")
      resultado = dividendo/divisor
      return resultado
    else:
      print("No puedo dividir porque el divisor es cero")
      resultado = 0
  else:
    print("Los parametros no son numeros, pero voy a intentar convertirlos")
    try:
      print("Intento convertir a numeros con exito")
      # Vamos a intentar convertirlo a numeros
      dividendo = float(dividendo)
      divisor = float(divisor)
      resultado = dividendo/divisor
      return resultado
    except:
      print("He intentado convertir a numeros, pero no he podido")
      return 0
```

### Actividades propuestas

### Actividad 1: Mejora la Función de División
**Descripción:** 
Modifica la función `hazDivision` para que maneje correctamente los casos en que se proporcionan parámetros incorrectos (por ejemplo, cadenas no numéricas). Asegúrate de que el código maneja adecuadamente las divisiones entre cero y devuelva un mensaje significativo cuando esto ocurra.

### Actividad 2: Depuración de Código
**Descripción:** 
Identifica los errores en la función `hazDivision` cuando se pasan parámetros incorrectos. Utiliza técnicas de depuración para encontrar y corregir estos errores, luego prueba tu código con diferentes entradas.

### Actividad 3: Documentar una Función
**Descripción:** 
Añade un docstring a la función `hazDivision` que explique claramente las entradas esperadas, los posibles casos de error y el resultado devuelto. La documentación debe ser precisa y útil para otros programadores.

### Actividad 4: Prueba Unitaria
**Descripción:** 
Escribe pruebas unitarias para la función `hazDivision` utilizando el marco de pruebas PyTest o cualquier otro framework que prefieras. Asegúrate de cubrir diferentes casos, como divisiones válidas, divisiones entre cero y entradas no numéricas.

### Actividad 5: Extracción de Funciones
**Descripción:** 
Separa la función `hazDivision` en un archivo externo llamado `funciondivision.py`. Luego, importa esta función desde otro script principal y prueba su funcionamiento. Asegúrate que el módulo se puede utilizar como una biblioteca.

### Actividad 6: Implementación de Raíz Cuadrada Segura
**Descripción:** 
Implementa la función `raizSegura` según las especificaciones proporcionadas en el archivo `010-ejercicio propuesto.py`. Asegúrate de incluir validación, manejo de errores y documentación adecuada.

### Actividad 7: Juego del Tres en Raya
**Descripción:** 
Completa la implementación del juego del tres en raya para dos jugadores. Mejora el código actualizando las variables de estado para que sean más fáciles de gestionar, como matrices o listas. Asegúrate de manejar bien las entradas del usuario.

### Actividad 8: Mejorando la Interactividad
**Descripción:** 
Añade funcionalidades al juego del tres en raya (archivo `011-tres en raya.py`) para mejorar su interactividad. Esto podría incluir una mejor presentación de los mensajes y notificaciones para el usuario, así como verificar que las entradas son válidas antes de actualizarlas.

### Actividad 9: Refactorización del Código
**Descripción:** 
Refactoriza la función `hazDivision` para mejorar su claridad y eficiencia. Esto podría implicar simplificar los bloques condicionales, usar funciones auxiliares donde sea apropiado o cualquier otra mejora que puedas pensar.

### Actividad 10: Integración de Funciones
**Descripción:** 
Integra la función `hazDivision` y la función `raizSegura` en un solo archivo principal. Diseña una interfaz simple para permitir al usuario seleccionar qué operación matemática desea realizar. Asegúrate de que tu código maneje correctamente las excepciones y proporcione feedback útil al usuario.

Estas actividades se basan directamente en los ejercicios proporcionados, adaptándolos a un nivel apropiado para estudiantes de Formación Profesional, con énfasis en la práctica técnica, depuración, documentación e integración de código.


<a id="ejercicio"></a>
## Ejercicio

### Introducción a los ejercicios

Esta carpeta contiene un conjunto de ejercicios diseñados para practicar el uso de estructuras de control en Python, como bucles y condicionales. Los problemas abordan situaciones prácticas que implican la interacción con el usuario (entrada), procesamiento de datos (cálculos, clasificaciones) y manejo de errores (try-except). Entre los ejercicios se encuentran simulaciones como contar días en un mes, subir escalones, entrenar dragones y duelos mágicos, que permiten a los estudiantes aplicar sus conocimientos sobre flujo de control y estructuras de datos. Estos ejercicios ayudan a desarrollar competencias esenciales como la lógica programática, la gestión de errores y el manejo eficiente de entradas y salidas en programas simples.

### ejercicio for
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código en Python utiliza una estructura de control llamada `for` para imprimir un mensaje diario del 1 al 30. En cada iteración del bucle, se imprime la frase "Hoy es el día [número] del mes", donde `[número]` es reemplazado por el número actual del día que va desde 1 hasta 30.

Además, dentro de este bucle `for`, hay una condición `if` que verifica si el valor de la variable `dia` es igual a 15. Si esto se cumple, el programa imprime un mensaje adicional: "🎉 Hoy es el cumpleaños de mi amigo". Esto significa que solo cuando el día sea 15, aparecerá este anuncio especial.

Esta estructura de código es útil para realizar tareas repetitivas y añadir comportamientos específicos en momentos determinados, como celebrar un evento único dentro de una secuencia regular de eventos.

`001-ejercicio for.py`

```python
for dia in range(1,31):
  print("Hoy es el dia",dia,"del mes")
  if dia == 15:
    print("🎉 Hoy es el cumpleaños de mi amigo")
    
```

### ejercicio escalones
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código es un ejemplo sencillo de cómo usar un bucle `while` en Python para realizar una tarea repetitiva. El programa comienza estableciendo la variable `escalon` a 1, lo que representa el primer peldaño de una serie imaginaria de escalones. Luego, entra en un ciclo `while` que se ejecuta mientras `escalon` sea menor que 16.

Dentro del bucle, el programa imprime en la consola "Estoy en el escalon" seguido del número actual de la variable `escalon`. Después de imprimir esta información, incrementa el valor de `escalon` en 1. Este proceso se repite hasta que `escalon` llega a ser 16, momento en el cual la condición del bucle ya no es verdadera y termina la ejecución.

Este tipo de estructura es útil para realizar acciones que deben repetirse un número especificado de veces o mientras ciertas condiciones se mantengan. En este caso específico, el programa simula subir una serie de 15 escalones, imprimiendo el número del peldaño en cada paso.

`002-ejercicio escalones.py`

```python
escalon = 1

while escalon < 16:
  print("Estoy en el escalon",escalon)
  escalon += 1
```

### subir escalones de dos en dos
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código está escrito en Python y muestra cómo utilizar un bucle `while` para imprimir una secuencia numérica. El objetivo es subir los escalones de dos en dos hasta llegar al décimo quinto escalón.

El programa comienza estableciendo la variable `escalon` a 1, lo que indica que empezamos desde el primer escalón. Luego entra en un bucle `while`, que se ejecutará mientras la variable `escalon` sea menor que 16. Dentro del bucle, primero imprimimos una frase indicando en qué escalón nos encontramos (por ejemplo, "Estoy en el escalon 1", "Estoy en el escalon 3", etc.). Después de imprimir esta información, aumentamos la variable `escalon` en 2 con la operación `escalon += 2`. Esto asegura que salimos del bucle una vez que llegamos al décimo quinto escalón (número 15).

Este tipo de código es útil para entender cómo funcionan los bucles y cómo podemos controlar el flujo de ejecución del programa a través de las condiciones en un bucle `while`.

`003-subir escalones de dos en dos.py`

```python
escalon = 1

while escalon < 16:
  print("Estoy en el escalon",escalon)
  escalon += 2
```

### dragones
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código Python es un programa simple que permite a los usuarios ingresar detalles sobre dos dragones, como sus nombres y edades. Luego, clasifica a estos dragones en categorías basadas en su edad (joven, adulto o anciano) y finalmente, entrena a los dragones por tres días, mejorando sus habilidades de fuerza y resistencia.

Primero, el programa solicita al usuario que introduzca el nombre y la edad para cada uno de dos dragones. Las edades se intentan convertir a números enteros usando un bloque `try-except`. Si no es posible hacer esta conversión (por ejemplo, si el usuario ingresa una cadena de texto en lugar de un número), la edad se establece automáticamente en 100 años.

Luego, basándose en las edades numéricas convertidas, el programa clasifica cada dragón según su categoría. Esta clasificación depende del rango de edad: dragones menores a 50 años son considerados jóvenes, aquellos entre 50 y 199 años son adultos, y los que tienen 200 o más años son ancianos.

Finalmente, el programa simula un entrenamiento para ambos dragones durante tres días. La cantidad de mejora en fuerza y resistencia depende del estado de clasificación (joven, adulto o anciano) del dragón. Los dragones jóvenes mejoran más rápidamente que los adultos y ancianos en términos de fuerza y resistencia.

Este código es una introducción a cómo manejar entradas del usuario, conversiones de tipos de datos, estructuras condicionales (`if-elif-else`) y bucles (`for`), conceptos clave para programadores principiantes.

`004-dragones.py`

```python
# En este bloque tomo los datos del usuario #######################

nombre_dragon_a = input("Dime el nombre del dragón A: ")
edad_dragon_a = input("Dime la edad del dragón A: ")
clasificacion_dragon_a = ""
fuerza_dragon_a = 0
resistencia_dragon_a = 0

print("El nombre del dragon A es:",nombre_dragon_a)
print("La edad del dragon A es:",edad_dragon_a)

nombre_dragon_b = input("Dime el nombre del dragón B: ")
edad_dragon_b = input("Dime la edad del dragón B: ")
clasificacion_dragon_b = ""
fuerza_dragon_b = 0
resistencia_dragon_b = 0

print("El nombre del dragon A es:",nombre_dragon_b)
print("La edad del dragon A es:",edad_dragon_b)

# En este bloque me aseguro de que son enteros #######################

try:
  edad_dragon_a = int(edad_dragon_a)
  print("He convertido la edad A correctamente")
except:
  edad_dragon_a = 100
  print("No he convertido la edad A correctamente, asigno 100")
  
try:
  edad_dragon_b = int(edad_dragon_b)
  print("He convertido la edad B correctamente")
except:
  edad_dragon_b = 100
  print("No he convertido la edad B correctamente, asigno 100")

# En este bloque clasifico a los dragones #######################

if edad_dragon_a < 50:
  clasificacion_dragon_a = "Joven"
elif edad_dragon_a >= 50 and edad_dragon_a <= 199:
  clasificacion_dragon_a = "Adulto"
elif edad_dragon_a >= 200:
  clasificacion_dragon_a = "Anciano"
print("El dragon A es:",clasificacion_dragon_a)
  
if edad_dragon_b < 50:
  clasificacion_dragon_b = "Joven"
elif edad_dragon_b >= 50 and edad_dragon_b <= 199:
  clasificacion_dragon_b = "Adulto"
elif edad_dragon_b >= 200:
  clasificacion_dragon_b = "Anciano"
print("El dragon B es:",clasificacion_dragon_b)

# Ahora los vamos a entrenar ###################################

for dia in range (1,4):
  # Como entrenar a tu dragon A
  if clasificacion_dragon_a == "Joven":
    fuerza_dragon_a += 2
    resistencia_dragon_a += 2
  elif clasificacion_dragon_a == "Adulto":
    fuerza_dragon_a += 1
    resistencia_dragon_a += 1
  elif clasificacion_dragon_a == "Anciano":
    fuerza_dragon_a += 1
    resistencia_dragon_a += 1
  print("Final del dia",dia)
  print("El dragon A ahora tiene ",fuerza_dragon_a,"de fuerza y ",resistencia_dragon_a,"de resistencia")
  # Como entrenar a tu dragon B
  if clasificacion_dragon_b == "Joven":
    fuerza_dragon_b += 2
    resistencia_dragon_b += 2
  elif clasificacion_dragon_b == "Adulto":
    fuerza_dragon_b += 1
    resistencia_dragon_b += 1
  elif clasificacion_dragon_b == "Anciano":
    fuerza_dragon_b += 1
    resistencia_dragon_b += 1
  print("Final del dia",dia)
  print("El dragon B ahora tiene ",fuerza_dragon_b,"de fuerza y ",resistencia_dragon_b,"de resistencia")
```

### magos
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

El código en este archivo `005-magos.py` simula un duelo entre un mago y un escudo mágico con puntos de energía. El programa comienza pidiendo la edad del mago y validando que sea un número entero, asignándole 100 años si no se puede convertir correctamente. A continuación, clasifica al mago en tres categorías basadas en su edad: "Aprendiz" para menores de 30 años, "Hechicero" entre 30 y 99, y "Archimago" a partir de los 100 años.

El programa define una función llamada `poderBase` que devuelve un valor entero según la categoría del mago: 5 para Aprendiz, 8 para Hechicero y 10 para Archimago. Este valor se utiliza para calcular el daño en dos turnos de duelo: el primer turno es con un "Hechizo de Fuego" que causa `poderBase // 2` puntos de daño al escudo, mientras que en el segundo turno es un "Hechizo de Rayo" con `poderBase // 3` puntos de daño.

El código verifica después cada valor del daño y la energía restante del escudo para asegurar que son numéricos y no negativos usando aserciones. Finalmente, muestra los resultados del duelo, indicando si el mago rompió el escudo o este resistió al duelo relámpago.

Este tipo de ejercicio ayuda a entender cómo combinar estructuras de control como bucles, condicionales, y funciones para crear un programa lógico que simula una situación compleja.

`005-magos.py`

```python
Descripción

Crea un programa por consola que simule un duelo relámpago entre un mago y un hechizo protector.

Entrada con validación

Pide la edad del mago. Convierte a int con try/except.

Si falla, usa edad 100 por defecto.

Clasificación y poder base (selección + función)

Clasifica al mago según su edad:

<30 → Aprendiz

30–99 → Hechicero

≥100 → Archimago

Implementa poderBase(edad) -> int que devuelva:

Aprendiz → 5

Hechicero → 8

Archimago → 10

(documenta la función con un docstring).

Rompimiento del hechizo (bucle + selección)

El escudo mágico empieza con 15 puntos de energía.

Recorre dos turnos con un for de 1 a 2:

Turno 1 → “Hechizo de Fuego” → daño = poderBase // 2

Turno 2 → “Hechizo de Rayo” → daño = poderBase // 3

Resta el daño al escudo.

Si la energía del escudo baja de 0, ajústala a 0 y sal del bucle.

Aserciones mínimas

Tras calcular cada daño: assert que el daño es numérico y ≥ 0.

Tras ajustar la energía: assert que la energía es ≥ 0.

Salida

Muestra: edad, rango del mago, poder base, energía final del escudo y resultado:

Si la energía es 0 → “¡El mago rompe el escudo mágico!”

Si no → “El escudo resiste al duelo relámpago.”


# pedir edad
edad_mago = input("Introduce la edad del mago: ")
# convertir a entero
try:
  edad_mago = int(edad_mago)
except: 
  # si falla, pon 100
  edad_mago = 100

# clasifica por edad
# menor que 30 es Aprendiz
# de 30 a 99 es Hechicero
# mas de 100 es Archimago

# funcion poderBase, recibe edad, devuelve entero
# si es aprendiz, devuelve 5
# si es hechicero, devuelve 8
# si es archimago, devuelve 10

# empezamos bucle
# escudo empieza con 15 puntos
# recorre dos turnos con for
# turno 1 fuego daño = poderBase // 2
# turno 2 hechizo rayo = daño = poderBase // 3
# resta el daño al escudo
# si energia escudo baja de cero, ajusta a cero

# tras cada daño, print de daño y mayor que cero
# tras ajuste energia, print y energia es mayor que cero

# salida: edad, rango, poder base, energia del escudo
# energia es cero, mago rompe escudo
# energia mayor que cero, escudo resiste duelo
```

### Actividades propuestas

### Actividad 1: Conteo de Días del Mes
**Descripción:**  
Los estudiantes deben escribir un programa similar al ejercicio `001-ejercicio for.py` para contar los días del mes. El objetivo es que comprendan y utilicen correctamente el bucle `for` en Python.

### Actividad 2: Escalones Incrementales
**Descripción:**  
Los alumnos deberán crear un código similar a `002-ejercicio escalones.py`, pero deben adaptarlo para mostrar los números del 1 al 15 usando un bucle `while`. Esta actividad reforzará su comprensión de la estructura `while`.

### Actividad 3: Subir Escalones Saltando
**Descripción:**  
Se les pedirá a los estudiantes que tomen el ejercicio `003-subir escalones de dos en dos.py` como base para crear un programa que recorra desde el primer peldaño hasta el décimo quinto, saltando dos escalones cada vez. Esto ayudará a consolidar su conocimiento sobre la estructura `while`.

### Actividad 4: Clasificación de Dragones
**Descripción:**  
A partir del código en `004-dragones.py`, los estudiantes tendrán que clasificar dragones basándose en su edad y luego calcular sus atributos. Esta actividad profundizará el uso de condicionales complejos y manejo de errores.

### Actividad 5: Simulación de Entrenamiento de Dragones
**Descripción:**  
Usando `004-dragones.py` como punto de partida, los estudiantes deberán desarrollar una simulación que realice un entrenamiento para los dragones durante varios días. El objetivo es familiarizarse con bucles anidados y condiciones complejas.

### Actividad 6: Registro de Magos
**Descripción:**  
Basándose en `005-magos.py`, los estudiantes deben crear un programa que clasifique a un mago según su edad y determine su poder base. Esto reforzará sus habilidades con la lógica condicional y manejo de excepciones.

### Actividad 7: Duelos Mágicos
**Descripción:**  
Se les pedirá a los estudiantes que completen el código en `005-magos.py` para simular un duelo entre un mago y su hechizo protector. La actividad incluirá la implementación de métodos como `poderBase()` y la simulación de turnos de ataque, consolidando así su entendimiento del manejo de errores y lógica condicional.

### Actividad 8: Análisis de Errores en Simulaciones
**Descripción:**  
Los estudiantes deberán revisar los ejercicios `004-dragones.py` y `005-magos.py`, identificar posibles puntos donde podrían ocurrir errores (como entradas no numéricas) e implementar soluciones utilizando `try/except`. Esta actividad ayudará a reforzar el manejo de excepciones en Python.

### Actividad 9: Mejora del Registro de Dragones
**Descripción:**  
Los alumnos deben tomar el ejercicio `004-dragones.py` y mejorar la funcionalidad añadiendo un método que calcule automáticamente la salud inicial basada en la edad del dragón. Esto reforzará su habilidad para implementar funciones y métodos.

### Actividad 10: Implementación de Bucle While en Duelos
**Descripción:**  
A partir del ejercicio `005-magos.py`, los estudiantes deben modificar el código para simular un duelo utilizando un bucle `while` en lugar de un `for`. Esto permitirá que los duelos se realicen hasta que una condición específica sea satisfecha, reforzando la estructura del bucle `while` y las condiciones de parada.


<a id="ejercicio-de-final-de-unidad-2"></a>
## Ejercicio de final de unidad

### Introducción a los ejercicios

Este conjunto de ejercicios en Python está diseñado para ayudarte a familiarizarte con los conceptos básicos de programación, como impresión de texto, manejo de variables y tipos de datos. Los ejercicios abarcan desde la creación simple de programas que imprimen mensajes hasta el desarrollo de una calculadora básica que realiza cálculos numéricos y muestra resultados en pantalla. Además, practicarás técnicas de entrada de usuario y conversión entre diferentes tipos de datos para garantizar que tus operaciones matemáticas sean precisas. Estos ejercicios te preparan para dominar la estructura y el flujo básico de un programa Python, sentando las bases para temas más avanzados en tu formación profesional.

### Holamundo
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es muy simple y básico en la programación con Python. La función `print()` se utiliza para mostrar texto o información en la pantalla, también conocida como salida estándar. En este caso específico, el programa imprime la frase "Hola mundo desde Python" cuando se ejecuta.

El mensaje "Hola mundo desde Python" es una cadena de texto (o string) que está dentro de comillas dobles, lo que indica al intérprete de Python que debe tratarlo como un conjunto de caracteres literales. Cuando el programa se ejecuta, la línea completa `print("Hola mundo desde Python")` hace que esa frase aparezca en la pantalla o en la ventana de salida del entorno de desarrollo.

Este ejercicio es muy común al inicio del aprendizaje de cualquier lenguaje de programación porque ayuda a los estudiantes a familiarizarse con el proceso de creación y ejecución de un programa simple antes de pasar a conceptos más complejos.

`001-Holamundo.py`

```python
print("Hola mundo desde Python")
```

### variables
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código Python establece dos variables sencillas para almacenar información sobre una persona. La primera línea, `nombre = "Jose Vicente"`, crea una variable llamada `nombre` y le asigna el valor "Jose Vicente", que es un string o cadena de texto. La segunda línea, `edad = 47`, hace lo mismo pero con un número entero: la edad del individuo es 47 años.

Estas líneas son fundamentales porque muestran cómo declarar y asignar valores a variables en Python, lo cual es una habilidad básica para cualquier programa que maneje datos. Las variables permiten almacenar información que puede ser usada o modificada más adelante en el código.

`002-variables.py`

```python
nombre = "Jose Vicente"
edad = 47
```

### salidas
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código en Python sirve para imprimir un mensaje personalizado en la consola. Primero, se crea una variable llamada `nombre` y se le asigna el valor `"Jose Vicente"`. Luego, utiliza la función `print()` para mostrar en pantalla el texto "Mi nombre es" seguido del contenido de la variable `nombre`.

El código combina texto estático ("Mi nombre es") con un dato almacenado en una variable (`nombre`), lo que permite personalizar y hacer más interesante el mensaje impreso. Esto es especialmente útil cuando se desea mostrar información específica o datos cambiantes en la consola.

Este tipo de operación es fundamental en programación, ya que nos ayuda a visualizar los resultados de nuestras variables y es una herramienta básica para depurar código y verificar cómo evoluciona la ejecución del programa.

`003-salidas.py`

```python
nombre = "Jose Vicente"
print("Mi nombre es",nombre)
```

### variar una variable
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código muestra cómo se pueden modificar las variables en Python. En este caso, la variable `nombre` cambia su valor a lo largo del programa. Primero, se asigna el valor `"Jose Vicente"` a la variable `nombre`, y luego se imprime una frase que incluye ese nombre. Posteriormente, la variable `nombre` se actualiza con un nuevo valor, `"Juan"`, y se vuelve a imprimir la misma frase, pero ahora utilizando el nuevo valor de la variable.

Este código es importante porque demuestra cómo las variables pueden ser modificadas en cualquier momento durante la ejecución del programa. En este caso, vemos que una vez que `nombre` cambia de "Jose Vicente" a "Juan", toda referencia posterior al nombre utilizará el último valor asignado. Es útil para comprender que los valores almacenados en las variables pueden ser actualizados y utilizados en diferentes partes del código según sea necesario.

`004-variar una variable.py`

```python
nombre = "Jose Vicente"
print("Mi nombre es",nombre)

nombre = "Juan"
print("Mi nombre es",nombre)
```

### identificadores permitidos
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código está mostrando ejemplos de cómo se pueden nombrar variables en Python, y también algunos ejemplos de nombres que son inválidos. En primer lugar, defines tres variables llamadas `nombre`, `nombre2` y `nombre_completo`, cada una con un valor distinto. Luego, hay varios comentarios que muestran nombres de variables no válidos: `2nombre`, `nombre-completo` y `nombre completo`. Estos son incorrectos porque los nombres de las variables en Python deben comenzar con una letra (a-z, A-Z) o con un guion bajo (_), seguido por cualquier número de letras, dígitos u otros guiones bajos. Finalmente, el código muestra la forma correcta pero no recomendada `nombreCompleto`, que es un nombre válido pero puede ser confuso debido a su falta de separación entre las palabras. La mejor práctica es usar nombres descriptivos y claros como los primeros ejemplos para facilitar la lectura del código por parte de otros programadores.

`005-identificadores permitidos.py`

```python
nombre = "Jose"
nombre2 = "Vicente"
# 2nombre = "Jose Vicente"
nombre_completo = "Jose Vicente"
#nombre-completo = "Jose Vicente"
#nombre completo = "Jose Vicente"
nombreCompleto = "Jose Vicente" # Es legal pero no se recomienda
```

### comentarios
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código muestra dos formas diferentes de escribir comentarios en Python. Los comentarios son partes del código que no se ejecutan pero ayudan al programador a entender mejor el propósito o la lógica detrás del código.

El primer comentario (`# Esto es un comentario de una única línea`) es un ejemplo de cómo hacer un comentario de una sola línea. En Python, todo lo que sigue después del símbolo `#` hasta el final de la línea no será ejecutado por el interprete y se considera como un comentario.

El segundo bloque (`'''\n    Esto es un comentario\n    Esto sigue siendo un comentario\n    Y esto también lo es'''`) es un ejemplo de un comentario multilinea. En Python, puedes escribir comentarios que ocupen varias líneas utilizando tres comillas simples (``'``` o `"""`). Todo el texto dentro de estas comillas hasta encontrar otras tres comillas del mismo tipo será ignorado por el interprete y considerado como parte de un comentario.

Los comentarios son muy importantes porque ayudan a otros programadores (o incluso a ti mismo en el futuro) a entender rápidamente qué hace una sección específica del código sin tener que profundizar en su lógica detallada.

`006-comentarios.py`

```python
# Esto es un comentario de una única línea

'''
    Esto es un comentario
    Esto sigue siendo un comentario
    Y esto también lo es
'''
```

### Explicacion del codigo
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código en Python establece una variable llamada `edad` y le asigna el valor numérico 47. En programación, cuando decimos "asignar", nos referimos a la acción de dar un nombre (que es lo que llamamos identificador) a un valor o dato. Aquí, `edad` es el identificador, `=` es el operador de asignación y 47 es el valor literal numérico.

Este tipo de código es fundamental porque permite almacenar información en variables para su uso posterior en programas más grandes y complejos. Por ejemplo, podrías usar esta variable `edad` para realizar cálculos relacionados con la edad del usuario en un programa interactivo o para tomar decisiones basadas en el valor que contiene.

Es importante entender cómo funcionan los identificadores, operadores de asignación y valores literales porque son conceptos básicos que se usan continuamente a medida que avanzas en tu aprendizaje de la programación.

`007-Explicacion del codigo.py`

```python
edad = 47
# edad es el identificador
# = es el operador de asignación
# 47 es el valor literal que se es está asignando al identificador
```

### Tipos de datos
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es una introducción a los diferentes tipos de datos que se utilizan en la programación con Python. Aquí, cuatro variables son declaradas y asignados valores específicos a cada una para ilustrar cómo manejar distintos tipos de datos:

1. **nombre**: Esta variable es un ejemplo de una cadena (o `str` por sus siglas en inglés), que se utiliza para almacenar texto como "Jose Vicente".
2. **edad**: Esta variable almacena un número entero, también conocido como `int`, con el valor 47.
3. **altura**: La altura es un ejemplo de dato decimal o flotante (también llamado `float` en Python), representando 1.78 metros en este caso.
4. **vivo**: Esta variable es un booleano (`bool` en Python), que puede tomar solo dos valores: verdadero (`True`) o falso (`False`). En este ejemplo, se está indicando que el valor de esta variable es `True`.

Este código es importante porque muestra cómo declarar y asignar tipos de datos diferentes, lo cual es fundamental para cualquier programa que maneje información diversa.

`008-Tipos de datos.py`

```python
nombre = "Jose Vicente" # Cadena
edad = 47 # Entero
altura = 1.78 # Decimal
vivo = True # Booleano
```

### Entradas
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código te ayuda a interactuar con el usuario cuando ejecutas un programa en Python. La primera línea utiliza la función `input()`, que muestra un mensaje al usuario ("Dime tu nombre:") y espera a que el usuario teclee su nombre y presione enter. El texto ingresado por el usuario se almacena en la variable `nombre`.

Luego, la segunda línea usa la instrucción `print()` para mostrar en pantalla un mensaje que incluye lo que el usuario acaba de ingresar. En este caso, imprime "Tu nombre es: " seguido del valor almacenado en la variable `nombre`. Esto permite al programa confirmar y mostrar de vuelta al usuario lo que ha ingresado previamente.

Este código es importante porque demuestra cómo recoger información del usuario (entradas) y cómo devolver esa misma información procesada (salida). Es una pieza fundamental para programas interactivos.

`009-Entradas.py`

```python
nombre = input("Dime tu nombre: ")
print("Tu nombre es: ",nombre)
```

### Entrada y problema
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código solicita al usuario que ingrese su edad y luego muestra en pantalla el doble de esa edad. En primer lugar, la línea `edad = input("Dime tu edad: ")` pide al usuario que teclee su edad cuando se le haga esta pregunta. El valor ingresado por el usuario será guardado como una cadena (texto) en la variable `edad`. Luego, la segunda línea, `print("El doble de tu edad es: "+edad)`, imprime un mensaje en pantalla junto con el valor almacenado en la variable `edad`. Sin embargo, hay un error conceptual aquí, ya que no calcula realmente el doble de la edad. Para hacer ese cálculo correctamente, necesitaríamos convertir primero el texto ingresado por el usuario a un número entero o decimal y luego multiplicarlo por dos.

Este fragmento ilustra cómo obtener información del usuario y mostrarla en pantalla, pero también demuestra que es importante tener cuidado con el tipo de datos almacenados cuando se realizan cálculos matemáticos. Es crucial convertir las cadenas ingresadas a números enteros o flotantes antes de realizar operaciones aritméticas para evitar errores en nuestro programa.

`010-Entrada y problema.py`

```python
edad = input("Dime tu edad: ")
print("El doble de tu edad es: "+edad)
```

### Cambio de tipo de dato
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código solicita al usuario que ingrese su edad y luego realiza algunos cálculos sencillos con ese dato. Primero, usa la función `input()` para pedirle al usuario que introduzca su edad, lo cual captura el texto que el usuario escribe como una cadena de caracteres (texto). Luego, convierte esa cadena en un número entero mediante la función `int()`, permitiendo así realizar operaciones matemáticas con ella. Después, calcula el doble de ese número entero y finalmente intenta mostrar el resultado por pantalla usando la función `print()`.

El problema clave en este código es que al imprimir el resultado, trata de concatenar un número entero (`doble`) directamente con una cadena de texto ("El doble de tu edad es: ") sin convertir primero el número a texto. En Python, no puedes combinar diferentes tipos de datos (como números y cadenas) en esta forma. Para solucionarlo, debes convertir el número entero `doble` a una cadena usando la función `str()` antes de intentar imprimirlo junto con el mensaje. La línea correcta sería:

```python
print("El doble de tu edad es: " + str(doble))
```

Esta corrección asegura que todos los elementos que se imprimen sean del mismo tipo, permitiendo mostrar correctamente el resultado en pantalla.

`011-Cambio de tipo de dato.py`

```python
# Le pregunto al usuario por su edad
edad = input("Dime tu edad: ")
# Me aseguro de convertir la edad a un número entero
entero = int(edad)
# Calculo el doble de un número entero
doble = entero*2
# Saco el resultado por pantalla
print("El doble de tu edad es: "+doble)
```

### literales
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código Python está asignando valores a dos variables, `nombre` y `edad`. La variable `nombre` se le asigna la cadena "Jose Vicente", que en este contexto se conoce como un literal de cadena. Esto significa que "Jose Vicente" es una secuencia de caracteres entre comillas, que representa el nombre de una persona. Por otro lado, la variable `edad` recibe el valor 47, que es un número entero sin decimales, conocido como literal numérico o entero en Python.

Estos literales son importantes porque permiten almacenar y manipular datos de manera directa en nuestro programa. La cadena permite representar texto, mientras que el entero puede ser usado para realizar cálculos matemáticos o simplemente para guardar números sin decimales como la edad de una persona.

`012-literales.py`

```python
nombre = "Jose Vicente"
# Jose Vicente es el literal, y es de tipo cadena

edad = 47
# 47 es el literal, y es de tipo entero
```

### constantes
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código muestra cómo se define y modifica una variable en Python. Primero, se asigna un valor a la variable `PI`, que representa el número π (pi), inicialmente establecido como 3.1415. Luego, se imprime el mensaje "PI vale" seguido del valor actual de `PI`. A continuación, se cambia el valor de `PI` a 4 y vuelve a imprimir la variable con su nuevo valor.

Lo importante aquí es entender que aunque se intente representar una constante matemática como π (pi) en mayúsculas para indicar que no debería cambiarse (`PI`), en Python las variables pueden cambiar de valor en cualquier momento. Por eso, aunque `PI` fue inicialmente establecido con un valor comúnmente usado para π, se cambia después a 4, mostrando que el concepto de una "constante" en programación dependerá del contexto y la convención (en este caso, escribir los nombres de las constantes en mayúsculas para indicar su naturaleza constante) no impide modificarlas.

`013-constantes.py`

```python
PI = 3.1415

print("PI vale",PI)

PI = 4 # Le cambio el valor a PI

print("PI vale",PI)
# Las constantes deben formularse con mayúsculas
# Las variables deben formularse con minúsculas
```

### Diferencia
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código muestra cómo se pueden cambiar los valores y tipos de una variable en Python. Inicialmente, la variable `PI` es definida como un número decimal (`3.1416`), lo cual representa el valor aproximado del número matemático π (pi). Sin embargo, después de esta línea, ocurre un cambio: se reasigna a `PI` con el valor `"unnumero"`, que es una cadena de texto (string).

Este ejemplo destaca dos conceptos importantes en programación. Primero, cómo las variables pueden ser reasignadas para contener diferentes tipos de datos según sea necesario en tu programa. Segundo, aunque la variable originalmente contenía un número, puede cambiar a cualquier otro tipo de dato, incluyendo una cadena de texto, lo que demuestra la flexibilidad pero también la importancia de mantener el control sobre los tipos de datos para evitar errores en tu código más adelante.

`014-Diferencia.py`

```python

# La constante es PI
# El literal es 3.1416

PI = 3.1416

PI = "unnumero"
```

### operadores aritmeticos
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código en Python muestra cómo se utilizan diferentes operadores aritméticos para realizar cálculos básos. Los operadores que se están usando aquí son:

1. `+` (suma): suma dos números, en este caso 4 y 3.
2. `-` (resta): resta el segundo número del primero, también con los valores de 4 y 3.
3. `*` (multiplicación): multiplica ambos números entre sí, utilizando nuevamente 4 y 3.
4. `/` (división): divide el primer número por el segundo, aquí dividiendo 4 entre 3.
5. `%` (módulo): devuelve el resto de la división entera del primer número por el segundo, en este caso, 4 dividido por 3.

Estos operadores son fundamentales para cualquier tipo de cálculo matemático que se realice con Python y es importante entender cómo funcionan para poder realizar tareas más avanzadas. Cada línea del código imprime un resultado distinto dependiendo del operador aritmético utilizado, permitiéndote ver claramente los efectos de cada uno.

En relación al archivo anterior (014-Diferencia.py), este nuevo archivo `014-operadores aritmeticos.py` representa una transición hacia el uso práctico de operaciones matemáticas en lugar del manejo de constantes y literales. En vez de centrarse en la definición de variables como constantes, ahora se enfoca directamente en ejemplos concretos que muestran cómo funcionan los operadores aritméticos básicos en Python. Esto ayuda a entender mejor cómo manipular números utilizando estas operaciones en tu propio código.

`014-operadores aritmeticos.py`

```python
print(4+3)
print(4-3)
print(4*3)
print(4/3)
print(4%3)
```

### operadores de comparacion
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código está utilizando operadores de comparación en Python para hacer varias comprobaciones entre dos números y luego imprimir los resultados. Los operadores utilizados son:

- `<` (menor que): Comprueba si el primer número es menor que el segundo.
- `<=` (menor o igual que): Verifica si el primer número es menor o igual al segundo.
- `>` (mayor que): Determina si el primer número es mayor que el segundo.
- `>=` (mayor o igual que): Evalúa si el primer número es mayor o igual al segundo.
- `==` (igual a): Comprueba la igualdad entre dos números.
- `!=` (diferente de): Verifica si los dos números son diferentes.

Cada línea del código realiza una comparación entre el número 4 y el número 3, utilizando uno de estos operadores. Luego, imprime un valor booleano (`True` o `False`) que indica el resultado de la comparación. Por ejemplo, `print(4 < 3)` imprimirá `False` porque 4 no es menor que 3.

Este tipo de código es importante para entender cómo funcionan las comparaciones en Python y servirá como base para usar estas operaciones en estructuras condicionales más adelante en tu aprendizaje.

`015-operadores de comparacion.py`

```python
print(4 < 3)
print(4 <= 3)
print(4 > 3)
print(4 >= 3)
print(4 == 3)
print(4 != 3)
```

### operadores arimeticos abreviados
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código en Python muestra cómo se pueden actualizar variables utilizando operadores aritméticos abreviados. En el código, la variable `edad` comienza con un valor inicial de 47. A continuación, se demuestra cuánto más sencillo es utilizar los operadores aritméticos combinados (como += para sumar y -= para restar) en lugar de escribir expresiones completas como `edad = edad + 2`. Estos operadores permiten realizar una operación matemática sobre la variable, mientras se actualiza con el resultado de dicha operación. De esta manera, después de cada línea que utiliza un operador abreviado (como += o -=), la edad es modificada según la operación indicada: suma 2, resta 2, multiplica por dos y divide por dos.

Este tipo de notación no solo hace el código más conciso y fácil de leer, sino que también minimiza errores al evitar la necesidad de repetir la variable en cada lado del signo igual. Es importante entender estos operadores porque facilitan el manejo de valores numéricos en programas donde las variables cambian con frecuencia, como en cálculos financieros o simulaciones matemáticas.

`016-operadores arimeticos abreviados.py`

```python
edad = 47
# Le quiero sumar dos unidades
edad = edad + 2
edad += 2
#Le quiero restar dos unidades
edad = edad - 2
edad -= 2
# Lo quiero multiplicar por dos
edad = edad * 2
edad *= 2
# Lo quiero dividir por dos
edad = edad / 2
edad /= 2
```

### operadores booleanos
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código utiliza operadores booleanos en Python para evaluar y mostrar el resultado de varias expresiones lógicas. Los operadores `and` y `or` son clave aquí: el operador `and` devuelve `True` solo si todas las condiciones que lo componen son verdaderas, mientras que el operador `or` devuelve `True` si al menos una de las condiciones es verdadera.

En la primera línea, el código evalúa tres comparaciones con `==`, que comprueba si dos valores son iguales: `4 == 4`, `3 == 3`, y `2 == 2`. Como todas estas comparaciones son verdaderas, la expresión completa evaluada por `and` también es verdadera, por lo que se imprime `True`.

En las líneas siguientes, hay una variación en los valores de comparación, pero la estructura lógica sigue siendo la misma. Por ejemplo, en `4 == 4 and 3 == 3 and 2 == 1`, dos de las condiciones son verdaderas pero la última es falsa, por lo que el resultado completo es falso y se imprime `False`.

Para las líneas que usan `or`, como en `4 == 4 or 3 == 3 or 2 == 1`, solo una condición necesita ser verdadera para que toda la expresión sea verdadera. En este caso, todas son correctas, por lo que se imprime `True`. Sin embargo, cuando hay condiciones falsas mezcladas, como en `4 == 4 or 3 == 2 or 2 == 1`, solo una condición es verdadera (la primera), así que el resultado final es también `True`.

Este código ilustra cómo combinar múltiples comparaciones lógicas utilizando operadores booleanos para evaluar y determinar si ciertas condiciones se cumplen o no.

`017-operadores booleanos.py`

```python
print(4 == 4 and 3 == 3 and 2 == 2)
print(4 == 4 and 3 == 3 and 2 == 1)

print(4 == 4 or 3 == 3 or 2 == 1)
print(4 == 4 or 3 == 2 or 2 == 1)
print(4 == 3 or 3 == 2 or 2 == 1)
```

### Ejercicio1-Calculadora de impuestos
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código es la introducción o encabezado (también conocido como docstring en Python) de un programa llamado "Calculadora de Impuestos". En él, el autor del programa, Jose Vicente Carratalá, proporciona una breve descripción sobre cómo funciona este script. El objetivo principal del programa es permitir al usuario ingresar un valor base imponible (es decir, el precio original sin impuestos) y luego calcular automáticamente tanto el IVA correspondiente como el total final que incluye ese impuesto.

Este tipo de comentarios al inicio del código son importantes porque ayudan a entender rápidamente la función del programa y cómo se utiliza. Son útiles para cualquier persona que esté trabajando con el código o simplemente quiere saber qué hace el programa sin entrar en detalles técnicos innecesarios.

`018-Ejercicio1-Calculadora de impuestos.py`

```python
'''
    Calculadora de Impuestos
    v0.1 por Jose Vicente Carratalá
    Funcionamiento: Introduce una base imponible y se calcula IVA y total
'''
```

### Calculadora
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es el inicio de un programa en Python que actúa como una simple calculadora para calcular impuestos basado en la base imponible de una factura. El objetivo del programa es solicitar al usuario que introduzca el importe bruto o base imponible de una factura y, posteriormente, realizar cálculos sobre este valor para determinar el IVA (Impuesto sobre el Valor Añadido) y el total de la factura.

El código comienza con un comentario que describe brevemente qué hace el programa. Luego, se declaran tres variables: `base_imponible`, `total_iva` y `total_factura`. Estas variables son utilizadas para almacenar respectivamente el valor introducido por el usuario (la base imponible), el cálculo del IVA y el total de la factura que resulta de sumar la base imponible con el IVA.

El código muestra una línea donde se solicita al usuario que ingrese la base imponible mediante la función `input()`. Sin embargo, es importante notar que este fragmento no completa todo el proceso; falta calcular el valor del IVA y sumarlo a la base imponible para obtener el total de la factura. Además, está indicado con un comentario "Aquí pondría las funciones/clases", lo cual sugiere que en una versión más avanzada del programa se añadirían estructuras adicionales para organizar mejor el código.

`019-Calculadora.py`

```python
'''
    Calculadora de Impuestos
    v0.1 por Jose Vicente Carratalá
    Funcionamiento: Introduce una base imponible y se calcula IVA y total
'''

# Este programa no tiene importaciones

# Creo variables
base_imponible = 0
total_iva = 0
total_factura = 0

# Aquí pondría las funciones/clases

# Ahora calculamos
base_imponible = input("Introduce la base imponible de la factura: ")
```

### Calculadora
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código es un programa sencillo escrito en Python que sirve como una calculadora básica para calcular impuestos, específicamente el IVA (Impuesto al Valor Agregado) y el total de una factura. Al ejecutar el programa, se muestra un mensaje al usuario indicando que va a calcular el IVA y el total basándose en la base imponible que ingrese.

El código comienza definiendo tres variables: `base_imponible`, `total_iva` e `total_factura`. Estas variables servirán para almacenar los valores de entrada del usuario y las salidas calculadas por el programa. Luego, imprime en la consola un mensaje bienvenido y una instrucción que indica al usuario cómo usar el programa.

El programa solicita al usuario que introduzca la base imponible mediante la función `input()`, capturando lo que el usuario escribe como texto (string) y almacenándolo en la variable `base_imponible`. Sin embargo, este código solo recoge la entrada del usuario pero no realiza cálculos con ella ni muestra los resultados de los mismos. Los pasos siguientes para completar esta calculadora incluirían convertir el valor introducido a un número (por ejemplo, usando `float()`), calcular el IVA y el total, y finalmente imprimir estos valores en la consola.

Es importante entender este código porque te muestra cómo interactuar con el usuario mediante entradas y salidas básicas en Python y cómo manejar datos numéricos.

`020-Calculadora.py`

```python
'''
    Calculadora de Impuestos
    v0.1 por Jose Vicente Carratalá
    Funcionamiento: Introduce una base imponible y se calcula IVA y total
'''

# Este programa no tiene importaciones

# Creo variables
base_imponible = 0
total_iva = 0
total_factura = 0

# Aquí pondría las funciones/clases

# Ahora calculamos
print("Programa calculadora de impuestos")
print("(c) 2025 Jose Vicente Carratalá")
print("Introduce una base y te calculo el IVA y el total")
base_imponible = input("Introduce la base imponible de la factura: ")
```

### Calculo de IVA
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este programa calcula el Impuesto sobre Valor Agregado (IVA) y el total de una factura basándose en la base imponible introducida por el usuario. Al ejecutarlo, primero muestra información sobre el autor del programa y luego solicita al usuario que ingrese la base imponible de la factura. La base imponible es el valor antes de aplicarle el IVA.

El programa calcula el IVA multiplicando la base imponible por el 21% (0.21 en decimal), que es la tasa del IVA general en España. Luego, para obtener el total de la factura, suma la base imponible y el IVA recién calculado.

Finalmente, muestra al usuario tanto el monto del IVA como el total de la factura, proporcionando así una fácil comprensión del costo final incluyendo impuestos. Este tipo de programa es útil para entender cómo calcular costos totales en situaciones comerciales o personales donde se aplican tasas de IVA.

`021-Calculo de IVA.py`

```python
'''
    Calculadora de Impuestos
    v0.1 por Jose Vicente Carratalá
    Funcionamiento: Introduce una base imponible y se calcula IVA y total
'''

# Este programa no tiene importaciones

# Creo variables
base_imponible = 0
total_iva = 0
total_factura = 0

# Aquí pondría las funciones/clases

# Ahora calculamos

# Primero pido una entrada
print("Programa calculadora de impuestos")
print("(c) 2025 Jose Vicente Carratalá")
print("Introduce una base y te calculo el IVA y el total")
base_imponible = float(input("Introduce la base imponible de la factura: "))

# Luego realizo cálculos
total_iva = base_imponible*0.21
total_factura = base_imponible + total_iva

# Por último expreso una salida
print("El IVA de la factura es: ",total_iva)
print("El total de la factura es: ",total_factura)
```

### Actividades propuestas

### Actividades Propuestas para Estudiantes de Formación Profesional (FP)

#### 1. **Bienvenida al Alumno**
- **Descripción**: Crea un programa en Python que salude al usuario mostrando su nombre y el día actual.
- **Objetivo**: Aprender a utilizar funciones básicas como `print` y manejar variables.

#### 2. **Edad del Usuario**
- **Descripción**: Diseña un programa que pregunte la edad del usuario e imprima una frase indicando cuántos años tiene.
- **Objetivo**: Familiarizarse con el uso de entradas y salidas en Python.

#### 3. **Calculadora Básica**
- **Descripción**: Implementa una calculadora sencilla que permita al usuario sumar o restar dos números introducidos por teclado.
- **Objetivo**: Entender la importancia de los operadores aritméticos y cómo manejar entradas numéricas.

#### 4. **Comparación de Edades**
- **Descripción**: Escribe un programa que compare las edades de dos personas y determine quién es mayor o si tienen la misma edad.
- **Objetivo**: Practicar el uso de operadores de comparación en Python.

#### 5. **Cálculo del IVA**
- **Descripción**: Desarrolla una aplicación que calcule el importe del IVA y el total a pagar a partir de un valor base imponible introducido por el usuario.
- **Objetivo**: Aprender cómo realizar cálculos matemáticos en Python, incluyendo operadores aritméticos y entradas numéricas.

#### 6. **Cambio de Tipos de Datos**
- **Descripción**: Crea un programa que convierta una entrada de texto (representando un número) a entero, y luego imprima el doble del número.
- **Objetivo**: Dominar la conversión entre tipos de datos en Python.

#### 7. **Saludo Personalizado**
- **Descripción**: Diseña un programa que reciba como entrada el nombre y la edad del usuario, y genere una salida personalizada con esta información.
- **Objetivo**: Mejorar las habilidades de manejo de variables y concatenación de cadenas.

#### 8. **Operaciones Básicas**
- **Descripción**: Implementa un programa que permita realizar operaciones básicas (suma, resta, multiplicación) entre dos números introducidos por el usuario.
- **Objetivo**: Práctica con funciones, variables y cálculos matemáticos en Python.

#### 9. **Comprobación de Identificadores**
- **Descripción**: Escribe un programa que evalúe si los identificadores utilizados cumplen las normas (uso correcto de mayúsculas/minúsculas).
- **Objetivo**: Aprender a manejar y validar nombres de variables y constantes en Python.

#### 10. **Biblioteca Personal**
- **Descripción**: Crea un programa simple que simule una pequeña biblioteca, donde el usuario pueda agregar libros (título y autor) y listarlos después.
- **Objetivo**: Introducción a la manipulación de estructuras de datos básicas como listas.

Estas actividades están diseñadas para ayudar a los estudiantes a dominar conceptos fundamentales de programación en Python, alineados con el nivel y el contenido que se observa en la carpeta proporcionada.



<a id="desarrollo-de-clases"></a>
# Desarrollo de clases

<a id="concepto-de-clase"></a>
## Concepto de clase

### Introducción a los ejercicios

Esta carpeta contiene una serie de ejercicios diseñados para introducir a los estudiantes al concepto fundamental de la programación orientada a objetos (POO) mediante el uso de clases en Python. Los problemas abordan desde la creación básica de clases hasta la implementación de propiedades y métodos dentro de ellas, enfatizando cómo encapsular datos y comportamientos para mejorar la organización del código y facilitar su mantenimiento y escalabilidad.

A través de estos ejercicios, los estudiantes practicarán habilidades clave como la definición de clases, instanciación de objetos, creación de propiedades y métodos, así como entender cómo las clases permiten una mejor estructuración del código en comparación con el paradigma estructurado tradicional. Estos ejercicios son esenciales para comprender los principios fundamentales que subyacen a la programación orientada a objetos y su importancia en el desarrollo de software más complejo.

### clase gato
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es la definición básica de una clase llamada `Gato` en Python. La palabra clave `class` indica que estamos creando una nueva clase con el nombre "Gato". Dentro de la clase, se usa la palabra `pass`, lo cual significa que por ahora no hay ninguna propiedad o método (función dentro de la clase) definido para esta clase; es simplemente un molde vacío. Esta estructura básica es importante porque te permite comenzar a formular cómo vas a organizar las características y comportamientos específicos del objeto "Gato" en futuras versiones del código. Es como dibujar el esqueleto de una casa antes de empezar con los detalles de la construcción.

`002-clase gato.py`

```python
class Gato:
  pass
  
```

### instanciamos un gato
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es una introducción básica al concepto de clases en Python. Primero, se define una clase llamada `Gato` usando la palabra clave `class`. En este caso, dentro de la clase solo se usa la declaración `pass`, que indica que no hay contenido adicional en esta clase (no se definen propiedades ni métodos para el gato). 

Después, se crea un objeto o instancia de la clase `Gato` llamado `gato1`. Esto significa que estás creando una versión específica del concepto abstracto de "Gato". Finalmente, se imprime este objeto usando `print(gato1)`, lo cual mostrará información sobre el objeto `gato1`, incluyendo su clase y dirección en memoria. 

Este código es útil para entender cómo crear clases vacías y luego instanciarlas, que son conceptos fundamentales al aprender a programar orientada a objetos en Python.

`003-instanciamos un gato.py`

```python
class Gato:
  pass
  
gato1 = Gato()
print(gato1)
```

### ahora quiero crear otro gato
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código Python está creando y mostrando dos instancias de una clase llamada `Gato`. Primero, se define la clase `Gato` con la palabra clave `class`, pero no se añade ninguna funcionalidad adicional dentro de ella, por lo que se usa la instrucción `pass` para indicar que aún no queremos agregar detalles a esta clase. 

Luego, se crean dos objetos (o instancias) de la clase `Gato`: uno llamado `gato1` y otro llamado `gato2`. Esto significa que cada objeto es una versión específica de lo que define la clase `Gato`, pero en este caso no hemos especificado diferencias entre ellos.

Finalmente, el código imprime ambos objetos utilizando la función `print()`. Al imprimir estos objetos, obtendrás una salida que te indica cuál es el tipo del objeto (`<class '__main__.Gato'>`) y su ubicación de memoria única. Esto demuestra cómo cada instancia de la clase `Gato` tiene su propia identidad en el programa.

Es importante destacar que este ejemplo básico ilustra cómo crear clases y objetos, pero no muestra aún cómo puedes personalizar las características o comportamientos de estos objetos, lo cual es un paso crucial en la programación orientada a objetos.

`004-ahora quiero crear otro gato.py`

```python
class Gato:
  pass
  
gato1 = Gato()
print(gato1)

gato2 = Gato()
print(gato2)
```

### propiedades y metodos
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código es una introducción a las clases y objetos en Python. En él, se crea una clase llamada `Gato` que tiene un método especial llamado `__init__`. Este método se ejecuta automáticamente cuando se crea un nuevo objeto de la clase `Gato`, y en este caso inicializa una propiedad del gato llamada `color`, que comienza como una cadena vacía.

Después, el código crea dos instancias de la clase `Gato`: `jaegger` y `lana`. Para cada uno, se asigna un valor a su propiedad `color`; por ejemplo, para `jaegger` se establece en "crema" y para `lana` en "gris". Esto demuestra cómo los objetos individuales de una misma clase pueden tener diferentes valores para sus propiedades.

Este fragmento es importante porque muestra cómo definir clases con atributos y crear instancias (objetos) de dichas clases, que son conceptos fundamentales en la programación orientada a objetos.

`006-propiedades y metodos.py`

```python
class Gato:
  def __init__(self):
    self.color = ""
  
jaegger = Gato()
jaegger.color = "crema"

lana = Gato()
lana.color = "gris"
```

### propiedades
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código crea una clase llamada `Gato` en Python, que es como un modelo o plantilla para crear gatos virtuales. Dentro de la clase, hay un método especial llamado `__init__`, que se ejecuta automáticamente cada vez que creamos (o "instanciamos") un nuevo objeto tipo Gato. En este método, inicializamos dos propiedades del gato: `color` y `edad`, estableciéndolas como cadenas vacías (`""`) para el color y cero (`0`) para la edad.

Después de definir la clase, creamos dos objetos (o instancias) de tipo Gato: `jaegger` y `lana`. Para cada uno de estos gatos, especificamos su color y edad. Por ejemplo, a `jaegger` le asignamos el color "crema" y una edad de 9 años, mientras que a `lana` le damos un color gris y una edad de 11 años.

Este tipo de código es importante porque te permite crear objetos en Python con características específicas (en este caso, color y edad), lo cual es fundamental para construir programas más complejos y realistas donde los objetos interactúan entre sí.

`007-propiedades.py`

```python
class Gato:
  def __init__(self):
    self.color = ""
    self.edad = 0
  
jaegger = Gato()
jaegger.color = "crema"
jaegger.edad = 9

lana = Gato()
lana.color = "gris"
lana.edad = 11
```

### introduccion a los metodos
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código en Python crea una clase llamada `Gato` que representa características y comportamientos de un gato. La clase tiene dos atributos (propiedades): `color`, que indica el color del pelaje, y `edad`, que es la edad del gato en años. Estos atributos se inicializan en el método especial `__init__()` cuando se crea una instancia de la clase.

Además, la clase define un método llamado `maulla()`, que simplemente imprime el mensaje "El gato está maullando" cada vez que es llamado. Este método simula el comportamiento del gato de emitir sonidos vocales para comunicarse o llamar atención.

Después de definir la clase, se crean dos instancias (objetos) de `Gato`: `jaegger` y `lana`. Cada uno tiene sus propios valores para `color` y `edad`, reflejando que diferentes gatos pueden tener distintas características. Por último, cada objeto llama al método `maulla()`, lo cual hace que el programa imprima la frase "El gato está maullando" dos veces en la consola, una por cada instancia de gato.

Este código es importante porque muestra cómo se puede modelar un concepto del mundo real (en este caso, un gato) como objetos dentro del lenguaje de programación Python. Además, demuestra cómo los métodos dentro de las clases pueden ser utilizados para simular comportamientos específicos asociados con ese objeto.

`008-introduccion a los metodos.py`

```python
class Gato:
  def __init__(self):
    self.color = ""
    self.edad = 0
  def maulla(self):
    print("El gato está maullando")
  
jaegger = Gato()
jaegger.color = "crema"
jaegger.edad = 9
jaegger.maulla()

lana = Gato()
lana.color = "gris"
lana.edad = 11
lana.maulla()
```

### objeto cliente
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es una introducción a la creación de objetos en Python, aunque no se están utilizando las clases aún. Lo que vemos aquí son simplemente variables que almacenan información sobre dos clientes diferentes: un cliente llamado Jose Vicente Carratala Sanchis y otro llamado Juan García. Cada cliente tiene atributos como el correo electrónico, la dirección, nombre y apellidos. Esta forma de almacenar datos es útil para entender cómo se organiza la información antes de aprender a usar clases y objetos en Python. Sin embargo, en una programación más avanzada, esta misma información podría encapsularse dentro de una clase `Cliente`, lo que permitiría gestionar los detalles del cliente de manera mucho más organizada y reutilizable.

`009-objeto cliente.py`

```python
cliente1_email = "info@jocarsa.com"
cliente1_direccion = "La calle de Jose Vicente"
cliente1_nombre = "Jose Vicente"
cliente1_apellidos = "Carratala Sanchis"

cliente2_email = "info@cliente2.com"
cliente2_direccion = "La calle del cliente2"
cliente2_nombre = "Juan"
cliente2_apellidos = "García"
```

### clase cliente
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código te muestra cómo pasar de manejar información sobre clientes usando muchas variables separadas a usar una estructura llamada clase para organizar esa información. En la parte superior, el código tiene cuatro clientes diferentes (supongamos que solo dos en este ejemplo) y usa variables individuales para almacenar detalles como su email, dirección, nombre y apellidos. Esto puede volverse complicado rápidamente si tienes muchos clientes.

Luego, el código muestra cómo crear una clase llamada `Cliente` que tiene un método especial llamado `__init__`. Este método se ejecuta automáticamente cuando creamos (o instanciamos) un nuevo objeto de la clase `Cliente`. En este caso, `__init__` inicializa las propiedades del cliente con cadenas vacías. Luego, puedes crear objetos específicos como `cliente1` y `cliente2`, asignando valores a sus propiedades respectivas.

Usar una clase para representar un cliente es mucho más eficiente porque permite organizar la información de manera estructurada y fácilmente accesible. Esto facilita agregar o modificar datos sobre clientes, especialmente cuando tienes muchos clientes en lugar de solo dos como en este ejemplo.

`010-clase cliente.py`

```python
# Poco escalable - uso de muchas variables

cliente1_email = "info@jocarsa.com"
cliente1_direccion = "La calle de Jose Vicente"
cliente1_nombre = "Jose Vicente"
cliente1_apellidos = "Carratala Sanchis"

cliente2_email = "info@cliente2.com"
cliente2_direccion = "La calle del cliente2"
cliente2_nombre = "Juan"
cliente2_apellidos = "García"

# Mucho mejor: uso de clases

class Cliente:
  def __init__(self):
    self.email = ""
    self.direccion = "" 
    self.nombre = ""
    self.apellidos = ""
    
cliente1 = Cliente()
cliente1.email = "info@jocarsa.com"
cliente1.direccion = "La calle de Jose Vicente"
cliente1.nombre = "Jose Vicente"
cliente1.apellidos = "Carratala Sanchis"

cliente2 = Cliente()
cliente2.email = "info@cliente2.com"
cliente2.direccion = "La calle del cliente2"
cliente2.nombre = "Juan"
cliente2.apellidos = "García"
  
```

### Actividades propuestas

### Actividad 1: Creación Básica de Clases en Python

**Descripción:** Los estudiantes deberán crear una clase simple en Python que modele objetos relacionados con su entorno diario (por ejemplo, un vehículo, un libro o cualquier otro objeto). Se espera que comprendan cómo encapsular datos y métodos en una clase.

### Actividad 2: Instanciar Objetos desde Clases

**Descripción:** Tras crear clases básicas, los estudiantes deben instanciar varios objetos a partir de dicha clase. Esto les ayudará a entender la diferencia entre una clase y un objeto.

### Actividad 3: Propiedades en Clases

**Descripción:** Los alumnos deberán añadir propiedades (variables) a las clases que han creado para representar atributos específicos del objeto (por ejemplo, el color de un vehículo o el autor de un libro). Se evaluará su comprensión sobre cómo definir y asignar valores a estas propiedades.

### Actividad 4: Métodos en Clases

**Descripción:** Los estudiantes deben añadir métodos a las clases que han creado. Estos métodos deberán realizar acciones basadas en los atributos del objeto (por ejemplo, un método para simular la conducción de un vehículo). Esta actividad evalúa su capacidad para crear y usar funciones dentro de una clase.

### Actividad 5: Instanciación Mejorada

**Descripción:** Los alumnos deben mejorar el proceso de instanciar objetos en sus clases mediante el uso de parámetros en los métodos `__init__`. Esto les ayudará a entender cómo inicializar datos cuando se crean nuevos objetos.

### Actividad 6: Modelo Cliente-Servidor Simulado

**Descripción:** Con la ayuda de una clase "Cliente" ya proporcionada, los estudiantes deben simular interacciones simples entre clientes. El objetivo es aplicar el conocimiento adquirido sobre clases y métodos para modelar un escenario realista.

### Actividad 7: Mejora del Modelo Cliente

**Descripción:** Basándose en la clase "Cliente", los alumnos deberán mejorar su diseño añadiendo más atributos y métodos que simulen funcionalidades adicionales (como hacer una reserva o cambiar la dirección). Esto les permitirá practicar la creación de clases con mayor complejidad.

### Actividad 8: Implementación Orientada a Objetos

**Descripción:** Los estudiantes deben implementar un pequeño programa orientado a objetos basándose en las clases que han creado. Este programa debe incluir múltiples instancias de los objetos y la ejecución de métodos. Se evaluará su capacidad para aplicar el paradigma orientado a objetos en una solución práctica.

### Actividad 9: Documentación de Códigos Clase

**Descripción:** Tras crear clases y métodos, los estudiantes deberán escribir documentación adicional (document strings o docstrings) que expliquen claramente la función de cada clase y método. Esto les ayudará a mejorar sus habilidades en la documentación del código.

### Actividad 10: Comparativa Paradigmas

**Descripción:** Los estudiantes deberán investigar y comparar los paradigmas de programación (estructurado, funcional y orientado a objetos) con respecto a Python. Se les pedirá que redacten un breve resumen sobre qué tipo de problemas pueden abordarse mejor en cada paradigma utilizando ejemplos prácticos.

Estas actividades están diseñadas para incrementar gradualmente la complejidad, permitiendo a los estudiantes consolidar su comprensión y habilidades en programación orientada a objetos.


<a id="estructura-y-miembros-de-una-clase-visibilidad"></a>
## Estructura y miembros de una clase. Visibilidad

### Introducción a los ejercicios

Este conjunto de ejercicios está diseñado para ayudarte a familiarizarte con la creación y manejo de clases en Python, centrando la atención en cómo estructurar y utilizar miembros de una clase. A través de estos ejercicios, aprenderás a crear objetos desde clases simples hasta más complejas que interactúan con datos proporcionados por el usuario. Los problemas abarcan temas como la creación de instancias de clases, la entrada del usuario para definir propiedades de un objeto y operaciones básicas CRUD (Crear, Leer, Actualizar, Borrar) sobre una lista de objetos. Estos ejercicios te permiten practicar competencias esenciales en programación orientada a objetos, como encapsulamiento e interacción con datos dinámicos.

### listas
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código está presentando un concepto básico sobre cómo trabajar con listas en Python. Primero, se crean dos variables llamadas `cliente1` y `cliente2`, que contienen los nombres "Juan" y "Jorge", respectivamente. Sin embargo, el objetivo principal del código es crear una lista llamada `clientes` que contiene varios nombres de clientes: "Juan", "Jorge", "Jaime" y "Jose". La lista es muy útil cuando necesitas almacenar múltiples elementos relacionados, como en este caso, los nombres de diferentes clientes. Finalmente, el código imprime la lista completa de clientes utilizando la función `print()`, lo que muestra en pantalla todos los nombres que están dentro de la lista `clientes`. Este ejemplo básico ayuda a entender cómo crear y manipular listas en Python, que es una estructura de datos muy importante para programar.

`001-listas.py`

```python
cliente1 = "Juan"
cliente2 = "Jorge"

clientes = ["Juan","Jorge","Jaime","Jose"]

print(clientes)
```

### operaciones con listas
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código muestra cómo trabajar con listas en Python, específicamente cómo añadir y eliminar elementos. Inicia definiendo dos variables, `cliente1` y `cliente2`, que almacenan nombres de clientes, pero luego crea una lista llamada `clientes` que contiene cuatro nombres: "Juan", "Jorge", "Jaime" y "Jose". Luego imprime esta lista para mostrar su contenido inicial.

A continuación, utiliza el método `append()` de la lista para añadir un nuevo elemento, en este caso, el nombre "Julia", al final de la lista. Esto demuestra cómo se puede agregar dinámicamente nuevos elementos a una lista existente. Después del añadido, imprime nuevamente la lista.

Finalmente, utiliza el método `pop()` sin argumentos para eliminar el último elemento de la lista, lo que significa que quita "Julia" (el más reciente). Este método es útil cuando se necesita eliminar un elemento en particular de una lista. De nuevo, después de esta operación, vuelve a imprimir la lista para mostrar los cambios realizados.

Este fragmento de código ilustra las operaciones básicas de adición y eliminación que son fundamentales al trabajar con listas en Python, proporcionando una base sólida para entender cómo manejar datos dinámicamente.

`002-operaciones con listas.py`

```python
cliente1 = "Juan"
cliente2 = "Jorge"

clientes = ["Juan","Jorge","Jaime","Jose"]

print(clientes)

# Añadir un cliente

clientes.append("Julia")

print(clientes)

# Quito un elemento de la lista

clientes.pop()

print(clientes)
```

### clase cliente
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código muestra cómo se define y utiliza una clase básica llamada `Cliente` en Python. La clase `Cliente` contiene un método especial llamado `__init__`, que es el constructor de la clase. Este método inicializa los atributos (también conocidos como miembros o propiedades) de la clase, en este caso, `email`, `nombre` y `direccion`. Estos atributos se inicializan con el valor `None`.

Después de definir la clase, creamos una instancia de esta clase llamada `cliente1`. Una vez que tenemos esta instancia, podemos asignar valores a los atributos del objeto `cliente1`, como su correo electrónico, nombre y dirección. Esto demuestra cómo puedes crear objetos en Python y personalizarlos para representar entidades específicas, como un cliente en una base de datos o una lista de contactos.

Es importante entender este concepto porque permite organizar el código en estructuras lógicas que reflejan el modelo del problema real que estás resolviendo. En este caso, la clase `Cliente` es una representación abstracta de un cliente con sus atributos relevantes.

`003-clase cliente.py`

```python
# Declaramos una clase
class Cliente():
  def __init__(self):
    self.email = None
    self.nombre = None
    self.direccion = None
    
# Usamos la clase instanciando en un objeto
cliente1 = Cliente()
cliente1.email = "jose@empresa.com"
cliente1.nombre = "Jose"
cliente1.direccion = "La calle de Jose"



    
```

### le preguntamos al usuario
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código Python muestra cómo crear una clase llamada `Cliente` y luego utilizarla para pedir información al usuario sobre un cliente en particular. Primero, se define la clase `Cliente`, que contiene tres atributos: `email`, `nombre` y `direccion`. Estos atributos representan datos importantes de un cliente y están inicializados como `None`.

Después de definir la clase, se crea una instancia del objeto llamada `cliente1`. Luego, el programa utiliza la función `input()` para pedir al usuario que introduzca el email, nombre y dirección del cliente. Estos valores ingresados por el usuario se asignan a los atributos correspondientes del objeto `cliente1`.

Finalmente, el código imprime en pantalla toda la información sobre `cliente1`, es decir, muestra los datos recopilados del usuario de forma organizada. Esto es útil para verificar que la información fue capturada correctamente y está disponible dentro del objeto.

Este tipo de estructura ayuda a organizar mejor el código y facilita agregar más funcionalidades al programa en un futuro, como métodos para manipular o almacenar esta información sobre clientes.

`004-le preguntamos al usuario.py`

```python
# Declaramos una clase
class Cliente():
  def __init__(self):
    self.email = None
    self.nombre = None
    self.direccion = None
    
# Usamos la clase instanciando en un objeto
cliente1 = Cliente()
cliente1.email = input("Introduce el email del cliente: ")
cliente1.nombre = input("Introduce el nombre del cliente: ")
cliente1.direccion = input("Introduce la direccion del cliente: ")

print(cliente1)



    
```

### leemos los datos del cliente
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código crea una clase llamada `Cliente` en Python, que representa a un cliente con tres atributos básicos: email, nombre y dirección. Al crear la clase, también se define el método especial `__init__`, que es como una función de inicio para cada objeto creado basado en esta clase. En este método, inicializamos los atributos del cliente (email, nombre y dirección) a `None` porque aún no tienen valores específicos.

Luego, creamos un objeto llamado `cliente1` a partir de la clase `Cliente`. A través de la función `input`, pedimos al usuario que introduzca el email, el nombre y la dirección del cliente. Estos datos se asignan a los atributos correspondientes del objeto `cliente1`.

Finalmente, imprimimos el objeto `cliente1` en su totalidad (aunque por defecto esto solo mostrará una referencia de memoria) y luego mostramos los valores específicos de cada uno de sus atributos: email, nombre y dirección.

Este código es importante porque muestra cómo se crean e inicializan objetos en Python, cómo interactúan estos con el usuario para obtener datos y cómo acceder a la información almacenada dentro del objeto.

`005-leemos los datos del cliente.py`

```python
# Declaramos una clase
class Cliente():
  def __init__(self):
    self.email = None
    self.nombre = None
    self.direccion = None
    
# Usamos la clase instanciando en un objeto
cliente1 = Cliente()
cliente1.email = input("Introduce el email del cliente: ")
cliente1.nombre = input("Introduce el nombre del cliente: ")
cliente1.direccion = input("Introduce la direccion del cliente: ")

print(cliente1)
print(cliente1.email)
print(cliente1.nombre)
print(cliente1.direccion)



    
```

### crud
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código es una parte de un programa que gestiona operaciones básicas con clientes, utilizando las siglas CRUD (Crear, Leer, Actualizar y Eliminar). El programa presenta al usuario un menú interactivo donde puede seleccionar entre diferentes opciones para gestionar los datos de los clientes.

Primero, el programa muestra en pantalla una lista de opciones: insertar un cliente, listar todos los clientes, actualizar la información de un cliente o eliminar a un cliente. Luego, le pide al usuario que introduzca su elección y guarda esa entrada como un número entero en la variable `opcion`. Después, crea una lista vacía llamada `clientes`, que servirá para almacenar información sobre los clientes.

El código luego entra en un bucle infinito (`while True`), lo cual significa que el programa continuará ejecutándose hasta que se cumpla alguna condición de salida. Dentro del bucle, se verifica qué opción ha seleccionado el usuario y muestra un mensaje correspondiente para cada caso (1: insertar cliente, 2: listar clientes, 3: actualizar cliente, 4: eliminar cliente). Si el usuario no ha introducido ninguna de las opciones válidas, el programa saldrá del bucle con la instrucción `break`, terminando así su ejecución.

Esta estructura es fundamental en aplicaciones que requieren interacción continua con un usuario para realizar operaciones CRUD en una base de datos o lista de clientes.

`006-crud.py`

```python
# CRUD
# Create 
# Read
# Update
# Delete

print("Programa de gestión de clientes v0.1 Jose Vicente Carratala")

# Muestro opciones en el menú para el usuario
print("Selecciona una opción: ")
print("1.-Insertar un cliente")
print("2.-Listar clientes")
print("3.-Actualizar clientes")
print("4.-Eliminar clientes")

# Le permito escoger una opción
opcion = input("Escoge una opción: ")
opcion = int(opcion)   # Convierto a entero

clientes = []   # Creo una lista VACIA

while True: # Esto desata un bucle infinito pero controlado
  if opcion == 1:
    print("Vamos a insertar un cliente")
  elif opcion == 2:
    print("Vamos a ver los clientes")
  elif opcion == 3:
    print("Vamos a actualizar un cliente")
  elif opcion == 4:
    print("Vamos a eliminar un cliente")
  else:
    break
    
```

### crud insertar y listar
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código es una pequeña aplicación en Python que permite gestionar clientes utilizando las operaciones básicas de creación, lectura, actualización y eliminación (CRUD). En la parte inicial del programa, se muestra al usuario un menú con opciones para insertar, listar, actualizar y eliminar clientes. La lista `clientes` es utilizada para almacenar el nombre de cada cliente que se añade.

El bucle `while True:` crea una estructura que permite que el usuario interactúe continuamente con la aplicación hasta que decide salir del programa eligiendo una opción no válida (mayor a 4). Cuando el usuario selecciona la opción 1, se pide su nombre y este es añadido a la lista `clientes`. Si elige la opción 2, simplemente imprime en pantalla los nombres de todos los clientes almacenados en esa lista. Las opciones 3 y 4 no implementan ninguna acción específica en este código.

Esta estructura básica es muy útil para entender cómo manejar datos en aplicaciones más complejas, ya que permite ver cómo interactuar con una base de datos simple (en este caso, una simple lista) a través de un menú sencillo.

`007-crud insertar y listar.py`

```python
# CRUD
# Create 
# Read
# Update
# Delete

print("Programa de gestión de clientes v0.1 Jose Vicente Carratala")

# Muestro opciones en el menú para el usuario
print("Selecciona una opción: ")
print("1.-Insertar un cliente")
print("2.-Listar clientes")
print("3.-Actualizar clientes")
print("4.-Eliminar clientes")

clientes = []   # Creo una lista VACIA

while True: # Esto desata un bucle infinito pero controlado

  # Le permito escoger una opción
  opcion = input("Escoge una opción: ")
  opcion = int(opcion)   # Convierto a entero
  
  if opcion == 1:
    print("Vamos a insertar un cliente")
    nuevocliente = input("Introduce el nombre del cliente: ")
    clientes.append(nuevocliente)
  elif opcion == 2:
    print("Vamos a ver los clientes")
    print(clientes)
  elif opcion == 3:
    print("Vamos a actualizar un cliente")
  elif opcion == 4:
    print("Vamos a eliminar un cliente")
  else:
    break
    
```

### clase cliente
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es una aplicación simple en Python que permite gestionar clientes mediante las operaciones básicas de creación, lectura, actualización y eliminación (CRUD). En primer lugar, se define una clase llamada `Cliente` con tres atributos: `email`, `nombre` y `direccion`. Estos atributos son inicializados como `None` en el método `__init__()`, que es el constructor de la clase.

Después, el programa muestra un menú interactivo al usuario permitiéndole elegir entre cuatro opciones: insertar un cliente nuevo, listar los clientes existentes, actualizar datos de un cliente y eliminar un cliente. El código utiliza una lista vacía llamada `clientes` para almacenar instancias del objeto `Cliente`.

Cuando el usuario selecciona la opción 1 (Insertar un cliente), se crea una nueva instancia de la clase `Cliente`, se le solicita al usuario que introduzca los datos del cliente, y luego esa instancia es añadida a la lista `clientes`. Si el usuario elige la opción 2 (Listar clientes), simplemente se imprime en pantalla la lista actualizada de clientes.

El código está estructurado para permitir una fácil expansión en el futuro: las opciones 3 y 4 no implementan aún la funcionalidad completa, pero indican claramente qué acciones realizarían si fueran implementadas (actualizar datos del cliente y eliminar un cliente respectivamente).

Esta estructura es importante porque proporciona una base sólida para aprender sobre clases en Python y cómo manejar objetos de forma eficiente dentro de aplicaciones CRUD.

`008-clase cliente.py`

```python
# CRUD
# Create 
# Read
# Update
# Delete

class Cliente():
  def __init__(self):
    self.email = None
    self.nombre = None
    self.direccion = None

print("Programa de gestión de clientes v0.1 Jose Vicente Carratala")

# Muestro opciones en el menú para el usuario
print("Selecciona una opción: ")
print("1.-Insertar un cliente")
print("2.-Listar clientes")
print("3.-Actualizar clientes")
print("4.-Eliminar clientes")

clientes = []   # Creo una lista VACIA

while True: # Esto desata un bucle infinito pero controlado

  # Le permito escoger una opción
  opcion = input("Escoge una opción: ")
  opcion = int(opcion)   # Convierto a entero
  
  if opcion == 1:
    print("Vamos a insertar un cliente")
    # Primero creamos un nuevo cliente
    nuevocliente = Cliente()
    # Ahora le ponemos propiedades
    nuevocliente.nombre = input("Introduce el nombre del cliente: ")
    nuevocliente.email = input("Introduce el email del cliente: ")
    nuevocliente.direccion = input("Introduce la direccion del cliente: ")
    # A la lista de clientes añadimos nuestro cliente
    clientes.append(nuevocliente)
  elif opcion == 2:
    print("Vamos a ver los clientes")
    print(clientes)
  elif opcion == 3:
    print("Vamos a actualizar un cliente")
  elif opcion == 4:
    print("Vamos a eliminar un cliente")
  else:
    break
    
    
    
    
    
    
    
    
    
    
    
```

### Actividades propuestas

### Actividad 1: Crear una clase básica de usuario

**Descripción:** Diseña e implementa una clase `Usuario` que tenga atributos como nombre, email y dirección. Los estudiantes deben instanciar esta clase con datos proporcionados por el usuario a través del teclado.

**Objetivo:** Aprender la estructura básica de una clase en Python y cómo utilizar métodos `__init__`.

### Actividad 2: Modificar atributos de una instancia

**Descripción:** Los estudiantes deben modificar los valores iniciales de las propiedades (atributos) de un objeto instanciado a partir de la clase `Usuario` que crearon en la actividad anterior.

**Objetivo:** Entender cómo acceder y cambiar el estado de un objeto desde fuera de su definición.

### Actividad 3: Clase con métodos

**Descripción:** Añadir a la clase `Usuario` creada antes, varios métodos que permitan obtener y establecer los valores de los atributos. Los estudiantes deben probar estos métodos en sus respectivos objetos.

**Objetivo:** Familiarizarse con el concepto de métodos dentro de una clase y cómo facilitan la interacción con las propiedades del objeto.

### Actividad 4: Interfaz simple de usuario

**Descripción:** Crear un programa que permita al usuario interactuar con instancias de `Usuario`, pidiéndole que introduzca valores para los atributos a través de entradas de texto. El programa debe mostrar estos datos después.

**Objetivo:** Practicar la integración entre clases y entrada/salida del usuario en Python, además de entender cómo usar métodos definidos previamente.

### Actividad 5: Lista de usuarios

**Descripción:** Los estudiantes deben crear una lista para almacenar instancias múltiples de `Usuario`. Deben implementar funcionalidades básicas como agregar y listar los usuarios registrados.

**Objetivo:** Aprender a trabajar con listas que contienen objetos, así como entender cómo realizar operaciones CRUD (Crear, Leer, Actualizar, Borrar) en un contexto orientado a objetos.

### Actividad 6: Gestión de usuarios avanzada

**Descripción:** Extender la funcionalidad del programa anterior para permitir a los usuarios actualizar y eliminar información de una instancia `Usuario`. 

**Objetivo:** Mejorar las habilidades de manejo de listas con objetos, aprender sobre actualización y eliminación de datos en contextos orientados a objetos.

### Actividad 7: Manejar excepciones

**Descripción:** Los estudiantes deben incorporar control de errores básicos (manejo de excepciones) en su programa CRUD para tratar situaciones como inserción de valores no válidos o acceso a elementos que no existen en la lista.

**Objetivo:** Introducir conceptos básicos sobre el manejo de errores y excepciones en programas orientados a objetos, aprendiendo a hacer los programas más robustos.

### Actividad 8: Mejorar la interfaz del usuario

**Descripción:** Los estudiantes deben mejorar la interacción con el programa CRUD, proporcionando instrucciones claras para cada opción del menú y formatando mejor la salida de datos.

**Objetivo:** Refinar las habilidades en diseño de interfaces simples y eficaces, así como aprender a formatear y presentar información de manera legible.


<a id="creacion-de-propiedades"></a>
## Creación de propiedades

### Introducción a los ejercicios

En esta carpeta de ejercicios, se profundiza en el uso y manipulación de propiedades dentro de clases utilizando Python. Los ejercicios comienzan con una introducción básica sobre cómo declarar e inicializar propiedades en una clase, pasando luego a operaciones más avanzadas como la creación de listas de propiedades y lectura/escritura de estas propiedades en objetos instanciados. A medida que avanza el conjunto de ejercicios, se integra la gestión de datos mediante clases para desarrollar una aplicación sencilla de gestión de productos. Esta aplicación permite al usuario crear, listar, actualizar y eliminar productos, practicando así la creación de estructuras de datos complejas y la interacción con objetos de clase en un contexto aplicado.

Estos ejercicios son ideales para estudiantes que buscan refinar sus habilidades en el manejo de clases y objetos en Python, enfocándose tanto en la sintaxis como en la aplicación práctica del paradigma orientado a objetos.

### Repaso de propiedades
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código define una clase llamada `Cliente` en Python. Una clase es como un modelo o plantilla para crear objetos, que son instancias concretas de ese modelo. En esta clase, se utiliza el método especial `__init__`, que actúa como constructor y se ejecuta automáticamente cuando se crea un nuevo objeto de la clase `Cliente`.

Dentro del método `__init__`, se inicializan dos propiedades: `nombre` y `edad`. Estas propiedades son atributos que cada instancia de la clase `Cliente` tendrá. Se les asigna valores iniciales: `nombre` es una cadena vacía (`""`) y `edad` es un número entero igual a cero (0). Esto significa que cuando se crea un nuevo objeto de tipo `Cliente`, estos dos atributos estarán disponibles y podrás cambiar sus valores según sea necesario.

Las propiedades dentro de la clase son importantes porque encapsulan los datos relevantes para cada instancia del cliente, permitiendo manipular y proteger esta información a través de métodos definidos en la clase.

`001-Repaso de propiedades.py`

```python
# Las propiedades son como las variables PERO dentro de una clase

class Cliente():
  def __init__(self):
    self.nombre = ""
    self.edad = 0
    
```

### las propiedades pueden ser arrays
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código define una clase en Python llamada `Cliente`. Una clase es como un modelo o plantilla para crear objetos, que son instancias concretas basadas en esa plantilla. En este caso, la clase tiene tres propiedades: `nombre`, `edad` y `telefonos`.

La propiedad `nombre` es una cadena vacía (`""`), lo que significa que inicialmente no hay ningún nombre asignado a un cliente nuevo. La propiedad `edad` se inicializa como `0`, indicando que también está sin especificar al principio. Lo interesante aquí es la propiedad `telefonos`, que es una lista (o array) con dos elementos: `'543534'` y `'5345345'`. Esto significa que puedes almacenar múltiples números de teléfono para un solo cliente desde el inicio, en lugar de añadirlos uno por uno después.

Este código es importante porque muestra cómo inicializar una clase con diferentes tipos de datos (cadenas, enteros y listas), lo cual es fundamental al crear objetos en Python.

`002-las propiedades pueden ser arrays.py`

```python
# Las propiedades son como las variables PERO dentro de una clase

class Cliente():
  def __init__(self):
    self.nombre = ""
    self.edad = 0
    self.telefonos = ['543534','5345345']
    
```

### escribir las propiedades de una clase
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código te muestra cómo crear y utilizar propiedades dentro de una clase en Python. La clase `Cliente` se define con tres propiedades: `nombre`, que es una cadena vacía inicialmente, `edad`, que comienza siendo 0, y `telefonos`, que es una lista predefinida con dos números telefónicos.

Después de definir la clase, el código crea una instancia de esta clase llamada `cliente1`. Luego, se le asigna un valor a la propiedad `nombre` de este objeto específico, cambiándolo de su estado inicial (una cadena vacía) a "Jose Vicente". Esto demuestra cómo puedes modificar las propiedades de los objetos creados desde una clase para almacenar datos específicos relacionados con cada instancia del objeto.

Este ejemplo es importante porque muestra la flexibilidad de las clases en Python: puedes definir un conjunto estándar de atributos y luego personalizar esos atributos según sea necesario para cada instancia única.

`003-escribir las propiedades de una clase.py`

```python
# Las propiedades son como las variables PERO dentro de una clase

class Cliente():
  def __init__(self):
    self.nombre = ""
    self.edad = 0
    self.telefonos = ['543534','5345345']
    
# Ahora instancio un nuevo objeto
cliente1 = Cliente()

# Ahora le escribo una propiedad

cliente1.nombre = "Jose Vicente"

    
```

### leemos propiedad
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código en Python está mostrando cómo trabajar con propiedades dentro de una clase. En este caso, la clase se llama `Cliente` y contiene tres propiedades: `nombre`, que es un string vacío inicialmente; `edad`, que es un número entero 0 por defecto; y `telefonos`, que es una lista con dos números telefónicos predefinidos.

El código crea una instancia de la clase `Cliente` llamada `cliente1`. Luego, cambia el valor del atributo `nombre` de esta instancia a "Jose Vicente". Finalmente, imprime en pantalla el nombre del cliente recién asignado. Este ejemplo demuestra cómo puedes acceder y modificar las propiedades de un objeto una vez que se ha creado.

Es importante entender este concepto porque te permite gestionar datos de manera estructurada dentro de objetos, lo cual es fundamental para desarrollar aplicaciones más complejas en Python.

`004-leemos propiedad.py`

```python
# Las propiedades son como las variables PERO dentro de una clase

class Cliente():
  def __init__(self):
    self.nombre = ""
    self.edad = 0
    self.telefonos = ['543534','5345345']
    
# Ahora instancio un nuevo objeto
cliente1 = Cliente()

# Ahora le escribo una propiedad

cliente1.nombre = "Jose Vicente"

print("El nombre del cliente es:",cliente1.nombre)
    
```

### los telefonos deben ser una lista
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código Python muestra cómo crear una clase llamada `Cliente` y luego utilizarla para gestionar información de un cliente. La clase tiene tres propiedades: `nombre`, que almacena el nombre del cliente; `edad`, que almacena la edad como un número entero; y `telefonos`, que es una lista vacía donde se pueden guardar varios números telefónicos.

En primer lugar, se crea una instancia de la clase `Cliente` llamada `cliente1`. Luego, a esta instancia se le asigna el nombre "Jose Vicente" a través del atributo `nombre`.

Finalmente, se añaden dos números telefónicos a la lista `telefonos` utilizando el método `append()`, que agrega elementos al final de una lista. El código imprime en pantalla tanto el nombre como los teléfonos del cliente.

Este tipo de estructura es útil cuando necesitas manejar múltiples datos para un mismo objeto, permitiendo así organizar la información de manera clara y acceder a ella fácilmente.

`005-los telefonos deben ser una lista.py`

```python
# Las propiedades son como las variables PERO dentro de una clase

class Cliente():
  def __init__(self):
    self.nombre = ""
    self.edad = 0
    self.telefonos = []
    
# Ahora instancio un nuevo objeto
cliente1 = Cliente()

# Ahora le escribo una propiedad

cliente1.nombre = "Jose Vicente"

print("El nombre del cliente es:",cliente1.nombre)

cliente1.telefonos.append("63354333")
cliente1.telefonos.append("65436456")

print(cliente1.telefonos)
    
```

### aplicacion de productos
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento es el encabezado o prologue del archivo de Python llamado `006-aplicacion de productos.py`. En él, se proporcionan detalles sobre la naturaleza y el propósito del código que sigue. El comentario inicial identifica al autor del código (en este caso, "Jose Vicente Carratala") y también incluye información sobre los derechos de autor.

El encabezado también describe brevemente lo que hace la aplicación: en este caso, se trata de una aplicación para gestionar productos. Este tipo de descripción es útil porque ayuda a otros programadores (o incluso al propio autor cuando revisa el código después de un tiempo) a entender rápidamente el propósito del programa sin tener que leer todo el código.

Es importante incluir esta información en los archivos de código, especialmente en proyectos más grandes o colaborativos, para mantener la organización y facilitar la comprensión.

`006-aplicacion de productos.py`

```python
'''
  Aplicación de gestión de productos
  (c) 2025 Jose Vicente Carratala
  Esta aplicación gestiona productos
'''

# En esta aplicación no aplica importar librerías
    
```

### funciones y clases
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es el inicio de una aplicación en Python diseñada para gestionar productos. La documentación al principio describe que se trata de un programa creado por Jose Vicente Carratala en el año 2025 y que tiene como objetivo administrar productos, aunque no se especifican más detalles sobre las funcionalidades exactas.

La parte central del código define una clase llamada `Producto`. Esta clase es muy básica y contiene solo dos propiedades: `nombre` y `precio`, ambas inicializadas en el método especial `__init__()`. Este método se ejecuta automáticamente cada vez que se crea un nuevo objeto de la clase `Producto`. En este caso, `self.nombre` está inicializado como una cadena vacía (`""`) y `self.precio` es establecido a 0. Esto significa que cuando creas un nuevo producto, deberás asignarle valores específicos a estas propiedades antes de usar el objeto.

Este código forma la base para desarrollar funcionalidades adicionales en torno a la gestión de productos, como añadir métodos para establecer y obtener los datos del producto, listar todos los productos disponibles o gestionar inventarios.

`007-funciones y clases.py`

```python
'''
  Aplicación de gestión de productos
  (c) 2025 Jose Vicente Carratala
  Esta aplicación gestiona productos
'''

# En esta aplicación no aplica importar librerías

# Definimos clases y funciones

class Producto():
  def __init__(self):
    self.nombre = ""
    self.precio = 0
    

    
```

### creamos las variables globales
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es una parte del inicio de una aplicación en Python diseñada para gestionar productos. La idea principal aquí es establecer la estructura básica de la clase `Producto` y crear una variable global llamada `productos`.

En primer lugar, se define la clase `Producto`. Esta clase tiene un método especial llamado `__init__`, que se ejecuta automáticamente cuando se crea un nuevo objeto de tipo `Producto`. En este caso, el método inicializa dos propiedades: `nombre` y `precio`, estableciéndolas en valores vacíos (`""`) y cero (`0`), respectivamente. Esto significa que cada vez que se cree una nueva instancia de la clase `Producto`, estos atributos comenzarán con estos valores por defecto.

Luego, fuera de la clase, se crea una lista llamada `productos`. Esta lista global es probablemente utilizada para almacenar instancias (objetos) de la clase `Producto` que serán creadas más adelante en el programa. De esta manera, todos los métodos y funciones definidos después podrán acceder a esta lista y manipular las diferentes entradas de productos.

Esta estructura básica es importante porque permite organizar el código de una forma clara y modular, permitiendo gestionar fácilmente la creación y almacenamiento de objetos `Producto` en toda la aplicación.

`008-creamos las variables globales.py`

```python
'''
  Aplicación de gestión de productos
  (c) 2025 Jose Vicente Carratala
  Esta aplicación gestiona productos
'''

# En esta aplicación no aplica importar librerías

# Definimos clases y funciones

class Producto():
  def __init__(self):
    self.nombre = ""
    self.precio = 0
    
# Creamos las variables globales

productos = []


    
```

### pseudocodigo
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es una plantilla para una aplicación en Python que gestiona productos. La idea principal es crear una estructura básica para administrar un inventario o lista de productos. Vamos a desglosarlo:

1. **Definición de la clase Producto**: Se define una clase llamada `Producto` con dos atributos: `nombre` y `precio`. El método `__init__()` se utiliza para inicializar estos atributos cuando se crea un nuevo objeto de tipo `Producto`.

2. **Variable global productos**: Se declara una lista vacía llamada `productos`, que será utilizada para almacenar los objetos de la clase `Producto`.

3. **Interfaz de usuario básica**: El código comenta sobre lanzar un mensaje de bienvenida al usuario y mostrarle las opciones disponibles (crear, listar, actualizar o eliminar productos). Aunque no se proporciona el detalle del flujo exacto de cómo manejar estas opciones, es claro que la aplicación espera recibir una entrada del usuario para determinar qué acción realizar.

Este código es importante porque establece los cimientos para desarrollar una aplicación interactiva. La clase `Producto` permite encapsular toda la información relacionada con un producto en un objeto; mientras que el uso de una lista global (`productos`) facilita gestionar múltiples objetos de tipo `Producto`. Esta estructura permite a estudiantes comprender cómo diseñar clases y utilizar variables globales para manejar datos.

`009-pseudocodigo.py`

```python
'''
  Aplicación de gestión de productos
  (c) 2025 Jose Vicente Carratala
  Esta aplicación gestiona productos
'''

# En esta aplicación no aplica importar librerías

# Definimos clases y funciones

class Producto():
  def __init__(self):
    self.nombre = ""
    self.precio = 0
    
# Creamos las variables globales

productos = []

# Primero lanzamos un mensaje de bienvenida
# Le mostramos al usuario las opciones que tiene
# En función de la opción que coja el usuario
  # O bien creamos un nuevo producto
  # O bien listamos los productos
  # O bien actualizamos los productos
  # O bien eliminamos los productos
    
```

### voy creando el codigo
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es el inicio del desarrollo de una aplicación en Python para gestionar productos. La aplicación tiene como objetivo permitir al usuario realizar operaciones básicas con productos, tales como crear nuevos productos, listar existentes, actualizar o eliminar.

El código comienza definiendo una clase llamada `Producto`, que contiene dos propiedades: `nombre` y `precio`. Estas propiedades se inicializan en el método `__init__` de la clase, donde se establecen los valores iniciales como cadena vacía para `nombre` y cero para `precio`.

A continuación, se declara una lista vacía llamada `productos`, que servirá para almacenar objetos de tipo `Producto`. Después, el programa imprime un mensaje de bienvenida al usuario.

El comentario final indica que el siguiente paso será mostrar al usuario las opciones disponibles: crear nuevos productos, listar los existentes, actualizarlos o eliminarlos. Estas acciones se gestionarán basándose en la elección del usuario y se repetirán hasta que el usuario decida salir del programa.

Esta estructura básica proporciona un marco para una aplicación más completa que permitirá a los usuarios interactuar con los productos de manera eficiente, utilizando clases y funciones.

`010-voy creando el codigo.py`

```python
'''
  Aplicación de gestión de productos
  (c) 2025 Jose Vicente Carratala
  Esta aplicación gestiona productos
'''

# En esta aplicación no aplica importar librerías

# Definimos clases y funciones

class Producto():
  def __init__(self):
    self.nombre = ""
    self.precio = 0
    
# Creamos las variables globales

productos = []

# Primero lanzamos un mensaje de bienvenida
print("Gestor de productos v0.1 Jose Vicente Carratala")
# Le mostramos al usuario las opciones que tiene
# En función de la opción que coja el usuario
  # O bien creamos un nuevo producto
  # O bien listamos los productos
  # O bien actualizamos los productos
  # O bien eliminamos los productos
# Y volvemos a repetir
    
```

### le mostramos al usuario las opciones que tiene
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es una parte inicial de una aplicación simple para gestionar productos. La aplicación comienza mostrando un mensaje de bienvenida al usuario y luego presenta varias opciones que el usuario puede seleccionar, como crear, listar, actualizar o eliminar productos.

El código define una clase llamada `Producto` con dos propiedades: `nombre` y `precio`. Aunque en este punto solo se inicializan estas propiedades sin ninguna lógica adicional, forman la base para que más adelante puedas añadir funcionalidades relacionadas con los productos.

Después de definir la clase, el código crea una lista vacía llamada `productos`, que servirá como contenedor para almacenar objetos del tipo `Producto`.

El programa finaliza mostrando un menú interactivo al usuario. Este menú permite al usuario elegir entre diferentes operaciones (como crear o listar productos), y aunque no se implementa la lógica completa de estas opciones en este código, se describe brevemente lo que debería hacer cada opción seleccionada.

Esta parte del programa es crucial porque establece el marco para que los usuarios interactúen con la aplicación y permite a continuación desarrollar las funciones necesarias para manejar estos productos de manera efectiva.

`011-le mostramos al usuario las opciones que tiene.py`

```python
'''
  Aplicación de gestión de productos
  (c) 2025 Jose Vicente Carratala
  Esta aplicación gestiona productos
'''

# En esta aplicación no aplica importar librerías

# Definimos clases y funciones

class Producto():
  def __init__(self):
    self.nombre = ""
    self.precio = 0
    
# Creamos las variables globales

productos = []

# Primero lanzamos un mensaje de bienvenida
print("Gestor de productos v0.1 Jose Vicente Carratala")
# Le mostramos al usuario las opciones que tiene
print("Selecciona una opción:")
print("1.-Crear un nuevo producto")
print("2.-Listar productos")
print("3.-Actualizar productos")
print("4.-Eliminar productos")
# En función de la opción que coja el usuario
  # O bien creamos un nuevo producto
  # O bien listamos los productos
  # O bien actualizamos los productos
  # O bien eliminamos los productos
# Y volvemos a repetir
    
```

### tomamos la entrada de usuario
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código es una aplicación sencilla en Python que gestiona productos básicos. La aplicación muestra un menú con opciones al usuario y permite realizar acciones como crear, listar, actualizar o eliminar productos. En el código, se define una clase llamada `Producto` que contiene dos propiedades: `nombre` y `precio`. Estas propiedades son inicializadas en el método `__init__`, estableciendo el nombre del producto a una cadena vacía y el precio a cero.

Además, el programa crea una lista global llamada `productos` donde se almacenarán los objetos de la clase `Producto`. El código principal imprime un mensaje de bienvenida y muestra al usuario las opciones disponibles. Luego, utiliza la función `input()` para tomar la entrada del usuario sobre qué acción desea realizar.

El fragmento proporcionado no implementa completamente las acciones que menciona (crear, listar, actualizar, eliminar), sino que solo establece el marco y la interacción inicial con el usuario. Es importante porque establece una estructura básica de cómo manejar un sistema en capas: primero se define la lógica del negocio (clase `Producto`), luego se definen las variables globales necesarias, y finalmente se gestiona la entrada y salida al usuario.

Esta estructura ayuda a organizar el código de manera clara y mantenerlo modular, lo cual es crucial cuando se trabaja en proyectos más grandes o complejos.

`012-tomamos la entrada de usuario.py`

```python
'''
  Aplicación de gestión de productos
  (c) 2025 Jose Vicente Carratala
  Esta aplicación gestiona productos
'''

# En esta aplicación no aplica importar librerías

# Definimos clases y funciones

class Producto():
  def __init__(self):
    self.nombre = ""
    self.precio = 0
    
# Creamos las variables globales

productos = []

# Primero lanzamos un mensaje de bienvenida
print("Gestor de productos v0.1 Jose Vicente Carratala")
# Le mostramos al usuario las opciones que tiene
print("Selecciona una opción:")
print("1.-Crear un nuevo producto")
print("2.-Listar productos")
print("3.-Actualizar productos")
print("4.-Eliminar productos")
opcion = int(input("Escoge tu opción: "))
# En función de la opción que coja el usuario
  # O bien creamos un nuevo producto
  # O bien listamos los productos
  # O bien actualizamos los productos
  # O bien eliminamos los productos
# Y volvemos a repetir
    
```

### estructura if
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es una aplicación sencilla que gestiona diferentes operaciones con productos. La aplicación muestra un menú al usuario donde puede elegir entre varias opciones: crear un nuevo producto, listar los productos existentes, actualizar información sobre los productos o eliminar productos. El código utiliza una estructura condicional `if-elif-else` para ejecutar acciones específicas basadas en la opción que elige el usuario.

El programa comienza importando la clase `Producto`, que tiene dos propiedades: `nombre` y `precio`. Posteriormente, se define una lista vacía llamada `productos`, donde se almacenarán los objetos de tipo `Producto`.

Después del menú interactivo que muestra al usuario las opciones disponibles, el programa solicita al usuario que ingrese su elección. Dependiendo del número ingresado por el usuario (1 para crear un producto, 2 para listar productos, etc.), la aplicación imprime un mensaje correspondiente indicando qué acción va a realizar.

Esta estructura es importante porque permite al usuario interactuar con los datos de manera controlada y dirigida, permitiendo así una gestión sencilla pero efectiva del inventario de productos.

`013-estructura if.py`

```python
'''
  Aplicación de gestión de productos
  (c) 2025 Jose Vicente Carratala
  Esta aplicación gestiona productos
'''

# En esta aplicación no aplica importar librerías

# Definimos clases y funciones

class Producto():
  def __init__(self):
    self.nombre = ""
    self.precio = 0
    
# Creamos las variables globales

productos = []

# Primero lanzamos un mensaje de bienvenida
print("Gestor de productos v0.1 Jose Vicente Carratala")
# Le mostramos al usuario las opciones que tiene
print("Selecciona una opción:")
print("1.-Crear un nuevo producto")
print("2.-Listar productos")
print("3.-Actualizar productos")
print("4.-Eliminar productos")
opcion = int(input("Escoge tu opción: "))
# En función de la opción que coja el usuario
if opcion == 1:
  # O bien creamos un nuevo producto
  print("Creamos un nuevo producto")
elif opcion == 2:
  # O bien listamos los productos
  print("Vamos a listar los productos")
elif opcion == 3:
  # O bien actualizamos los productos
  print("Vamos a actualizar productos")
elif opcion == 4:
  # O bien eliminamos los productos
  print("Vamos a eliminar productos")
# Y volvemos a repetir
    
```

### bucle infinito
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código Python es una aplicación simple para gestionar productos en un almacén o tienda. El programa se inicia mostrando un mensaje de bienvenida y luego entra en un bucle infinito que permite al usuario seleccionar diferentes acciones como crear, listar, actualizar o eliminar productos.

El bucle `while True` asegura que el menú principal del sistema esté siempre disponible hasta que el programa sea cerrado manualmente. Dentro del bucle, se muestra una lista de opciones al usuario y solicita su elección a través de la función `input()`. Dependiendo de la opción elegida (1, 2, 3 o 4), el programa imprime un mensaje correspondiente para indicar qué acción va a realizar. Sin embargo, en este ejemplo, no se implementa la lógica necesaria para realmente crear, listar, actualizar o eliminar productos; simplemente muestra mensajes informativos.

Este tipo de bucle infinito con menú es una estructura común en aplicaciones interactivas porque permite al usuario interactuar repetidamente hasta que decida finalizar el programa. Sin embargo, esta implementación no incluye la funcionalidad real para manipular los productos y solo sirve como un punto de partida o esqueleto para desarrollar las funciones necesarias.

`014-bucle infinito.py`

```python
'''
  Aplicación de gestión de productos
  (c) 2025 Jose Vicente Carratala
  Esta aplicación gestiona productos
'''

# En esta aplicación no aplica importar librerías

# Definimos clases y funciones

class Producto():
  def __init__(self):
    self.nombre = ""
    self.precio = 0
    
# Creamos las variables globales

productos = []

# Primero lanzamos un mensaje de bienvenida
print("Gestor de productos v0.1 Jose Vicente Carratala")
# Metemos al usuario en un bucle infinito
while True:
  # Le mostramos al usuario las opciones que tiene
  print("Selecciona una opción:")
  print("1.-Crear un nuevo producto")
  print("2.-Listar productos")
  print("3.-Actualizar productos")
  print("4.-Eliminar productos")
  opcion = int(input("Escoge tu opción: "))
  # En función de la opción que coja el usuario
  if opcion == 1:
    # O bien creamos un nuevo producto
    print("Creamos un nuevo producto")
  elif opcion == 2:
    # O bien listamos los productos
    print("Vamos a listar los productos")
  elif opcion == 3:
    # O bien actualizamos los productos
    print("Vamos a actualizar productos")
  elif opcion == 4:
    # O bien eliminamos los productos
    print("Vamos a eliminar productos")
  # Y volvemos a repetir
    
```

### desarrollo la insercion de producto
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código es una aplicación simple en Python que permite gestionar productos básicos. La aplicación se basa en un bucle infinito donde el usuario puede elegir entre varias opciones: crear, listar, actualizar o eliminar productos. 

La clase `Producto` define los atributos `nombre` y `precio`, lo cual significa que cada producto tendrá estos dos datos asociados a él. Cuando el usuario selecciona la opción para crear un nuevo producto, se instancia una nueva clase `Producto`, se solicitan al usuario tanto el nombre como el precio del producto, y luego ese producto se añade a una lista global llamada `productos`.

El programa imprime un menú de opciones y dependiendo de lo que escoja el usuario, ejecuta la acción correspondiente. Sin embargo, solo implementa completamente la opción para crear un nuevo producto; las otras acciones (listar, actualizar y eliminar productos) están marcadas con mensajes descriptivos pero no tienen código detallado.

Este tipo de estructura es común en aplicaciones menú-driven donde el usuario interactúa seleccionando opciones hasta que decide terminar. Es importante notar que esta aplicación podría beneficiarse de ser más robusta al manejar errores, como asegurarse de que los datos ingresados sean del tipo correcto (por ejemplo, garantizar que `precio` sea un número y no una cadena).

`015-desarrollo la insercion de producto.py`

```python
'''
  Aplicación de gestión de productos
  (c) 2025 Jose Vicente Carratala
  Esta aplicación gestiona productos
'''

# En esta aplicación no aplica importar librerías

# Definimos clases y funciones

class Producto():
  def __init__(self):
    self.nombre = ""
    self.precio = 0
    
# Creamos las variables globales

productos = []

# Primero lanzamos un mensaje de bienvenida
print("Gestor de productos v0.1 Jose Vicente Carratala")
# Metemos al usuario en un bucle infinito
while True:
  # Le mostramos al usuario las opciones que tiene
  print("Selecciona una opción:")
  print("1.-Crear un nuevo producto")
  print("2.-Listar productos")
  print("3.-Actualizar productos")
  print("4.-Eliminar productos")
  opcion = int(input("Escoge tu opción: "))
  # En función de la opción que coja el usuario
  if opcion == 1:
    # O bien creamos un nuevo producto
    print("Creamos un nuevo producto")
    producto1 = Producto()           # Creo una nueva instancia de la clase
    producto1.nombre = input("Introduce el nombre del producto: ")   # Escribo la propiedad
    producto1.precio = input("Introduce el precio del producto: ")   # Escribo la propiedad
    productos.append(producto1)      # Y a la la lista de productos le añado el producto
  elif opcion == 2:
    # O bien listamos los productos
    print("Vamos a listar los productos")
  elif opcion == 3:
    # O bien actualizamos los productos
    print("Vamos a actualizar productos")
  elif opcion == 4:
    # O bien eliminamos los productos
    print("Vamos a eliminar productos")
  # Y volvemos a repetir
    
```

### Actividades propuestas

1. **Clase Cliente: Propiedades y Métodos Básicos**
   - **Descripción:** Crea una clase `Cliente` con propiedades como nombre, edad y telefonos (una lista). Implementa métodos para agregar y eliminar números telefónicos.

2. **Gestor de Clientes**
   - **Descripción:** Diseña un programa que gestione clientes a través de diferentes operaciones: agregar cliente, listar clientes, actualizar datos del cliente, eliminar cliente.

3. **Aplicación de Gestión de Productos (Parte 1)**
   - **Descripción:** Crea una clase `Producto` con atributos nombre y precio. Implementa la creación de un producto nuevo y muestra cómo almacenarlo en una lista global.

4. **Interfaz del Usuario para Gestión de Productos**
   - **Descripción:** Desarrolla el menú principal que permita al usuario seleccionar entre opciones como crear, listar, actualizar o eliminar productos.

5. **Validación de Entradas de Usuarios**
   - **Descripción:** Asegura la validación de las entradas del usuario en las operaciones CRUD (Crear, Leer, Actualizar y Eliminar) para evitar errores en tiempo de ejecución.

6. **Aplicación de Gestión de Productos (Parte 2)**
   - **Descripción:** Amplía el menú principal añadiendo la lógica necesaria para cada opción seleccionada por el usuario, incluyendo la manipulación de datos y almacenamiento en una lista.

7. **Bucle Infinito con Gestión de Productos**
   - **Descripción:** Desarrolla un bucle infinito que permita al usuario interactuar repetidamente con las opciones del menú hasta que decida salir voluntariamente.

8. **Ejercicio Práctico: Implementación Final del Proyecto**
   - **Descripción:** Combina todos los componentes anteriores para crear una aplicación funcional de gestión de productos con interacción completa del usuario, incluyendo la implementación de operaciones CRUD y manejo de excepciones.


<a id="creacion-de-metodos"></a>
## Creación de métodos

### Introducción a los ejercicios

Esta carpeta contiene una serie de ejercicios que te ayudarán a entender y practicar el uso de métodos en la programación orientada a objetos con Python. Los ejercicios van desde conceptos básicos como definir propiedades y métodos, hasta prácticas más avanzadas como encapsulamiento (usando setters y getters) y manejo de listas de objetos. A través de estos ejercicios, aprenderás cómo proteger la integridad de tus datos utilizando variables privadas y validaciones en los métodos setter, así como cómo interactuar con colecciones de objetos para realizar operaciones CRUD (Crear, Leer, Actualizar, Eliminar).

### repaso de los metodos
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código Python muestra cómo crear y usar una clase simple llamada `Gato`. La clase tiene dos componentes principales: un método constructor (`__init__`) y un método llamado `maulla`.

El método constructor inicializa la propiedad de instancia `color`, que es una cadena vacía en este caso. Esta propiedad se usa para almacenar el color del gato, aunque no está siendo establecida dentro del método constructor.

El método `maulla` es una acción que devuelve un string `"miau"`. Este método simula el sonido que hace un gato cuando maulla.

Luego de definir la clase, se crea una instancia de la clase `Gato` llamada `gato1` y se establece su color en "naranja". Finalmente, se llama al método `maulla()` para que el objeto `gato1` produzca un sonido.

Este código es importante porque demuestra cómo definir clases con atributos y métodos, así como cómo crear instancias de estas clases y acceder a sus propiedades y métodos. Es una introducción básica al concepto de programación orientada a objetos en Python.

`001-repaso de los metodos.py`

```python
class Gato():
  def __init__(self):
    self.color = ""     # Esto es una propiedad
  
  def maulla(self):     # Esto es un método (es una acción)
    return "miau"
    
    
gato1 = Gato()
gato1.color = "naranja"   # Aquí seteamos una propiedad
print(gato1.maulla())     # Aquí llamamos a un método
```

### metodo set
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código en Python muestra cómo definir y utilizar un método llamado `setColor` que actúa como un setter para cambiar el valor de la propiedad `color` de la clase `Gato`. En primer lugar, se crea una clase `Gato` con dos métodos: `maulla`, que simplemente retorna "miau", y `setColor`, el cual recibe un parámetro llamado `nuevocolor` para establecer el color del gato. El método `setColor` es importante porque permite controlar cómo se cambia la propiedad `color`. Por ejemplo, podrías añadir lógica en este método para verificar que el nuevo valor sea válido.

A continuación, el código muestra dos formas de cambiar el color del primer objeto `gato1`, aunque solo la segunda forma (`setColor("naranja")`) es considerada una buena práctica. Directamente asignar un valor a la propiedad (`gato1.color = "naranja"`) no permite tener control sobre cómo se realiza este cambio, mientras que utilizar el método `setColor` ofrece la posibilidad de añadir validaciones y otros comportamientos adicionales cuando se cambia el color del gato.

Este enfoque es crucial para mantener una buena estructura de código y permitir modificaciones futuras sin alterar directamente las propiedades de los objetos.

`002-metodo set.py`

```python
class Gato():
  def __init__(self):
    self.color = ""     # Esto es una propiedad
  
  def maulla(self):     # Esto es un método (es una acción)
    return "miau"
    
  def setColor(self,nuevocolor):   # Defino un setter - el método es el responsable de cambiar la
    # Por ejemplo aquí podría validar si el color es un color válido para un gato
    self.color = nuevocolor         # Y cambio la propiedad
    
    
gato1 = Gato()
gato1.color = "naranja"   # Aquí seteamos una propiedad directamente (no es buena práctica)

gato1.setColor("naranja") # Esto es una práctica mucho mejor
```

### metodo getter
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código define una clase llamada `Gato` que incluye propiedades y métodos. La propiedad más importante es `color`, que representa el color del gato. En la clase, también se definen dos métodos: `setColor()` y `getColor()`. Estos métodos son conocidos como setters y getters respectivamente.

El método `setColor(nuevocolor)` permite establecer el valor de la propiedad `color` en un nuevo valor que recibe como parámetro. Esto es preferible a asignar directamente a `gato1.color = "naranja"`, ya que el setter puede contener validaciones adicionales para asegurar que se utilicen valores válidos.

Por otro lado, el método `getColor()` devuelve el valor actual de la propiedad `color`. Este enfoque es preferible al acceso directo a través de `gato1.color` porque permite encapsular el manejo del atributo dentro del objeto, manteniendo un alto nivel de abstracción y permitiendo cambios internos sin afectar a las partes que usan la clase.

En resumen, este código demuestra cómo usar setters y getters para mejorar la seguridad y flexibilidad en la gestión de propiedades de objetos.

`003-metodo getter.py`

```python
class Gato():
  def __init__(self):
    self.color = ""     # Esto es una propiedad
  
  def maulla(self):     # Esto es un método (es una acción)
    return "miau"
    
  def setColor(self,nuevocolor):   # Defino un setter - el método es el responsable de cambiar la
    # Por ejemplo aquí podría validar si el color es un color válido para un gato
    self.color = nuevocolor         # Y cambio la propiedad
  
  def getColor(self):
    # Una vez más, aquí podría poner validaciones si lo quisiera
    return self.color
    
    
gato1 = Gato()
gato1.color = "naranja"   # Aquí seteamos una propiedad directamente (no es buena práctica)

gato1.setColor("naranja") # Esto es una práctica mucho mejor

print(gato1.color)      # Acceso directo, se puede pero no se recomienda

print(gato1.getColor()) # Acceso mediante método, se recomienda
```

### defino propiedad privada
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código crea una clase llamada `Gato` en Python. Dentro de esta clase, hay un método especial llamado `__init__`, que se ejecuta automáticamente cuando se crea una nueva instancia de la clase (es decir, cuando se crea un nuevo objeto gato). En este método, se define una propiedad privada llamada `__color` y se le asigna el valor "naranja". La doble subrayada al principio del nombre (`__color`) indica que esta variable es privada, lo que significa que no debería ser accedida o modificada desde fuera de la clase.

Después de definir la clase, se crea una instancia llamada `gato1`. Sin embargo, cuando se intenta imprimir el valor de `gato1.__color`, Python genera un error porque las propiedades privadas no pueden ser accesibles directamente desde fuera de la clase. Este ejemplo ilustra cómo proteger ciertos aspectos del objeto para evitar que sean manipulados sin controlar, lo cual es una práctica común en programación orientada a objetos para mantener la integridad del estado del objeto.

Este tipo de encapsulamiento ayuda a prevenir errores y mejora la seguridad del código al restringir el acceso directo a ciertas partes de los objetos.

`004-defino propiedad privada.py`

```python
class Gato():
  def __init__(self):
    self.__color = "naranja"     # Esto es una propiedad privada (contrapuesta a pública)
    
gato1 = Gato()

print(gato1.__color)
  
```

### Clase cuenta bancaria
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código define una clase llamada `CuentaBancaria` en Python. La función principal de este bloque es inicializar la clase cuando se crea un nuevo objeto, gracias al método `__init__`. Este método establece dos atributos iniciales para cada cuenta bancaria: el saldo (`saldo`) y el nombre del cliente (`cliente`). Al crear una nueva instancia de `CuentaBancaria`, automáticamente se asigna un saldo inicial de 0 (lo que significa que la cuenta empieza sin dinero) y el nombre del cliente permanece vacío hasta que se proporciona información específica para ese cliente. Este tipo de estructura es fundamental en el desarrollo orientado a objetos, ya que permite crear objetos con características predefinidas antes incluso de llenar todos los detalles específicos del cliente o la cuenta.

`005-Clase cuenta bancaria.py`

```python
class CuentaBancaria():
  def __init__(self):
    self.saldo = 0
    self.cliente = ""
    
```

### convertir en privadas
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código Python define una clase llamada `CuentaBancaria` que representa una cuenta bancaria básica. La clase tiene un método especial llamado `__init__`, que se ejecuta automáticamente cuando creamos un objeto de esta clase. En este método, inicializamos dos atributos privados: `__saldo` y `__cliente`. El saldo (`__saldo`) se establece en 0, lo que indica que la cuenta comienza sin dinero, y el nombre del cliente (`__cliente`) está vacío porque no ha sido proporcionado.

Además de los atributos, la clase incluye un método llamado `setSaldo`, que es una forma común de definir setters en Python. Este método toma un parámetro `nuevosaldo` y asigna este valor al atributo privado `__saldo`. Esto permite cambiar el saldo de la cuenta bancaria desde fuera de la clase, manteniendo el atributo `__saldo` protegido.

Finalmente, se crea una instancia de la clase `CuentaBancaria` llamada `cuentecliente1`, y luego se utiliza el método `setSaldo()` para establecer su saldo en 10.000 millones (10,000,000,000). Esto demuestra cómo podemos modificar los atributos privados a través de métodos públicos, manteniendo la encapsulación y seguridad del código.

La idea detrás de este ejercicio es enseñar cómo proteger datos importantes dentro de una clase (haciéndolos privados) y proporcionar interfaces controladas para acceder a ellos.

`006-convertir en privadas.py`

```python
class CuentaBancaria():
  def __init__(self):
    self.__saldo = 0
    self.__cliente = ""
    
  # Defino setters y getters para el saldo
  def setSaldo(self,nuevosaldo):
    self.__saldo = nuevosaldo
    
cuentecliente1 = CuentaBancaria()
cuentecliente1.setSaldo(10000000000)


    
```

### get saldo
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código define una clase llamada `CuentaBancaria` que simula las funciones básicas de una cuenta bancaria. La clase tiene un método especial llamado `__init__`, que se ejecuta automáticamente cuando se crea un objeto de la clase y establece dos atributos privados: `__saldo` (que inicialmente es 0) y `__cliente` (que inicialmente está vacío).

Además, la clase define dos métodos adicionales: `setSaldo()` y `getSaldo()`. El método `setSaldo(nuevosaldo)` permite cambiar el valor del saldo de la cuenta bancaria a un nuevo valor proporcionado como parámetro. Por otro lado, `getSaldo()` devuelve el valor actual del saldo sin permitir que este sea modificado desde fuera de la clase.

Finalmente, se crea una instancia (o objeto) de `CuentaBancaria` llamada `cuentecliente1`, y a continuación se utiliza el método `setSaldo(10000000000)` para establecer un saldo inicial de 10 mil millones. Luego, el programa imprime en la consola el saldo actual utilizando el método `getSaldo()`. Este ejemplo ilustra cómo usar métodos getters y setters para manejar datos privados de una clase de manera segura y controlada.

`007-get saldo.py`

```python
class CuentaBancaria():
  def __init__(self):
    self.__saldo = 0
    self.__cliente = ""
    
  # Defino setters y getters para el saldo
  def setSaldo(self,nuevosaldo):
    self.__saldo = nuevosaldo
  def getSaldo(self):
    return self.__saldo
    
cuentecliente1 = CuentaBancaria()
cuentecliente1.setSaldo(10000000000)
print(cuentecliente1.getSaldo())


    
```

### validacion
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código crea una clase llamada `CuentaBancaria` en Python, que es utilizada para gestionar el saldo de una cuenta bancaria. La clase tiene un método constructor (`__init__`) que inicializa dos atributos privados: `__saldo`, que almacena la cantidad de dinero en la cuenta y se establece a 0 cuando se crea una instancia de la clase, y `__cliente`, que identifica al cliente dueño de la cuenta pero no está implementado en este fragmento.

Lo más relevante es el método `setSaldo(self, nuevosaldo)`. Este método permite actualizar el saldo de la cuenta bancaria. Sin embargo, antes de permitir un cambio de saldo, verifica si el nuevo saldo propuesto (`nuevosaldo`) es significativamente mayor (en este caso, 1000 euros más) que el saldo actual en la cuenta. Si se supera esta diferencia (`if nuevosaldo > self.__saldo + 1000:`), el código imprime un aviso indicando que se ha detectado una posible operación sospechosa y no realiza la actualización del saldo.

Por último, hay una instancia de `CuentaBancaria` llamada `cuentacliente1`, a la cual se intenta asignar un nuevo saldo muy alto (10000000000 euros) mediante el método `setSaldo`. Dado que esta cantidad supera con creces los 1000 euros adicionales, se imprime el aviso y el saldo de la cuenta no cambia.

Este tipo de validación es importante en contextos bancarios para prevenir fraudes o errores en las transacciones.

`008-validacion.py`

```python
limitediferenciasaldo = 1000

class CuentaBancaria():
  def __init__(self):
    self.__saldo = 0
    self.__cliente = ""
    
  # Defino setters y getters para el saldo
  def setSaldo(self,nuevosaldo):
    # Establezco una condicion de que valida si el saldo nuevo es mayor de 1000 euros
    if nuevosaldo > self.__saldo + 1000:
      # Si salta la alarma, avisa y NO cambia el saldo
      print("Voy a avisar a la entidad de un ingreso muy grande")
    else
      # Si pasa el filtro, solo entonces se cambia el saldo
      self.__saldo = nuevosaldo
      
  def getSaldo(self):
    return self.__saldo
    
cuentacliente1 = CuentaBancaria()
cuentacliente1.setSaldo(10000000000)
print(cuentacliente1.getSaldo())


    
```

### variable global
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código Python muestra cómo crear una clase llamada `CuentaBancaria` que gestiona el saldo de una cuenta bancaria y utiliza un valor global para controlar las diferencias en los saldos. La variable global `limitediferenciasaldo` está definida fuera de la clase y tiene un valor fijo de 1000, lo cual representa el límite permitido para incrementos del saldo.

En la clase `CuentaBancaria`, se inicializa con dos atributos privados: `__saldo` (que inicia en 0) y `__cliente`. El método `setSaldo(nuevosaldo)` permite establecer un nuevo valor para el saldo, pero incluye una validación que impide que el nuevo saldo exceda más de 1000 unidades (euros en este caso) por encima del saldo actual. Si se intenta establecer un saldo que supere este límite, se imprime un aviso y el saldo no cambia.

El método `getSaldo()` simplemente devuelve el valor actual del saldo sin hacer modificaciones.

Finalmente, se crea una instancia de la clase `CuentaBancaria` llamada `cuentacliente1`, se intenta establecer un saldo muy elevado utilizando `setSaldo(10000000000)`, y luego se imprime el saldo actual usando `getSaldo()`. Debido a la validación en el método `setSaldo()`, es probable que solo se haya impreso el aviso del límite y el saldo no haya cambiado realmente.

`009-variable global.py`

```python
limitediferenciasaldo = 1000

class CuentaBancaria():
  def __init__(self):
    self.__saldo = 0
    self.__cliente = ""
    
  # Defino setters y getters para el saldo
  def setSaldo(self,nuevosaldo):
    # Establezco una condicion de que valida si el saldo nuevo es mayor de 1000 euros
    if nuevosaldo > self.__saldo + limitediferenciasaldo:
      # Si salta la alarma, avisa y NO cambia el saldo
      print("Voy a avisar a la entidad de un ingreso muy grande")
    else
      # Si pasa el filtro, solo entonces se cambia el saldo
      self.__saldo = nuevosaldo
      
  def getSaldo(self):
    return self.__saldo
    
cuentacliente1 = CuentaBancaria()
cuentacliente1.setSaldo(10000000000)
print(cuentacliente1.getSaldo())


    
```

### creo setters y getters
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

El fragmento de código proporcionado es el inicio de la definición de una clase llamada `Cliente` en Python. Una clase en programación orientada a objetos es como un modelo o plantilla que define los atributos y comportamientos de los objetos que se crearán a partir de esa clase. En este caso, la clase `Cliente` está siendo creada para representar las características generales de un cliente.

El método especial `__init__()` es el constructor de la clase. Se llama automáticamente cuando se crea una nueva instancia (objeto) de esta clase. En el código dado, el método no tiene parámetros después del argumento `self`, lo que significa que no está inicializando los objetos con valores específicos al crearlos. Esto es inusual y generalmente queremos proporcionar valores para iniciar las variables de la clase.

Las dos líneas dentro del constructor establecen dos atributos de instancia: `nombrecompleto` y `email`. Estos atributos son cadenas vacías (`""`) en este momento, lo que significa que al crear un objeto `Cliente`, estos campos no tendrán información inicializada. En la práctica, querríamos pasar valores para estas propiedades cuando se crea el objeto.

Este código está incompleto y necesita ser corregido para funcionar correctamente; por ejemplo, necesitaría parámetros en el método `__init__()` y una declaración correcta de la función que defina adecuadamente los argumentos.

`010-creo setters y getters.py`

```python
class Cliente():
  def __init__():
    self.nombrecompleto = ""
    self.email = ""
  
    


    
```

### ejemplo practico
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

El código que se proporciona es una clase llamada `Cliente` en Python. La función principal de esta clase es definir un objeto `Cliente`, pero el fragmento dado no parece estar completamente desarrollado ya que la función inicializadora (`__init__`) no tiene parámetros ni cuerpo, lo cual no es correcto según las reglas del lenguaje Python y hace que la clase esté incompleta. La clase contiene dos atributos: `nombrecompleto` y `email`, pero no hay métodos para interactuar con estos atributos (como setters o getters).

La importancia de este código radica en el concepto básico de cómo se define una clase y sus elementos, aunque está incompleto y requeriría ser mejorado para que sea funcional.

ÚLTIMO PÁRRAFO: Comparando con la versión anterior `010-creo setters y getters.py`, no hay cambios significativos en el código proporcionado. Ambos fragmentos presentan una clase `Cliente` sin una inicialización correcta ni métodos adicionales, lo que sugiere que este podría ser un borrador o punto intermedio de desarrollo antes de agregar funcionalidades como los setters y getters para manejar correctamente los atributos del cliente.

`010-ejemplo practico.py`

```python
class Cliente():
  def __init__():
    self.nombrecompleto = ""
    self.email = ""
  
    


    
```

### creo setters y getters
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código define una clase en Python llamada `Cliente`. La clase tiene un método constructor (`__init__`) que inicializa dos atributos privados del objeto: `nombrecompleto` y `email`, estableciéndolos como cadenas vacías al crear una nueva instancia de la clase. Además, la clase incluye cuatro métodos adicionales: `setNombreCompleto()`, `setEmail()`, `getNombreCompleto()` y `getEmail()`. Estos métodos permiten a otros programadores establecer (con los métodos que terminan en "set") o recuperar (con los métodos que terminan en "get") el valor de estos atributos del objeto. 

Los setters (`setNombreCompleto` y `setEmail`) actualizan internamente los valores de `nombrecompleto` y `email`, respectivamente, mientras que los getters (`getNombreCompleto` y `getEmail`) simplemente devuelven los valores actuales de estos atributos sin modificarlos. Este patrón de diseño es común en programación orientada a objetos para encapsular los datos dentro de una clase y controlar cómo se accede y modifica esa información.

Este enfoque es importante porque ayuda a proteger la integridad del objeto, evitando que otros componentes del programa puedan cambiar directamente estos atributos sin seguir las reglas establecidas por la clase. Esto mejora tanto la seguridad como la mantenibilidad del código.

`011-creo setters y getters.py`

```python
class Cliente():
  # Este es el método constructor
  def __init__(self):
    self.nombrecompleto = ""
    self.email = ""
  # Estos son los setters y los getters
  def setNombreCompleto(self,nuevonombre):
    self.nombrecompleto = nuevonombre
  def setEmail(self,nuevoemail):
    self.email = nuevoemail
  def getNombreCompleto(self):
    return self.nombrecompleto
  def getEmail(self):
    return self.email
    
# CRUD - Create, Read, Update, Delete
# CRUD SQL - INSERT, SELECT, UPDATE, DELETE


    

    


    
```

### pequeño programa
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es una pequeña parte de un programa en Python que gestiona datos de clientes. La estructura del programa incluye una clase llamada `Cliente` que contiene métodos para establecer (`set`) y obtener (`get`) los valores del nombre completo y el correo electrónico de un cliente.

El método `__init__` es el constructor de la clase, lo cual inicializa las propiedades del objeto con cadenas vacías para el nombre completo y el email. Los métodos `setNombreCompleto()` y `setEmail()` permiten establecer estos valores, mientras que los métodos `getNombreCompleto()` y `getEmail()` devuelven estos datos respectivamente.

Después de definir la clase, el código muestra un menú interactivo en el cual se pide al usuario seleccionar una opción para insertar un nuevo cliente o obtener el listado de clientes. Aunque el código incluye opciones para leer y actualizar información (CRUD), en este fragmento sólo hay mensajes informativos que indican qué acción se tomaría si se seleccionara cada opción.

Este tipo de estructura es común cuando estás empezando a aprender sobre la programación orientada a objetos, ya que combina conceptos como clases, métodos y control de flujo para crear una interfaz simple pero funcional.

`012-pequeño programa.py`

```python
class Cliente():
  # Este es el método constructor
  def __init__(self):
    self.nombrecompleto = ""
    self.email = ""
  # Estos son los setters y los getters
  def setNombreCompleto(self,nuevonombre):
    self.nombrecompleto = nuevonombre
  def setEmail(self,nuevoemail):
    self.email = nuevoemail
  def getNombreCompleto(self):
    return self.nombrecompleto
  def getEmail(self):
    return self.email
    
# CRUD - Create, Read, Update, Delete
# CRUD SQL - INSERT, SELECT, UPDATE, DELETE

print("Gestor de clientes v0.1 Jose Vicente Carratala")
print("Selecciona una opción:")
print("1.-Insertar un nuevo cliente")
print("2.-Obtener listado de clientes")
opcion = int(input("Indica tu opción (1,2): "))

if opcion == 1:
  print("Voy a insertar un cliente")
elif opcion == 2:
  print("Saco el listado de clientes")
  
  

    

    


    
```

### creo una lista de clientes
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es una parte del programa que gestiona un sistema simple para manejar información sobre clientes. La clase `Cliente` se utiliza para crear objetos que representan a diferentes clientes, y estos objetos tienen propiedades como el nombre completo y el email.

La clase incluye métodos especiales llamados "setters" (como `setNombreCompleto`) y "getters" (como `getEmail`). Los setters son usados para establecer los valores de las propiedades del objeto cliente, mientras que los getters permiten obtener esos valores. Estos métodos facilitan el manejo seguro y controlado de la información dentro del objeto.

El código principal crea una lista vacía llamada `clientes` para almacenar todos los clientes creados. Luego presenta un menú simple al usuario donde pueden elegir entre dos opciones: "Insertar un nuevo cliente" o "Obtener listado de clientes". Si el usuario selecciona la opción 1, se pide que introduzcan el nombre y email del nuevo cliente, y luego esos datos son almacenados en un objeto `Cliente` recién creado mediante los métodos setters. Este objeto cliente se debería añadir a la lista `clientes`, aunque esa parte específica no está implementada completamente en este fragmento.

Este tipo de estructura es fundamental para aprender cómo manipular datos en objetos, y cómo organizar el flujo de interacción entre un usuario y una aplicación que maneja información sobre varios elementos.

`013-creo una lista de clientes.py`

```python
class Cliente():
  # Este es el método constructor
  def __init__(self):
    self.nombrecompleto = ""
    self.email = ""
  # Estos son los setters y los getters
  def setNombreCompleto(self,nuevonombre):
    self.nombrecompleto = nuevonombre
  def setEmail(self,nuevoemail):
    self.email = nuevoemail
  def getNombreCompleto(self):
    return self.nombrecompleto
  def getEmail(self):
    return self.email
    
# CRUD - Create, Read, Update, Delete
# CRUD SQL - INSERT, SELECT, UPDATE, DELETE

clientes = []             ############## Meto una lista de clientes vacia

print("Gestor de clientes v0.1 Jose Vicente Carratala")
print("Selecciona una opción:")
print("1.-Insertar un nuevo cliente")
print("2.-Obtener listado de clientes")
opcion = int(input("Indica tu opción (1,2): "))

if opcion == 1:     # Los SETTERS se usan en las operaciones de creación de nuevos elementos
  print("Voy a insertar un cliente")
  nuevocliente = Cliente()
  nombrecliente = input("Introduce el nombre del cliente: ")  # Tomo el dato
  nuevocliente.setNombreCompleto(nombrecliente) # Uso el metodo set para meter el dato en el objeto
  emailcliente = input("Introduce el email del cliente: ")  # Tomo el dato
  nuevocliente.setEmail(emailcliente) # Uso el metodo set para meter el dato en el objeto
elif opcion == 2:
  print("Saco el listado de clientes")
  

  
  

    

    


    
```

### getters
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código Python crea una clase llamada `Cliente` que permite gestionar información sobre los clientes, como su nombre completo y correo electrónico. La clase incluye métodos especiales llamados setters (como `setNombreCompleto()` y `setEmail()`) para establecer o actualizar esta información, así como getters (`getNombreCompleto()` y `getEmail()`) para recuperarla.

Además de la definición de la clase, el código también presenta un menú simple que permite al usuario añadir nuevos clientes a una lista y mostrar los detalles de todos los clientes existentes. Cuando se selecciona la opción 1 (Insertar un nuevo cliente), se crea un objeto `Cliente`, se le asignan valores utilizando los métodos setter correspondientes, y luego se agrega este objeto a una lista global llamada `clientes`. Si el usuario elige la opción 2 (Obtener listado de clientes), el código recorre la lista `clientes` e imprime en pantalla los detalles de cada cliente usando los métodos getter.

Esta estructura es importante porque permite encapsular y proteger los datos del objeto, asegurando que solo se acceda a ellos mediante las interfaces proporcionadas por los getters y setters. Además, facilita mantener y expandir el código en el futuro, ya que cualquier cambio en cómo se manejan los datos de un cliente puede hacerse directamente en la clase `Cliente` sin afectar al resto del programa.

`014-getters.py`

```python
class Cliente():
  # Este es el método constructor
  def __init__(self):
    self.nombrecompleto = ""
    self.email = ""
  # Estos son los setters y los getters
  def setNombreCompleto(self,nuevonombre):
    self.nombrecompleto = nuevonombre
  def setEmail(self,nuevoemail):
    self.email = nuevoemail
  def getNombreCompleto(self):
    return self.nombrecompleto
  def getEmail(self):
    return self.email
    
# CRUD - Create, Read, Update, Delete
# CRUD SQL - INSERT, SELECT, UPDATE, DELETE

clientes = []             ############## Meto una lista de clientes vacia

print("Gestor de clientes v0.1 Jose Vicente Carratala")
while True:
  print("Selecciona una opción:")
  print("1.-Insertar un nuevo cliente")
  print("2.-Obtener listado de clientes")
  opcion = int(input("Indica tu opción (1,2): "))

  if opcion == 1:     # Los SETTERS se usan en las operaciones de creación de nuevos elementos
    print("Voy a insertar un cliente")
    nuevocliente = Cliente()
    nombrecliente = input("Introduce el nombre del cliente: ")  # Tomo el dato
    nuevocliente.setNombreCompleto(nombrecliente) # Uso el metodo set para meter el dato en el objeto
    emailcliente = input("Introduce el email del cliente: ")  # Tomo el dato
    nuevocliente.setEmail(emailcliente) # Uso el metodo set para meter el dato en el objeto
    clientes.append(nuevocliente) # Y por ultimo añado el cliente a la lista de clientes
  elif opcion == 2:   # Los GETTERS se usan en las operaciones de listado
    print("Saco el listado de clientes")
    for cliente in clientes:
      print("-------------------------")
      print("Nombre: ",cliente.getNombreCompleto())
      print("email: ",cliente.getEmail())
      print("-------------------------")


  
  

  
  

    

    


    
```

### Actividades propuestas

### Actividad 1: Creación y Acceso a Propiedades de Objetos

**Descripción:** Crea una clase `Perro` con atributos como nombre, raza y edad. Luego, crea un objeto de esta clase e imprime la información del perro utilizando métodos getters. Este ejercicio permite entender cómo encapsular y acceder a propiedades.

### Actividad 2: Métodos Setters

**Descripción:** Añade métodos setters a tu clase `Perro` para cambiar los valores de sus atributos. Prueba estos setters en un objeto de la clase e imprime el resultado para verificar que los cambios se han aplicado correctamente.

### Actividad 3: Uso de Propiedades Privadas

**Descripción:** Modifica la clase `Perro` para hacer algunas de las propiedades privadas (prefijos con "__"). Luego, crea métodos getters y setters para acceder a estas propiedades. Prueba el funcionamiento.

### Actividad 4: Clase Cuenta Bancaria Básica

**Descripción:** Crea una clase `CuentaBancaria` que tenga un atributo de saldo inicial en cero. Implementa los métodos necesarios para depositar y retirar dinero, con validaciones básicas para evitar saldos negativos.

### Actividad 5: Validación de Operaciones Bancarias

**Descripción:** Añade una nueva clase `CuentaBancaria` que incluya un límite en las transacciones. Implementa métodos que permitan depositar y retirar dinero, pero alerten al usuario si la operación supera este límite.

### Actividad 6: Cliente con Setters y Getters

**Descripción:** Crea una clase `Cliente` similar a la vista en el código proporcionado. Incluye métodos para establecer y obtener datos como nombre completo y email, y luego prueba estos métodos insertando y mostrando información de clientes.

### Actividad 7: Gestión Básica de Clientes

**Descripción:** Desarrolla un programa sencillo que permita al usuario elegir entre agregar un nuevo cliente o mostrar la lista de todos los clientes. Utiliza la clase `Cliente` y sus métodos setters y getters para manipular datos.

### Actividad 8: Manejo de Listas de Clientes

**Descripción:** Añade funcionalidades al programa anterior para permitir que el usuario inserte varios clientes en una lista y luego los muestre. Implementa también la opción para mostrar un cliente específico por su nombre.

### Actividad 9: Práctica con Clases y Métodos

**Descripción:** Utilizando las clases `Cliente` y `CuentaBancaria`, crea una aplicación que permita gestionar cuentas bancarias de clientes, incluyendo operaciones como depósito, retiro e impresión del saldo actual.

### Actividad 10: Integración y Pruebas

**Descripción:** Combina todas las clases y métodos desarrollados en actividades anteriores para crear una aplicación integral que permita gestionar tanto a los clientes como sus cuentas bancarias. Implementa validaciones adicionales para mejorar la robustez del sistema.

Estas actividades están diseñadas para ir incrementando gradualmente el nivel de complejidad, desde conceptos básicos hasta implementación de funcionalidades más avanzadas con clases y métodos en Python.


<a id="creacion-de-constructores"></a>
## Creación de constructores

### Introducción a los ejercicios

Esta carpeta contiene una serie de ejercicios que te ayudarán a entender y practicar cómo crear constructores en Python. Los ejercicios van desde un repaso básico sobre la creación de una clase simple con un constructor sin parámetros, hasta ejemplos más complejos donde se pasan múltiples argumentos al construir instancias de una clase como gatos o clientes. A través de estos ejercicios, aprenderás a inicializar atributos en los objetos al momento de su creación y cómo gestionar diferentes tipos de datos (números, cadenas) como parámetros del constructor. Estas actividades son fundamentales para dominar la creación de clases y objetos personalizados en Python.

### repaso gato
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código en Python te muestra cómo crear y usar una clase simple llamada `Gato`. La clase tiene un constructor (`__init__`) que se ejecuta automáticamente cuando creas una nueva instancia del objeto `Gato`. En este caso, el constructor inicializa la edad del gato a 0.

Además del constructor, la clase contiene un método llamado `maulla` que retorna una cadena de texto diciendo "El gato está maullando". Este método no se ejecuta automáticamente como el constructor; sólo se llama cuando tú lo deseas explícitamente en tu código.

En el bloque principal del programa, creamos una instancia de la clase `Gato` llamada `gato1`. Luego, imprimimos la edad del gato (que es 0 según lo que definimos en el constructor) y también llamamos al método `maulla()` para hacer que nuestro objeto Gato "maulle" mostrando el mensaje por pantalla.

Este código ayuda a entender los conceptos básicos de cómo se crean instancias, se inicializan atributos mediante constructores y cómo se usan métodos en Python. Es útil para estudiantes que están aprendiendo sobre orientación a objetos en programación.

`001-repaso gato.py`

```python
class Gato():
  def __init__(self):    # El constructor se ejecuta sí o sí
    self.edad = 0
    
  def maulla(self):     # El resto de métodos sólo se ejecutan si los llamas
    return "El gato está maullando"
    
    
gato1 = Gato()
print(gato1.edad)

print(gato1.maulla())
    
```

### a un construtor se le pueden pasar parametros
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código define una clase llamada `Gato` en Python, que es un concepto fundamental para la programación orientada a objetos. La clase tiene dos elementos principales: un constructor (`__init__`) y un método llamado `maulla`.

El constructor de la clase `Gato` se ejecuta automáticamente cuando creamos una nueva instancia del objeto Gato (como en la línea donde decimos `gato1 = Gato()`). En este caso, el constructor inicializa una propiedad de la clase `edad` con el valor 0. Esto significa que cada gato creado a partir de esta clase empezará con una edad de cero.

Además del constructor, hay un método llamado `maulla`, que devuelve una cadena indicando que "El gato está maullando". Este método no se ejecuta automáticamente al crear el objeto; sólo se llama explícitamente cuando lo necesitas, como en la última línea del código donde decimos `print(gato1.maulla())`.

En la parte final del código, creamos una instancia de Gato llamada `gato1` y luego cambiamos su propiedad `edad` a 5. Finalmente, mostramos en pantalla la edad actual del gato (que ahora es 5) y también ejecutamos el método `maulla()` para escucharlo maullar.

Este ejemplo es importante porque muestra cómo se utilizan constructores para inicializar datos importantes al crear un objeto y cómo los métodos son funciones que pueden ser llamadas en cualquier momento para realizar acciones específicas o devolver información.

`002-a un construtor se le pueden pasar parametros.py`

```python
class Gato():
  def __init__(self):    # El constructor se ejecuta sí o sí
    self.edad = 0
    
  def maulla(self):     # El resto de métodos sólo se ejecutan si los llamas
    return "El gato está maullando"
    
    
gato1 = Gato()
print(gato1.edad)
gato1.edad = 5
print(gato1.edad)

print(gato1.maulla())
    
```

### constructor con parametros
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código define una clase en Python llamada `Gato` que representa a un gato con ciertas características. La clase tiene dos partes principales: el constructor y un método.

1. **Constructor**: El constructor de la clase se llama automáticamente cuando creas una nueva instancia del objeto `Gato`. En este caso, el constructor recibe un parámetro llamado `edad`, que establece la edad del gato nuevo que estás creando. Cuando se crea un gato (por ejemplo, con `gato1 = Gato(5)`), el valor de 5 es asignado a `self.edad` dentro del constructor, lo que significa que este gato tendrá una propiedad llamada `edad` que vale 5.

2. **Método maulla**: Este método simplemente devuelve un mensaje indicando que "El gato está maullando". A diferencia del constructor, el método `maulla()` solo se ejecutará cuando lo llames explícitamente (por ejemplo, `gato1.maulla()`).

Este código es importante porque ilustra cómo puedes inicializar propiedades de un objeto a través del uso de constructores que aceptan parámetros. Esto permite crear objetos con características específicas desde el momento en que son creados.

`003-constructor con parametros.py`

```python
class Gato():
  def __init__(self,edad):    # El constructor se ejecuta sí o sí
    self.edad = edad
    
  def maulla(self):     # El resto de métodos sólo se ejecutan si los llamas
    return "El gato está maullando"
    
    
gato1 = Gato(5)

    
```

### mas parametros
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código en Python crea una clase llamada `Gato` que modela las características y comportamientos de un gato. La función especial `__init__` es el constructor, que se ejecuta automáticamente cada vez que se crea una nueva instancia del objeto `Gato`. En este caso, el constructor recibe dos parámetros: `edad` y `nombre`, los cuales se utilizan para inicializar las propiedades de la clase `self.edad` y `self.nombre`.

Además del constructor, hay un método llamado `maulla()` que devuelve una cadena informando que "El gato está maullando". Este método no requiere parámetros adicionales aparte del objeto `gato1`, por lo que se puede llamar directamente a través de una instancia de la clase.

Finalmente, en el último renglón, se crea un objeto `gato1` de la clase `Gato`, pasándole como argumentos los valores 5 y "micifu", correspondientes a la edad del gato y su nombre. Esto significa que cuando se accede a las propiedades o métodos del objeto `gato1`, tendrá asociados estos valores específicos. Es importante destacar que el método `maulla()` no es llamado en este código, por lo que solo estaría disponible para ser usado después de crear la instancia del gato si fuera necesario.

`004-mas parametros.py`

```python
class Gato():
  def __init__(self,edad,nombre):    # El constructor se ejecuta sí o sí
    self.edad = edad
    self.nombre = nombre
    
  def maulla(self):     # El resto de métodos sólo se ejecutan si los llamas
    return "El gato está maullando"
    
    
gato1 = Gato(5,"micifu")

    
```

### tercera propiedad
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código crea una clase en Python llamada `Gato`. Una clase es como un modelo o plantilla para crear objetos. En este caso, el objeto representará a un gato real y tendrá tres características principales: edad, nombre y raza.

El constructor de la clase se llama `__init__` y está diseñado para inicializar las propiedades del gato cuando se crea una nueva instancia de la clase. Aquí, el constructor recibe tres parámetros (edad, nombre y raza), que son asignados a los atributos de la instancia correspondiente (`self.edad`, `self.nombre`, `self.raza`). Esto significa que cada vez que creas un nuevo objeto `Gato`, debes proporcionar estos valores para configurarlo correctamente.

Además del constructor, hay un método llamado `maulla` que simplemente devuelve una cadena de texto indicando que el gato está maullando. Este método se ejecutará solo cuando lo llames explícitamente en tu código, por ejemplo, después de haber creado una instancia de la clase `Gato`.

En la última línea, se crea un objeto específico llamado `gato1` usando la clase `Gato`, proporcionando los valores 5 para edad, "micifu" para el nombre y "mainecoon" para la raza.

`005-tercera propiedad.py`

```python
class Gato():
  def __init__(self,edad,nombre,raza):    # El constructor se ejecuta sí o sí
    self.edad = edad
    self.nombre = nombre
    self.raza = raza
    
  def maulla(self):     # El resto de métodos sólo se ejecutan si los llamas
    return "El gato está maullando"
    
    
gato1 = Gato(5,"micifu","mainecoon")

    
```

### ejemplo con cliente
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código Python enseña cómo crear una clase llamada `Cliente` que almacena información personal de un cliente, como su nombre, apellidos, email y dirección. La parte importante es el método `__init__`, conocido como constructor en la programación orientada a objetos (POO). Este constructor recibe cuatro parámetros: `nombre`, `apellidos`, `email` y `direccion`. Estos parámetros se utilizan para inicializar las propiedades de la clase correspondientes (`self.nombre = nombre`, etc.), lo que permite almacenar los datos del cliente dentro de un objeto.

Después, el código solicita al usuario que introduzca estos cuatro datos mediante el uso de funciones `input()`. Una vez que el usuario ha proporcionado todos los detalles requeridos, se crea una instancia de la clase `Cliente` llamada `cliente1`, pasando como argumentos los valores ingresados por el usuario. Finalmente, se imprime el objeto `cliente1` en pantalla.

Este tipo de código es importante porque demuestra cómo se pueden crear y manipular objetos que contienen información estructurada (en este caso, datos de un cliente), lo cual es fundamental para desarrollar aplicaciones más complejas que manejan entidades definidas por el usuario.

`006-ejemplo con cliente.py`

```python
class Cliente():
  def __init__(self,nombre,apellidos,email,direccion):
    self.nombre = nombre
    self.apellidos = apellidos
    self.email = email
    self.direccion = direccion
    
nombre = input("Introduce el nombre del cliente: ")
apellidos = input("Introduce los apellidos del cliente: ")
email = input("Introduce el email del cliente: ")
direccion = input("Introduce la dirección del cliente: ")

cliente1 = Cliente(nombre,apellidos,email,direccion)
print(cliente1)




    
```

### listado de clientes
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código Python crea una clase llamada `Cliente` que almacena información personal de un cliente como su nombre, apellidos, email y dirección. La función especial `__init__` en la clase se utiliza para inicializar los atributos del objeto cuando este es creado.

El programa principal utiliza un bucle `while True`, lo que significa que el ciclo continuará indefinidamente hasta que interrumpas su ejecución manualmente (generalmente con Ctrl+C o cerrando la terminal). Dentro de este bucle, se pide al usuario que introduzca información sobre un cliente y luego se crea una instancia de la clase `Cliente` usando esta información. Esta nueva instancia del cliente es añadida a una lista llamada `clientes`.

Este código es importante porque demuestra cómo crear objetos basados en entradas del usuario y almacenarlos para su uso posterior, lo que puede ser útil en aplicaciones reales donde se necesita manejar datos de múltiples clientes.

`007-listado de clientes.py`

```python
class Cliente():
  def __init__(self,nombre,apellidos,email,direccion):
    self.nombre = nombre
    self.apellidos = apellidos
    self.email = email
    self.direccion = direccion
 
clientes = []
while True:  
 
  nombre = input("Introduce el nombre del cliente: ")
  apellidos = input("Introduce los apellidos del cliente: ")
  email = input("Introduce el email del cliente: ")
  direccion = input("Introduce la dirección del cliente: ")

  clientes.append(Cliente(nombre,apellidos,email,direccion))





    
```

### Actividades propuestas

### Actividades Propuestas

1. **Constructor Básico de Gato**
   - Descripción: Diseña una clase `Gato` con un constructor que inicialice el atributo `edad`. Este ejercicio ayuda a entender cómo definir y utilizar constructores en Python.
   
2. **Modificar Atributos del Gato**
   - Descripción: Crea un método dentro de la clase `Gato` para modificar su edad después de crear una instancia. Los alumnos aprenderán a interactuar con los atributos de una instancia.

3. **Constructor con Parámetros**
   - Descripción: Mejora el constructor del gato para que acepte parámetros al instanciar un objeto, inicializando la edad y nombre en función de estos valores.
   
4. **Añadir Múltiples Propiedades**
   - Descripción: Añade más propiedades a tu clase `Gato`, como el nombre y la raza, para practicar con múltiples parámetros en un constructor.

5. **Método de Acción del Gato**
   - Descripción: Implementa un método llamado `maulla` dentro de la clase que devuelva una cadena indicando que el gato está maullando, para entender cómo trabajar con métodos de instancia.
   
6. **Instanciar Clientes**
   - Descripción: Crea instancias de la clase `Cliente`, recogiendo datos del usuario como nombre y dirección. Los estudiantes aprenderán a manipular clases más complejas.

7. **Listado de Clientes**
   - Descripción: Elabora un programa que permita almacenar múltiples clientes en una lista, solicitando información al usuario para cada uno.
   
8. **Personalización del Cliente**
   - Descripción: Añade propiedades adicionales a la clase `Cliente`, como número de teléfono o preferencias de contacto, y modifica el constructor y los métodos necesarios.

Estas actividades están diseñadas para ayudar a los estudiantes a comprender y aplicar conceptos fundamentales de programación orientada a objetos en Python, adaptándose al nivel intermedio esperado en Formación Profesional.


<a id="utilizacion-de-clases-y-objetos"></a>
## Utilización de clases y objetos

### Introducción a los ejercicios

En esta carpeta de ejercicios, te encuentras con tres archivos que exploran el uso y la creación de clases en Python para realizar operaciones matemáticas básicas como redondeo hacia arriba y hacia abajo. Estos ejemplos comienzan por crear una clase personalizada llamada `Matematicas` donde se implementa un método para redondear números, y luego expanden esta clase añadiendo métodos para obtener el techo (redondeo al alza) y suelo (redondeo a la baja). El último ejercicio muestra cómo utilizar funciones equivalentes desde la librería estándar de Python (`math`). A través de estos ejercicios, aprenderás a encapsular funcionalidades en clases propias y a utilizar eficientemente las herramientas que ofrece el lenguaje para resolver problemas matemáticos.

### Mi propia clase
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código define una clase llamada `Matematicas` en Python, que tiene como objetivo proporcionar funciones matemáticas básicas. La clase incluye un método especial llamado `__init__`, que se ejecuta cada vez que se crea un nuevo objeto de esta clase. En este caso, el método inicializador establece una variable de instancia llamada `PI` con el valor del número pi.

Además, la clase contiene otro método llamado `redondeo`, que toma un número como entrada y devuelve su versión redondeada al entero más cercano. Este método calcula primero la parte entera del número y luego determina si el decimal es menor o mayor a 0.5 para decidir qué entero cercano debe devolverse.

Finalmente, se crea una instancia de la clase `Matematicas` llamada `Mate`, y luego se llama al método `redondeo` dos veces con diferentes números (4.7 y 4.2) para mostrar cómo funciona el redondeo en ambos casos. Este código es útil porque demuestra cómo encapsular funciones matemáticas específicas dentro de una clase, lo que facilita su reutilización en otros lugares del programa.

`001-Mi propia clase.py`

```python
class Matematicas():
  def __init__(self):
    self.PI = 3.14159265359
    
  def redondeo(self,numero):
    entero = int(numero)
    decimal = numero - entero
    if decimal < 0.5:
      redondeo = 0
    else:
      redondeo = 1
    return entero + redondeo
    
Mate = Matematicas()
print(Mate.redondeo(4.7))
print(Mate.redondeo(4.2))
```

### redondeos alza y baja
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código define una clase llamada `Matematicas` que contiene métodos para realizar diferentes operaciones matemáticas. La clase tiene un método constructor (`__init__`) donde se inicializa la constante PI con el valor aproximado 3.14159265359.

La clase incluye tres funciones principales:
- `redondeo(numero)`: Este método toma un número como entrada, separa la parte entera del decimal y redondea hacia abajo si el decimal es menor que 0.5, o hacia arriba si es mayor o igual a 0.5.
- `techo(numero)`: Siempre redondea el número hacia arriba al siguiente entero más cercano.
- `suelo(numero)`: Redondea siempre hacia abajo al entero inmediatamente inferior.

En la parte final del código, se crea una instancia de la clase `Matematicas` llamada `Mate`. Luego, se invocan los métodos definidos para demostrar cómo funcionan: primero muestra el redondeo de 4.7 y 4.2, luego el techo de 4.7, y por último el suelo de 4.7.

Este tipo de código es útil cuando necesitas controlar precisamente cómo se manejan los números decimales en tus aplicaciones, asegurándote de que las operaciones matemáticas se realicen según las reglas específicas que definas.

`002-redondeos alza y baja.py`

```python
class Matematicas():
  def __init__(self):
    self.PI = 3.14159265359
    
  def redondeo(self,numero):
    entero = int(numero)
    decimal = numero - entero
    if decimal < 0.5:
      redondeo = 0
    else:
      redondeo = 1
    return entero + redondeo
    
  def techo(self,numero):
    return int(numero)+1
  def suelo(self,numero):
    return int(numero)
    
Mate = Matematicas()
print(Mate.redondeo(4.7))
print(Mate.redondeo(4.2))
print(Mate.techo(4.7))
print(Mate.suelo(4.7))
```

### ahora uso la libreria estandar
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código muestra cómo se utilizan las funciones incorporadas y las funciones de la biblioteca estándar en Python para manipular números con decimales. Primero, el programa importa la librería `math`, que contiene varias funciones matemáticas útiles.

Luego, utiliza la función `round()` sin necesidad de importar nada adicional, ya que esta función es parte del núcleo de Python y está disponible por defecto. Esta función redondea un número a su entero más cercano. En el código se muestra cómo redondear los números 4.7 y 4.2.

Después, utiliza las funciones `ceil()` y `floor()` que son parte de la librería `math` importada al principio del programa. La función `ceil()`, o "techo", devuelve el menor entero mayor o igual al número dado (por ejemplo, el techo de 4.7 es 5). Por otro lado, `floor()`, o "suelo", devuelve el mayor entero menor o igual al número dado (en este caso, el suelo de 4.7 sería 4).

Este código es importante porque demuestra cómo Python proporciona diferentes formas de trabajar con números y redondearlos según sea necesario en tus aplicaciones, ya sean para matemáticas básicas o más complejas.

`003-ahora uso la libreria estandar.py`

```python
import math
    
print(round(4.7))
print(round(4.2))
print(math.ceil(4.7))
print(math.floor(4.7))
```

### Actividades propuestas

### Actividades Propuestas

1. **Clase `Matematicas`: Creación y Uso Básico**
   - Desarrolla una clase llamada `Calculadora` que incluya un método para redondear números, similar a la implementación en el archivo `001-Mi propia clase.py`. El objetivo es familiarizarse con la creación de clases y métodos en Python.

2. **Expansión de Funcionalidades**
   - Añade dos nuevos métodos a la clase `Matematicas` del ejercicio anterior: uno que redondee hacia arriba (techo) y otro que redondee hacia abajo (suelo), como se muestra en el archivo `002-redondeos alza y baja.py`. Esto permitirá entender mejor cómo extender las funcionalidades de una clase existente.

3. **Comparación con Librerías Estandar**
   - Utiliza la librería estándar `math` para implementar funciones similares a los métodos creados en `002-redondeos alza y baja.py`. Comparar ambas implementaciones ayudará a entender las ventajas de usar bibliotecas existentes.

4. **Documentación de Métodos**
   - Añade docstrings (documentación) a cada método dentro de la clase `Matematicas` para describir brevemente su función. Esto es fundamental para mejorar la calidad del código y facilitar el mantenimiento.

5. **Uso de Atributos Estáticos**
   - Modifica la clase `Calculadora` para que tenga un atributo estático llamado `PI`. Este valor debe ser accesible desde cualquier instancia de la clase sin necesidad de crear una nueva instancia cada vez que se quiera usar.

6. **Encapsulamiento y Atributos Privados**
   - Introduce el concepto de encapsulamiento cambiando los atributos de la clase a privados (`_PI`, `_numero`). Crea métodos getter para acceder a estos atributos desde fuera de la clase, lo que ayudará a entender cómo proteger ciertos datos.

7. **Herencia Simple**
   - Diseña una nueva clase llamada `CalculadoraCientifica` que herede de `Matematicas`. Añade un nuevo método en esta clase para calcular el seno de un número, demostrando cómo se puede utilizar la herencia para ampliar funcionalidades.

8. **Testeo y Pruebas Unitarias**
   - Escribe pruebas unitarias utilizando una biblioteca como `unittest` para verificar que los métodos `redondeo`, `techo`, y `suelo` de tu clase `Matematicas` funcionan correctamente. Esto es crucial para garantizar la robustez del código.

Estas actividades están diseñadas para permitir a los estudiantes de Formación Profesional adquirir experiencia práctica en la creación y uso de clases en Python, desde conceptos básicos hasta temas más avanzados como herencia e implementación de pruebas unitarias.


<a id="utilizacion-de-clases-heredadas"></a>
## Utilización de clases heredadas

### Introducción a los ejercicios

En esta carpeta de ejercicios, se exploran conceptos fundamentales sobre la herencia en programación orientada a objetos utilizando Python. Los ejercicios comienzan con clases independientes para gatos y perros (archivo 001), luego introducen una clase madre llamada "Animal" que es utilizada por las subclases Gato y Perro, mostrando cómo compartir atributos entre ellas mediante la herencia (archivo 002). En el archivo 003, se introduce una nueva clase "Roca", para ilustrar situaciones en las que no es apropiado utilizar herencia. Finalmente, en el ejercicio 004, se amplía la profundidad de la herencia mostrando cómo las clases pueden formar cadenas jerárquicas más complejas con múltiples niveles de herencia.

Estos ejercicios buscan desarrollar tus habilidades para diseñar estructuras de datos y objetos que reflejen relaciones reales en el mundo, ayudándote a comprender mejor cuándo es apropiado utilizar la herencia y cómo manejar distintas configuraciones de clases.

### gatos y perros
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código define dos clases en Python: `Gato` y `Perro`. Cada una de estas clases tiene un método especial llamado `__init__`, que se ejecuta automáticamente cuando creamos un nuevo objeto basado en la clase. En este caso, tanto el método `__init__` de la clase Gato como el de Perro inicializan tres atributos: `edad`, `nombre` y `raza`. Estos atributos representan características comunes que se asocian con los gatos y perros respectivamente, como su edad, nombre y raza. Sin embargo, es importante notar que este código no utiliza la herencia de clases, a pesar del contexto en el que aparece (dentro de una carpeta sobre la utilización de clases heredadas). Si bien aquí cada clase está definida independientemente, podría haberse simplificado utilizando herencia si las dos compartieran comportamientos o atributos comunes.

`001-gatos y perros.py`

```python
class Gato():
  def __init__(self):
    self.edad = 0
    self.nombre = ""
    self.raza = ""
    
class Perro():
  def __init__(self):
    self.edad = 0
    self.nombre = ""
    self.raza = ""
```

### clase madre animal
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código en Python muestra cómo crear y utilizar clases heredadas. Primero, se define una clase base llamada `Animal`, que tiene tres atributos: `edad`, `nombre` e `raza`. Estos atributos son inicializados en el método `__init__`.

Luego, se crean dos subclases de `Animal`: `Gato` y `Perro`. Cada una de estas subclases redefine su propio constructor (`__init__`) para llamar al constructor de la clase base usando `super().__init__()`. Esto significa que cada vez que se crea un objeto `Gato` o `Perro`, también se inicializan los atributos definidos en la clase `Animal`.

Finalmente, el código crea una instancia de `Gato` llamada `gato1` y una instancia de `Perro` llamada `perro1`. Ambos objetos heredan los atributos de la clase base `Animal`, por lo que pueden acceder a las propiedades como `edad`, aunque no se proporcionen valores específicos para ellas en el momento de crear los objetos.

Esta práctica es importante porque permite reutilizar código y mantener una estructura clara cuando hay relaciones entre diferentes tipos de entidades, como animales domésticos.

`002-clase madre animal.py`

```python
class Animal():
  def __init__(self):
    self.edad = 0
    self.nombre = ""
    self.raza = ""

class Gato(Animal):
  def __init__(self):
    super().__init__()    # Me traigo todo lo que tenga la clase superior
    
class Perro(Animal):      # Me traigo todo lo que tenga la clase superior
  def __init__(self):
    super().__init__()

gato1 = Gato()
print(gato1.edad)

perro1 = Perro()
print(perro1.edad)
    
```

### clase Roca
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código muestra cómo se crean clases y objetos en Python, centrándose especialmente en la herencia de clases. Primero, se define una clase base llamada `Animal` que tiene atributos como edad, nombre y raza. Luego, se crean dos clases derivadas (`Gato` y `Perro`) que heredan de la clase `Animal`. Esto significa que tanto el gato como el perro pueden usar los atributos y métodos definidos en la clase `Animal`, pero también tienen sus propios atributos adicionales (en este caso, las coordenadas x, y y z).

Sin embargo, hay un detalle importante: la clase `Roca` no hereda de `Animal`. Esto significa que aunque el gato y el perro pueden acceder a los atributos como `edad`, la roca no puede hacerlo. El código final crea objetos de tipo `Gato` e `Perro`, muestra sus edades (que son inicializadas en 0 por defecto) pero intenta crear un objeto de tipo `Roca` que, sin herencia de `Animal`, no tiene estos atributos.

Es importante entender la diferencia entre las clases derivadas y una clase independiente como `Roca`. Las clases derivadas heredan características de su clase padre (en este caso `Animal`), mientras que `Roca` es completamente autónoma y no comparte nada con `Animal` directamente.

`003-clase Roca.py`

```python
class Animal():
  def __init__(self):
    self.edad = 0
    self.nombre = ""
    self.raza = ""

class Gato(Animal):
  def __init__(self):
    super().__init__()    # Me traigo todo lo que tenga la clase superior
    self.x = 0
    self.y = 0
    self.z = 0
    
class Perro(Animal):      
  def __init__(self):
    super().__init__()  # Me traigo todo lo que tenga la clase superior
    self.x = 0
    self.y = 0
    self.z = 0

class Roca():
  def __init__(self):
    self.x = 0
    self.y = 0
    self.z = 0

gato1 = Gato()
print(gato1.edad)

perro1 = Perro()
print(perro1.edad)
    
```

### herencia o multinivel
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código muestra cómo se utilizan las clases heredadas en Python para crear una jerarquía de objetos que comparten características comunes. La clase `Entidad` es la base y define propiedades como `x`, `y` y `z`, que representan posiciones en un espacio tridimensional. Luego, se crea una clase llamada `Animal` que hereda de `Entidad`. Esto significa que cualquier instancia de `Animal` también tendrá las propiedades `x`, `y` y `z`, además de añadir sus propias propiedades como `edad`, `nombre` y `raza`.

Las clases `Gato` y `Perro` son subclases de `Animal`, por lo que heredan todas las características de la clase `Animal`. Esto significa que un objeto `Gato` o `Perro` tendrá las mismas propiedades que cualquier animal, incluyendo su posición en el espacio tridimensional. Sin embargo, en este código no se añade más funcionalidad específica a estas clases para ser gatos o perros.

Además, existe una clase `Roca` que también hereda de `Entidad`, pero es independiente del sistema de animales y solo incluye las propiedades espaciales definidas por la clase base. Al final, se crean instancias de `Gato` y `Perro` e intenta imprimir sus edades, lo cual generará un error porque aunque la clase `Animal` define una propiedad `edad`, tanto `Gato` como `Perro` no inicializan esta propiedad en su constructor. Esto demuestra cómo es importante establecer valores específicos para las propiedades de cada subclase si se requieren características únicas para los objetos que representan (como la edad específica de un perro o un gato).

`004-herencia o multinivel.py`

```python
class Entidad():
  def __init__(self):
    self.x = 0
    self.y = 0
    self.z = 0

class Animal(Entidad):
  def __init__(self):
    super().__init__()
    self.edad = 0
    self.nombre = ""
    self.raza = ""

class Gato(Animal):
  def __init__(self):
    super().__init__()    # Me traigo todo lo que tenga la clase superior

    
class Perro(Animal):      
  def __init__(self):
    super().__init__()  # Me traigo todo lo que tenga la clase superior
    

class Roca(Entidad):
  def __init__(self):
    super().__init__()


gato1 = Gato()
print(gato1.edad)

perro1 = Perro()
print(perro1.edad)
    
```

### Actividades propuestas

### Actividades Propuestas

#### 1. Creación de Clases con Herencia Simples
**Descripción:** Los estudiantes deben crear una clase abstracta `Vehiculo` que incluya atributos comunes a todos los vehículos (como marca y modelo). A continuación, deben crear dos clases derivadas: `Coche` e `Moto`, incorporando características específicas de cada tipo. La actividad busca reforzar el concepto de herencia y polimorfismo.

#### 2. Clase Madre con Herencia Múltiple
**Descripción:** Los estudiantes deben implementar una clase base llamada `Persona` que tenga atributos como nombre, edad y dirección. A partir de esta clase, deben crear dos clases derivadas: `Estudiante` e `Empleado`, añadiendo propiedades adicionales relevantes para cada rol.

#### 3. Creación de Clases con Herencia Multinivel
**Descripción:** Se pide a los estudiantes que diseñen una jerarquía de clases basada en la creación de plantas, donde una clase `Planta` actúa como clase base y tiene dos subclases: `Hierba` e `Árbol`. Cada una debe tener características propias adicionales al modelo básico.

#### 4. Herencia vs Composición
**Descripción:** Los estudiantes deben discutir y demostrar cómo usar la herencia o la composición para modelar una relación de contención entre clases, como por ejemplo entre `Escuela` (contiene `Profesor`) y `Alumno`. La actividad busca entender cuándo es apropiado usar cada técnica.

#### 5. Sobrescribir Métodos en Herencia
**Descripción:** Se pide a los estudiantes que escriban una clase base con un método genérico, luego crear varias clases derivadas que sobreescriben este método para comportarse de manera diferente según su tipo específico (por ejemplo, `Aves` y `Peces`). La actividad pretende reforzar el concepto de polimorfismo.

#### 6. Ejercicio Práctico: Creación de un Sistema de Personajes
**Descripción:** Los estudiantes deben crear una jerarquía de clases que represente a diferentes personajes en un juego, como `Jugador` y `Enemigo`. Cada clase debe tener características específicas e implementar métodos comunes pero con comportamientos únicos.

#### 7. Uso de Superclases
**Descripción:** Se pide diseñar una estructura basada en la herencia donde una superclase abstracta tenga métodos y atributos que deben ser utilizados por sus subclases, mostrando cómo se utiliza `super()` para inicializar las partes comunes.

#### 8. Ejercicio de Refactorización
**Descripción:** Los estudiantes reciben un código con múltiples clases y les piden refactorizarlo para mejorar la estructura herárquica y el uso eficiente de la herencia, buscando eliminar redundancias y aumentar la cohesión del código.

#### 9. Herencia Profunda
**Descripción:** Los estudiantes deben diseñar una jerarquía compleja basada en una clase base `Objeto` que se ramifica para crear objetos más específicos como `Artefacto`, `Mueble`, y `Utensilio`. Cada nivel de la jerarquía debe agregar detalles específicos.

#### 10. Ejercicio de Polimorfismo Complejo
**Descripción:** Los estudiantes deben implementar un sistema donde varias clases (por ejemplo, diferentes tipos de vehículos) heredan de una clase base y se comportan en función del contexto actual, mostrando el uso avanzado de polimorfismo en situaciones prácticas.


<a id="ejercicio-de-final-de-unidad-3"></a>
## Ejercicio de final de unidad

### Introducción a los ejercicios

Este conjunto de ejercicios en Python está diseñado para cubrir los fundamentos básicos del lenguaje, desde la impresión simple hasta el manejo de datos y operaciones aritméticas. Los estudiantes aprenderán a trabajar con variables, tipos de datos, entradas y salidas, así como a realizar cálculos simples y comprender conceptos como literales y constantes. A medida que avanzan, se les introduce la creación de programas más complejos, como una calculadora básica para calcular impuestos, lo cual les ayuda a aplicar en práctica los conocimientos adquiridos sobre variables, tipos de datos y operaciones matemáticas.

La secuencia gradual del contenido permite a los estudiantes familiarizarse con la sintaxis y las estructuras básicas de Python antes de abordar problemas más complejos que requieren el uso combinado de varios conceptos. Esto incluye la conversión entre tipos de datos, uso eficaz de operadores aritméticos y de comparación, así como manipulación básica de entradas y salidas del usuario.

### Holamundo
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es muy sencillo y básico. Utiliza la función `print()` en Python para mostrar el texto "Hola mundo desde Python" en la pantalla cuando se ejecuta. Este tipo de programa, conocido como "Hola Mundo", sirve principalmente como un ejemplo introductorio para demostrar cómo crear e imprimir una cadena de texto en una aplicación de Python. Es importante porque ayuda a los estudiantes a entender cómo estructurar y ejecutar su primer código en el lenguaje, familiarizándose con la sintaxis básica y el flujo del programa.

`001-Holamundo.py`

```python
print("Hola mundo desde Python")
```

### variables
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código en Python está asignando valores a dos variables, `nombre` y `edad`. La variable `nombre` almacena el nombre de una persona como un texto (string), que en este caso es "Jose Vicente". Por otro lado, la variable `edad` guarda la edad de esa misma persona como un número entero (integer), que aquí se establece en 47. Este tipo de código es fundamental porque nos permite almacenar y manipular información sobre personas o cualquier entidad en nuestros programas, permitiéndonos realizar operaciones más complejas con esos datos a medida que avanzamos en el desarrollo del programa.

`002-variables.py`

```python
nombre = "Jose Vicente"
edad = 47
```

### salidas
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código Python muestra cómo imprimir una frase junto con un valor almacenado en una variable. En primer lugar, se crea una variable llamada `nombre` y se le asigna el valor de la cadena `"Jose Vicente"`. Luego, utilizando la función `print()`, el programa imprime en pantalla la frase `"Mi nombre es"` seguida del contenido de la variable `nombre`.

Esta técnica es útil cuando deseas combinar texto estático con información que puede variar, como un nombre o una fecha. La función `print()` permite incluir múltiples argumentos separados por comas y los muestra en orden, añadiendo espacios automáticamente entre ellos para mejorar la legibilidad de la salida en pantalla.

En resumen, este código es un ejemplo básico pero importante sobre cómo utilizar variables junto con texto estático para generar salidas personalizadas en Python.

`003-salidas.py`

```python
nombre = "Jose Vicente"
print("Mi nombre es",nombre)
```

### variar una variable
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código en Python muestra cómo se pueden cambiar los valores de una variable durante la ejecución del programa. En primer lugar, se asigna a la variable `nombre` el valor `"Jose Vicente"`, y luego este valor se imprime utilizando la función `print()`. Después, se cambia el valor de la misma variable `nombre` a `"Juan"` y se vuelve a imprimir.

Es importante entender que en Python (y en muchos otros lenguajes de programación), las variables son contenedores para almacenar datos. Estos contenedores pueden ser reutilizados y actualizados con nuevos valores durante el flujo del programa, como en este caso donde la variable `nombre` cambia su contenido desde `"Jose Vicente"` a `"Juan"`. Este tipo de cambio es muy útil cuando necesitas actualizar información basada en eventos o condiciones que ocurren mientras tu programa está en ejecución.

`004-variar una variable.py`

```python
nombre = "Jose Vicente"
print("Mi nombre es",nombre)

nombre = "Juan"
print("Mi nombre es",nombre)
```

### identificadores permitidos
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código en Python demuestra cómo funcionan los identificadores permitidos y no permitidos en el lenguaje. Los identificadores son nombres que utilizamos para variables, funciones u otros objetos en nuestro programa. En este caso, se muestran ejemplos válidos como `nombre` y `nombreCompleto`, donde las reglas importantes son usar letras o guiones bajos al principio seguido de letras, números o guiones bajos.

El código también incluye varias líneas que están comentadas con el símbolo `#`, lo cual significa que esas líneas no se ejecutan como parte del programa. Estas líneas muestran ejemplos de nombres que son ilegales en Python:

- No puedes comenzar un nombre con un número, por ejemplo: `2nombre`.
- Los guiones o espacios entre palabras no están permitidos; el nombre debe ser una sola palabra sin separaciones especiales. Ejemplos incorrectos incluyen `nombre-completo` y `nombre completo`.

Finalmente, aunque `nombreCompleto` es un identificador válido porque se compone de varias palabras en mayúscula al principio (también conocido como formato "Camel Case"), el comentario indica que no es la práctica recomendada debido a su dificultad para leerse y escribirse claramente. Es preferible usar guiones bajos entre las palabras, por ejemplo `nombre_completo`, para hacer más legibles los identificadores largos en Python.

`005-identificadores permitidos.py`

```python
nombre = "Jose"
nombre2 = "Vicente"
# 2nombre = "Jose Vicente"
nombre_completo = "Jose Vicente"
#nombre-completo = "Jose Vicente"
#nombre completo = "Jose Vicente"
nombreCompleto = "Jose Vicente" # Es legal pero no se recomienda
```

### comentarios
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código muestra dos tipos diferentes de comentarios en Python. El primer tipo es un comentario de una sola línea, que comienza con el símbolo numeral (#). Todo lo que se escriba después del numeral hasta el final de la línea será ignorado por el intérprete de Python y servirá simplemente para documentar o explicar ese fragmento del código.

El segundo tipo de comentario es un bloque de comentarios, también conocido como docstring (documentación en cadena). Estos comentarios se escriben entre tres comillas simples ('''...''') o tres comillas dobles ("""..."""). Los bloques de comentarios son útiles para documentar partes más grandes del código, proporcionando una descripción detallada de funciones, clases u otros elementos del programa. En este caso, el bloque de comentario explica que se trata de un comentario que abarca varias líneas y es ignorado por Python al ejecutar el código.

La importancia de los comentarios en la programación radica en su capacidad para ayudar a otros desarrolladores (y también a ti mismo en el futuro) a entender rápidamente qué hace cada parte del código. Esto mejora la legibilidad, mantenimiento y colaboración en proyectos de desarrollo.

`006-comentarios.py`

```python
# Esto es un comentario de una única línea

'''
    Esto es un comentario
    Esto sigue siendo un comentario
    Y esto también lo es
'''
```

### Explicacion del codigo
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código Python establece la variable `edad` y le asigna un valor específico. En esta línea, `edad` es el nombre que se le da a la variable, también conocido como identificador. El signo igual (`=`) es el operador de asignación que indica que queremos guardar en la variable `edad` el valor numérico 47. Este valor, 47, se llama literal porque representa un número específico sin necesidad de cálculos o referencias adicionales.

Este código es importante porque muestra cómo declarar y usar variables para almacenar información, como edades, en programas más grandes. Es una parte fundamental del aprendizaje de la programación ya que las variables permiten a los programas trabajar con datos variados e incluso cambiarlos durante la ejecución.

`007-Explicacion del codigo.py`

```python
edad = 47
# edad es el identificador
# = es el operador de asignación
# 47 es el valor literal que se es está asignando al identificador
```

### Tipos de datos
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código en Python está asignando diferentes tipos de datos a varias variables. Comenzamos definiendo `nombre` como una cadena de texto, que en este caso es `"Jose Vicente"`. Luego, creamos la variable `edad` y le asignamos un número entero, que es el valor 47. A continuación, definimos `altura` con un número decimal (también conocido como flotante) que tiene el valor 1.78. Finalmente, declaramos una variable llamada `vivo`, y le damos un valor booleano `True`, lo cual significa "verdadero". Estas líneas de código son importantes porque ilustran cómo Python maneja diferentes tipos de datos para almacenar información variada y permitir operaciones más complejas en el futuro.

`008-Tipos de datos.py`

```python
nombre = "Jose Vicente" # Cadena
edad = 47 # Entero
altura = 1.78 # Decimal
vivo = True # Booleano
```

### Entradas
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código en Python solicita al usuario que ingrese su nombre y luego muestra el nombre ingresado por pantalla. La primera línea utiliza la función `input()` para pedirle al usuario que introduzca su nombre cuando se le hace la pregunta "Dime tu nombre: ". Todo lo que el usuario escriba se guarda en la variable llamada `nombre`. Luego, la segunda línea usa la instrucción `print` para mostrar por pantalla un mensaje que dice "Tu nombre es: " seguido del valor almacenado en la variable `nombre`.

Este código es importante porque muestra cómo interactuar con el usuario y recoger datos directamente desde teclado, lo cual es fundamental cuando se desarrollan programas interactivos.

`009-Entradas.py`

```python
nombre = input("Dime tu nombre: ")
print("Tu nombre es: ",nombre)
```

### Entrada y problema
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código en Python solicita al usuario que ingrese su edad y luego imprime el doble de esa edad. Primero, la línea `edad = input("Dime tu edad: ")` muestra un mensaje en pantalla pidiendo al usuario que introduzca su edad. El valor ingresado por el usuario se guarda en la variable `edad`. Es importante notar que la función `input()` siempre devuelve una cadena de texto (string), incluso si el usuario ingresa un número.

Luego, la línea `print("El doble de tu edad es: "+edad)` imprime un mensaje que indica cuál sería el doble de la edad ingresada. Sin embargo, en este caso, no se está calculando realmente el doble de la edad; simplemente se está mostrando nuevamente la cadena almacenada en `edad`. Para calcular correctamente el doble de la edad, necesitaríamos convertir la entrada del usuario (que es una cadena) a un número entero usando la función `int()` antes de hacer cualquier operación matemática.

`010-Entrada y problema.py`

```python
edad = input("Dime tu edad: ")
print("El doble de tu edad es: "+edad)
```

### Cambio de tipo de dato
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código pide al usuario que ingrese su edad, realiza algunos cálculos y luego muestra el resultado en la pantalla. Primero, el programa utiliza la función `input()` para obtener una entrada del usuario, almacenando esa entrada como una cadena de texto (texto) en la variable `edad`. Luego, convierte esa cadena a un número entero usando la función `int()`, guardándolo en la variable `entero`.

Después, el programa calcula el doble de este número entero y lo almacena en otra variable llamada `doble`. Finalmente, intenta imprimir el resultado del doble de la edad utilizando la función `print()`.

Es importante notar que hay un error en esta línea: `print("El doble de tu edad es: "+doble)`. El código está tratando de concatenar una cadena (texto) con un número entero, lo cual no es permitido en Python sin convertir el tipo de dato. Para solucionarlo, deberías convertir la variable `doble` a una cadena antes de imprimir:

```python
print("El doble de tu edad es: " + str(doble))
```

Este código ayuda a entender cómo se pueden transformar los tipos de datos entre texto y números, lo cual es fundamental para interactuar con el usuario que puede ingresar información en formato de texto pero necesitas realizar cálculos numéricos.

`011-Cambio de tipo de dato.py`

```python
# Le pregunto al usuario por su edad
edad = input("Dime tu edad: ")
# Me aseguro de convertir la edad a un número entero
entero = int(edad)
# Calculo el doble de un número entero
doble = entero*2
# Saco el resultado por pantalla
print("El doble de tu edad es: "+doble)
```

### literales
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código Python establece dos variables, `nombre` y `edad`, utilizando literales. Un literal en programación es simplemente una forma directa de representar un valor básico en el código sin necesidad de cálculos o conversiones adicionales.

En primer lugar, se define la variable `nombre` y se le asigna el valor `"Jose Vicente"`. Este valor está entre comillas dobles, lo que indica que es una cadena de caracteres (o string), un tipo de dato utilizado para representar texto en Python.

Seguidamente, se establece la variable `edad` con el valor `47`, que no está encerrado en comillas. Esto significa que el literal `47` se interpreta como un número entero (integer).

Estos ejemplos son fundamentales porque te ayudan a comprender cómo almacenar diferentes tipos de datos en variables, lo cual es una habilidad básica y necesaria para cualquier programa.

`012-literales.py`

```python
nombre = "Jose Vicente"
# Jose Vicente es el literal, y es de tipo cadena

edad = 47
# 47 es el literal, y es de tipo entero
```

### constantes
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código en Python te enseña cómo se manejan las "constantes" y las diferencias entre mayúsculas y minúsculas para nombrarlas. Al principio, el programa define una constante llamada `PI` con un valor aproximado de 3.1415 y luego imprime este valor en pantalla. Luego, cambia el valor de `PI` a 4 y vuelve a imprimirlo.

Es importante notar que en Python no hay un tipo de dato específico para constantes como tal, pero se convierte en una convención entre los programadores usar mayúsculas para las variables que deberían considerarse constantes (como el valor matemático de PI). Al final del código, el autor incluye dos comentarios para recordarte esta práctica: usar letras mayúsculas para constantes y minúsculas para variables. Aunque en este caso `PI` cambia su valor después de la primera asignación, la intención es mostrar que no debes cambiar el valor de una constante durante la ejecución del programa.

Este código te ayuda a entender las buenas prácticas de codificación en Python y cómo puedes comunicar tu intención al lector del código mediante convenciones de nombrado.

`013-constantes.py`

```python
PI = 3.1415

print("PI vale",PI)

PI = 4 # Le cambio el valor a PI

print("PI vale",PI)
# Las constantes deben formularse con mayúsculas
# Las variables deben formularse con minúsculas
```

### Diferencia
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código está mostrando un ejemplo sobre cómo se pueden cambiar las definiciones de variables en Python, lo cual puede ser confuso al principio. En primer lugar, el programa define una constante llamada `PI` y le asigna el valor numérico 3.1416. Sin embargo, justo después, la misma variable `PI` es reasignada con el valor "unnumero", que en este caso es un texto (string) en lugar de un número.

Lo importante aquí es entender que en Python, las variables no tienen tipos fijos y pueden cambiar su contenido a lo largo del programa. Esto significa que una variable puede contener números al principio y luego strings más tarde, como ocurre en este ejemplo con la constante `PI`. Aunque técnicamente se llama a esta variable "constante", el código demuestra cómo se puede modificar ese valor.

Es crucial entender que aunque el comentario inicial sugiere que `PI` es una constante matemática (π), en programación, esto no implica que su valor sea inmutable. En este caso particular, la declaración de `PI` como constante es más bien un comentario descriptivo y no limita el cambio del valor de la variable en absoluto.

`014-Diferencia.py`

```python

# La constante es PI
# El literal es 3.1416

PI = 3.1416

PI = "unnumero"
```

### operadores aritmeticos
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código en Python muestra cómo se utilizan diferentes operadores aritméticos para realizar cálculos básos. Los operadores que se muestran son:

1. La suma (`+`) entre dos números (en este caso, 4 y 3), lo cual imprime el resultado de la suma.
2. La resta (`-`), que resta uno del otro.
3. La multiplicación (`*`), que multiplica los dos números juntos para dar un producto.
4. La división (`/`), que divide el primer número por el segundo y muestra el cociente en formato decimal.
5. El operador módulo (`%`), que devuelve el resto de la división entera entre los dos números.

Cada línea del código utiliza uno de estos operadores para realizar una operación matemática específica con los números 4 y 3, e imprime el resultado en la consola o terminal. Esta es una forma básica de entender cómo Python maneja cálculos numéricos y proporciona resultados directamente.

ÚLTIMO PÁRRAFO: En comparación con el archivo anterior (`014-Diferencia.py`), este nuevo código abandona por completo el uso de constantes o literales para centrarse en la demostración práctica de varios operadores aritméticos, mostrando directamente cómo se utilizan y qué resultados producen cuando se aplican a números específicos.

`014-operadores aritmeticos.py`

```python
print(4+3)
print(4-3)
print(4*3)
print(4/3)
print(4%3)
```

### operadores de comparacion
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código muestra cómo se utilizan los operadores de comparación en Python. Los operadores de comparación permiten que el programa compare dos valores y devuelva un resultado booleano (verdadero o falso) basado en la relación entre esos valores.

En este caso, cada línea del código compara el número 4 con el número 3 usando diferentes tipos de operadores: menor que (`<`), menor o igual que (`<=`), mayor que (`>`), mayor o igual que (`>=`), igual a (`==`), y distinto de (`!=`). Cuando se ejecuta, cada comparación imprime `True` (verdadero) si la condición es cierta, y `False` (falso) si no lo es.

Por ejemplo, `print(4 < 3)` imprimirá `False` porque 4 no es menor que 3. Por otro lado, `print(4 > 3)` imprimirá `True` ya que 4 es mayor que 3. Estos operadores son fundamentales en la programación para tomar decisiones basadas en condiciones específicas, como controlar el flujo de un programa o realizar acciones dependiendo del resultado de una comparación.

`015-operadores de comparacion.py`

```python
print(4 < 3)
print(4 <= 3)
print(4 > 3)
print(4 >= 3)
print(4 == 3)
print(4 != 3)
```

### operadores arimeticos abreviados
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código te enseña cómo usar operadores aritméticos abreviados en Python. Primero, se establece una variable llamada `edad` con un valor inicial de 47 años. Luego, el programa realiza varias operaciones matemáticas sobre esta variable para mostrar cómo sumar, restar, multiplicar y dividir su valor.

En lugar de escribir la operación completa (por ejemplo, `edad = edad + 2`), se utiliza una versión más corta (`edad += 2`) que hace lo mismo. Esto no solo es más conciso sino también más fácil de leer cuando se manejan operaciones simples. La misma lógica aplica para las demás operaciones: resta (`-=`, por ejemplo `edad -= 2`), multiplicación (`*=`, como en `edad *= 2`) y división (`/=` con `edad /= 2`). Estos operadores abreviados son comunes en programación porque permiten escribir código más limpio y eficiente sin perder la claridad.

`016-operadores arimeticos abreviados.py`

```python
edad = 47
# Le quiero sumar dos unidades
edad = edad + 2
edad += 2
#Le quiero restar dos unidades
edad = edad - 2
edad -= 2
# Lo quiero multiplicar por dos
edad = edad * 2
edad *= 2
# Lo quiero dividir por dos
edad = edad / 2
edad /= 2
```

### operadores booleanos
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código en Python utiliza operadores booleanos para evaluar y comparar diferentes expresiones. Los operadores booleanos `and` y `or` son utilizados para combinar varias condiciones lógicas. En el código, se compara si varios números son iguales entre sí.

1. La primera línea comprueba tres igualdades (`4 == 4`, `3 == 3`, `2 == 2`) usando el operador `and`. Como todas estas comparaciones son verdaderas, la salida será `True`.

2. En la segunda línea, dos de las comparaciones son correctas (`4 == 4` y `3 == 3`), pero la tercera es falsa (`2 == 1`). Por lo tanto, el resultado final es `False` porque todos los elementos combinados con `and` deben ser verdaderos para que toda la expresión sea verdadera.

3. La tercera línea utiliza el operador `or`, por lo que solo necesita una de las comparaciones ser verdadera para que todo sea verdadero (`True`). Como en esta línea todas las condiciones son falsas, excepto `4 == 4` (que es verdadera), la salida será `True`.

4. La cuarta línea incluye dos comparaciones falsas y una verdadera (`3 == 2` es falso, pero `4 == 4` es verdadero), por lo que el resultado de la expresión con `or` será `True`.

5. Finalmente, en la quinta línea todas las comparaciones son falsas (`4 == 3`, `3 == 2`, `2 == 1`). Debido a esto, y al usar el operador `or`, la salida será `False` ya que no hay ninguna condición verdadera.

Estos ejercicios ayudan a entender cómo funcionan los operadores booleanos en Python y son fundamentales para manipular lógicas complejas en programas más grandes.

`017-operadores booleanos.py`

```python
print(4 == 4 and 3 == 3 and 2 == 2)
print(4 == 4 and 3 == 3 and 2 == 1)

print(4 == 4 or 3 == 3 or 2 == 1)
print(4 == 4 or 3 == 2 or 2 == 1)
print(4 == 3 or 3 == 2 or 2 == 1)
```

### Ejercicio1-Calculadora de impuestos
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es la cabecera o encabezado de un archivo Python que describe el propósito del programa llamado "Calculadora de Impuestos". La versión del programa es v0.1 y está creada por Jose Vicente Carratalá. En términos funcionales, este programa permite al usuario ingresar una cantidad base (normalmente antes de impuestos) y luego calcula automáticamente el IVA sobre esa cantidad y también proporciona la suma total que incluye el IVA.

Esta cabecera es importante porque ayuda a los desarrolladores o usuarios del código a entender rápidamente para qué sirve el programa, quién lo creó y qué versión están utilizando. Es una práctica común en programación añadir esta información al inicio de archivos para facilitar la colaboración y el mantenimiento del código.

`018-Ejercicio1-Calculadora de impuestos.py`

```python
'''
    Calculadora de Impuestos
    v0.1 por Jose Vicente Carratalá
    Funcionamiento: Introduce una base imponible y se calcula IVA y total
'''
```

### Calculadora
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es el comienzo de un programa en Python que sirve como una simple calculadora para calcular impuestos. El objetivo principal del programa es permitir al usuario introducir la base imponible (el monto antes del impuesto) y luego realizar cálculos sobre este valor para obtener tanto el IVA como el total de la factura.

El código inicia con comentarios que describen brevemente lo que hace el programa, quién lo ha creado y su versión. A continuación, se declaran tres variables: `base_imponible`, `total_iva` e `total_factura`. Estas variables almacenarán los valores de la base imponible antes del impuesto, el total del IVA calculado y el total de la factura (que es la suma de la base imponible y el IVA respectivamente).

El programa luego solicita al usuario que introduzca la base imponible mediante la función `input()`. Esta línea toma lo que el usuario digita en el teclado y guarda esa entrada en la variable `base_imponible`.

Es importante destacar que, aunque se inicializan las variables `total_iva` e `total_factura`, aún no se realizan cálculos para estas. Estas líneas de código muestran que falta implementar la lógica matemática necesaria para calcular el IVA y el total de la factura basado en lo introducido por el usuario.

`019-Calculadora.py`

```python
'''
    Calculadora de Impuestos
    v0.1 por Jose Vicente Carratalá
    Funcionamiento: Introduce una base imponible y se calcula IVA y total
'''

# Este programa no tiene importaciones

# Creo variables
base_imponible = 0
total_iva = 0
total_factura = 0

# Aquí pondría las funciones/clases

# Ahora calculamos
base_imponible = input("Introduce la base imponible de la factura: ")
```

### Calculadora
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código es el inicio de un programa en Python que sirve como una simple calculadora de impuestos. El objetivo del programa es permitir al usuario introducir la base imponible (el precio sin IVA) de una factura y calcular automáticamente el IVA aplicado y el total a pagar.

El programa comienza mostrando algunos mensajes para informar al usuario sobre lo que va a hacer, incluyendo un aviso de copyright. Luego, utiliza la función `input()` para solicitar al usuario que introduzca la base imponible. Esta entrada se guarda en la variable `base_imponible`.

Es importante destacar que este código es solo el inicio del programa y necesita más líneas para calcular realmente el IVA y mostrar los resultados. Para completarlo, necesitarías agregar funciones o cálculos adicionales que utilicen la base imponible introducida por el usuario para determinar el IVA y el total de la factura.

`020-Calculadora.py`

```python
'''
    Calculadora de Impuestos
    v0.1 por Jose Vicente Carratalá
    Funcionamiento: Introduce una base imponible y se calcula IVA y total
'''

# Este programa no tiene importaciones

# Creo variables
base_imponible = 0
total_iva = 0
total_factura = 0

# Aquí pondría las funciones/clases

# Ahora calculamos
print("Programa calculadora de impuestos")
print("(c) 2025 Jose Vicente Carratalá")
print("Introduce una base y te calculo el IVA y el total")
base_imponible = input("Introduce la base imponible de la factura: ")
```

### Calculo de IVA
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código es un programa sencillo que calcula el IVA y el total de una factura a partir de la base imponible introducida por el usuario. El programa inicia mostrando información sobre su autor y función. Luego, solicita al usuario que ingrese la base imponible de la factura mediante un mensaje en pantalla. Una vez obtenido este valor, realiza los cálculos necesarios para determinar el IVA (que es una proporción del 21% de la base imponible) y el total de la factura (base imponible más IVA). Finalmente, muestra estos resultados al usuario también a través de mensajes en pantalla. Este tipo de programa es útil para ayudar a las personas a entender cuánto costará algo después de aplicar impuestos o simplemente para practicar cómo manejar entradas y salidas de datos en Python.

`021-Calculo de IVA.py`

```python
'''
    Calculadora de Impuestos
    v0.1 por Jose Vicente Carratalá
    Funcionamiento: Introduce una base imponible y se calcula IVA y total
'''

# Este programa no tiene importaciones

# Creo variables
base_imponible = 0
total_iva = 0
total_factura = 0

# Aquí pondría las funciones/clases

# Ahora calculamos

# Primero pido una entrada
print("Programa calculadora de impuestos")
print("(c) 2025 Jose Vicente Carratalá")
print("Introduce una base y te calculo el IVA y el total")
base_imponible = float(input("Introduce la base imponible de la factura: "))

# Luego realizo cálculos
total_iva = base_imponible*0.21
total_factura = base_imponible + total_iva

# Por último expreso una salida
print("El IVA de la factura es: ",total_iva)
print("El total de la factura es: ",total_factura)
```

### Actividades propuestas

### Actividades Propuestas para los Estudiantes

#### 1. **Imprimir Datos Básicos**
**Descripción:** Los estudiantes deben crear un programa que imprima su nombre completo y edad en pantalla. Se espera que aprendan a utilizar las declaraciones de variables y la función `print()`.

#### 2. **Manejo de Entradas y Salidas**
**Descripción:** El alumnado debe realizar un programa que pida el nombre del usuario por consola y lo imprima con una frase amigable. Se espera que aprendan a utilizar la función `input()` junto con las declaraciones de variables.

#### 3. **Cambio en Variables**
**Descripción:** Los estudiantes deben escribir un código que cambie el valor de una variable ya existente y muestre los cambios por pantalla. Aprenderán cómo actualizar valores de variables existentes y usar múltiples impresiones para verificar las modificaciones.

#### 4. **Uso de Tipos de Datos**
**Descripción:** Se les solicita a los estudiantes que creen un programa que declare variables con distintos tipos de datos (cadenas, enteros, decimales y booleanos) e imprima sus valores en pantalla. Aprenderán sobre las diferencias entre tipos de datos y cómo declararlos.

#### 5. **Operaciones Matemáticas Básicas**
**Descripción:** Los alumnos deben crear un programa que realice operaciones matemáticas básicas como suma, resta, multiplicación y división utilizando dos números enteros dados por el usuario. Se espera que aprendan a usar los operadores aritméticos en Python.

#### 6. **Operadores de Comparación**
**Descripción:** Los estudiantes deben escribir un código que compare dos variables numéricas con diferentes operadores (menor, mayor, igual) y muestre el resultado por pantalla. Se espera que comprendan los operadores de comparación y cómo utilizarlos en expresiones condicionales.

#### 7. **Operaciones Aritméticas Avanzadas**
**Descripción:** Los estudiantes deben modificar un programa dado para que use operadores aritméticos abreviados (+=, -=, *=, /=) en lugar de las operaciones tradicionales. Se espera que aprendan a utilizar estos operadores eficientemente.

#### 8. **Operaciones Booleanas**
**Descripción:** Los alumnos deben crear un programa que combine varios operadores lógicos (and, or) para realizar comparaciones entre variables y mostrar el resultado por pantalla. Aprenderán sobre los operadores booleanos en Python y cómo utilizarlos en expresiones complejas.

#### 9. **Cálculo de Impuestos**
**Descripción:** Se les pide a los estudiantes que completen un programa para calcular IVA y total de una factura basándose en la base imponible ingresada por el usuario. Se espera que aprendan a realizar cálculos matemáticos con datos ingresados por consola.

#### 10. **Constantes vs Variables**
**Descripción:** Los estudiantes deben escribir un código que demuestre la diferencia entre una variable y una constante en Python, asignando valores y cambiándolos según corresponda. Aprenderán sobre el uso correcto de constantes y variables.

Estas actividades están diseñadas para ayudar a los estudiantes a adquirir habilidades fundamentales en programación con Python, adaptándose al nivel intermedio previsto para la Formación Profesional DAM (Desarrollo de Aplicaciones Multiplataforma).



<a id="lectura-y-escritura-de-informacion"></a>
# Lectura y escritura de información

<a id="flujos-tipos-bytes-y-caracteres-clases-relacionadas"></a>
## Flujos. Tipos bytes y caracteres. Clases relacionadas

### Introducción a los ejercicios

En esta carpeta de ejercicios, se exploran conceptos fundamentales relacionados con la manipulación de archivos en Python. Los estudiantes aprenderán cómo crear y escribir información en un archivo utilizando la función `open()` con el modo 'w' (write) para sobrescribir o crear nuevos archivos. También se enseñará cómo leer contenido desde un archivo existente usando el modo 'r' (read). Además, se incluye una práctica más avanzada donde los estudiantes crean una pequeña aplicación de agenda que permite añadir y listar contactos en un archivo, utilizando la opción 'a' (append) para agregar información sin borrar lo ya existente. Estos ejercicios ayudarán a fortalecer las habilidades de manejo básico de archivos y flujo de entrada/salida en Python.

### escribir texto a archivo
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código Python se utiliza para escribir información en un archivo de texto llamado "clientes.txt". La primera línea del código abre el archivo en modo escritura ('w'), lo que significa que cualquier contenido existente en el archivo será borrado y podrás añadir nuevo contenido. Luego, la segunda línea escribe una frase simple ("Esto es una prueba") dentro del archivo recién abierto. Finalmente, la tercera línea cierra el archivo para asegurarse de que toda la información se guarda correctamente y que los recursos sean liberados. Es importante cerrar siempre un archivo después de usarlo para evitar posibles problemas con otros programas o procesos que intenten acceder al mismo archivo.

`001-escribir texto a archivo.py`

```python
archivo = open("clientes.txt",'w') # W = Write

archivo.write("Esto es una prueba")

archivo.close()
```

### ahora leemos
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código en Python se utiliza para leer el contenido de un archivo llamado "clientes.txt". El programa comienza abriendo el archivo en modo lectura ('r'), lo que significa que solo va a leer los datos del archivo, no modificarlos. Luego, la función `readline()` lee la primera línea del archivo y la almacena en la variable `contenido`. Después de eso, se imprime esa línea usando la función `print()`. Finalmente, el archivo es cerrado con `archivo.close()`, lo que es importante hacer para asegurarse de que los recursos no se agoten si se abren muchos archivos. Este código te muestra cómo abrir un archivo, leer una línea específica y luego cerrar el archivo correctamente, lo cual es fundamental en la manipulación de archivos en Python.

`002-ahora leemos.py`

```python
archivo = open("clientes.txt",'r') # R = Read

contenido = archivo.readline()
# También existe archivo.readlines()

print(contenido)

archivo.close()
```

### creador agenda
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código es una pequeña aplicación en Python que permite gestionar una agenda de contactos básica. El programa muestra un menú con dos opciones: añadir un nuevo contacto y leer todos los contactos existentes.

Cuando el usuario selecciona la opción 1, se le pide que introduzca el nombre y el email del contacto que desea agregar. La información es entonces escrita en un archivo llamado "agenda.txt", usando el modo 'a' para añadir esta nueva línea al final del archivo sin eliminar lo que ya estaba allí.

Si el usuario selecciona la opción 2, se abre el mismo archivo "agenda.txt" pero en este caso con el modo 'r', que significa lectura. El programa lee todas las líneas del archivo y las imprime una por una en la consola para mostrar todos los contactos almacenados.

Este tipo de estructura permite a un usuario interactuar fácilmente con un archivo de texto, añadiendo o leyendo datos sin necesidad de tener que hacerlo manualmente. Es importante notar cómo el uso adecuado de 'open' y 'close' asegura la correcta manipulación del archivo para evitar cualquier pérdida de datos o problemas con permisos en el sistema operativo.

`003-creador agenda.py`

```python
while True:
  print("Dime lo que quieres hacer: ")
  print("1.-Introduce un nuevo contacto")
  print("2.-Leer todos los contactos")
  opcion = int(input("Escoge tu opción: "))
  if opcion == 1:
    nombre = input("Introduce el nombre de la persona: ")
    email = input("Introduce el email de la persona: ")
    archivo = open("agenda.txt",'a') # A = añadir
    archivo.write(nombre+","+email+"\n")
    archivo.close()
  elif opcion == 2:
    archivo = open("agenda.txt",'r')
    lineas = archivo.readlines()
    for linea in lineas:
      print(linea)
    archivo.close()
```

### agenda
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código no es realmente un bloque de código en sí, sino que parece ser una línea dentro de un archivo de texto llamado `agenda.txt`. En este caso, la línea contiene información sobre una persona y su correo electrónico. Específicamente, "Jorge" es el nombre de la persona y "jorge@jocarsa.com" es su dirección de correo electrónico.

En el contexto del curso, esta línea sería probablemente parte de un ejercicio donde se trabaja con archivos de texto para leer o escribir datos. La idea es que los estudiantes aprendan a manipular archivos en Python, extrayendo información como nombres y correos electrónicos, lo cual es una habilidad fundamental en la programación y el procesamiento de datos.

Es importante entender cómo acceder y manipular este tipo de información ya que permite interactuar con bases de datos simplificadas o realizar tareas automatizadas que requieren el uso de listas de contactos o registros similares.

`agenda.txt`

```
Jorge,jorge@jocarsa.com
```

### clientes
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

El fragmento de código que has proporcionado no es realmente un código de programación, sino simplemente texto. En este caso, "Esto es una prueba" parece ser un comentario o una nota para el autor del archivo o para otros lectores. No realiza ninguna acción en particular dentro de un programa y no tiene efectos sobre la ejecución de ningún script o programa.

En contextos de programación, es común ver comentarios como este durante las etapas iniciales de desarrollo cuando se está experimentando con la estructura del archivo antes de incorporar el código real. Sin embargo, en un archivo final, sería recomendable eliminar estos mensajes u otros textos que no sean parte del código ejecutable para mantener la limpieza y claridad del programa.

Dado que este texto aparece en un archivo relacionado con ejercicios de programación específicos sobre lectura y escritura de archivos (como los mencionados: 001-escribir texto a archivo.py, 002-ahora leemos.py), es posible que haya sido dejado ahí como recordatorio o para indicar la intención del ejercicio.

`clientes.txt`

```
Esto es una prueba
```

### Actividades propuestas

1. **Lectura y escritura básica de archivos**
   - **Descripción:** Los estudiantes deben abrir un archivo existente, leer su contenido e imprimirlo en la consola. A continuación, deberán escribir una nueva línea al mismo archivo sin borrar el contenido previo. Este ejercicio ayuda a entender las diferencias entre los modos 'r' y 'a'.

2. **Manejo de excepciones en archivos**
   - **Descripción:** Los estudiantes deben crear un programa que abra un archivo, pero si no existe, deberá mostrar un mensaje indicando que el archivo está faltante sin producir un error crítico. Este ejercicio enseña sobre manejo de errores y la importancia del control excepcional.

3. **Crear una agenda personal**
   - **Descripción:** A partir del código proporcionado, los estudiantes deben desarrollar un programa que permita a los usuarios agregar múltiples contactos (nombre y email) en una agenda digital y posteriormente leer todos los contactos existentes. Esto refuerza la comprensión de bucles, condicionales y archivos.

4. **Modificando datos en el archivo**
   - **Descripción:** Los estudiantes deben escribir un programa que permita a los usuarios buscar y editar un contacto específico dentro del archivo 'agenda.txt'. Este ejercicio mejora las habilidades para manipular archivos existentes y trabajar con estructuras de control más complejas.

5. **Flujos de bytes vs flujos de caracteres**
   - **Descripción:** Los estudiantes deben investigar e implementar el manejo de ambos tipos de flujo (bytes y caracteres) al leer y escribir en un archivo binario. Este ejercicio ayuda a entender las diferencias fundamentales entre los dos y cuándo usar cada uno.

6. **Validación de datos antes del guardado**
   - **Descripción:** Los estudiantes deben añadir validaciones para asegurarse de que el nombre y email introducidos en la agenda sean correctos (por ejemplo, verificar que el correo electrónico tenga un @) antes de guardarlos en el archivo. Este ejercicio enseña sobre la importancia de la validación de datos.

7. **Programa de gestión de clientes**
   - **Descripción:** Los estudiantes deben crear un programa similar al proporcionado pero orientado a gestionar una lista de clientes (nombre, email y teléfono). Este ejercicio implica trabajar con archivos más complejos que incluyen múltiples campos para cada registro.

8. **Búsqueda y eliminación de registros**
   - **Descripción:** Los estudiantes deben implementar la funcionalidad en su agenda o programa de gestión de clientes para buscar un contacto específico y permitir su eliminación del archivo. Esto refuerza las habilidades de lectura/escritura selectiva en archivos.

9. **Integrando funciones**
   - **Descripción:** Los estudiantes deben dividir el código proporcionado en varias funciones (una para leer, otra para escribir, etc.) y luego usarlas en un menú principal. Este ejercicio ayuda a entender la modularización del código.

10. **Backup de archivos**
    - **Descripción:** Los estudiantes deben crear una función que genere automáticamente un archivo de respaldo cada vez que se realizan cambios importantes (como añadir o eliminar registros). Esto enseña sobre buenas prácticas en el manejo y seguridad de datos.


<a id="ficheros-de-datos-registros"></a>
## Ficheros de datos. Registros

### Introducción a los ejercicios

En esta carpeta de ejercicios, trabajaremos principalmente con la lectura y manipulación de archivos en diferentes formatos como HTML, JSON y texto plano. Los ejercicios te guiarán a través del proceso de leer datos desde estos archivos y luego acceder y mostrar dicha información en Python. Asimismo, explorarás cómo integrar esta lógica con un servidor web básico usando Flask para generar páginas HTML dinámicamente a partir de los datos leídos. Este conjunto de ejercicios fortalecerá tus habilidades en el manejo de archivos y estructuras de datos en Python, además de introducirte al desarrollo web mediante la creación de sitios simples que muestran información almacenada en archivos externos.

### leer archivo
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código se encarga de leer un archivo llamado "blog.txt" y mostrar su contenido en la consola línea por línea. En primer lugar, el programa abre el archivo "blog.txt" en modo lectura ('r'), lo que significa que solo va a leer los datos del archivo sin modificarlo. Luego, lee todas las líneas del archivo y las almacena en una lista llamada `lineas`. Finalmente, recorre cada elemento de la lista (cada línea) e imprime el contenido de esa línea en la consola. Este tipo de código es fundamental para entender cómo interactuar con archivos en Python, lo que es crucial cuando necesitas manejar información almacenada fuera del programa.

`001-leer archivo.py`

```python
archivo = open("blog.txt",'r')

lineas = archivo.readlines()

for linea in lineas:
  print(linea)
```

### leer json
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código Python se utiliza para leer un archivo JSON llamado "blog.json" y mostrar su contenido en pantalla. Primero, importa el módulo `json`, que proporciona las herramientas necesarias para trabajar con archivos JSON.

Luego, abre el archivo "blog.json" en modo lectura ('r'). Este archivo contiene datos estructurados como un diccionario o lista de Python. A continuación, utiliza la función `json.load()` para cargar los datos del archivo en una variable llamada `contenido`. Esta función convierte el contenido JSON del archivo en un objeto Python que es fácil de manipular.

Finalmente, imprime el contenido cargado en pantalla con la función `print()`, lo que permite ver los datos estructurados del archivo JSON. Este tipo de operación es importante cuando necesitas procesar o analizar información almacenada en formatos JSON.

`002-leer json.py`

```python
import json

archivo = open("blog.json",'r')

contenido = json.load(archivo)

print(contenido)
```

### leemos linea a linea
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código Python se utiliza para leer un archivo JSON y mostrar su contenido línea por línea. Primero, el programa importa la biblioteca `json`, que es necesaria para trabajar con archivos en formato JSON.

Luego, se abre el archivo llamado "blog.json" en modo de lectura (`'r'`). Este archivo contiene datos estructurados en formato JSON. Después de abrir el archivo, se carga su contenido usando la función `json.load()`, lo que convierte los datos JSON en un objeto Python iterable (generalmente una lista o un diccionario).

Finalmente, el código itera sobre cada elemento del objeto cargado y lo imprime en pantalla con el comando `print(linea)`. Cada elemento del archivo JSON se muestra de forma individual, permitiendo ver fácilmente los datos estructurados que contiene. Este tipo de lectura es útil cuando necesitas procesar o revisar manualmente la información almacenada en un archivo JSON.

`003-leemos linea a linea.py`

```python
import json

archivo = open("blog.json",'r')

contenido = json.load(archivo)

for linea in contenido:
  print(linea)
```

### ahora accedemos a las parejas
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código en Python es utilizado para leer un archivo JSON llamado `blog.json` y luego imprimir información específica de cada entrada del archivo. Primero, el programa abre el archivo `blog.json` en modo lectura (`'r'`). Luego, utiliza la función `json.load()` para cargar el contenido del archivo como un objeto Python (generalmente un diccionario o una lista).

El código continúa con un bucle `for`, que itera sobre cada elemento del objeto cargado. Dado que se asume que este objeto es una colección de entradas, cada iteración del bucle procesa una entrada individual y muestra en pantalla el título (`'titulo'`), la fecha (`'fecha'`), el autor (`'autor'`) y el contenido (`'contenido'`) de esa entrada.

Este tipo de código es importante para comprender cómo se manejan archivos externos en Python, así como cómo trabajar con datos estructurados almacenados en formato JSON. Es útil tanto para la lectura como para la manipulación de información que puede ser compartida entre diferentes aplicaciones o sistemas.

`004-ahora accedemos a las parejas.py`

```python
import json

archivo = open("blog.json",'r')

contenido = json.load(archivo)

for linea in contenido:
  print(linea['titulo'])
  print(linea['fecha'])
  print(linea['autor'])
  print(linea['contenido'])
```

### una pequeña decoracion
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código en Python se utiliza para leer y mostrar el contenido de un archivo JSON llamado `blog.json`. Primero, el programa abre este archivo en modo lectura (`'r'`). Luego, usa la función `json.load()` para cargar los datos del archivo en una estructura de datos Python, generalmente un diccionario o una lista dependiendo del formato del JSON.

El código itera sobre cada línea (en realidad, cada elemento) dentro de este contenido cargado. Cada elemento se espera que sea un diccionario que contiene información sobre un artículo, como el título, la fecha, el autor y el contenido del mismo. Para cada artículo, el programa imprime una serie de detalles: primero, muestra un encabezado para indicar que comienza un nuevo artículo; luego, imprime los valores asociados a las claves 'titulo', 'fecha', 'autor' y 'contenido' dentro del diccionario correspondiente. Finalmente, imprime un pie de página similar al encabezado para marcar el final del artículo antes de pasar al siguiente.

Este tipo de código es importante porque muestra cómo manejar datos estructurados en formato JSON, que es muy común cuando trabajas con APIs web y bases de datos no relacionales.

`005-una pequeña decoracion.py`

```python
import json

archivo = open("blog.json",'r')

contenido = json.load(archivo)

for linea in contenido:
  print("####### ARTICULO ########")
  print(linea['titulo'])
  print(linea['fecha'])
  print(linea['autor'])
  print(linea['contenido'])
  print("#########################")
  print("")
```

### blog
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código es una plantilla básica de HTML que crea la estructura fundamental de una página web. La etiqueta `<!doctype html>` al inicio indica que el documento sigue las reglas del HTML5, lo cual es importante para que los navegadores interpreten correctamente el contenido.

En la sección `<head>`, encontramos información crucial pero no visible directamente en la página. Aquí está especificado el título de la página "JOCARSAblog" entre las etiquetas `<title>` y `</title>`. Este título aparecerá en la pestaña del navegador y es muy importante para SEO (posicionamiento en motores de búsqueda). Además, se establece un conjunto de caracteres codificados (`utf-8`) que asegura que todos los símbolos y caracteres especiales puedan ser mostrados correctamente.

La parte `<body>` está vacía por ahora, pero aquí es donde irán todas las partes visibles del contenido web: texto, imágenes, enlaces y más. Este archivo HTML parece estar preparado para conectarse con otros archivos o scripts que proporcionarán el contenido dinámico de la página, como los mencionados `blog.json` y `blog.txt`.

En resumen, esta plantilla básica es la estructura mínima necesaria para empezar a crear una página web funcional en HTML5.

`006-blog.html`

```html
<!doctype html>
<html lang="es">
  <head>
    <title>JOCARSAblog</title>
    <meta charset="utf-8">
    <style>
      
    </style>
  </head>
  <body>
    
  </body>
</html>
```

### secciones
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código HTML es la estructura básica de una página web llamada "JOCARSAblog". En la sección `<head>`, definimos el título de la página que aparecerá en la pestaña del navegador, además de especificar el conjunto de caracteres que usaremos (UTF-8), lo cual asegura que todos los símbolos y letras internacionales sean correctamente interpretados. También es donde podríamos incluir hojas de estilo o scripts adicionales.

La sección `<body>` contiene todo el contenido visual que verá un usuario cuando visite la página web. En este caso, tenemos una cabecera (`<header>`) con un título principal ("JOCARSAblog"), una sección principal vacía para agregar más contenido en el futuro (como artículos o entradas del blog), y un pie de página (`<footer>`) que indica los derechos de autor.

Esta estructura es importante porque sigue las mejores prácticas de HTML, ayudando tanto a la legibilidad del código como al rendimiento y accesibilidad del sitio web.

`007-secciones.html`

```html
<!doctype html>
<html lang="es">
  <head>
    <title>JOCARSAblog</title>
    <meta charset="utf-8">
    <style>
      
    </style>
  </head>
  <body>
    <header><h1>JOCARSAblog</h1></header>
    <main>
    
    </main>
    <footer>(c)2025 Jose Vicente Carratalá</footer>
  </body>
</html>
```

### articulo
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código HTML crea una página web simple que representa un artículo en un blog. La estructura básica del documento se define con la etiqueta `<!doctype html>`, lo que indica al navegador que está tratándose de un documento HTML5.

En la cabecera (`<head>`), encontramos elementos como el título de la página, que aparecerá en la pestaña del navegador y en los resultados de búsqueda; además, se establece la codificación de caracteres con `<meta charset="utf-8">` para asegurar que el documento pueda manejar cualquier caracter Unicode.

El cuerpo (`<body>`) contiene la estructura principal de la página. Se inicia con un encabezado (`<header>`), que incluye el título del blog con una etiqueta `h1`. El contenido principal está dentro de una sección `<main>`, donde hay un artículo específico marcado por las etiquetas `<article>`. Dentro de este artículo, se encuentra información relevante como el título del artículo en una subcategoría `<h3>` para destacar que es un subtítulo dentro del blog, la fecha de publicación con la etiqueta semántica `<time>`, y detalles sobre el autor y el contenido del artículo.

Al final de la página, se incluye un pie de página (`<footer>`), donde se muestra información legal básica como los derechos de autor.

Este tipo de estructura HTML es importante para mejorar tanto la accesibilidad como el SEO (posicionamiento en motores de búsqueda) de una web, ya que usa etiquetas semánticas que permiten a buscadores y lectores de pantalla entender mejor la jerarquía y propósito del contenido.

`008-articulo.html`

```html
<!doctype html>
<html lang="es">
  <head>
    <title>JOCARSAblog</title>
    <meta charset="utf-8">
    <style>
      
    </style>
  </head>
  <body>
    <header><h1>JOCARSAblog</h1></header>
    <main>
      <article>
        <h3>Titulo del articulo</h3>
        <time>2025-10-16</time>
        <p>Jose Vicente Carratala</p>
        <p>Este es el contenido de un artículo ficticio</p>
      </article>
    </main>
    <footer>(c)2025 Jose Vicente Carratalá</footer>
  </body>
</html>
```

### estilos minimos
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código HTML crea una estructura básica para una página web simple, como un blog. La página tiene tres secciones principales: el encabezado (`header`), el cuerpo principal (`main`), y el pie de página (`footer`). El estilo CSS incorporado en la etiqueta `<style>` dentro del bloque `<head>` define cómo aparecerá esta estructura en el navegador web.

En el encabezado, hay un título para la página que dice "JOCARSAblog". Esto es lo primero que verás cuando se cargue la página. A continuación, en el cuerpo principal (`main`), hay una entrada de blog que incluye información sobre el autor y la fecha del artículo, además del contenido del artículo en sí. Finalmente, en el pie de página, aparece un mensaje de derechos de autor.

Este diseño simple es importante porque ayuda a organizar claramente las diferentes partes de una página web, haciéndola fácil de navegar y entender para los visitantes.

`009-estilos minimos.html`

```html
<!doctype html>
<html lang="es">
  <head>
    <title>JOCARSAblog</title>
    <meta charset="utf-8">
    <style>
      body{background:steelblue;color:steelblue;font-family:sans-serif;}
      header,main,footer{background:white;padding:20px;margin:auto;width:600px;}
      header,footer{text-align:center;}
      main{color:black;}
    </style>
  </head>
  <body>
    <header><h1>JOCARSAblog</h1></header>
    <main>
      <article>
        <h3>Titulo del articulo</h3>
        <time>2025-10-16</time>
        <p>Jose Vicente Carratala</p>
        <p>Este es el contenido de un artículo ficticio</p>
      </article>
    </main>
    <footer>(c)2025 Jose Vicente Carratalá</footer>
  </body>
</html>
```

### arranco flask
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código crea una sencilla aplicación web utilizando la biblioteca Flask en Python. Primero, importamos la clase `Flask` que nos permite crear nuestra aplicación web. Luego, creamos un objeto de tipo `Flask` llamado `aplicacion`, el cual es responsable de gestionar las diferentes funciones y rutas de nuestra app.

El decorador `@aplicacion.route("/")` define una ruta en la aplicación web donde se puede acceder a una función específica. En este caso, cuando un usuario visita la URL base (es decir, "/"), será ejecutada la función `raiz()`. Esta función simplemente devuelve un mensaje de texto que es interpretado como contenido HTML por el navegador.

Finalmente, con el bloque `if __name__ == "__main__":` aseguramos que solo se ejecute el servidor Flask cuando se corre directamente este script Python. Esto no será cierto si se importa en otro archivo, permitiendo así un mayor control sobre cómo y cuándo iniciar la aplicación.

Esta estructura básica es importante porque te permite empezar a crear páginas web interactivas con muy poco código, facilitando el aprendizaje y desarrollo rápido de aplicaciones web.

`011-arranco flask.py`

```python
# Abre una terminal e instala flask:
# pip install flask
# Flask es un microservidorweb que nos permite generar HTML desde Python

from flask import Flask

aplicacion = Flask(__name__)

@aplicacion.route("/")
def raiz():
  return "Esto es HTML desde Flask"
  
# Ahora arranco el servidor
if __name__ == "__main__":
  aplicacion.run(debug=True)
```

### frankenstein
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es un ejemplo básico de cómo crear una aplicación web utilizando Flask, que es un micro framework en Python. En este caso, el archivo crea una simple página HTML estática cuando se accede a la raíz del servidor (la URL principal).

El código comienza importando la clase `Flask` desde el módulo flask y luego crea una instancia de esta clase llamada `aplicacion`. Esta instancia es lo que va a manejar todas las solicitudes HTTP que llegan al servidor.

Luego, se define una ruta para la página principal del sitio web utilizando el decorador `@aplicacion.route("/")`, lo cual indica que cuando un usuario visita la URL base (en este caso, `/`), debería ejecutarse la función `raiz()`. Dentro de esta función, simplemente retorna un trozo de código HTML directamente como una cadena de texto larga. Este HTML define el diseño y contenido básico de la página web, incluyendo un encabezado, un cuerpo principal que contiene un artículo ficticio, y un pie de página.

Finalmente, si este archivo se ejecuta como un script independiente (y no importado por otro módulo), la línea `aplicacion.run(debug=True)` inicia el servidor Flask. Con `debug=True`, cualquier error o cambio en los archivos del proyecto hará que el servidor se reinicie automáticamente y mostrará mensajes de depuración para ayudar a identificar problemas rápidamente.

Este tipo de código es útil para estudiantes porque muestra cómo combinar Python con HTML para crear aplicaciones web simples, además de introducir conceptos básicos sobre frameworks como Flask.

`012-frankenstein.py`

```python
from flask import Flask

aplicacion = Flask(__name__)

@aplicacion.route("/")
def raiz():
  return '''
    <!doctype html>
<html lang="es">
  <head>
    <title>JOCARSAblog</title>
    <meta charset="utf-8">
    <style>
      body{background:steelblue;color:steelblue;font-family:sans-serif;}
      header,main,footer{background:white;padding:20px;margin:auto;width:600px;}
      header,footer{text-align:center;}
      main{color:black;}
    </style>
  </head>
  <body>
    <header><h1>JOCARSAblog</h1></header>
    <main>
      <article>
        <h3>Titulo del articulo</h3>
        <time>2025-10-16</time>
        <p>Jose Vicente Carratala</p>
        <p>Este es el contenido de un artículo ficticio</p>
      </article>
    </main>
    <footer>(c)2025 Jose Vicente Carratalá</footer>
  </body>
</html>
  '''
  
if __name__ == "__main__":
  aplicacion.run(debug=True)
```

### blog
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

El archivo `blog.json` contiene una estructura de datos en formato JSON que representa varios artículos para un blog. Cada entrada en la lista (que se asemeja a un conjunto de registros) tiene cuatro campos: "titulo", "fecha", "autor" y "contenido". Estos campos describen los detalles específicos de cada artículo, como su título, fecha de publicación, autor y texto del contenido.

Esta estructura es importante porque permite organizar la información de manera clara y fácilmente accesible. Por ejemplo, si estás desarrollando una aplicación web que muestra artículos de un blog, puedes leer este archivo JSON para obtener los datos necesarios para mostrar en las páginas del sitio web.

El uso de formatos como JSON facilita la intercambiabilidad de datos entre diferentes sistemas y aplicaciones, permitiendo a otros programadores o servicios acceder y manipular esta información con facilidad.

`blog.json`

```json
[
  {
    "titulo":"Primer artículo",
    "fecha":"2025-10-16",
    "autor":"Jose Vicente Carratala",
    "contenido":"Este es el contenido del primer artículo"
  },
  {
    "titulo":"Segundo artículo",
    "fecha":"2025-10-17",
    "autor":"Jose Vicente Carratala",
    "contenido":"Este es el contenido del segundo artículo"
  },
  {
    "titulo":"Tercer artículo",
    "fecha":"2025-10-16",
    "autor":"Jose Vicente Carratala",
    "contenido":"Este es el contenido del tercer artículo"
  },
  {
    "titulo":"Cuarto artículo",
    "fecha":"2025-10-16",
    "autor":"Jose Vicente Carratala",
    "contenido":"Este es el contenido del cuarto artículo"
  }
]
```

### blog
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

El fragmento que has proporcionado es simplemente texto dentro del archivo `blog.txt`. Este archivo parece contener varios artículos de blog escritos uno debajo del otro. Cada línea representa un artículo diferente, y en este caso, el archivo contiene cuatro artículos en total: "Este es un primer articulo de blog", "Este es un segundo artículo de blog", "Y este es el tercero" y "Y por qué no, podemos tener un cuarto artículo". 

El propósito de este archivo es servir como una base para ejercicios relacionados con la lectura y escritura de datos en ficheros. En contextos de programación, este tipo de archivos son útiles para aprender cómo leer el contenido del archivo línea por línea o cómo manipular cada uno de los artículos que contiene.

`blog.txt`

```
Este es un primer articulo de blog
Este es un segundo artículo de blog
Y este es el tercero
Y por qué no, podemos tener un cuarto artículo
```

### Actividades propuestas

### Actividad 1: Leer y Mostrar Contenido de Ficheros de Texto
**Descripción:** Los estudiantes deben crear un programa en Python que lea un archivo de texto (blog.txt) y muestre su contenido por pantalla línea a línea. Se espera que aprendan cómo abrir archivos, leer sus líneas y manipular el flujo de datos.

### Actividad 2: Leer JSON e Imprimir Datos
**Descripción:** Los estudiantes deben escribir un programa Python para leer un archivo JSON (blog.json) y mostrar en la consola los datos del primer artículo. A través de esta actividad, aprenderán a trabajar con estructuras de datos más complejas usando el módulo `json`.

### Actividad 3: Manipulación Avanzada de JSON
**Descripción:** Los estudiantes deben crear un programa Python que recorra cada uno de los artículos en blog.json y imprima solo el título, fecha y contenido del autor. Esta actividad les ayudará a entender la manipulación de datos en estructuras JSON más complejas.

### Actividad 4: Personalizar Salida con Formato
**Descripción:** Los estudiantes deben modificar un programa existente para que, al leer blog.json, imprima cada artículo con una línea de separación decorativa antes y después. Esta actividad permitirá a los alumnos practicar el uso de bucles y cadenas formateadas.

### Actividad 5: Crear un Servidor Web Básico
**Descripción:** Los estudiantes deben configurar Flask para servir contenido HTML básico (como visto en 012-frankenstein.py), mostrando una página estática en lugar del texto plano. Esta actividad les ayudará a entender cómo crear y ejecutar aplicaciones web simples.

### Actividad 6: Creación de Páginas HTML desde Python
**Descripción:** A partir de los archivos HTML existentes, los estudiantes deben modificar el código en Python para generar dinámicamente un archivo HTML que incluya múltiples artículos del blog.json. Esto permitirá a los alumnos combinar conocimientos de HTML y programación.

### Actividad 7: Implementar Estilos Básicos en HTML
**Descripción:** Los estudiantes deben tomar el código HTML básico (008-articulo.html) y agregar estilos mínimos para mejorar la presentación visual, similar al ejemplo en 009-estilos minimos.html. Esta actividad les ayudará a entender cómo aplicar CSS simple para mejorar la apariencia de sitios web.

### Actividad 8: Desarrollar una Página HTML Dinámica
**Descripción:** Los estudiantes deben crear un script Flask que lea blog.json y genere dinámicamente una página HTML con múltiples artículos. Esta actividad les ayudará a combinar conceptos de programación, manejo de archivos JSON, generación de HTML y servidor web.

### Actividad 9: Integrar HTML Dinámico en Servidor Flask
**Descripción:** Los estudiantes deben modificar el código existente (012-frankenstein.py) para que genere dinámicamente un HTML basado en datos del blog.json. Esto les permitirá entender cómo integrar la generación de contenido web con servidores web Flask.

### Actividad 10: Crear y Configurar Servidor Local
**Descripción:** Los estudiantes deben instalar un servidor local (XAMPP o Apache) según las instrucciones en 010-Instalar servidor.md, configurarlo para que se pueda acceder a los archivos HTML generados en el servidor. Esta actividad les permitirá entender la infraestructura necesaria para servir contenido web y manejar solicitudes HTTP desde un entorno de desarrollo local.


<a id="apertura-y-cierre-de-ficheros-modos-de-acceso-escritura-y-lectura-de-informacion-en-ficheros"></a>
## Apertura y cierre de ficheros. Modos de acceso. Escritura y lectura de información en ficheros

### Introducción a los ejercicios

En esta carpeta, trabajaremos con ejercicios que te ayudarán a entender cómo manejar archivos en Python. Los problemas abordan la creación, escritura y lectura de archivos tanto en formato texto como binario. Aprenderás a abrir archivos con diferentes modos (lectura, escritura, apendizaje) y a gestionar correctamente su cierre para evitar errores y garantizar la integridad de los datos.

Además, practicarás técnicas avanzadas como el uso del módulo `pickle` para serializar objetos complejos en archivos binarios y luego recuperarlos. Esto es especialmente útil cuando necesitas almacenar estructuras de datos más elaboradas que simples cadenas de texto.

### escribir
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código Python abre un archivo llamado "basededatos.txt" en modo de escritura ("w"), lo que significa que cualquier contenido previo en el archivo será eliminado. Luego, el programa escribe la frase "esto es otro contenido" dentro del archivo recién abierto. Finalmente, cierra el archivo para asegurarse de que todos los cambios se guardan correctamente y no hay más acceso a él.

Es importante entender este proceso porque manejar archivos en modo de escritura sin precauciones puede resultar en pérdida de datos si el archivo ya contenía información valiosa antes de ser modificado. Además, es crucial cerrar el archivo después de manipularlo para evitar problemas relacionados con la concurrencia y asegurarse de que los cambios se guarden correctamente en disco.

`001-escribir.py`

```python
archivo = open("basededatos.txt","w")
archivo.write("esto es otro contenido")
archivo.close()
```

### apendizar
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código en Python muestra cómo abrir y escribir información en un archivo existente. En primer lugar, se abre el archivo llamado "basededatos.txt" usando la función `open()`, pero con una pequeña diferencia: el segundo argumento es `"a"` en lugar de `"w"`. El modo `"a"` (append o añadir) significa que cualquier texto nuevo que escribamos será agregado al final del archivo, sin sobrescribir lo que ya contiene.

Después de abrir el archivo, se utiliza la función `write()` para agregar una nueva línea que dice "esto es un contenido" en el archivo. Esta operación no borrará nada existente, simplemente añadirá esta nueva frase al final del documento.

Finalmente, el archivo se cierra con la función `close()`. Es importante cerrar los archivos después de trabajar con ellos para liberar cualquier recurso que esté siendo utilizado por Python y asegurar que toda la información haya sido escrita correctamente en disco.

`002-apendizar.py`

```python
archivo = open("basededatos.txt","a")
archivo.write("esto es un contenido")
archivo.close()
```

### añadir salto de linea
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código en Python se utiliza para escribir información en un archivo existente. El programa comienza abriendo el archivo llamado "basededatos.txt" en modo de apendizaje ("a"), lo que significa que cualquier texto añadido será agregado al final del archivo sin sobrescribir su contenido anterior.

Luego, utiliza la función `write()` para agregar una nueva línea de texto: "esto es un contenido\n". El "\n" al final de esta cadena de texto es importante porque agrega un salto de línea después del mensaje escrito, lo que ayuda a mantener el formato del archivo separando claramente las diferentes entradas.

Finalmente, se cierra el archivo con `archivo.close()`, lo cual es crucial para asegurar que todos los cambios realizados en el archivo se guarden correctamente y para liberar cualquier recurso que pueda estar siendo utilizado por el sistema operativo.

`003-añadir salto de linea.py`

```python
archivo = open("basededatos.txt","a")
archivo.write("esto es un contenido\n")
archivo.close()
```

### leer una linea
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código Python abre un archivo llamado "basededatos.txt" en modo de lectura ("r"). Luego, utiliza la función `readline()` para leer la primera línea del archivo y guarda esa línea en la variable `linea`. Finalmente, imprime el contenido de la variable `linea` usando la función `print()`, lo que muestra en la pantalla la primera línea del archivo. Al finalizar estas operaciones, cierra el archivo con la función `close()` para liberar los recursos del sistema.

Este código es importante porque demuestra cómo abrir y leer datos desde un archivo de texto en Python. Es una habilidad fundamental para manejar archivos y extraer información almacenada fuera del programa mismo.

`004-leer una linea.py`

```python
archivo = open("basededatos.txt","r")
linea = archivo.readline()
print(linea)
archivo.close()
```

### leer varias lineas
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código Python se encarga de leer todas las líneas de un archivo llamado "basededatos.txt" y luego imprimir estas líneas en la consola. Veamos cómo funciona:

1. La línea `archivo = open("basededatos.txt","r")` abre el archivo "basededatos.txt" en modo lectura (`"r"` significa read, o leer). Esto prepara al programa para acceder a los datos que están almacenados en este archivo.

2. Luego, la línea `lineas = archivo.readlines()` lee todas las líneas del archivo recién abierto y las guarda en una lista llamada `lineas`. Cada elemento de esta lista es una cadena (string) que representa una línea completa del archivo.

3. La línea `print(lineas)` imprime la lista completa de líneas en la consola, mostrando así el contenido del archivo "basededatos.txt" como una serie de cadenas.

4. Finalmente, `archivo.close()` cierra el archivo después de haber terminado de leerlo y manipular su contenido. Es importante cerrar archivos que se han abierto para evitar problemas relacionados con la gestión de recursos en el sistema operativo.

Este código es útil cuando necesitas procesar o visualizar todo el contenido de un archivo de texto, como puede ser una base de datos simple o cualquier otro tipo de archivo de texto estructurado.

`005-leer varias lineas.py`

```python
archivo = open("basededatos.txt","r")
lineas = archivo.readlines()
print(lineas)
archivo.close()
```

### recorrer la lista
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código Python se encarga de abrir un archivo llamado `basededatos.txt` en modo lectura y luego recorrer todas las líneas del archivo. Aquí está lo que hace cada parte:

1. **Abrir el archivo**: La línea `archivo = open("basededatos.txt","r")` abre el archivo `basededatos.txt` en modo de lectura (`"r"`), lo que significa que solo puedes leer su contenido, no modificarlo.

2. **Leer todas las líneas del archivo**: `lineas = archivo.readlines()` lee todo el contenido del archivo y crea una lista donde cada elemento es una línea del archivo. Esto te permite trabajar con cada línea individualmente después de leerlas.

3. **Recorrer e imprimir las líneas**: El bucle `for linea in lineas:` itera sobre cada elemento en la lista `lineas`. En cada iteración, el contenido de la variable `linea` es impreso usando `print(linea)`, lo que muestra el contenido de cada línea del archivo por separado.

4. **Cerrar el archivo**: Finalmente, la línea `archivo.close()` cierra el archivo después de haber terminado de leerlo y trabajar con su contenido. Es importante cerrar los archivos una vez que ya no los necesitas para asegurar que todos los recursos sean liberados correctamente.

Este código es útil cuando necesitas procesar o visualizar cada línea de un archivo de texto, como en este caso al mostrar el contenido del `basededatos.txt` por consola.

`006-recorrer la lista.py`

```python
archivo = open("basededatos.txt","r")
lineas = archivo.readlines()
for linea in lineas:
  print(linea)
archivo.close()
```

### pickle escribir
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código Python se utiliza para guardar datos en un archivo binario utilizando el módulo `pickle`. En primer lugar, el programa importa la biblioteca `pickle`, que es una herramienta útil para serializar y deserializar objetos de Python. Esto significa que puedes convertir estructuras de datos complejas como listas o diccionarios en un formato que puede ser escrito en un archivo de texto o binario.

El código abre un archivo llamado "datos.bin" en modo escritura binaria ("wb"). Luego, utiliza la función `pickle.dump()` para guardar una cadena de texto, en este caso `"Jose Vicente"`, dentro del archivo recién creado. La función `dump()` esencialmente serializa el objeto (en este caso, la cadena) y lo guarda en el archivo.

Finalmente, se cierra el archivo con `archivo.close()`. Es importante cerrar los archivos después de usarlos para asegurarse de que todos los datos se escriban correctamente y que no haya problemas de recursos abiertos sin resolver. Este código es útil cuando necesitas guardar información estructurada en un formato binario compacto, lo cual puede ser más eficiente que almacenarlo como texto simple.

`007-pickle escribir.py`

```python
#pip3 install pickle | pip install pickle
import pickle

archivo = open("datos.bin","wb")
cadena = "Jose Vicente"

pickle.dump(cadena,archivo)

archivo.close()
```

### leer pickle
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código Python se utiliza para leer datos que previamente fueron guardados en un archivo binario usando la biblioteca `pickle`. El propósito principal del fragmento es deserializar (convertir de formato binario a objeto Python) los datos almacenados en el archivo llamado "datos.bin" y luego imprimirlos en pantalla.

1. **Importar módulo pickle**: Al inicio, se importa el módulo `pickle`, que proporciona la funcionalidad necesaria para serializar (convertir objetos de Python a una representación binaria) y deserializar (conversión inversa) datos.
   
2. **Abrir archivo en modo lectura binario**: La línea `archivo = open("datos.bin","rb")` abre el archivo "datos.bin" en modo lectura binaria (`rb`). El modo `r` indica que se va a leer desde el archivo, y la letra `b` añade un indicador de que estamos trabajando con datos binarios.

3. **Cargar los datos del archivo**: La línea `cadena = pickle.load(archivo)` carga los datos serializados en el objeto Python original y los almacena en la variable `cadena`. Esto es lo que convierte el contenido binario del archivo en un formato de texto o estructura de datos legible para Python.

4. **Imprimir los datos**: Finalmente, con `print(cadena)`, se muestra en pantalla el contenido deserializado que estaba guardado en "datos.bin".

5. **Cerrar el archivo**: Es importante cerrar el archivo después de usarlo con `archivo.close()` para liberar cualquier recurso del sistema operativo que esté ocupando el programa.

Este tipo de manejo de archivos es útil cuando necesitas almacenar datos complejos, como listas o diccionarios en Python, y luego recuperarlos exactamente tal cual fueron guardados.

`008-leer pickle.py`

```python
#pip3 install pickle | pip install pickle
import pickle

archivo = open("datos.bin","rb")

cadena = pickle.load(archivo)
print(cadena)

archivo.close()
```

### crear cliente
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código crea una clase llamada `Cliente` en Python, la cual se utiliza para representar información básica sobre un cliente, como su nombre y email. La función `__init__()` es el método constructor que inicializa los objetos de la clase `Cliente`, estableciendo sus atributos `nombre` y `email` con valores proporcionados al crear cada instancia.

Después de definir la clase, se crea una lista vacía llamada `clientes`. Luego, se añaden dos instancias de la clase `Cliente` a esta lista: el primer cliente tiene el nombre "Jose Vicente" y su email es "info@jocarsa.com", mientras que el segundo cliente es "Juan" con el email "juan@jocarsa.com". Finalmente, se imprime la lista `clientes`, mostrando así las dos instancias de clientes creadas.

Esta parte del código ilustra cómo utilizar clases y objetos en Python para organizar datos de manera estructurada. Es importante destacar que este bloque es el inicio de un programa más amplio que probablemente continuará con operaciones adicionales sobre los clientes, como guardar estos registros en un archivo o realizar búsquedas entre ellos.

`009-crear cliente.py`

```python
class Cliente():
  def __init__(self,nuevonombre,nuevoemail):
    self.nombre = nuevonombre
    self.email = nuevoemail

clientes = []

clientes.append(Cliente("Jose Vicente","info@jocarsa.com"))
clientes.append(Cliente("Juan","juan@jocarsa.com"))

print(clientes)
```

### guardo con pickle a binario
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código es una parte de un programa que guarda objetos en formato binario usando el módulo `pickle` en Python. El objetivo principal aquí es crear objetos de la clase `Cliente`, almacenarlos en una lista y luego guardar toda esta información en un archivo binario llamado "clientes.bin".

El código comienza importando el módulo `pickle`, que es útil para serializar (convertir datos complejos en una representación de texto) y deserializar (conversión inversa) objetos Python. Luego, se define una clase llamada `Cliente` con un constructor (`__init__`) que recibe dos parámetros: `nuevonombre` y `nuevoemail`. Esta función inicializa los atributos `nombre` e `email` del objeto Cliente.

A continuación, se crea una lista vacía llamada `clientes`, a la cual se añaden dos instancias de `Cliente`: uno con el nombre "Jose Vicente" y email "info@jocarsa.com", y otro con el nombre "Juan" y email "juan@jocarsa.com".

Finalmente, el código abre un archivo llamado "clientes.bin" en modo binario para escritura ("wb"), utiliza la función `pickle.dump()` para guardar la lista de clientes en este archivo y luego cierra el archivo. Este proceso permite que los datos complejos como objetos puedan ser almacenados permanentemente en archivos, lo cual es útil para bases de datos o persistencia de estado entre diferentes ejecuciones del programa.

En resumen, este código ayuda a almacenar información estructurada en formato binario, facilitando la gestión y recuperación de datos en futuras sesiones del programa.

`010-guardo con pickle a binario.py`

```python
import pickle

class Cliente():
  def __init__(self,nuevonombre,nuevoemail):
    self.nombre = nuevonombre
    self.email = nuevoemail

clientes = []

clientes.append(Cliente("Jose Vicente","info@jocarsa.com"))
clientes.append(Cliente("Juan","juan@jocarsa.com"))

archivo = open("clientes.bin","wb")
pickle.dump(clientes,archivo)
archivo.close()
```

### recupero los datos
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código es una parte de un programa que se encarga de leer y deserializar datos almacenados en un archivo binario utilizando la biblioteca `pickle` en Python. En primer lugar, el código define una clase llamada `Cliente`, que tiene dos atributos: `nombre` y `email`. Estos atributos son inicializados a través del método `__init__`, que es el constructor de la clase.

Luego, se abre un archivo binario denominado "clientes.bin" en modo lectura binaria (`rb`). La función `pickle.load()` lee desde este archivo los objetos previamente serializados (guardados) y los convierte de nuevo a objetos Python, almacenándolos en la variable `clientes`.

Finalmente, se imprime el contenido del objeto `clientes`, que contiene una lista o estructura de datos deserializada que representa varios clientes. Este proceso es crucial cuando necesitas recuperar información compleja que has guardado previamente y deseas volver a utilizarla en tu programa.

Esta técnica es útil para almacenar estados de aplicaciones, objetos personalizados como los definidos en la clase `Cliente`, o cualquier otro tipo de datos no estructurados de manera tradicional (como listas, diccionarios anidados) que necesitas persistir y recuperar más tarde.

`011-recupero los datos.py`

```python
import pickle

class Cliente():
  def __init__(self,nuevonombre,nuevoemail):
    self.nombre = nuevonombre
    self.email = nuevoemail

archivo = open("clientes.bin","rb")
clientes = pickle.load(archivo)
archivo.close()

print(clientes)
```

### basededatos
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código no contiene realmente ningún código de programación, sino que se trata del contenido de un archivo de texto llamado `basededatos.txt`. Este archivo parece contener tres líneas idénticas, cada una diciendo "esto es un contenido". En el contexto de los ejercicios que has mencionado, este archivo podría ser utilizado para probar diferentes aspectos de la lectura y escritura en ficheros. Por ejemplo, podrías usarlo para aprender cómo leer las líneas del archivo o cómo contar cuántas líneas hay en él. Es importante entender el contenido de los archivos con los que trabajamos ya que esto nos ayuda a comprender mejor cómo interactuar con ellos mediante la programación.

`basededatos.txt`

```
esto es un contenido
esto es un contenido
esto es un contenido
```

### Actividades propuestas

1. **Escribir en Ficheros**
   - Descripción: Los estudiantes deben escribir una cadena de texto en un fichero y luego cerrarlo correctamente.
   - Objetivo: Aprender a abrir, escribir y cerrar archivos en modo "w".

2. **Añadir Contenido al Final del Fichero**
   - Descripción: Los alumnos añaden contenido nuevo al final del archivo existente sin sobrescribirlo.
   - Objetivo: Comprender la apertura de archivos en modo "a" y el uso adecuado del método `write()`.

3. **Incluir Saltos de Línea**
   - Descripción: Los estudiantes deben añadir un salto de línea después de escribir cada frase en un archivo.
   - Objetivo: Aprender a usar `\n` para insertar saltos de línea en los archivos escritos.

4. **Leer Contenido de un Fichero**
   - Descripción: Los estudiantes deben leer y mostrar una línea específica de un fichero existente.
   - Objetivo: Entender cómo abrir y cerrar archivos en modo "r" y usar `readline()`.

5. **Recorrer y Mostrar Todas las Líneas**
   - Descripción: Los alumnos deben recoger todas las líneas del archivo y mostrarlas por pantalla.
   - Objetivo: Aprender a utilizar `readlines()` para leer múltiples líneas de un fichero.

6. **Manejo de Listas con Archivos**
   - Descripción: Los estudiantes crearán una lista de clientes (objetos) y la almacenarán en un archivo binario.
   - Objetivo: Aprender a usar `pickle` para guardar objetos complejos en archivos binarios.

7. **Serialización y Deserialización con Pickle**
   - Descripción: Los estudiantes serializan un objeto simple (cadena) usando pickle y luego lo recuperan del archivo.
   - Objetivo: Familiarizar al estudiante con la importancia de `pickle` para almacenar datos estructurados.

8. **Manipulación Compleja de Datos**
   - Descripción: Los alumnos crean un conjunto de objetos cliente, los serializan y luego los recuperan del archivo binario.
   - Objetivo: Aprender a manejar conjuntos complejos de datos (listas de objetos) utilizando `pickle`.

Estas actividades proporcionarán a los estudiantes una base sólida en la manipulación de archivos y el uso de serialización para guardar y recuperar datos estructurados, aspectos clave en el desarrollo de aplicaciones orientadas a la persistencia de datos.


<a id="utilizacion-de-los-sistemas-de-ficheros"></a>
## Utilización de los sistemas de ficheros.

### Introducción a los ejercicios

It looks like you've shared a list of file paths from what appears to be a course directory for a programming or database management course. Each path points to a specific topic within the curriculum, covering various aspects related to object-oriented programming and databases.

Here's a brief summary of the main topics based on the filenames:

1. **Concepts of Classes**: Introduction to classes, objects, properties, methods, and basic OOP principles.
2. **Structure and Members of Classes**: Detailed explanation about class structures including attributes (properties), constructors, destructors, static members, visibility modifiers (public, private).
3. **Development of Class Methods**: Focuses on the creation and implementation of methods within classes, their functionalities, and best practices for method design.
4. **Inheritance and Polymorphism**: Covers how to create hierarchical class relationships using inheritance, understanding base and derived classes, overriding methods, etc.
5. **Persistence Management of Objects**: Techniques and tools used in saving object state to a database or file system so that it can be restored later when needed.
6. **Query Language Syntax & Expressions**: Introduces OQL (Object Query Language) syntax for querying objects stored within an object-oriented database management system.
7. **Database Creation**: Steps and commands for creating new databases, tables, indexes etc., using a specific DBMS like db4o or similar systems.
8. **Retrieval, Modification & Deletion of Information**: How to retrieve data from the database, update existing records, delete unwanted entries efficiently.
9. **Collection Data Types**: Explains different types of collections (like Sets, Lists) available in object-oriented programming and their use cases.

The course structure seems well-organized with detailed explanations followed by evaluation criteria for each topic. If you need help understanding any particular aspect or want to dive deeper into one of these topics based on the provided file paths, feel free to ask!

### listar contenido de carpeta
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código en Python te permite listar todos los archivos y carpetas que están dentro de una carpeta específica. Primero, importa el módulo `os`, que proporciona funciones para interactuar con el sistema operativo.

El programa pide al usuario que ingrese el nombre de una carpeta utilizando la función `input()`. La entrada del usuario se guarda en la variable `carpeta`.

Luego, utiliza la función `os.listdir(carpeta)` para obtener una lista de todos los elementos (archivos y carpetas) que están dentro de la carpeta proporcionada por el usuario. Esta lista se almacena en la variable `elementos`.

Finalmente, el código itera a través de cada elemento en la lista usando un bucle `for` y imprime el nombre de cada elemento en la consola. Esto te muestra todos los archivos y carpetas que hay en la carpeta especificada por el usuario.

Este tipo de programa es útil para explorar o visualizar el contenido de cualquier directorio de tu sistema, lo cual puede ser fundamental cuando estás trabajando con grandes cantidades de datos o necesitas gestionar archivos.

`001-listar contenido de carpeta.py`

```python
import os

carpeta = input("Indica una carpeta: ")

elementos = os.listdir(carpeta)

for elemento in elementos:
  print(elemento)
```

### atributos
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código te ayuda a entender mejor los archivos y directorios de tu computadora. Primero, el programa pide que ingreses la ruta de una carpeta específica. Luego, usa una función llamada `os.listdir()` para obtener una lista de todos los elementos (archivos y subdirectorios) dentro de esa carpeta.

El código recorre cada elemento en esta lista utilizando un bucle `for`. Para cada elemento, construye su ruta completa usando `os.path.join()`, lo que es útil porque asegura que la concatenación de rutas sea correcta independientemente del sistema operativo utilizado (como Windows o Linux).

Finalmente, para cada archivo dentro de la carpeta, muestra tres cosas importantes:
1. La ruta completa del archivo.
2. El tamaño del archivo en bytes usando `os.path.getsize()`.
3. La última vez que el archivo fue modificado (`mtime`), proporcionada por `os.path.getmtime()`.

Esto es útil para comprender mejor qué archivos hay en una carpeta y algunas características básicas de cada uno, como su tamaño y cuándo fue la última vez que se modificó.

`002-atributos.py`

```python
import os

carpeta = input("Indica una carpeta: ")

elementos = os.listdir(carpeta)

for elemento in elementos:
  ruta = os.path.join(carpeta, elemento)
  print(ruta)
  print(os.path.getsize(ruta))
  print(os.path.getmtime(ruta))
```

### formateo el resultado
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código en Python te permite listar los archivos y subcarpetas de una carpeta específica que el usuario proporciona, mostrando además detalles adicionales sobre cada elemento.

Primero, se importa el módulo `os`, que es útil para trabajar con sistemas operativos. Luego, el programa solicita al usuario que introduzca la ruta de una carpeta.

La función `os.listdir()` se utiliza para obtener una lista de todos los archivos y subcarpetas dentro del directorio especificado por el usuario. A continuación, el código itera sobre cada elemento en esta lista utilizando un bucle `for`.

Para cada elemento, primero construye la ruta completa hacia ese elemento usando `os.path.join()`, que asegura que la ruta sea correcta para cualquier sistema operativo.

Luego, muestra dos detalles adicionales del archivo o subcarpeta:
1. El tamaño del archivo en megabytes (MB). Esto se calcula usando `os.path.getsize()` que devuelve el tamaño del archivo en bytes, y después convirtiendo ese número de bytes a megabytes dividiendo entre 1024*1024.
2. La hora en la que fue modificada por última vez (`mtime`) utilizando `os.path.getmtime()`. Este valor se muestra como es.

Este código es útil para obtener una rápida visión del contenido de un directorio y algunos detalles importantes sobre cada archivo o subcarpeta, lo que puede ser muy práctico cuando trabajas con grandes conjuntos de archivos.

`003-formateo el resultado.py`

```python
import os

carpeta = input("Indica una carpeta: ")

elementos = os.listdir(carpeta)

for elemento in elementos:
  ruta = os.path.join(carpeta, elemento)
  print(ruta)
  print(os.path.getsize(ruta)/(1024*1024),"MB")
  print(os.path.getmtime(ruta))
```

### suma del tamaño
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código en Python te ayuda a calcular el tamaño total ocupado por todos los archivos dentro de una carpeta específica que tú indiques. Primero, se solicita al usuario que introduzca la ruta de la carpeta que quiere analizar. Luego, el programa lista todos los elementos (archivos y subcarpetas) dentro de esa carpeta utilizando la función `os.listdir()`. 

A continuación, en un bucle `for`, el código itera sobre cada elemento de la lista obtenida y calcula su tamaño real en el disco con la función `os.path.getsize()`. Estos tamaños se van acumulando en una variable llamada `suma`.

Finalmente, después del bucle, se imprime en pantalla el total ocupado por todos los archivos, convirtiendo este valor de bytes a megabytes para facilitar su comprensión. Esto es útil cuando necesitas saber cuánto espacio ocupa un conjunto específico de archivos y te permite tomar decisiones basadas en el uso del espacio en disco.

`004-suma del tamaño.py`

```python
import os

carpeta = input("Indica una carpeta: ")

elementos = os.listdir(carpeta)

suma = 0

for elemento in elementos:
  ruta = os.path.join(carpeta, elemento)
  suma += os.path.getsize(ruta)

print("La carpeta ocupa:")
print(suma/(1024*1024),"MB")
```

### recorrer
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código es un ejemplo simple de cómo recorrer y explorar el contenido de una carpeta en Python utilizando la biblioteca estándar `os`. Primero, se importa el módulo `os` que proporciona varias funciones para interactuar con el sistema operativo.

El programa solicita al usuario que introduzca el nombre o ruta de una carpeta. Luego, utiliza un bucle `for` junto con la función `os.walk()`, la cual recorre recursivamente todos los directorios y archivos dentro del directorio proporcionado por el usuario. En cada iteración del bucle, `os.walk()` devuelve tres valores: el nombre del directorio actual (`directorio`), una lista de nombres de las carpetas que están dentro del directorio actual (`carpetas`), y una lista de nombres de los archivos que también se encuentran en ese directorio (`archivo`).

El código simplemente imprime estos valores, mostrando así el nombre del directorio actual, seguido por la lista de carpetas y después la lista de archivos encontrados. Esto es útil para entender la estructura jerárquica de las carpetas y los archivos dentro de un directorio dado.

Este tipo de recorrido de carpetas y listado de contenido es fundamental en programas que necesitan procesar o analizar grandes cantidades de datos distribuidos en múltiples subcarpetas, como en la gestión de proyectos de desarrollo software o en el análisis de bases de datos.

`005-recorrer.py`

```python
import os

carpeta = input("Indica una carpeta: ")

for directorio,carpetas,archivo in os.walk(carpeta):
  print(directorio)
  print(carpetas)
  print(archivo)
```

### tamaño recursivo
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código Python calcula el tamaño total en megabytes de todos los archivos dentro de una carpeta y sus subcarpetas que indiques. Empezamos pidiéndote que introduzcas la ruta de la carpeta para analizar. El programa luego recorre esta carpeta, así como todas las carpetas anidadas dentro, utilizando la función `os.walk()`, que nos permite navegar por el árbol de directorios.

Para cada archivo encontrado en este proceso, se construye su ruta completa (`ruta = os.path.join(directorio, archivo)`) y se intenta obtener su tamaño en bytes con `os.path.getsize(ruta)`. Si algún archivo no puede ser leído (por ejemplo, si carece de permisos para acceder a él), el código simplemente omite ese archivo sin interrumpir la ejecución del programa. Finalmente, suma todos los tamaños de archivos que pudo leer y muestra el resultado total en megabytes.

Este tipo de código es útil cuando necesitas conocer cuánto espacio está ocupando una carpeta específica junto con todas sus subcarpetas y archivos incluidos, lo cual puede ser un paso importante para la gestión del almacenamiento de datos en sistemas informáticos.

`006-tamaño recursivo.py`

```python
import os

carpeta = input("Indica una carpeta: ")

suma = 0

for directorio, carpetas, archivos in os.walk(carpeta):
    for archivo in archivos:
        ruta = os.path.join(directorio, archivo)
        try:
            suma += os.path.getsize(ruta)
        except:
            pass  # Evita errores si un archivo no se puede leer
  
print("La carpeta ocupa:")
print(suma/(1024*1024),"MB")
```

### condicion
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código Python es una herramienta sencilla que permite al usuario buscar archivos grandes en una carpeta especificada. Primero, el programa solicita al usuario que introduzca la ruta de una carpeta. Luego, utiliza la función `os.walk()` para recorrer todos los archivos dentro de esa carpeta y sus subcarpetas.

Para cada archivo encontrado, construye su ruta completa utilizando `os.path.join()`. A continuación, intenta obtener el tamaño del archivo usando `os.path.getsize(ruta)`, que devuelve el tamaño en bytes. Si este tamaño es mayor que 1 gigabyte (configurado como `grande`), imprime la ruta del archivo seguido de su tamaño en megabytes.

El uso de un bloque `try-except` permite manejar posibles errores, como intentar acceder a archivos no accesibles para el usuario actual, sin interrumpir completamente el programa. Esto es importante porque ayuda al código a ser más robusto y funcional en diferentes entornos.

Este tipo de script es útil cuando necesitas revisar rápidamente cuáles son los archivos grandes que ocupan espacio en tu sistema o en una carpeta específica, facilitando la gestión del almacenamiento o la optimización del espacio en disco.

`007-condicion.py`

```python
import os

carpeta = input("Indica una carpeta: ")
grande = 1024*1024*1024 # 1 giga

for directorio, carpetas, archivos in os.walk(carpeta):
    for archivo in archivos:
        ruta = os.path.join(directorio, archivo)
        try:
            if os.path.getsize(ruta) > grande:
              print(ruta,os.path.getsize(ruta)/(1024*1024),"MB")
        except:
            pass  
    
```

### escribir en archivo el contenido de la carpeta
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código Python es una herramienta sencilla que permite guardar la lista de todos los archivos en un directorio (y subdirectorios) especificado por el usuario en un archivo llamado `mapa.txt`. 

El programa empieza pidiéndote que introduzcas la ruta de una carpeta. Luego, define qué considerará como tamaño grande para fines del código, aunque este valor no se usa directamente en este fragmento específico.

Después, el script abre un archivo llamado `mapa.txt` en modo de añadir (`'a'`), lo que significa que cualquier contenido nuevo será añadido al final del archivo sin borrar lo existente. Luego, utiliza la función `os.walk()` para recorrer todos los archivos y subdirectorios dentro de la carpeta proporcionada por el usuario.

Por cada archivo encontrado en este proceso, se genera una ruta completa desde el directorio base hasta el archivo actual usando `os.path.join()`, y luego esa ruta se escribe en `mapa.txt` seguida de un salto de línea. Finalmente, cierra el archivo para asegurarse de que todos los cambios han sido guardados correctamente.

Este tipo de script es útil cuando necesitas crear una lista detallada de archivos en tu sistema, lo cual puede ser muy práctico para la gestión del espacio de almacenamiento o para tareas relacionadas con seguridad y auditoría.

`008-escribir en archivo el contenido de la carpeta.py`

```python
import os

carpeta = input("Indica una carpeta: ")
grande = 1024*1024*1024 # 1 giga

mapa = open("mapa.txt",'a') # Vaciamos los contenidos anteriores

for directorio, carpetas, archivos in os.walk(carpeta):
    for archivo in archivos:
        ruta = os.path.join(directorio, archivo)
        mapa.write(ruta+"\n")
        
mapa.close()
         
    
```

### sobreescribir cada vez
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código Python ayuda a crear una lista de todos los archivos dentro de un directorio específico que nos interesa y guardar sus rutas en un archivo llamado `mapa.txt`. Primero, el programa te pide que introduzcas la ruta de una carpeta. Luego, crea un archivo llamado `mapa.txt` en blanco para asegurarse de que cualquier contenido anterior se borre.

El código utiliza la función `os.walk()` para recorrer todos los directorios y subdirectorios desde el que nos interesa, incluyendo cada archivo encontrado dentro de ellos. Para cada archivo, construye su ruta completa usando `os.path.join()` y luego escribe esa ruta en nuestro archivo `mapa.txt`, seguida de un salto de línea para mantener la legibilidad.

Finalmente, cierra el archivo `mapa.txt` para guardar todos los cambios realizados.

Este tipo de código es útil cuando necesitas crear una lista detallada de todos los archivos dentro de una estructura de carpetas compleja y guardarlo en un lugar donde sea fácil revisar o utilizar esa información posteriormente.

`009-sobreescribir cada vez.py`

```python
import os

carpeta = input("Indica una carpeta: ")
grande = 1024*1024*1024 # 1 giga

mapa = open("mapa.txt",'w') # Vaciamos los contenidos anteriores

for directorio, carpetas, archivos in os.walk(carpeta):
    for archivo in archivos:
        ruta = os.path.join(directorio, archivo)
        mapa.write(ruta+"\n")
        
mapa.close()
         
    
```

### minibuscador
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código en Python realiza una búsqueda simple para determinar si un cierto texto aparece dentro de otra. En primer lugar, se define una variable llamada `cadena` que contiene el texto "Esto es una cadena de prueba". Luego, se establece una segunda variable llamada `objetivo`, la cual almacena el texto "manzana" que será buscado en la primera cadena.

El código utiliza una estructura condicional `if` para comprobar si el valor almacenado en `objetivo` está presente dentro del texto de `cadena`. Si se encuentra, el programa imprime en pantalla "Efectivamente está". En caso contrario, es decir, si no se localiza la palabra buscada, entonces se muestra el mensaje "No está".

Esta técnica de búsqueda simple es muy útil cuando necesitas saber rápidamente si una cadena contiene cierto texto específico. Es importante para entender cómo manipular y analizar textos en programación, ya que permite realizar tareas como filtrado de datos o verificación de información con palabras clave.

`010-minibuscador.py`

```python
cadena = "Esto es una cadena de prueba"
objetivo = "manzana"

if objetivo in cadena:
  print("Efectivamente está")
else:
  print("No está")
  
```

### busca en mapa
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código está diseñado para buscar una palabra específica en un archivo de texto llamado `mapa.txt`. En este caso, el programa busca la cadena "json" dentro del archivo. 

Primero, se abre el archivo `mapa.txt` en modo lectura (`'r'`). Luego, el programa lee todas las líneas del archivo y las almacena en una lista llamada `lineas`.

Después, usando un bucle `for`, el código itera sobre cada línea de la lista. Si encuentra que la cadena "json" está presente en alguna línea, imprime una línea con un separador (formado por varios signos de número) y luego muestra la línea completa donde se encontró la palabra "json".

Este tipo de script es útil cuando necesitas buscar información específica dentro de archivos grandes o múltiples archivos. Es importante destacar que esta búsqueda es sensible a mayúsculas y minúsculas, lo que significa que solo encontrará coincidencias exactas con el texto en minúsculas "json".

`011-busca en mapa.py`

```python
archivo = open("mapa.txt",'r') # READ

lineas = archivo.readlines()

for linea in lineas:
  if "json" in linea:
    print("###########################")
    print("Encontrado!: ",linea)   
     
```

### usuario busca
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código en Python está diseñado para ayudarte a buscar un término específico dentro de un archivo de texto llamado "mapa.txt". Lo primero que hace es abrir el archivo en modo lectura ('r'), lo cual significa que solo puede leer su contenido pero no modificarlo. Luego, le pide al usuario que introduzca el término que quiere buscar.

El código lee todas las líneas del archivo y las guarda en una lista llamada `lineas`. A continuación, utiliza un bucle "for" para iterar sobre cada línea de esta lista. Dentro del bucle, verifica si la palabra o frase buscada (guardada en la variable `busca`) está presente en alguna de estas líneas. Si se encuentra el término, imprime una línea de separación y luego muestra la línea completa donde aparece.

Este tipo de script es útil para buscar información específica dentro de un archivo sin tener que revisar manualmente cada línea del documento. Es importante destacar que este código busca exactamente las cadenas introducidas por el usuario en cualquier parte de las líneas, lo que puede ser muy práctico cuando estás buscando datos específicos en grandes conjuntos de información.

`012-usuario busca.py`

```python
archivo = open("mapa.txt",'r') # READ
busca = input("Introduce el término a buscar: ")

lineas = archivo.readlines()

for linea in lineas:
  if busca in linea:
    print("###########################")
    print("Encontrado!: ",linea)   
     
```

### mapa
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

It looks like you've listed a series of file paths related to different sections within a course or documentation set focused on object-oriented programming and database management. Based on the structure, these files appear to be part of an educational module or guide covering topics such as:

1. **Concepts and basics of classes**: Introduces fundamental concepts like objects, properties, methods, and operations with lists.
2. **Development of classes and their components**: Explores more advanced class development including methods, inheritance, encapsulation, etc.
3. **Database concepts and object-oriented databases**: Covers installation of database systems, creation of databases, characteristics of OODBMS, querying mechanisms, and persistence management.
4. **Query languages and database operations**: Discusses SQL-like query syntax, expressions, operators for working with objects in a DB context.

To provide more specific assistance or address particular needs related to these topics, could you please clarify what exactly you're looking for? For example:

- Do you need explanations or examples related to any of the listed sections?
- Are you trying to find out how to implement certain features using Python, Java, or another programming language in conjunction with object-oriented databases?
- Would you like guidance on setting up and working with specific database systems (e.g., MongoDB)?
- Or are there particular exercises or problems you're facing while going through these materials that require additional help?

Please specify your requirements for further assistance.

`mapa.txt`

```
/var/www/html/programaciondam2526/001-Resumen.md
/var/www/html/programaciondam2526/README.md
/var/www/html/programaciondam2526/000-Resumen.md
/var/www/html/programaciondam2526/peticiones.py
/var/www/html/programaciondam2526/006-Aplicación de las estructuras de almacenamiento/000-Resumen.md
/var/www/html/programaciondam2526/006-Aplicación de las estructuras de almacenamiento/Criterios de evaluacion.md
/var/www/html/programaciondam2526/006-Aplicación de las estructuras de almacenamiento/001-Estructuras estáticas y dinámicas/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/006-Aplicación de las estructuras de almacenamiento/001-Estructuras estáticas y dinámicas/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/006-Aplicación de las estructuras de almacenamiento/004-Genericidad/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/006-Aplicación de las estructuras de almacenamiento/004-Genericidad/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/006-Aplicación de las estructuras de almacenamiento/003-Matrices (arrays) multidimensionales/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/006-Aplicación de las estructuras de almacenamiento/003-Matrices (arrays) multidimensionales/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/006-Aplicación de las estructuras de almacenamiento/005-Cadenas de caracteres. Expresiones regulares/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/006-Aplicación de las estructuras de almacenamiento/005-Cadenas de caracteres. Expresiones regulares/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/006-Aplicación de las estructuras de almacenamiento/002-Creación de matrices (arrays)/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/006-Aplicación de las estructuras de almacenamiento/002-Creación de matrices (arrays)/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/006-Aplicación de las estructuras de almacenamiento/006-Colecciones Listas, Conjuntos y Diccionarios/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/006-Aplicación de las estructuras de almacenamiento/006-Colecciones Listas, Conjuntos y Diccionarios/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/006-Aplicación de las estructuras de almacenamiento/007-Operaciones agregadas filtrado, reducción y recolección/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/006-Aplicación de las estructuras de almacenamiento/007-Operaciones agregadas filtrado, reducción y recolección/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/001-Introduccion.md
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/000-Resumen.md
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/Criterios de evaluacion.md
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/101-Ejercicio de final de unidad/101-Ejercicios/013-constantes.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/101-Ejercicio de final de unidad/101-Ejercicios/014-Diferencia.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/101-Ejercicio de final de unidad/101-Ejercicios/009-Entradas.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/101-Ejercicio de final de unidad/101-Ejercicios/014-operadores aritmeticos.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/101-Ejercicio de final de unidad/101-Ejercicios/019-Calculadora.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/101-Ejercicio de final de unidad/101-Ejercicios/003-salidas.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/101-Ejercicio de final de unidad/101-Ejercicios/011-Cambio de tipo de dato.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/101-Ejercicio de final de unidad/101-Ejercicios/010-Entrada y problema.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/101-Ejercicio de final de unidad/101-Ejercicios/021-Calculo de IVA.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/101-Ejercicio de final de unidad/101-Ejercicios/017-operadores booleanos.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/101-Ejercicio de final de unidad/101-Ejercicios/004-variar una variable.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/101-Ejercicio de final de unidad/101-Ejercicios/001-Holamundo.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/101-Ejercicio de final de unidad/101-Ejercicios/012-literales.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/101-Ejercicio de final de unidad/101-Ejercicios/020-Calculadora.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/101-Ejercicio de final de unidad/101-Ejercicios/005-identificadores permitidos.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/101-Ejercicio de final de unidad/101-Ejercicios/007-Explicacion del codigo.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/101-Ejercicio de final de unidad/101-Ejercicios/008-Tipos de datos.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/101-Ejercicio de final de unidad/101-Ejercicios/018-Ejercicio1-Calculadora de impuestos.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/101-Ejercicio de final de unidad/101-Ejercicios/002-variables.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/101-Ejercicio de final de unidad/101-Ejercicios/006-comentarios.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/101-Ejercicio de final de unidad/101-Ejercicios/016-operadores arimeticos abreviados.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/101-Ejercicio de final de unidad/101-Ejercicios/015-operadores de comparacion.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/101-Ejercicio de final de unidad/201-Criterios de evaluación/001-actividad.md
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/001-Estructura y bloques fundamentales/101-Ejercicios/001-Holamundo.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/001-Estructura y bloques fundamentales/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/001-Estructura y bloques fundamentales/001-Contenidos básicos/Introduccion.md
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/001-Estructura y bloques fundamentales/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/002-Variables/101-Ejercicios/003-salidas.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/002-Variables/101-Ejercicios/004-variar una variable.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/002-Variables/101-Ejercicios/005-identificadores permitidos.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/002-Variables/101-Ejercicios/007-Explicacion del codigo.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/002-Variables/101-Ejercicios/002-variables.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/002-Variables/101-Ejercicios/006-comentarios.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/002-Variables/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/002-Variables/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/005-Constantes/101-Ejercicios/013-constantes.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/005-Constantes/101-Ejercicios/014-Diferencia.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/005-Constantes/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/005-Constantes/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/004-Literales/101-Ejercicios/012-literales.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/004-Literales/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/004-Literales/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/006-Operadores y expresiones/101-Ejercicios/014-operadores aritmeticos.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/006-Operadores y expresiones/101-Ejercicios/019-Calculadora.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/006-Operadores y expresiones/101-Ejercicios/021-Calculo de IVA.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/006-Operadores y expresiones/101-Ejercicios/017-operadores booleanos.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/006-Operadores y expresiones/101-Ejercicios/020-Calculadora.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/006-Operadores y expresiones/101-Ejercicios/018-Ejercicio1-Calculadora de impuestos.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/006-Operadores y expresiones/101-Ejercicios/016-operadores arimeticos abreviados.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/006-Operadores y expresiones/101-Ejercicios/015-operadores de comparacion.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/006-Operadores y expresiones/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/006-Operadores y expresiones/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/003-Tipos de datos/101-Ejercicios/009-Entradas.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/003-Tipos de datos/101-Ejercicios/011-Cambio de tipo de dato.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/003-Tipos de datos/101-Ejercicios/010-Entrada y problema.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/003-Tipos de datos/101-Ejercicios/008-Tipos de datos.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/003-Tipos de datos/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/003-Tipos de datos/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/009-Gestión de bases de datos/000-Resumen.md
/var/www/html/programaciondam2526/009-Gestión de bases de datos/Criterios de evaluacion.md
/var/www/html/programaciondam2526/009-Gestión de bases de datos/002-Establecimiento de conexiones/101-Ejercicios/001-ejercicio.md
/var/www/html/programaciondam2526/009-Gestión de bases de datos/002-Establecimiento de conexiones/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/009-Gestión de bases de datos/002-Establecimiento de conexiones/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/009-Gestión de bases de datos/003-Almacenamiento, recuperación, actualización y eliminación de información en bases de datos/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/009-Gestión de bases de datos/003-Almacenamiento, recuperación, actualización y eliminación de información en bases de datos/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/009-Gestión de bases de datos/001-Acceso a bases de datos. Estándares. Características/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/009-Gestión de bases de datos/001-Acceso a bases de datos. Estándares. Características/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/007-Utilización avanzada de clases/000-Resumen.md
/var/www/html/programaciondam2526/007-Utilización avanzada de clases/Criterios de evaluacion.md
/var/www/html/programaciondam2526/007-Utilización avanzada de clases/006-Sobreescritura de métodos/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/007-Utilización avanzada de clases/006-Sobreescritura de métodos/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/007-Utilización avanzada de clases/005-Interfaces/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/007-Utilización avanzada de clases/005-Interfaces/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/007-Utilización avanzada de clases/001-Composición de clases/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/007-Utilización avanzada de clases/001-Composición de clases/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/007-Utilización avanzada de clases/007-Constructores y herencia/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/007-Utilización avanzada de clases/007-Constructores y herencia/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/007-Utilización avanzada de clases/003-Jerarquía de clases Superclases y subclases/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/007-Utilización avanzada de clases/003-Jerarquía de clases Superclases y subclases/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/007-Utilización avanzada de clases/004-Clases y métodos abstractos y finales/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/007-Utilización avanzada de clases/004-Clases y métodos abstractos y finales/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/007-Utilización avanzada de clases/002-Herencia y polimorfismo/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/007-Utilización avanzada de clases/002-Herencia y polimorfismo/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/003-Uso de estructuras de control/000-Resumen.md
/var/www/html/programaciondam2526/003-Uso de estructuras de control/Criterios de evaluacion.md
/var/www/html/programaciondam2526/003-Uso de estructuras de control/002-Estructuras de repetición/101-Ejercicios/006-ahora los impares.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/002-Estructuras de repetición/101-Ejercicios/004-mas anidacion.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/002-Estructuras de repetición/101-Ejercicios/002-estructura for.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/002-Estructuras de repetición/101-Ejercicios/001-ineficiente.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/002-Estructuras de repetición/101-Ejercicios/007-while.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/002-Estructuras de repetición/101-Ejercicios/0005-saltos.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/002-Estructuras de repetición/101-Ejercicios/009-Ejercicio propuesto patitos.md
/var/www/html/programaciondam2526/003-Uso de estructuras de control/002-Estructuras de repetición/101-Ejercicios/008-incremento.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/002-Estructuras de repetición/101-Ejercicios/003-anidacion.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/002-Estructuras de repetición/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/003-Uso de estructuras de control/002-Estructuras de repetición/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/003-Uso de estructuras de control/001-Estructuras de selección/101-Ejercicios/003-varios if.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/001-Estructuras de selección/101-Ejercicios/004-varios if.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/001-Estructuras de selección/101-Ejercicios/006-anidacion.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/001-Estructuras de selección/101-Ejercicios/002-else.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/001-Estructuras de selección/101-Ejercicios/001-Condicional.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/001-Estructuras de selección/101-Ejercicios/007-Ejercicio en clase.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/001-Estructuras de selección/101-Ejercicios/005-particula elif.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/001-Estructuras de selección/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/003-Uso de estructuras de control/001-Estructuras de selección/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/003-Uso de estructuras de control/005-Aserciones/101-Ejercicios/004-combinacion.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/005-Aserciones/101-Ejercicios/002-el chivato salta.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/005-Aserciones/101-Ejercicios/001-chivato.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/005-Aserciones/101-Ejercicios/003-ejemplo no tan traumatico.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/005-Aserciones/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/003-Uso de estructuras de control/005-Aserciones/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/003-Uso de estructuras de control/003-Estructuras de salto/101-Ejercicios/funcionsuma.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/003-Estructuras de salto/101-Ejercicios/008-llamada a la funcion de suma.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/003-Estructuras de salto/101-Ejercicios/002-uso de la funcion.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/003-Estructuras de salto/101-Ejercicios/006-las funcione retornan.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/003-Estructuras de salto/101-Ejercicios/005-varios parametros.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/003-Estructuras de salto/101-Ejercicios/004-Llamada correcta.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/003-Estructuras de salto/101-Ejercicios/007-funcion de sumar.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/003-Estructuras de salto/101-Ejercicios/003-parametros.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/003-Estructuras de salto/101-Ejercicios/001-Funciones.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/003-Estructuras de salto/101-Ejercicios/__pycache__/funcionsuma.cpython-312.pyc
/var/www/html/programaciondam2526/003-Uso de estructuras de control/003-Estructuras de salto/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/003-Uso de estructuras de control/003-Estructuras de salto/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/003-Uso de estructuras de control/006-Prueba, depuración y documentación de la aplicación/101-Ejercicios/010-ejercicio propuesto.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/006-Prueba, depuración y documentación de la aplicación/101-Ejercicios/005-cadenas.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/006-Prueba, depuración y documentación de la aplicación/101-Ejercicios/008-documentacion de la funcion.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/006-Prueba, depuración y documentación de la aplicación/101-Ejercicios/003-nuevo fallo.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/006-Prueba, depuración y documentación de la aplicación/101-Ejercicios/002-mejora.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/006-Prueba, depuración y documentación de la aplicación/101-Ejercicios/006-mejoro cadenas.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/006-Prueba, depuración y documentación de la aplicación/101-Ejercicios/009-extraccion de funcion.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/006-Prueba, depuración y documentación de la aplicación/101-Ejercicios/004-nuevo fallo mas.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/006-Prueba, depuración y documentación de la aplicación/101-Ejercicios/001-funcion de division.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/006-Prueba, depuración y documentación de la aplicación/101-Ejercicios/011-tres en raya.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/006-Prueba, depuración y documentación de la aplicación/101-Ejercicios/funciondivision.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/006-Prueba, depuración y documentación de la aplicación/101-Ejercicios/007-depuracion.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/006-Prueba, depuración y documentación de la aplicación/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/003-Uso de estructuras de control/006-Prueba, depuración y documentación de la aplicación/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/003-Uso de estructuras de control/004-Control de excepciones/101-Ejercicios/002-error.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/004-Control de excepciones/101-Ejercicios/003-error con try except.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/004-Control de excepciones/101-Ejercicios/001-tryexcept.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/004-Control de excepciones/101-Ejercicios/004-pseudocodigo.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/004-Control de excepciones/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/003-Uso de estructuras de control/004-Control de excepciones/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/003-Uso de estructuras de control/007-Ejercicio/101-Ejercicios/001-ejercicio for.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/007-Ejercicio/101-Ejercicios/004-dragones.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/007-Ejercicio/101-Ejercicios/004-enunciado.md
/var/www/html/programaciondam2526/003-Uso de estructuras de control/007-Ejercicio/101-Ejercicios/005-magos.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/007-Ejercicio/101-Ejercicios/002-ejercicio escalones.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/007-Ejercicio/101-Ejercicios/003-subir escalones de dos en dos.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/007-Ejercicio/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/003-Uso de estructuras de control/007-Ejercicio/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/002-Utilización de objetos/000-Resumen.md
/var/www/html/programaciondam2526/002-Utilización de objetos/Criterios de evaluacion.md
/var/www/html/programaciondam2526/002-Utilización de objetos/006-Constructores/101-Ejercicios/000-Nota importante.md
/var/www/html/programaciondam2526/002-Utilización de objetos/006-Constructores/101-Ejercicios/007-propiedades de la fecha.py
/var/www/html/programaciondam2526/002-Utilización de objetos/006-Constructores/101-Ejercicios/006-fechas en python.py
/var/www/html/programaciondam2526/002-Utilización de objetos/006-Constructores/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/002-Utilización de objetos/006-Constructores/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/002-Utilización de objetos/007-Destrucción de objetos y liberación de memoria/101-Ejercicios/000-Nota importante.md
/var/www/html/programaciondam2526/002-Utilización de objetos/007-Destrucción de objetos y liberación de memoria/101-Ejercicios/011-entrada calculo y salida.py
/var/www/html/programaciondam2526/002-Utilización de objetos/007-Destrucción de objetos y liberación de memoria/101-Ejercicios/012-libreria matematica.py
/var/www/html/programaciondam2526/002-Utilización de objetos/007-Destrucción de objetos y liberación de memoria/101-Ejercicios/010-propiedades.py
/var/www/html/programaciondam2526/002-Utilización de objetos/007-Destrucción de objetos y liberación de memoria/101-Ejercicios/008-destruccion de objetos.py
/var/www/html/programaciondam2526/002-Utilización de objetos/007-Destrucción de objetos y liberación de memoria/101-Ejercicios/009-caballos en la cuadra.py
/var/www/html/programaciondam2526/002-Utilización de objetos/007-Destrucción de objetos y liberación de memoria/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/002-Utilización de objetos/007-Destrucción de objetos y liberación de memoria/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/002-Utilización de objetos/001-Características de los objetos/101-Ejercicios/000-Nota importante.md
/var/www/html/programaciondam2526/002-Utilización de objetos/001-Características de los objetos/101-Ejercicios/001-objeto math.py
/var/www/html/programaciondam2526/002-Utilización de objetos/001-Características de los objetos/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/002-Utilización de objetos/001-Características de los objetos/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/002-Utilización de objetos/003-Utilización de métodos. Parámetros/101-Ejercicios/000-Nota importante.md
/var/www/html/programaciondam2526/002-Utilización de objetos/003-Utilización de métodos. Parámetros/101-Ejercicios/003-llamada a metodos.py
/var/www/html/programaciondam2526/002-Utilización de objetos/003-Utilización de métodos. Parámetros/101-Ejercicios/004-sparse is better than dense.py
/var/www/html/programaciondam2526/002-Utilización de objetos/003-Utilización de métodos. Parámetros/101-Ejercicios/004-sparse.py
/var/www/html/programaciondam2526/002-Utilización de objetos/003-Utilización de métodos. Parámetros/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/002-Utilización de objetos/003-Utilización de métodos. Parámetros/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/002-Utilización de objetos/002-Instanciación de objetos/101-Ejercicios/000-Nota importante.md
/var/www/html/programaciondam2526/002-Utilización de objetos/002-Instanciación de objetos/101-Ejercicios/002-namespace.py
/var/www/html/programaciondam2526/002-Utilización de objetos/002-Instanciación de objetos/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/002-Utilización de objetos/002-Instanciación de objetos/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/002-Utilización de objetos/005-Utilización de métodos estáticos/101-Ejercicios/000-Nota importante.md
/var/www/html/programaciondam2526/002-Utilización de objetos/005-Utilización de métodos estáticos/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/002-Utilización de objetos/005-Utilización de métodos estáticos/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/002-Utilización de objetos/004-Utilización de propiedades/101-Ejercicios/000-Nota importante.md
/var/www/html/programaciondam2526/002-Utilización de objetos/004-Utilización de propiedades/101-Ejercicios/005-propiedades.py
/var/www/html/programaciondam2526/002-Utilización de objetos/004-Utilización de propiedades/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/002-Utilización de objetos/004-Utilización de propiedades/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/005-Lectura y escritura de información/000-Resumen.md
/var/www/html/programaciondam2526/005-Lectura y escritura de información/Criterios de evaluacion.md
/var/www/html/programaciondam2526/005-Lectura y escritura de información/Carpeta sin título/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/005-Lectura y escritura de información/004-Utilización de los sistemas de ficheros./101-Ejercicios/004-suma del tamaño.py
/var/www/html/programaciondam2526/005-Lectura y escritura de información/004-Utilización de los sistemas de ficheros./101-Ejercicios/007-condicion.py
/var/www/html/programaciondam2526/005-Lectura y escritura de información/004-Utilización de los sistemas de ficheros./101-Ejercicios/005-recorrer.py
/var/www/html/programaciondam2526/005-Lectura y escritura de información/004-Utilización de los sistemas de ficheros./101-Ejercicios/001-listar contenido de carpeta.py
/var/www/html/programaciondam2526/005-Lectura y escritura de información/004-Utilización de los sistemas de ficheros./101-Ejercicios/006-tamaño recursivo.py
/var/www/html/programaciondam2526/005-Lectura y escritura de información/004-Utilización de los sistemas de ficheros./101-Ejercicios/008-escribir en archivo el contenido de la carpeta.py
/var/www/html/programaciondam2526/005-Lectura y escritura de información/004-Utilización de los sistemas de ficheros./101-Ejercicios/003-formateo el resultado.py
/var/www/html/programaciondam2526/005-Lectura y escritura de información/004-Utilización de los sistemas de ficheros./101-Ejercicios/010-minibuscador.py
/var/www/html/programaciondam2526/005-Lectura y escritura de información/004-Utilización de los sistemas de ficheros./101-Ejercicios/009-sobreescribir cada vez.py
/var/www/html/programaciondam2526/005-Lectura y escritura de información/004-Utilización de los sistemas de ficheros./101-Ejercicios/mapa.txt
/var/www/html/programaciondam2526/005-Lectura y escritura de información/004-Utilización de los sistemas de ficheros./101-Ejercicios/011-busca en mapa.py
/var/www/html/programaciondam2526/005-Lectura y escritura de información/004-Utilización de los sistemas de ficheros./101-Ejercicios/002-atributos.py
/var/www/html/programaciondam2526/005-Lectura y escritura de información/009-Creación de controladores de eventos/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/005-Lectura y escritura de información/009-Creación de controladores de eventos/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/005-Lectura y escritura de información/007-Interfaces gráficas/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/005-Lectura y escritura de información/007-Interfaces gráficas/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/005-Lectura y escritura de información/005-Creación y eliminación de ficheros y directorios/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/005-Lectura y escritura de información/005-Creación y eliminación de ficheros y directorios/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/005-Lectura y escritura de información/006-Entrada desde teclado. Salida a pantalla. Formatos de visualización/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/005-Lectura y escritura de información/006-Entrada desde teclado. Salida a pantalla. Formatos de visualización/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/005-Lectura y escritura de información/003-Apertura y cierre de ficheros. Modos de acceso. Escritura y lectura de información en ficheros/101-Ejercicios/001-escribir.py
/var/www/html/programaciondam2526/005-Lectura y escritura de información/003-Apertura y cierre de ficheros. Modos de acceso. Escritura y lectura de información en ficheros/101-Ejercicios/007-pickle escribir.py
/var/www/html/programaciondam2526/005-Lectura y escritura de información/003-Apertura y cierre de ficheros. Modos de acceso. Escritura y lectura de información en ficheros/101-Ejercicios/010-guardo con pickle a binario.py
/var/www/html/programaciondam2526/005-Lectura y escritura de información/003-Apertura y cierre de ficheros. Modos de acceso. Escritura y lectura de información en ficheros/101-Ejercicios/009-crear cliente.py
/var/www/html/programaciondam2526/005-Lectura y escritura de información/003-Apertura y cierre de ficheros. Modos de acceso. Escritura y lectura de información en ficheros/101-Ejercicios/basededatos.txt
/var/www/html/programaciondam2526/005-Lectura y escritura de información/003-Apertura y cierre de ficheros. Modos de acceso. Escritura y lectura de información en ficheros/101-Ejercicios/002-apendizar.py
/var/www/html/programaciondam2526/005-Lectura y escritura de información/003-Apertura y cierre de ficheros. Modos de acceso. Escritura y lectura de información en ficheros/101-Ejercicios/011-recupero los datos.py
/var/www/html/programaciondam2526/005-Lectura y escritura de información/003-Apertura y cierre de ficheros. Modos de acceso. Escritura y lectura de información en ficheros/101-Ejercicios/datos.bin
/var/www/html/programaciondam2526/005-Lectura y escritura de información/003-Apertura y cierre de ficheros. Modos de acceso. Escritura y lectura de información en ficheros/101-Ejercicios/004-leer una linea.py
/var/www/html/programaciondam2526/005-Lectura y escritura de información/003-Apertura y cierre de ficheros. Modos de acceso. Escritura y lectura de información en ficheros/101-Ejercicios/005-leer varias lineas.py
/var/www/html/programaciondam2526/005-Lectura y escritura de información/003-Apertura y cierre de ficheros. Modos de acceso. Escritura y lectura de información en ficheros/101-Ejercicios/003-añadir salto de linea.py
/var/www/html/programaciondam2526/005-Lectura y escritura de información/003-Apertura y cierre de ficheros. Modos de acceso. Escritura y lectura de información en ficheros/101-Ejercicios/008-leer pickle.py
/var/www/html/programaciondam2526/005-Lectura y escritura de información/003-Apertura y cierre de ficheros. Modos de acceso. Escritura y lectura de información en ficheros/101-Ejercicios/clientes.bin
/var/www/html/programaciondam2526/005-Lectura y escritura de información/003-Apertura y cierre de ficheros. Modos de acceso. Escritura y lectura de información en ficheros/101-Ejercicios/006-recorrer la lista.py
/var/www/html/programaciondam2526/005-Lectura y escritura de información/003-Apertura y cierre de ficheros. Modos de acceso. Escritura y lectura de información en ficheros/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/005-Lectura y escritura de información/003-Apertura y cierre de ficheros. Modos de acceso. Escritura y lectura de información en ficheros/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/005-Lectura y escritura de información/001-Flujos. Tipos bytes y caracteres. Clases relacionadas/101-Ejercicios/003-creador agenda.py
/var/www/html/programaciondam2526/005-Lectura y escritura de información/001-Flujos. Tipos bytes y caracteres. Clases relacionadas/101-Ejercicios/clientes.txt
/var/www/html/programaciondam2526/005-Lectura y escritura de información/001-Flujos. Tipos bytes y caracteres. Clases relacionadas/101-Ejercicios/001-escribir texto a archivo.py
/var/www/html/programaciondam2526/005-Lectura y escritura de información/001-Flujos. Tipos bytes y caracteres. Clases relacionadas/101-Ejercicios/002-ahora leemos.py
/var/www/html/programaciondam2526/005-Lectura y escritura de información/001-Flujos. Tipos bytes y caracteres. Clases relacionadas/101-Ejercicios/agenda.txt
/var/www/html/programaciondam2526/005-Lectura y escritura de información/001-Flujos. Tipos bytes y caracteres. Clases relacionadas/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/005-Lectura y escritura de información/001-Flujos. Tipos bytes y caracteres. Clases relacionadas/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/005-Lectura y escritura de información/002-Ficheros de datos. Registros/101-Ejercicios/005-una pequeña decoracion.py
/var/www/html/programaciondam2526/005-Lectura y escritura de información/002-Ficheros de datos. Registros/101-Ejercicios/004-ahora accedemos a las parejas.py
/var/www/html/programaciondam2526/005-Lectura y escritura de información/002-Ficheros de datos. Registros/101-Ejercicios/007-secciones.html
/var/www/html/programaciondam2526/005-Lectura y escritura de información/002-Ficheros de datos. Registros/101-Ejercicios/003-leemos linea a linea.py
/var/www/html/programaciondam2526/005-Lectura y escritura de información/002-Ficheros de datos. Registros/101-Ejercicios/001-leer archivo.py
/var/www/html/programaciondam2526/005-Lectura y escritura de información/002-Ficheros de datos. Registros/101-Ejercicios/012-frankenstein.py
/var/www/html/programaciondam2526/005-Lectura y escritura de información/002-Ficheros de datos. Registros/101-Ejercicios/008-articulo.html
/var/www/html/programaciondam2526/005-Lectura y escritura de información/002-Ficheros de datos. Registros/101-Ejercicios/blog.txt
/var/www/html/programaciondam2526/005-Lectura y escritura de información/002-Ficheros de datos. Registros/101-Ejercicios/011-arranco flask.py
/var/www/html/programaciondam2526/005-Lectura y escritura de información/002-Ficheros de datos. Registros/101-Ejercicios/002-leer json.py
/var/www/html/programaciondam2526/005-Lectura y escritura de información/002-Ficheros de datos. Registros/101-Ejercicios/blog.json
/var/www/html/programaciondam2526/005-Lectura y escritura de información/002-Ficheros de datos. Registros/101-Ejercicios/006-blog.html
/var/www/html/programaciondam2526/005-Lectura y escritura de información/002-Ficheros de datos. Registros/101-Ejercicios/010-Instalar servidor.md
/var/www/html/programaciondam2526/005-Lectura y escritura de información/002-Ficheros de datos. Registros/101-Ejercicios/009-estilos minimos.html
/var/www/html/programaciondam2526/005-Lectura y escritura de información/002-Ficheros de datos. Registros/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/005-Lectura y escritura de información/002-Ficheros de datos. Registros/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/005-Lectura y escritura de información/008-Concepto de evento/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/005-Lectura y escritura de información/008-Concepto de evento/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/.git/ORIG_HEAD
/var/www/html/programaciondam2526/.git/COMMIT_EDITMSG
/var/www/html/programaciondam2526/.git/FETCH_HEAD
/var/www/html/programaciondam2526/.git/packed-refs
/var/www/html/programaciondam2526/.git/description
/var/www/html/programaciondam2526/.git/index
/var/www/html/programaciondam2526/.git/HEAD
/var/www/html/programaciondam2526/.git/config
/var/www/html/programaciondam2526/.git/logs/HEAD
/var/www/html/programaciondam2526/.git/logs/refs/remotes/origin/HEAD
/var/www/html/programaciondam2526/.git/logs/refs/remotes/origin/main
/var/www/html/programaciondam2526/.git/logs/refs/heads/main
/var/www/html/programaciondam2526/.git/refs/remotes/origin/HEAD
/var/www/html/programaciondam2526/.git/refs/remotes/origin/main
/var/www/html/programaciondam2526/.git/refs/heads/main
/var/www/html/programaciondam2526/.git/info/exclude
/var/www/html/programaciondam2526/.git/hooks/pre-push.sample
/var/www/html/programaciondam2526/.git/hooks/pre-rebase.sample
/var/www/html/programaciondam2526/.git/hooks/pre-receive.sample
/var/www/html/programaciondam2526/.git/hooks/fsmonitor-watchman.sample
/var/www/html/programaciondam2526/.git/hooks/applypatch-msg.sample
/var/www/html/programaciondam2526/.git/hooks/push-to-checkout.sample
/var/www/html/programaciondam2526/.git/hooks/pre-merge-commit.sample
/var/www/html/programaciondam2526/.git/hooks/sendemail-validate.sample
/var/www/html/programaciondam2526/.git/hooks/post-update.sample
/var/www/html/programaciondam2526/.git/hooks/update.sample
/var/www/html/programaciondam2526/.git/hooks/pre-applypatch.sample
/var/www/html/programaciondam2526/.git/hooks/commit-msg.sample
/var/www/html/programaciondam2526/.git/hooks/prepare-commit-msg.sample
/var/www/html/programaciondam2526/.git/hooks/pre-commit.sample
/var/www/html/programaciondam2526/.git/objects/2b/cb2f1852b538bc8ce87ffeeb1c1e77930cb7c4
/var/www/html/programaciondam2526/.git/objects/69/34a7c4892afae9f5212aed2c144b18f9beca0f
/var/www/html/programaciondam2526/.git/objects/69/4ed2381c1215672796b5d15d4480d4c62997f2
/var/www/html/programaciondam2526/.git/objects/ff/c0b1ff8dd1931f841e231fab1442f3e2257a81
/var/www/html/programaciondam2526/.git/objects/ff/4803bc071937e5e3d5217ca976d697dfc046b1
/var/www/html/programaciondam2526/.git/objects/ff/72907a8b1ac4d2fd537fc01ddad70af28b1990
/var/www/html/programaciondam2526/.git/objects/46/252db27ed7930199159a6548d72b127380db15
/var/www/html/programaciondam2526/.git/objects/37/bed996f76d60c3cb8ca593e901eb84baabcf82
/var/www/html/programaciondam2526/.git/objects/37/7c1aa390898102acfb1496202c1525105cd551
/var/www/html/programaciondam2526/.git/objects/52/0967073acc2dff82f3a22b92f751377a2c228a
/var/www/html/programaciondam2526/.git/objects/52/c165ab90f3ee9b2bde62d023952117e114f3d2
/var/www/html/programaciondam2526/.git/objects/52/223b0aa2a1ae702b5cdb432cf3cec6aa7a0692
/var/www/html/programaciondam2526/.git/objects/52/0583ba4dea480e8a361321a6acee35c6869f7a
/var/www/html/programaciondam2526/.git/objects/52/891b4caec2346a0439d6384eff5c58ee3e4ace
/var/www/html/programaciondam2526/.git/objects/52/e7f90036998ec15bc529fe5ea5a4b09cc0e415
/var/www/html/programaciondam2526/.git/objects/a6/4e00e82920414fe955f186e49ca3d939773a54
/var/www/html/programaciondam2526/.git/objects/a6/ba63e47bd069661a8e7d0c56a6fbd27228c78a
/var/www/html/programaciondam2526/.git/objects/70/069d71010d60916be60a51995a3fca04cc4776
/var/www/html/programaciondam2526/.git/objects/70/b47da25c70e85f9f4ec6226747706a057c3d43
/var/www/html/programaciondam2526/.git/objects/70/b60c9be33184c59742ebde759d916c308c7b96
/var/www/html/programaciondam2526/.git/objects/10/2f526da2f3ed423efe29d01e98bb330507d9ee
/var/www/html/programaciondam2526/.git/objects/63/991ba4c0b5de03d04edd5d8cb77608624c763f
/var/www/html/programaciondam2526/.git/objects/63/67129a1591fedf3ed27e4191e356d6cedf54d4
/var/www/html/programaciondam2526/.git/objects/2d/4e2c38b2a766a008eac3cb6580f5ef93f10ed2
/var/www/html/programaciondam2526/.git/objects/2d/1daa01f1c49d9b1f4083919aa8a6ab8f2d622a
/var/www/html/programaciondam2526/.git/objects/d2/93fc8960a2996eca2e8ffd6af58677d4c18681
/var/www/html/programaciondam2526/.git/objects/d2/fbc53d6da413345624ed1ab6cd34dc108b2e69
/var/www/html/programaciondam2526/.git/objects/d2/0742a97ba026afe6b49a8b5bafb14b038e7d7d
/var/www/html/programaciondam2526/.git/objects/c8/31721b5664539fc8f1eea91002defab4a854b3
/var/www/html/programaciondam2526/.git/objects/c8/a647434c3d156ac49f4d785f526ed41af88d76
/var/www/html/programaciondam2526/.git/objects/c8/300b84d709e9462874bb924b44fc3e36442174
/var/www/html/programaciondam2526/.git/objects/c8/31ea66527f6399342f70b9ed91d1592ba02f6e
/var/www/html/programaciondam2526/.git/objects/af/f248886548afda5ea34d4abf95771913b35710
/var/www/html/programaciondam2526/.git/objects/af/6353671fdd6c538df68bc9cdef98e7fd8ddb38
/var/www/html/programaciondam2526/.git/objects/f1/a40b1dd7a010554f43c208af4f53edadbac64a
/var/www/html/programaciondam2526/.git/objects/8b/0828e0c18a8cd1bfc0a4e98c6c75ae8154e4d2
/var/www/html/programaciondam2526/.git/objects/8b/137891791fe96927ad78e64b0aad7bded08bdc
/var/www/html/programaciondam2526/.git/objects/13/27e66641678d49f91e9150ca745610b87dd3a7
/var/www/html/programaciondam2526/.git/objects/13/a30f50d5938c9903c6f6de6c80b495aa3b1604
/var/www/html/programaciondam2526/.git/objects/2f/a6511f4ee6520f1a9a329a436532dd64dd81a2
/var/www/html/programaciondam2526/.git/objects/2f/dfb97eea4cd79c468a464b5d06675202790c71
/var/www/html/programaciondam2526/.git/objects/97/a5640f59796fafa4a346745a176b171581ff0f
/var/www/html/programaciondam2526/.git/objects/97/2eac3233bcbe983dcc0e03089f7eb7d0ee7614
/var/www/html/programaciondam2526/.git/objects/3f/06047a35ca80ed4ebca72c78687ea4e66c7c17
/var/www/html/programaciondam2526/.git/objects/3f/d279c859e98a94d02e990756c28acd8d0f0161
/var/www/html/programaciondam2526/.git/objects/3f/48de1308cfdee7032ebd2ad62dd8b758d43140
/var/www/html/programaciondam2526/.git/objects/3f/eccc336453782979f2c3a078ebd78054737c9a
/var/www/html/programaciondam2526/.git/objects/82/cdd216ae199a67246c6d6863e81a8983ac3aff
/var/www/html/programaciondam2526/.git/objects/82/7a5563d7cdb9447e8a36cacc6516abb1eb51b2
/var/www/html/programaciondam2526/.git/objects/82/1bc66e0704feff1fe0b552361d268faace9c67
/var/www/html/programaciondam2526/.git/objects/55/0376c979fdf75c228b9a8a160ff1d8b7beafd4
/var/www/html/programaciondam2526/.git/objects/55/24797cb6603ef3d2134248ae71c4555402c157
/var/www/html/programaciondam2526/.git/objects/55/d760010c5249850011e22e979b485f9bd69150
/var/www/html/programaciondam2526/.git/objects/ad/f39835bd4d2a4c647bdc0fe6063652233d51af
/var/www/html/programaciondam2526/.git/objects/ad/eb7de7f144aa128ea8713019fa83c6ba3ec087
/var/www/html/programaciondam2526/.git/objects/0e/4c54bc6ae99b69ba5605c980c5e55480950f12
/var/www/html/programaciondam2526/.git/objects/0e/072209bc55116c28faa1b0aa24413dbb500f02
/var/www/html/programaciondam2526/.git/objects/26/1d107cc316f90cc0f700964e235f21b3a6e04f
/var/www/html/programaciondam2526/.git/objects/26/10e939551aef74d9b0768fac402a2e0209107b
/var/www/html/programaciondam2526/.git/objects/26/f07baad39e14b757269aa71f9523022b35532f
/var/www/html/programaciondam2526/.git/objects/7a/35f8d326923e8012cd6f289a6a21e205826184
/var/www/html/programaciondam2526/.git/objects/c0/8b5e48c85f0d20fa91a4dfe181b2eae1501144
/var/www/html/programaciondam2526/.git/objects/ec/c4a33ce949c150c2cb227feed70199b746b3ac
/var/www/html/programaciondam2526/.git/objects/ec/11c56d5863cff7f1deeac283257b05a2370d08
/var/www/html/programaciondam2526/.git/objects/62/390b8577ee22284b1ed1d0b4431e7524d3d9ef
/var/www/html/programaciondam2526/.git/objects/62/cf1f2111cf03d9b7f52a4572c8e2383d63b460
/var/www/html/programaciondam2526/.git/objects/62/7f35de26524a979168415ff7b562cea2389fcb
/var/www/html/programaciondam2526/.git/objects/62/e321012dc2186b31b4f6e15d5106499abf8cf9
/var/www/html/programaciondam2526/.git/objects/62/023618b51fc484143ecce141d705b1a8b77e23
/var/www/html/programaciondam2526/.git/objects/62/3cc6b5cfd4d510c4f1e0e987fb498c8215fe9d
/var/www/html/programaciondam2526/.git/objects/e2/038bf8c8b27a3c7f47c622902f32e40af8d27d
/var/www/html/programaciondam2526/.git/objects/e2/94a060e8f7a21d851d13a3d93f5b2b8bcbd2fa
/var/www/html/programaciondam2526/.git/objects/e2/82a33bb19148a016dcef43e5ef88b708ad0c3f
/var/www/html/programaciondam2526/.git/objects/9d/4b0f8c07d989c62504c9f7b83a9e04bc6a024e
/var/www/html/programaciondam2526/.git/objects/9d/01c25023360f559fe9550cb8b54cf0e999f6bf
/var/www/html/programaciondam2526/.git/objects/9d/d95d74273ce86895c0c4dc0dfef1be4aa3832f
/var/www/html/programaciondam2526/.git/objects/9d/ada280de6bef83d7a41f8af45dd2ee8a029ad1
/var/www/html/programaciondam2526/.git/objects/9d/1e2569a9b800ad1b9dab0ad5226b90761c750f
/var/www/html/programaciondam2526/.git/objects/9d/c6ba7de0377317e3a314b5d48417ac59f3faba
/var/www/html/programaciondam2526/.git/objects/9d/d9146fd9e87acc1b0a8f85ce0e97c1943591b0
/var/www/html/programaciondam2526/.git/objects/9d/46f7146a8481a54df904ef3cb8ec9c68dd4e0e
/var/www/html/programaciondam2526/.git/objects/27/16d902b81913b69c846643a4ff62e30f7473e7
/var/www/html/programaciondam2526/.git/objects/ba/89f99b969304ad2fe0bbab17b4edc1872b2429
/var/www/html/programaciondam2526/.git/objects/ba/7332583e65c6f44fb37517d6295f2e919c8799
/var/www/html/programaciondam2526/.git/objects/5b/135bb7d9d54f1621226ae92116eb4160fad130
/var/www/html/programaciondam2526/.git/objects/5b/f9907bbed3cc24d211005c71d3e2e42a10bc41
/var/www/html/programaciondam2526/.git/objects/5b/0c13a6998891c1ac473e6761c6b87db79c4ce8
/var/www/html/programaciondam2526/.git/objects/5b/c794d697b7d3bdc7ef8dab61cd765ee9e8ac4f
/var/www/html/programaciondam2526/.git/objects/5b/9a7de1e2988381635adde952e5c18afca91353
/var/www/html/programaciondam2526/.git/objects/5b/c2701980f74a501de06b17fcc2cdcfad3e5610
/var/www/html/programaciondam2526/.git/objects/7f/2be6d6704bed987241d72255cfa23cb9ddfa98
/var/www/html/programaciondam2526/.git/objects/7f/14cc16bb6cd93d691d60dc797cde876e58023f
/var/www/html/programaciondam2526/.git/objects/7f/a4af2f7e396661d5102ef43b2373226f150644
/var/www/html/programaciondam2526/.git/objects/7f/742d809cc157bf10a75096e394af3ac9776522
/var/www/html/programaciondam2526/.git/objects/9e/59a6ffd7273a2391bd421bfb1cefe981635637
/var/www/html/programaciondam2526/.git/objects/9e/2555bca40caa8f42c7baf7f64a8233d2eca276
/var/www/html/programaciondam2526/.git/objects/ce/e00be67c99b555806a1ca49f6eb94fbd419922
/var/www/html/programaciondam2526/.git/objects/ce/281723546f15914ce27ae745628428f0f1c559
/var/www/html/programaciondam2526/.git/objects/ce/0e710b9cc4152b39f5f4efcffc91696c5d3b87
/var/www/html/programaciondam2526/.git/objects/ce/a63e860adefac9c3d7c977c0b889e3a85c53f9
/var/www/html/programaciondam2526/.git/objects/db/3c69565595e7b6e5fccc459079732cdf191ffa
/var/www/html/programaciondam2526/.git/objects/db/0fd3ead4d9935483cc7aed3a74ef10680875cb
/var/www/html/programaciondam2526/.git/objects/db/f5427a54dd0836248f738720ca1def0392d637
/var/www/html/programaciondam2526/.git/objects/bf/74192b4f0efbd2aed3fe23a67be325319bff2d
/var/www/html/programaciondam2526/.git/objects/50/2db0e9dd438bc2b93b52e0a3ed656f741e4d22
/var/www/html/programaciondam2526/.git/objects/50/0ab02fe4a8aebd7206fbcbe2959772dffd7bad
/var/www/html/programaciondam2526/.git/objects/9b/69d6d24be3f33834a2e9a4b9784d0d16e0e738
/var/www/html/programaciondam2526/.git/objects/9b/0d0b33f5f9f002630187e3fd4bd06e9ea5b4b3
/var/www/html/programaciondam2526/.git/objects/9b/d91eecc9413deb229c1b228d184de08a030513
/var/www/html/programaciondam2526/.git/objects/b1/1c0b4b6f66d8c84b269d5842a86131ff810f0f
/var/www/html/programaciondam2526/.git/objects/b1/72ea56a82614bf155fc0ea8c125d5e2e232c3e
/var/www/html/programaciondam2526/.git/objects/b1/235e16f45b4201456951b5ff6e1cec4d715ee9
/var/www/html/programaciondam2526/.git/objects/b1/9729dbe01f2be9069e4af26b65a1757707582f
/var/www/html/programaciondam2526/.git/objects/f9/405c7565a83cd8730bf5ed414b6b203e1ef822
/var/www/html/programaciondam2526/.git/objects/f9/1d64b849d68b7f5b0a5a922dbf1028605f33eb
/var/www/html/programaciondam2526/.git/objects/f9/b29a377da0adf4ad9f44ecd65427117bb6669e
/var/www/html/programaciondam2526/.git/objects/86/3196b96c0f735dc7ffd164259b6be3667c6749
/var/www/html/programaciondam2526/.git/objects/86/680d5ad56a82372a5585ea6d51cdf856b0f9cb
/var/www/html/programaciondam2526/.git/objects/cc/7401584a1266d2cd4f0e98c217b398281cf81a
/var/www/html/programaciondam2526/.git/objects/44/e1e488ca1f73add95c437ff1dcd5ccf88e9451
/var/www/html/programaciondam2526/.git/objects/73/974291e016b119b99abfe40930fc34ddb34945
/var/www/html/programaciondam2526/.git/objects/73/0db11edac01b886205c801530fff72deb5f013
/var/www/html/programaciondam2526/.git/objects/73/6b8f20af2132af8d437ddc9774d56b0aab2bcb
/var/www/html/programaciondam2526/.git/objects/96/d3ebc0d18da7f2474fba880a8914e45fe54a85
/var/www/html/programaciondam2526/.git/objects/77/8d67993d3bb8c5a847e13ac749f71e98d26cd0
/var/www/html/programaciondam2526/.git/objects/77/498ebae145774c2391468344fd774e1c6c8463
/var/www/html/programaciondam2526/.git/objects/77/5c96611985a297a7cf7c41f5f5a92c0ce6d257
/var/www/html/programaciondam2526/.git/objects/77/7f8b58aed584f2437279e9626f99ae9420bdf1
/var/www/html/programaciondam2526/.git/objects/77/4cd922f1c49ac67a4bef2faf21261ead834c5d
/var/www/html/programaciondam2526/.git/objects/92/a664c8cf7b94f19248ff11158fe2c72a6145bd
/var/www/html/programaciondam2526/.git/objects/92/30f125f66f964100de65fc465f7b136c5713b1
/var/www/html/programaciondam2526/.git/objects/92/397fecf8398b1272a14318f5f386ccd776fe8c
/var/www/html/programaciondam2526/.git/objects/92/fcbffd6b3ee8e730d56b0f3e43dfc2fb469db3
/var/www/html/programaciondam2526/.git/objects/5e/3a1a601fe402f03d226287ff3317dc2a28f0d6
/var/www/html/programaciondam2526/.git/objects/5e/4b38156d1eaa3b3c34c9ad87c480162277ccd4
/var/www/html/programaciondam2526/.git/objects/5e/2e37977051e7e4a87f2c23917b3c79bc93e7d6
/var/www/html/programaciondam2526/.git/objects/b9/98954ad5eb42d8d3150cbc3e645f5c4d027cc4
/var/www/html/programaciondam2526/.git/objects/b9/3e998dc5a636207a1f5f9d8e081606b2d95177
/var/www/html/programaciondam2526/.git/objects/b9/8def76a80ab4511483c74be9ca0fe6a8acc1ab
/var/www/html/programaciondam2526/.git/objects/79/7ab8a457485348f1120abdcdd7bfa1dbc1adac
/var/www/html/programaciondam2526/.git/objects/79/f020098a8d2e83d2c703a583a25a8c64ca8a92
/var/www/html/programaciondam2526/.git/objects/79/e565f0633a497b885627c8423c89635407daad
/var/www/html/programaciondam2526/.git/objects/79/ae4940ab0b6ba539da0902706ae4a9b3b3af3f
/var/www/html/programaciondam2526/.git/objects/08/ed63d62e778cd7d89c4599572a83aef151fe14
/var/www/html/programaciondam2526/.git/objects/08/ede852c1b9d4f2a81cbf9a7dd468f12041635b
/var/www/html/programaciondam2526/.git/objects/31/47ce5cf2b32cf1066890c9347a496008f65961
/var/www/html/programaciondam2526/.git/objects/43/6cfa85b55cbcbfaa9a21bdf428ab54f881cc6c
/var/www/html/programaciondam2526/.git/objects/43/96b8aae598f50bd32c8965cff3ed08791b1b2b
/var/www/html/programaciondam2526/.git/objects/43/71fce4835eea777353a9e6e4c1f39f3d8b86bd
/var/www/html/programaciondam2526/.git/objects/bc/eba012c0fcbdfb16f636ef7f9b334a56fba468
/var/www/html/programaciondam2526/.git/objects/88/edea8228181a3b0410c88ce8141945a5e7734e
/var/www/html/programaciondam2526/.git/objects/88/71b65e63fe4be89ce8015614b45cded54178d3
/var/www/html/programaciondam2526/.git/objects/88/a1411c6141c445193c5ef5c7ccc2e035d7630a
/var/www/html/programaciondam2526/.git/objects/0a/ffbaa002e6b411f1cf13c7c7d3a100331dee29
/var/www/html/programaciondam2526/.git/objects/61/d2a4a6bb107f2c0b07ebfcb6002584385ccbee
/var/www/html/programaciondam2526/.git/objects/61/87e97e609415bd8780493befdaf4801adc293f
/var/www/html/programaciondam2526/.git/objects/d6/01a1f1b9a145311639d44fb006a8b5f2e904cd
/var/www/html/programaciondam2526/.git/objects/d6/43a463687b37f45ec01bdbdef7be87c2200ecd
/var/www/html/programaciondam2526/.git/objects/d6/0bd7855aaae5d240010156d868479a62a0f85b
/var/www/html/programaciondam2526/.git/objects/9a/b703bda9940db8a19c7e95423ea31541e10fea
/var/www/html/programaciondam2526/.git/objects/30/0439b9cb70bbeb13a01ca5dd608ff9165bc135
/var/www/html/programaciondam2526/.git/objects/30/25e30dea9fe5aea6ebf65ec384fa53a2a8d32d
/var/www/html/programaciondam2526/.git/objects/30/c426c9df54def4319b0f87bd13f76eb0972963
/var/www/html/programaciondam2526/.git/objects/30/a44bda449dbc9cf593ebf993f69c089553b0f4
/var/www/html/programaciondam2526/.git/objects/30/b93340deaf90970aa3799431160b7e18fb0459
/var/www/html/programaciondam2526/.git/objects/30/3bfe4e948e17e15cf28f458d821b0cf6548e72
/var/www/html/programaciondam2526/.git/objects/d5/e1bf0f3f4bf7bbba3874a3cb4cd18d4a7bcbdb
/var/www/html/programaciondam2526/.git/objects/d5/ad494001b8acc5d9c1561d24a092818355fc96
/var/www/html/programaciondam2526/.git/objects/d5/0880bba8203a309929fb2dc27991ab04be2d04
/var/www/html/programaciondam2526/.git/objects/d5/ed7bc232a31fa8dde8f8ce60bf00f864e43980
/var/www/html/programaciondam2526/.git/objects/b8/9bfbd239c90e59459d40f1881302d68cc2d496
/var/www/html/programaciondam2526/.git/objects/b8/11abc46553871553d1c308c4ab14910e1cc21d
/var/www/html/programaciondam2526/.git/objects/8d/19f776796d2fea36a3067f3c3cbd8980063cdb
/var/www/html/programaciondam2526/.git/objects/b7/0883045a00a6036c29a0562b93444df76806b4
/var/www/html/programaciondam2526/.git/objects/b7/ebd856517564baa47608a1c9b575fdfd155ae3
/var/www/html/programaciondam2526/.git/objects/b7/f11f34597aa0b0b13e97215d640449191cbc37
/var/www/html/programaciondam2526/.git/objects/b7/80a4df6297c90af5a1bf2614356dc4ca65e302
/var/www/html/programaciondam2526/.git/objects/83/d63bf32663fb7de6e014ae8de04cfd01cd4ee8
/var/www/html/programaciondam2526/.git/objects/bd/5d82786104fee2a3c4a488b57e8173eeddc3b5
/var/www/html/programaciondam2526/.git/objects/bd/15753a6d2e973c2c015c2556031ee8e746647e
/var/www/html/programaciondam2526/.git/objects/65/f9bf06eff504317a9c0ba578221d4b148024aa
/var/www/html/programaciondam2526/.git/objects/65/ae2c00fe81d673b8eac8f9fbee28a234bd7fd7
/var/www/html/programaciondam2526/.git/objects/65/34db183be09a6dbcd950358f6360da1098a38b
/var/www/html/programaciondam2526/.git/objects/65/c14fa15a377473e442d12eb3aabbb77bd06c82
/var/www/html/programaciondam2526/.git/objects/17/d101bfb07d0ef06e1d0f1d9cc1be0da02e59de
/var/www/html/programaciondam2526/.git/objects/17/c719591f89af9b903c4f11588efe015e5ae5fc
/var/www/html/programaciondam2526/.git/objects/17/66fe8ec6206b2928f26557eabaa6eac867aa90
/var/www/html/programaciondam2526/.git/objects/17/85496a3eb6e0e7ec8838886933edea83fed641
/var/www/html/programaciondam2526/.git/objects/29/a1578b6278d3678e7182eaad9332208fefd74d
/var/www/html/programaciondam2526/.git/objects/29/685712da8b4225a414a61145c4386a242a6dc8
/var/www/html/programaciondam2526/.git/objects/29/9c7cb53f89ecc4c97db6add5ab5aa99a44ab7c
/var/www/html/programaciondam2526/.git/objects/b3/c8abf391ae2d257e04b472189c1ecc03b10c1a
/var/www/html/programaciondam2526/.git/objects/e4/1e3f248d5cb7eebf1cb2e66dd6826350472b1f
/var/www/html/programaciondam2526/.git/objects/f3/b27c2e2768ee3d32863358f1a9afe143315645
/var/www/html/programaciondam2526/.git/objects/f3/4c46f042e834ec7c4cfdf70befbdb5711ec077
/var/www/html/programaciondam2526/.git/objects/8a/b6924f1f128b424f067f66539c3ca59780291e
/var/www/html/programaciondam2526/.git/objects/e3/0d8e21e41040a0b7209ee9c2bd18f39623e04f
/var/www/html/programaciondam2526/.git/objects/e3/a51edf5d66b5273d06dd21686610feafd0dc34
/var/www/html/programaciondam2526/.git/objects/e3/2e947037d6ba0fef39b54735a1e991ca8e76cd
/var/www/html/programaciondam2526/.git/objects/75/ab4babb0554d12361e5c89935ad21d91c63e35
/var/www/html/programaciondam2526/.git/objects/75/7f58361f110d526754fdc50ee81d1abfb06233
/var/www/html/programaciondam2526/.git/objects/75/8c358c9ab2fe036d16cc0126a016625e45ed50
/var/www/html/programaciondam2526/.git/objects/0d/95ebcef09b03a164adb0a5fe0dcbdc943c4249
/var/www/html/programaciondam2526/.git/objects/0d/3a61c1580e8b3b72d4f9c8677932fb8ced50f4
/var/www/html/programaciondam2526/.git/objects/f2/05eb323014470b8fd10179d816020f549c8d0c
/var/www/html/programaciondam2526/.git/objects/f2/b95612f43c365d03e3a3f7e10d27c08fad0814
/var/www/html/programaciondam2526/.git/objects/f2/4f78b1eeea7c0e7128effaea62b439292fe5e5
/var/www/html/programaciondam2526/.git/objects/f2/d44c4b75b45749ff626e07f52897504454e6c3
/var/www/html/programaciondam2526/.git/objects/f2/43c302d0d8cb3a930a77ae3a242062680fc097
/var/www/html/programaciondam2526/.git/objects/54/121e9f00c1baaa86cf982a7c0709669bc4a28f
/var/www/html/programaciondam2526/.git/objects/54/a4d05d0e13a1f68ed4cae7ebb6567ebe73eead
/var/www/html/programaciondam2526/.git/objects/54/210adb9999a3cd93adfb7d2b72381eb9acbb76
/var/www/html/programaciondam2526/.git/objects/48/61bc9e5d8114ee073487d9998e41f215ef64a0
/var/www/html/programaciondam2526/.git/objects/48/7dc094fa20193f5855d116c2f92b0ef4939a24
/var/www/html/programaciondam2526/.git/objects/48/e4f3c778ed93728a4fc9511f101f1452c99370
/var/www/html/programaciondam2526/.git/objects/48/757cdd567076e63fefe953f22aaefbb95f87b7
/var/www/html/programaciondam2526/.git/objects/48/a8ac132397574df217ac9a53d4f822543fc4fb
/var/www/html/programaciondam2526/.git/objects/48/4e6dae47121b946079644264fe6b06f2c29470
/var/www/html/programaciondam2526/.git/objects/d7/18f1f14426c720fce206b20343f1fd579289fb
/var/www/html/programaciondam2526/.git/objects/b2/c438705de0ec23072d79cddf64c154a7ca35c6
/var/www/html/programaciondam2526/.git/objects/b2/aa0aa7ff77c8cbd7107b01513bc57639b0c213
/var/www/html/programaciondam2526/.git/objects/ee/586e1c8a606cb746ac2c97023bdc4ab1ebdf90
/var/www/html/programaciondam2526/.git/objects/ee/b3d009efa72e7095f8e43012531010026a88e1
/var/www/html/programaciondam2526/.git/objects/ee/f19b14282f82323ab8f2f448e9e1ce85058703
/var/www/html/programaciondam2526/.git/objects/ee/dbf1122a917d00c765e47705b3a0da336adf38
/var/www/html/programaciondam2526/.git/objects/ee/b74d4fb999d934778b3442decd52f3f64db027
/var/www/html/programaciondam2526/.git/objects/38/3c40e6d68922508e3f1fa32bca6dbd1823c878
/var/www/html/programaciondam2526/.git/objects/38/b1f0a80f2f26c148b24fd0814cbae387a657c1
/var/www/html/programaciondam2526/.git/objects/38/476315d589175a8edcf80c1d9dc1068e461c3b
/var/www/html/programaciondam2526/.git/objects/38/c9f3b0b23a9d0f0be234a030efdd5941e3e50b
/var/www/html/programaciondam2526/.git/objects/38/66f3c163ad0dcf5bda280cd19b9372969267f7
/var/www/html/programaciondam2526/.git/objects/64/25868eef55de20bf6a70ca4e3b66fb7783a376
/var/www/html/programaciondam2526/.git/objects/64/c7ffe75cd4f5b772ef5d59362088792bb5e8c6
/var/www/html/programaciondam2526/.git/objects/64/a7e13ccada46e6e393a93c5c744e918110e6f2
/var/www/html/programaciondam2526/.git/objects/de/d4a26d20a4ec6b0faa541d0fcfd61326da552a
/var/www/html/programaciondam2526/.git/objects/0f/bfedfa8089a68f108dc244becff82c396dfa10
/var/www/html/programaciondam2526/.git/objects/0f/ef011b8ad3e482acb2223497191f40a15a5834
/var/www/html/programaciondam2526/.git/objects/0f/37587171eb870c1c570c61b79eeafa942900a8
/var/www/html/programaciondam2526/.git/objects/fd/5b47aa9eec6405cc7250f190012d161abb8c09
/var/www/html/programaciondam2526/.git/objects/fd/b31d1cf66bef7bb9f64ad5586f28e09ca53b2b
/var/www/html/programaciondam2526/.git/objects/09/dd7a1f6bb9a6c7c1455fc497014d6e3de10c66
/var/www/html/programaciondam2526/.git/objects/09/dc3405d4683b2f25a6ef5b9d9f1080d11ee046
/var/www/html/programaciondam2526/.git/objects/09/23169f80c4030115c1a66134148d919753f8e8
/var/www/html/programaciondam2526/.git/objects/dd/db6533d48388ee00649120900fea43abfab62a
/var/www/html/programaciondam2526/.git/objects/dd/a603b80bcc780cc251958afa54a8110ad33ba2
/var/www/html/programaciondam2526/.git/objects/dd/c45bc8b211fc933ab0202e7b9bc746d0eabfd8
/var/www/html/programaciondam2526/.git/objects/5a/dd0d1bb570dd98a714af4353225d33028a311b
/var/www/html/programaciondam2526/.git/objects/5a/8c31b35e88d0c21c3213cc12700e633acf537c
/var/www/html/programaciondam2526/.git/objects/03/45a2434702378e4c3d86fd48d8644cf884e450
/var/www/html/programaciondam2526/.git/objects/53/90895e7735c5e91b710d4cb80d7eeb970c10f4
/var/www/html/programaciondam2526/.git/objects/53/9e3dbf84340be05687442ce51b8fdc155f43ca
/var/www/html/programaciondam2526/.git/objects/02/3b5d66b0162d8b2947989553ee4a21f5b80013
/var/www/html/programaciondam2526/.git/objects/45/1cf007d89a562d828de1ab71c8b03e0c813d60
/var/www/html/programaciondam2526/.git/objects/45/64842856c63058029a4dcf99a465bc1acb83f3
/var/www/html/programaciondam2526/.git/objects/45/5c25527acb9a9129d8e0dc84e0d6e2ac54cdcf
/var/www/html/programaciondam2526/.git/objects/45/42ccba22ab6a6d73f51f2604e8c8aafbaccb62
/var/www/html/programaciondam2526/.git/objects/45/811145b200ab08508922335578e1664c850c61
/var/www/html/programaciondam2526/.git/objects/91/1433b44037404be4e3918fca0163a41070a4fe
/var/www/html/programaciondam2526/.git/objects/91/d209c7da06ab25f11320b800adb3b45cd0beb1
/var/www/html/programaciondam2526/.git/objects/87/0a6da161e2d598ac653ea20b8578f2f8597bc9
/var/www/html/programaciondam2526/.git/objects/fa/1f0f15658310877063d67c51bf4df6a22cbb57
/var/www/html/programaciondam2526/.git/objects/3c/1c39e49de27b86736f405c6957ee3dd9cfdd5e
/var/www/html/programaciondam2526/.git/objects/3c/28b8e295e08924aef8cbfd2b2b403a127991b8
/var/www/html/programaciondam2526/.git/objects/3c/ea5b84a2adeb13b77600766e763007e626a41b
/var/www/html/programaciondam2526/.git/objects/a2/c0faf57f1a8881a085aeabfc72c4f0047abc5b
/var/www/html/programaciondam2526/.git/objects/a2/e8365ce5788e3be23bf2164a7134721acc21e7
/var/www/html/programaciondam2526/.git/objects/a2/fe959017436ff0bc880f2c2706b626a5369b96
/var/www/html/programaciondam2526/.git/objects/a2/d9a3814c6c1b753047e4e68e341a31bcdcc069
/var/www/html/programaciondam2526/.git/objects/19/649f3d813c90c24986378e9fa9a9dad70190aa
/var/www/html/programaciondam2526/.git/objects/19/f647e31651e7848782356d76d21dc50713f952
/var/www/html/programaciondam2526/.git/objects/19/6dd1121301c24cbb4ed1484c3a276822f4d6d7
/var/www/html/programaciondam2526/.git/objects/19/b34366a32f3a69029e29af706748985e66a841
/var/www/html/programaciondam2526/.git/objects/19/d2d80b89ff5bbd35a8ea9a26f64d4da38ec9a2
/var/www/html/programaciondam2526/.git/objects/19/f4895aba14ca2c85ce7f1fcf7d3c1c60ba2659
/var/www/html/programaciondam2526/.git/objects/4a/e5181893d095ddf054be12e3f4311e9eb1f750
/var/www/html/programaciondam2526/.git/objects/4a/a2ea3d9cae831fb0084996cd8d8ebfb4803515
/var/www/html/programaciondam2526/.git/objects/4a/e2249b69cca655a575f79c7c1a3a458861d845
/var/www/html/programaciondam2526/.git/objects/41/addfa843c81549fd9ba6f04a0a2eaed3d8aa0e
/var/www/html/programaciondam2526/.git/objects/41/fa6282db7eebc94bfc9c5ecb72b2a3cd7a0c4e
/var/www/html/programaciondam2526/.git/objects/42/67b6071a276ca3cbf1c486bc20f0cae54445c5
/var/www/html/programaciondam2526/.git/objects/42/d0b0450e6a2406433751a72e1a9399464a36c0
/var/www/html/programaciondam2526/.git/objects/42/912ccde4361c76cead9a503e30bb9636a18a3e
/var/www/html/programaciondam2526/.git/objects/f8/ca83f62e7b5815ed67258cdced033c03a5fd76
/var/www/html/programaciondam2526/.git/objects/f8/2c5158df0aff9e5f200ddda23723e3ce9d59ec
/var/www/html/programaciondam2526/.git/objects/f8/ac85c9b203696e14cf7fa8044f0049e2f33b48
/var/www/html/programaciondam2526/.git/objects/8f/eaee63b3e7d712f3da62814f8702eb607fc83f
/var/www/html/programaciondam2526/.git/objects/8f/25fef1913937ec663903aa17334c2ece6eb74b
/var/www/html/programaciondam2526/.git/objects/04/2adb8e49490d2ee0ed622a92a469833804d9d0
/var/www/html/programaciondam2526/.git/objects/04/d87877b5a369c14bab8750b9a71e1658d01466
/var/www/html/programaciondam2526/.git/objects/da/d0077e9a4c18c78c03bde2ab8526a0b01f1d18
/var/www/html/programaciondam2526/.git/objects/da/9119fe169eefa2c1ec378b2e77a5854ec5464e
/var/www/html/programaciondam2526/.git/objects/95/8f2dcda50443fd718894b6bc7a0c650a2c8fcf
/var/www/html/programaciondam2526/.git/objects/95/661de9345c7b2e23f804f84ef86b4254abe69b
/var/www/html/programaciondam2526/.git/objects/95/8f25d38ebb09de20a632b257288d2c6092e46f
/var/www/html/programaciondam2526/.git/objects/7d/2339cc0f5c9cb7e1fa191b1b8d46a2915d03e3
/var/www/html/programaciondam2526/.git/objects/ca/41ad75a41a47bae52e702e14d8aaec2b41c264
/var/www/html/programaciondam2526/.git/objects/ca/e622c8ecd7f3787744bf6685897516001cb416
/var/www/html/programaciondam2526/.git/objects/ca/00f0137c95a4a857885b8a7644fa8264f45291
/var/www/html/programaciondam2526/.git/objects/ca/bf950be28f889d53b0d1d450c7228210cc8089
/var/www/html/programaciondam2526/.git/objects/pack/pack-274984f77d51a2155b5a472cdf2f0a7d4f2672d1.pack
/var/www/html/programaciondam2526/.git/objects/pack/pack-274984f77d51a2155b5a472cdf2f0a7d4f2672d1.rev
/var/www/html/programaciondam2526/.git/objects/pack/pack-274984f77d51a2155b5a472cdf2f0a7d4f2672d1.idx
/var/www/html/programaciondam2526/.git/objects/20/06f7f3cbdb7b2e0e66bbab41c179430b867660
/var/www/html/programaciondam2526/.git/objects/a8/984628a1371a04f3993cc3febeab1931aa93fd
/var/www/html/programaciondam2526/.git/objects/a8/6902b4389e367b226c7d8ccc291a9ba7ed7b7f
/var/www/html/programaciondam2526/.git/objects/a8/5e772e9fb84795507c4e1e86fdf925541438b8
/var/www/html/programaciondam2526/.git/objects/76/6b90626bd957ffdca005f7a4d51f3a19d17f71
/var/www/html/programaciondam2526/.git/objects/76/c45cf132d78cb3b65457ad4d287e85effa4e6f
/var/www/html/programaciondam2526/.git/objects/c3/278606b754157f866b523c2ffdddca73e9ff1f
/var/www/html/programaciondam2526/.git/objects/c3/f59da46e7aa0b9531c7f7db9fe76488817cef3
/var/www/html/programaciondam2526/.git/objects/c3/7e1b7d448aec128569d554ae62305b4129df58
/var/www/html/programaciondam2526/.git/objects/39/a6655ecb01d5b48994504ac6d26b0f5ab0a6d1
/var/www/html/programaciondam2526/.git/objects/11/93de59eca611f220e0ea53563e24271915f51c
/var/www/html/programaciondam2526/.git/objects/11/c89f8b7f0448b63b52ba5caebb2ce01717cb05
/var/www/html/programaciondam2526/.git/objects/11/865b58f8b856b89f289537a1eccbdd2e4fc2b9
/var/www/html/programaciondam2526/.git/objects/11/e1e6d05923a91d2a2bf7d3e0f415975e2cdc05
/var/www/html/programaciondam2526/.git/objects/ae/0f8672a305d2850d6a3d44f830495ec745c816
/var/www/html/programaciondam2526/.git/objects/84/5ee88aab2a531159401db8f81c8b7585fae3c3
/var/www/html/programaciondam2526/.git/objects/84/616cbe1c6e8d9d2efe5aee8ec5768fa5852cb1
/var/www/html/programaciondam2526/.git/objects/84/f1f73330bce92ffdf11ab71c4d0ed82a0e2e67
/var/www/html/programaciondam2526/.git/objects/a9/64cf0aec0248c781ef4509e64e685d0fb01033
/var/www/html/programaciondam2526/.git/objects/a9/36fb391c37ea2ae7ac32ef0155e121038995a5
/var/www/html/programaciondam2526/.git/objects/e0/11fb4b931079449782bb120dae83a577d01ddf
/var/www/html/programaciondam2526/.git/objects/e0/8ac68bab2a2ed0b116c5f1b113aa8d5ddf96b7
/var/www/html/programaciondam2526/.git/objects/e0/b4ebccd5984ddc56cce87aabc3db5fd2235726
/var/www/html/programaciondam2526/.git/objects/56/57237f217586911e5639f0ff1bfc6786ae33ea
/var/www/html/programaciondam2526/.git/objects/aa/c215911d3c157ae2cedba20c61ed9941b36f4b
/var/www/html/programaciondam2526/.git/objects/aa/7509de6fccd30c2cb814f9d7a27b48b4e13507
/var/www/html/programaciondam2526/.git/objects/d4/65b192c6bbe600e8ac788243e7b894f8b04965
/var/www/html/programaciondam2526/.git/objects/1a/3f694bc563d1e222d45a4ea2f3cfb71cbe327e
/var/www/html/programaciondam2526/.git/objects/1a/7b6fadb7293ce7043f007520448c9fa692a4d2
/var/www/html/programaciondam2526/.git/objects/b0/bdfe1951c22a441321fad68a2a0dc24a35afc6
/var/www/html/programaciondam2526/.git/objects/cf/a5a1790cefd824950d63229ac74b397fa6f0bf
/var/www/html/programaciondam2526/.git/objects/cf/da7b9f6f2a5d4ee6cd45ed6b03af77ea28881b
/var/www/html/programaciondam2526/.git/objects/cf/b36bc0c61ecf8b6415468e98780d5719656618
/var/www/html/programaciondam2526/.git/objects/8e/b40ccb87b839428f51e3de693b37dca7568b3e
/var/www/html/programaciondam2526/.git/objects/8e/ae24056c73515701dcdbb50bf85b3777e5df80
/var/www/html/programaciondam2526/.git/objects/e9/34027d11a4a5cab7b3863a269b12771fbc29bf
/var/www/html/programaciondam2526/.git/objects/e9/4aba73b09129093091a3f839569e47fe9eaeed
/var/www/html/programaciondam2526/.git/objects/e9/54a9453b1d6b24a681230202bdaa31e876082c
/var/www/html/programaciondam2526/.git/objects/18/ed742e6850c9434e9232f7f22844ecf4e91041
/var/www/html/programaciondam2526/.git/objects/4e/f1feb08c5bdb1ff45e674ceb5e8d470fd8ac1c
/var/www/html/programaciondam2526/.git/objects/4e/21e26411f7ef495a86d6c6de731f37bba36579
/var/www/html/programaciondam2526/.git/objects/4e/8fad9dfe00e8a3c2bbd4b6a7b065a5ba66d5e8
/var/www/html/programaciondam2526/.git/objects/4e/91c6ca49b51505a982a7b70d07ad1dad938e3c
/var/www/html/programaciondam2526/.git/objects/5c/e8caf6b8aa8f2e81611e2288a15fdd8dd02116
/var/www/html/programaciondam2526/.git/objects/5c/911630fd365075ac3d94247dc2efac66d3dc1e
/var/www/html/programaciondam2526/.git/objects/5c/2ef8a70d1e6d6a010e84fef13eac609744194a
/var/www/html/programaciondam2526/.git/objects/47/4347702b0844c2506efb2b0189fb92a500b04e
/var/www/html/programaciondam2526/.git/objects/34/71f70e0ba98befe5d918d28ac0293c8328d5f6
/var/www/html/programaciondam2526/.git/objects/34/ae0a783ab128b833d2c4749c3e3cff3eff92bb
/var/www/html/programaciondam2526/.git/objects/34/46fbac7db381bbc8c84d942d9bcbda2d17b07e
/var/www/html/programaciondam2526/.git/objects/3a/26c602b2cd9b1e0b7959d314f1ecb03e33b73d
/var/www/html/programaciondam2526/.git/objects/3a/ab3f79d1854a873991ab9030de0a2756459586
/var/www/html/programaciondam2526/.git/objects/3a/7a7218cf3046821f0ad83a427c106b600cb312
/var/www/html/programaciondam2526/.git/objects/c7/eef26d3654cf73d4e9ffaf5501025320045403
/var/www/html/programaciondam2526/.git/objects/c7/bd05fbb730a2eed69c2c8687f1bfb288c32057
/var/www/html/programaciondam2526/.git/objects/93/b4ccbf25bed23eb63f7a6be144c2f6ff444f7e
/var/www/html/programaciondam2526/.git/objects/93/2236b2eb4e2d6b725dee7a8f39e5d22854dbd0
/var/www/html/programaciondam2526/.git/objects/93/837d67872df816883a4cd32c30fc3c8797fd41
/var/www/html/programaciondam2526/.git/objects/93/aab3fe5b6bf41ee3711e65c3ff19a7c396ea1a
/var/www/html/programaciondam2526/.git/objects/93/f6f1498ad5d505eb80d3be4362ed2812c44351
/var/www/html/programaciondam2526/.git/objects/74/fa52b3974157b3870071f44e1438c823dbe744
/var/www/html/programaciondam2526/.git/objects/74/8af43b1d31768abcccb9205696b2043e5acadb
/var/www/html/programaciondam2526/.git/objects/66/4212ba14894242e9e9911f5f70a79a7b7033b8
/var/www/html/programaciondam2526/.git/objects/66/664024f3686b6597d3cfc8edb015a8ca1358b9
/var/www/html/programaciondam2526/.git/objects/5d/6c05b55824d8b6476c82d806a72d039e483fc3
/var/www/html/programaciondam2526/.git/objects/5d/6e30c668c8065c12453a572a48b93b0bd24ff6
/var/www/html/programaciondam2526/.git/objects/3d/f355713fce1ea9794a28ab51edefc1874f5a5d
/var/www/html/programaciondam2526/.git/objects/3d/2df20637468c43046735cc8ac565e5a53c3e44
/var/www/html/programaciondam2526/.git/objects/3d/8636c09d959fc4808569b03932a939b414498b
/var/www/html/programaciondam2526/.git/objects/36/6107c19814005755ba2855e7dc017a2798d33a
/var/www/html/programaciondam2526/.git/objects/36/4cb80082e3ef71a0ce8921f2914adb19d33258
/var/www/html/programaciondam2526/.git/objects/a7/c97167f36129cbc929189dd3dc45ee5a5e11b9
/var/www/html/programaciondam2526/.git/objects/2e/91f09ea85141190b201b364f755c070f00ac09
/var/www/html/programaciondam2526/.git/objects/1c/fb926de4ae307fe44fdf9cc9d77f14d692400a
/var/www/html/programaciondam2526/.git/objects/1c/e9f1acf5264d23b17e325f941679970289bb84
/var/www/html/programaciondam2526/.git/objects/80/e600e42241c16f74375a01aa40870dff18b396
/var/www/html/programaciondam2526/.git/objects/80/96e341d04b03483bc4fac02f36a75b0ec26e9d
/var/www/html/programaciondam2526/.git/objects/80/c89d3f6b6e374765c44f88dde057062b6ffa80
/var/www/html/programaciondam2526/.git/objects/80/ed99cc363c64540600632ce7dd8fb29c58fb44
/var/www/html/programaciondam2526/.git/objects/80/d6d325d69cf37dc629a229f28e6b3b8845b085
/var/www/html/programaciondam2526/.git/objects/85/e54c434ffcaee73b8659b02e52e227fd08911d
/var/www/html/programaciondam2526/.git/objects/85/e9f58fb67c8d72ab69a8129a298be1b4ff43db
/var/www/html/programaciondam2526/.git/objects/85/61ed7711223538dc8cc5425e9c5f4d1d875a21
/var/www/html/programaciondam2526/.git/objects/d3/03e2a574601db9fda6d8b068878126e69fa183
/var/www/html/programaciondam2526/.git/objects/d3/23e667070aff6f4561bf51066bf36c4c33c075
/var/www/html/programaciondam2526/.git/objects/4d/4d7102b88d10a9d57b68e31a40c2ffd0786506
/var/www/html/programaciondam2526/.git/objects/4d/84c60c2e1868c84288c0ae90859ea56784c346
/var/www/html/programaciondam2526/.git/objects/4d/7f237c9f731988bfed94141b9ecd02bcb443f2
/var/www/html/programaciondam2526/.git/objects/49/fd59645f3120ffdaf29c0f6b4a20d790281379
/var/www/html/programaciondam2526/.git/objects/df/535878552e9ee5d311272801d4198df077d28d
/var/www/html/programaciondam2526/.git/objects/df/8e78cd8b7bb5de55ec2f7cf27999263f7d8577
/var/www/html/programaciondam2526/.git/objects/df/183998b16b5c1641d9c4017a9a648fdd1e3606
/var/www/html/programaciondam2526/.git/objects/eb/4db2ba9ffefd6c0f5c124bc8e1a746357ca7ba
/var/www/html/programaciondam2526/.git/objects/eb/ea7c97d421ef5c78115aaa800e6254cf2e2914
/var/www/html/programaciondam2526/.git/objects/72/5d2eb6f538494e99b1f15e32bc82e908371ade
/var/www/html/programaciondam2526/.git/objects/72/c8bc998da5f70188fb0773fb74b80f890339a6
/var/www/html/programaciondam2526/.git/objects/72/d4d0634ccff3a9f89960940972841bf055e897
/var/www/html/programaciondam2526/.git/objects/72/0fca0a228ae43396bc84b734e16b1346128735
/var/www/html/programaciondam2526/.git/objects/72/c44ad8272610141e3226ce7975679e13758be6
/var/www/html/programaciondam2526/.git/objects/40/5a8c4a9fc6c2a6d7b4d96fad38017eef392b6f
/var/www/html/programaciondam2526/.git/objects/7e/e49fe0c83d13ff9ccc7e8900de04978e9fc3a5
/var/www/html/programaciondam2526/.git/objects/7e/f8bd44a7295d5b7e613a0da2f3e9bedcc9805a
/var/www/html/programaciondam2526/.git/objects/7e/b025c954bc5efd7094962912504ceb45041941
/var/www/html/programaciondam2526/.git/objects/7e/fc1950b9fa671d7fb759f8de81051bba5b2e0a
/var/www/html/programaciondam2526/.git/objects/f4/1e9fac32111f87f8db69b4cfcd30187d27b6fb
/var/www/html/programaciondam2526/.git/objects/f4/32a2f3f8bb30519bb88a97e4a396e48d5a2361
/var/www/html/programaciondam2526/.git/objects/ac/40adeb97a623de893d526c02f46633500fe7e4
/var/www/html/programaciondam2526/.git/objects/ac/324352877661b373286b5414771ddbb72eb0cf
/var/www/html/programaciondam2526/.git/objects/a1/0d9fd18745396681629ce671aafb9b61ff5cce
/var/www/html/programaciondam2526/.git/objects/a1/874b78f3b8e39ed1c40fdda74cf084d3fdb282
/var/www/html/programaciondam2526/.git/objects/a1/10729e95a38395be50e62dc5b3199c39e3b31f
/var/www/html/programaciondam2526/.git/objects/0b/31e8e817bc876a9a5dbfe3adcbbe0d915f1429
/var/www/html/programaciondam2526/.git/objects/0b/bf1108e40dc291f220a7dbe2d16daf4f637a34
/var/www/html/programaciondam2526/.git/objects/0b/222552dcbfd15e3d4c14de6eca455df62d483c
/var/www/html/programaciondam2526/.git/objects/0b/9e4be95b506747c5726d055434a016b049343a
/var/www/html/programaciondam2526/.git/objects/0b/4d8c765b3961099c08e67274a32ef49103d65b
/var/www/html/programaciondam2526/.git/objects/21/55b4e8139bfc9c1ca8c0d35204ffd686e3255b
/var/www/html/programaciondam2526/.git/objects/e6/8862b85ce720c5c95acb405e545df6609faee2
/var/www/html/programaciondam2526/.git/objects/e6/9de29bb2d1d6434b8b29ae775ad8c2e48c5391
/var/www/html/programaciondam2526/.git/objects/e6/cefe17783008e3f95b763075921c95f095857e
/var/www/html/programaciondam2526/.git/objects/90/707d89828377bb44d7a72179b382239e1f4b71
/var/www/html/programaciondam2526/.git/objects/90/016c516562f56ea0d2f3c302bc47bc629a1b98
/var/www/html/programaciondam2526/.git/objects/90/e1925cd94673f113b823ed3581ce7def8e71c2
/var/www/html/programaciondam2526/.git/objects/6a/35b21a26d65989430a4eb1444a058e6e45bcee
/var/www/html/programaciondam2526/.git/objects/6a/8c0d53c9c967e1911bbed3cb4d5e8ddddd7b03
/var/www/html/programaciondam2526/.git/objects/6a/6b379624f1e10ba1a05783a5fa1700b16c7aec
/var/www/html/programaciondam2526/.git/objects/6a/0531878bf41b82ad3f500834edb253694eddaa
/var/www/html/programaciondam2526/.git/objects/78/d012c400d22a060a7c543fffc0f803c6623bc7
/var/www/html/programaciondam2526/.git/objects/78/530ccb582e365b32e0ef7356e109f4ee4a4bb7
/var/www/html/programaciondam2526/.git/objects/78/b152192e8bd024bafe324dae387eddb12cc315
/var/www/html/programaciondam2526/.git/objects/78/0380ee37c0651516c047425e0cecfec438a67e
/var/www/html/programaciondam2526/.git/objects/2a/77b7a25582f51afa42e6846430d794d31be7c8
/var/www/html/programaciondam2526/.git/objects/2a/bbf60f8cbcd1476b07768519b946a0e671cb48
/var/www/html/programaciondam2526/.git/objects/1f/89f43ed38769305dbd469aa340df75ff036a59
/var/www/html/programaciondam2526/.git/objects/1f/47ec295d246ce70768d40562f9dff1d4565a94
/var/www/html/programaciondam2526/.git/objects/1f/9065fd4ed5c1ed909c199294a5cbc144da1d06
/var/www/html/programaciondam2526/.git/objects/cd/42b4aa30fe8c8be5c789d9a1bc6c103437c4ba
/var/www/html/programaciondam2526/.git/objects/cd/6afacd3fbfe2ad2d47b13facb690d581c8eca4
/var/www/html/programaciondam2526/.git/objects/cd/6f5cb19c48eb0f80215f0b32f7e6f787eb74eb
/var/www/html/programaciondam2526/.git/objects/cd/9878d367f9199924b786346f1dea665f5acfeb
/var/www/html/programaciondam2526/.git/objects/1b/fbcff9718fec10bbd77a1c8ac9a269703b23f7
/var/www/html/programaciondam2526/.git/objects/1b/b9bce5cba16d293e2d5f9f11c688dddd4ae5d1
/var/www/html/programaciondam2526/.git/objects/2c/ba11b9ad8318c18246f417869d80cba58ea8a0
/var/www/html/programaciondam2526/.git/objects/2c/94213a76ada8196c6d506bd41f2294f0c9ae21
/var/www/html/programaciondam2526/.git/objects/9f/497ff1a228af84ef0f344a06d64ae1c73e2af6
/var/www/html/programaciondam2526/.git/objects/4b/b9582462dfc8f48e139f3e0154d0307ae22b70
/var/www/html/programaciondam2526/.git/objects/4b/bf591ce5f74ad6b72e7a5dec8aee988f35d98a
/var/www/html/programaciondam2526/.git/objects/6d/3ae8c2203ac2533ff29579d80ec4b26e96cc57
/var/www/html/programaciondam2526/.git/objects/6d/fb9f8855b35780af47a9b8df1c49a83d7cbc94
/var/www/html/programaciondam2526/.git/objects/6d/99820d963b0683dd1752c573f8d78782d8a94c
/var/www/html/programaciondam2526/.git/objects/6d/32a0588af2865c65ed6fe7c16127c6477a5643
/var/www/html/programaciondam2526/.git/objects/6d/de0147c7bf84e8de128db0831c7ce1f72773fe
/var/www/html/programaciondam2526/.git/objects/6c/954738f9de62b3586d40d7090d41c630dfa130
/var/www/html/programaciondam2526/.git/objects/3b/a4b9941bf04782455c228806635ff80c34f338
/var/www/html/programaciondam2526/.git/objects/67/0f38882dd35b114ec471d7ad10b0364a129d10
/var/www/html/programaciondam2526/.git/objects/67/14f44be8ed4b3ca2a7032b40b61afa74dddf14
/var/www/html/programaciondam2526/.git/objects/99/b71a74eea80c10a1e38b5a70178bdf3668f47e
/var/www/html/programaciondam2526/.git/objects/b4/4659e7bf116ee9013e45e9d5bb0dd53519e083
/var/www/html/programaciondam2526/.git/objects/b4/75d8ab7a2b1a0afd6d32c0d70f8ba3c0f8f99c
/var/www/html/programaciondam2526/.git/objects/b4/aad9a2942c418a0d6b3732ec83ea8d192756b9
/var/www/html/programaciondam2526/.git/objects/b4/62811b64a6b5fc241a1c59b3e6bed605098369
/var/www/html/programaciondam2526/.git/objects/4f/2a40c155fb2f95280abd631514830adea48234
/var/www/html/programaciondam2526/.git/objects/4f/9eccda329ef34d740335297c1beaf6261033b3
/var/www/html/programaciondam2526/.git/objects/4f/fa1b8db91ffa778d00535186747f96a9bf0033
/var/www/html/programaciondam2526/.git/objects/4f/fb90d77ab36fa203c99948b2f6fb8bc1bdffd9
/var/www/html/programaciondam2526/.git/objects/9c/03faaec8603f15cf39bd41fed6925c6e92dd8f
/var/www/html/programaciondam2526/.git/objects/1d/32f884cb2a31c0349bc01c007a77ca7b81cec9
/var/www/html/programaciondam2526/.git/objects/1d/967a21cfb096efa55a5af0ce07fd259b06e2bf
/var/www/html/programaciondam2526/.git/objects/d9/9986ccd3a47d1f5161cf7e8b697c1779c51a27
/var/www/html/programaciondam2526/.git/objects/05/aeec3ab353f4eb03a5a56529de56dfbb76c5c2
/var/www/html/programaciondam2526/.git/objects/05/98482b5d7f7fbfc82be933a89a91f4ff54bf23
/var/www/html/programaciondam2526/.git/objects/a0/91920f36f44374e27b0bce746f06689d7330eb
/var/www/html/programaciondam2526/.git/objects/a0/1bf65041c6c7e836e7b9ac8204c2d2512c478b
/var/www/html/programaciondam2526/.git/objects/a0/08ed62ad907114545dbfa0f42ea4b242973439
/var/www/html/programaciondam2526/.git/objects/a0/38ef3d428ba12d2c127490778bd9e4d8c62111
/var/www/html/programaciondam2526/.git/objects/b6/32d6d63a7c28a36a0be20010dfeceb2dd69959
/var/www/html/programaciondam2526/.git/objects/b6/cd4f6dfe2c6320cfefa2c822da09cc571ccb84
/var/www/html/programaciondam2526/.git/objects/f7/950b20a8bbc6527da9ae334517d33d4a453b24
/var/www/html/programaciondam2526/.git/objects/f7/528954ebc5dd9935879678dac65075e0d6ce60
/var/www/html/programaciondam2526/.git/objects/59/591f196b5bf70fc481e0495ac4cbdd183a50d6
/var/www/html/programaciondam2526/.git/objects/16/fce7e8c6f8ab53454ea4c9499f60e323dd28e2
/var/www/html/programaciondam2526/.git/objects/16/fa975cf94f941adf3d6571674d1dd3f1b256d0
/var/www/html/programaciondam2526/.git/objects/16/88fdc1ade53efda3503d75e8a750036f0786a7
/var/www/html/programaciondam2526/.git/objects/f0/9109b152c5d4ded93cb6cbfdaf31f209dc3ece
/var/www/html/programaciondam2526/.git/objects/f0/bee249fbace146d6942c111bbb9c74244e48e1
/var/www/html/programaciondam2526/.git/objects/bb/95a2d5d47d53e505807f725e089bdfac61df4c
/var/www/html/programaciondam2526/.git/objects/bb/4fc873d383343ff5e9369fc275b5c4877debcd
/var/www/html/programaciondam2526/.git/objects/3e/927bc386e357f8bcdc7ac59a6a49ced3e86ff7
/var/www/html/programaciondam2526/.git/objects/a5/a572dcb7e92013e90ee45d606cda6ecbb08271
/var/www/html/programaciondam2526/.git/objects/a5/e5b1d0e7229dfcb4ab37547ee48bc5ab1db161
/var/www/html/programaciondam2526/.git/objects/ed/575cf51df13927d5c639f8a0db22e9c1dae249
/var/www/html/programaciondam2526/.git/objects/ed/47eabd58ee303b2de149af3a43221a45344189
/var/www/html/programaciondam2526/.git/objects/33/4a3749a21b0b275065b5c294694aa350dfaddc
/var/www/html/programaciondam2526/.git/objects/01/ab91d9431c26600a11fc884491cd5e8261b974
/var/www/html/programaciondam2526/.git/objects/01/263a32d6a0b036a20981722a8337a0958c0166
/var/www/html/programaciondam2526/.git/objects/01/cee4624fc858d953eb6813d320b4dbe111b83b
/var/www/html/programaciondam2526/.git/objects/15/c7e3ecb73644c0f0376c66dc22405801a1e8fb
/var/www/html/programaciondam2526/.git/objects/15/c2e78c842e18ae6145bbd9f8346448f83ca8c7
/var/www/html/programaciondam2526/.git/objects/a3/7cd5baf4e52ee7866793b749687de15fb201be
/var/www/html/programaciondam2526/.git/objects/a3/8b7bc8e62766e92b40bebd0a172e5479a82daa
/var/www/html/programaciondam2526/.git/objects/a3/6ce66a05b908eeac1e87efcbe10b2c9d2cfd1a
/var/www/html/programaciondam2526/.git/objects/a3/b76e9beb9ce8703c6bb14ca55ff13298428b71
/var/www/html/programaciondam2526/.git/objects/22/3cf7f788066c4cefc32900b7dfd81d3c0ae995
/var/www/html/programaciondam2526/.git/objects/22/c05a3e0d6847ee951607b74af8fee47e6484e3
/var/www/html/programaciondam2526/.git/objects/00/b82a4d9be2b7d1bc53ec3bde32564f94de2716
/var/www/html/programaciondam2526/.git/objects/00/09eb8e24b8c2a5e6cc31a2d457418768c259c3
/var/www/html/programaciondam2526/.git/objects/35/ef16e53cf9271728cb7c5aeee4e1ae52de23bc
/var/www/html/programaciondam2526/.git/objects/35/ff20ffb4b31956f37d84ecca0f316381df60c8
/var/www/html/programaciondam2526/.git/objects/35/72fcfa0987e62fc686369881b360eb3684cd13
/var/www/html/programaciondam2526/.git/objects/35/89b539be622cbec73c6f2b67ad44a641c31be9
/var/www/html/programaciondam2526/.git/objects/35/3c980f9c3a2dfb41aa4c5aa2e565f86cfc9674
/var/www/html/programaciondam2526/.git/objects/35/3ef4d637cdaf3d79ed6ca46dff94bc77948c32
/var/www/html/programaciondam2526/.git/objects/c4/63ac01f88c426c9b8a6358e3f544d8c9b4aa05
/var/www/html/programaciondam2526/.git/objects/c4/f998db87069ad7254e847b4de43d8767a44562
/var/www/html/programaciondam2526/.git/objects/8c/213beea9fcd2db5852c0e4e8042d6dac73ee7e
/var/www/html/programaciondam2526/.git/objects/8c/a179d03587fe7bf2fa88bd5cd7674dfe1ae505
/var/www/html/programaciondam2526/.git/objects/8c/08fd3fd22988a528736002c665ff5487ee06bd
/var/www/html/programaciondam2526/.git/objects/8c/93691c900703cc65474b13925f32227d4c5d86
/var/www/html/programaciondam2526/.git/objects/c5/1dfbba3e5b81f72f867bb73bf2e9c4bc20e2d4
/var/www/html/programaciondam2526/.git/objects/06/e318d6b95f4853ebb453b94883cdf0632bc4c8
/var/www/html/programaciondam2526/.git/objects/06/c38788a579dfab048f05cd5be8cecbd8b5dd55
/var/www/html/programaciondam2526/.git/objects/06/8b53d8907c84b69822dd7acc8cc1e273369627
/var/www/html/programaciondam2526/.git/objects/06/28ff28ab9db1f8546eabb07ee1abb39466b3cc
/var/www/html/programaciondam2526/.git/objects/06/c07641ea823c49f5c682bd459cfc47b8996478
/var/www/html/programaciondam2526/.git/objects/06/c14926f200046123f1e4705bac90dc42740ad0
/var/www/html/programaciondam2526/.git/objects/c6/f2f65f262a816d96a5cb9a43d49378007f5d29
/var/www/html/programaciondam2526/.git/objects/81/918983325fcb1c564317cdfb4b8d9f23f04a3d
/var/www/html/programaciondam2526/.git/objects/1e/2a26d03b4ed038bc13e6c81fa8f60523bd009a
/var/www/html/programaciondam2526/.git/objects/1e/9bcaccb1a229c4ad6ab1121c2f524f104c9061
/var/www/html/programaciondam2526/.git/objects/1e/a1ab440e37f6c8b1ecc77737fccb558b9658d5
/var/www/html/programaciondam2526/.git/objects/28/5c129d063e85161e4531e49f320b43ab6fe6b6
/var/www/html/programaciondam2526/.git/objects/98/ecad0c56dff76910df0cc419c2c04c469690bf
/var/www/html/programaciondam2526/.git/objects/98/9021af1f8b15eba2519f0f53b215717b7258fd
/var/www/html/programaciondam2526/.git/objects/98/820ff75f7bfebf38e275406d9bac383f99acc2
/var/www/html/programaciondam2526/.git/objects/94/592749d1559c737355671491f7c88e4402a7c7
/var/www/html/programaciondam2526/.git/objects/94/628a2c12b1385d532641a19c6a4524d0c4e97a
/var/www/html/programaciondam2526/.git/objects/94/0ea58206eac9949370a6e1930adc7804dde5c0
/var/www/html/programaciondam2526/.git/objects/dc/e01cafc1a0ca5e6978c33c472149d859c0ad2d
/var/www/html/programaciondam2526/.git/objects/dc/ed79b1036447f1134da02aa4f8470ce9d29fbb
/var/www/html/programaciondam2526/.git/objects/24/daa5e42a71dac677d129760ddd9a7d9ad86be1
/var/www/html/programaciondam2526/.git/objects/24/4722a391c90125138c368a346aca61d16a914b
/var/www/html/programaciondam2526/.git/objects/24/646bde2f2a1d6e7fc0d235eab63ec67ee84efd
/var/www/html/programaciondam2526/.git/objects/71/40b2c88bc4154d15a8206e77e3edbd05a11f23
/var/www/html/programaciondam2526/.git/objects/71/0da1c1b0b69b99d3e83ae8185f882065efe147
/var/www/html/programaciondam2526/.git/objects/71/b0f0d2e2ed296373ef4913245264166c315908
/var/www/html/programaciondam2526/.git/objects/71/1c612351f684319938a7defcd8bc9e759c6aa7
/var/www/html/programaciondam2526/.git/objects/d1/fb293177557efd4f184cc9e192d8d4a107f0b1
/var/www/html/programaciondam2526/.git/objects/ea/08b34a406084b4f8dec53b0e652f5497bc7efe
/var/www/html/programaciondam2526/.git/objects/ea/873af148a57070133c6adba44c68273251e884
/var/www/html/programaciondam2526/.git/objects/ea/69c333990b764ca3c8a7248aa5c5282901e961
/var/www/html/programaciondam2526/.git/objects/ea/4c93b75a2902348586117cf018bba45b0b24f6
/var/www/html/programaciondam2526/.git/objects/a4/564eb5e18c8a5cb39be7c71b587ba6e18e1658
/var/www/html/programaciondam2526/.git/objects/a4/80b034a94363c30818cd58abd8b4455c3c6e39
/var/www/html/programaciondam2526/.git/objects/f6/c4c11a40492d6f5ccd0849d7709b833069604e
/var/www/html/programaciondam2526/.git/objects/51/e5f2a362d55d1b2192f5b40109c245987c3be9
/var/www/html/programaciondam2526/.git/objects/07/134b3002e83bb74e4d9297557d2803b05812a6
/var/www/html/programaciondam2526/.git/objects/07/11ee84cdb6be8fdc9ba21cb04704165a93c18c
/var/www/html/programaciondam2526/.git/objects/fc/8136c096643e4b00a58f60cbe9f9b02ae8fd85
/var/www/html/programaciondam2526/.git/objects/fc/09d14f0b2c28b38f9f8c5ccae692d3caba49cf
/var/www/html/programaciondam2526/.git/objects/fc/638d241c38ff6a1e5c4c9dcc1f0699adbd000b
/var/www/html/programaciondam2526/.git/objects/14/dab71047cda4716fcb69238e28d354cf67cc7a
/var/www/html/programaciondam2526/.git/objects/14/678b51cfaf8482c8be5a3c28062fdc823ec1fa
/var/www/html/programaciondam2526/.git/objects/14/bf2abdd399420218e109cb781e78b2e01e7558
/var/www/html/programaciondam2526/004-Desarrollo de clases/000-Resumen.md
/var/www/html/programaciondam2526/004-Desarrollo de clases/Criterios de evaluacion.md
/var/www/html/programaciondam2526/004-Desarrollo de clases/005-Creación de constructores/101-Ejercicios/001-repaso gato.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/005-Creación de constructores/101-Ejercicios/003-constructor con parametros.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/005-Creación de constructores/101-Ejercicios/006-ejemplo con cliente.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/005-Creación de constructores/101-Ejercicios/002-a un construtor se le pueden pasar parametros.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/005-Creación de constructores/101-Ejercicios/004-mas parametros.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/005-Creación de constructores/101-Ejercicios/005-tercera propiedad.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/005-Creación de constructores/101-Ejercicios/007-listado de clientes.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/005-Creación de constructores/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/004-Desarrollo de clases/005-Creación de constructores/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/004-Desarrollo de clases/004-Creación de métodos/101-Ejercicios/010-ejemplo practico.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/004-Creación de métodos/101-Ejercicios/013-creo una lista de clientes.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/004-Creación de métodos/101-Ejercicios/011-creo setters y getters.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/004-Creación de métodos/101-Ejercicios/009-variable global.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/004-Creación de métodos/101-Ejercicios/004-defino propiedad privada.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/004-Creación de métodos/101-Ejercicios/005-Clase cuenta bancaria.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/004-Creación de métodos/101-Ejercicios/008-validacion.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/004-Creación de métodos/101-Ejercicios/012-pequeño programa.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/004-Creación de métodos/101-Ejercicios/010-creo setters y getters.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/004-Creación de métodos/101-Ejercicios/002-metodo set.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/004-Creación de métodos/101-Ejercicios/007-get saldo.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/004-Creación de métodos/101-Ejercicios/014-getters.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/004-Creación de métodos/101-Ejercicios/003-metodo getter.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/004-Creación de métodos/101-Ejercicios/006-convertir en privadas.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/004-Creación de métodos/101-Ejercicios/001-repaso de los metodos.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/004-Creación de métodos/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/004-Desarrollo de clases/004-Creación de métodos/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/004-Desarrollo de clases/007-Utilización de clases heredadas/101-Ejercicios/002-clase madre animal.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/007-Utilización de clases heredadas/101-Ejercicios/004-herencia o multinivel.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/007-Utilización de clases heredadas/101-Ejercicios/003-clase Roca.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/007-Utilización de clases heredadas/101-Ejercicios/001-gatos y perros.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/007-Utilización de clases heredadas/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/004-Desarrollo de clases/007-Utilización de clases heredadas/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/004-Desarrollo de clases/003-Creación de propiedades/101-Ejercicios/002-las propiedades pueden ser arrays.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/003-Creación de propiedades/101-Ejercicios/011-le mostramos al usuario las opciones que tiene.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/003-Creación de propiedades/101-Ejercicios/004-leemos propiedad.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/003-Creación de propiedades/101-Ejercicios/013-estructura if.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/003-Creación de propiedades/101-Ejercicios/014-bucle infinito.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/003-Creación de propiedades/101-Ejercicios/003-escribir las propiedades de una clase.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/003-Creación de propiedades/101-Ejercicios/012-tomamos la entrada de usuario.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/003-Creación de propiedades/101-Ejercicios/001-Repaso de propiedades.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/003-Creación de propiedades/101-Ejercicios/006-aplicacion de productos.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/003-Creación de propiedades/101-Ejercicios/007-funciones y clases.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/003-Creación de propiedades/101-Ejercicios/009-pseudocodigo.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/003-Creación de propiedades/101-Ejercicios/008-creamos las variables globales.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/003-Creación de propiedades/101-Ejercicios/010-voy creando el codigo.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/003-Creación de propiedades/101-Ejercicios/005-los telefonos deben ser una lista.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/003-Creación de propiedades/101-Ejercicios/015-desarrollo la insercion de producto.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/003-Creación de propiedades/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/004-Desarrollo de clases/003-Creación de propiedades/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/004-Desarrollo de clases/006-Utilización de clases y objetos/101-Ejercicios/002-redondeos alza y baja.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/006-Utilización de clases y objetos/101-Ejercicios/001-Mi propia clase.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/006-Utilización de clases y objetos/101-Ejercicios/003-ahora uso la libreria estandar.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/006-Utilización de clases y objetos/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/004-Desarrollo de clases/006-Utilización de clases y objetos/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/004-Desarrollo de clases/002-Estructura y miembros de una clase. Visibilidad/101-Ejercicios/004-le preguntamos al usuario.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/002-Estructura y miembros de una clase. Visibilidad/101-Ejercicios/008-clase cliente.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/002-Estructura y miembros de una clase. Visibilidad/101-Ejercicios/001-listas.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/002-Estructura y miembros de una clase. Visibilidad/101-Ejercicios/006-crud.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/002-Estructura y miembros de una clase. Visibilidad/101-Ejercicios/005-leemos los datos del cliente.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/002-Estructura y miembros de una clase. Visibilidad/101-Ejercicios/007-crud insertar y listar.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/002-Estructura y miembros de una clase. Visibilidad/101-Ejercicios/003-clase cliente.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/002-Estructura y miembros de una clase. Visibilidad/101-Ejercicios/002-operaciones con listas.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/002-Estructura y miembros de una clase. Visibilidad/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/004-Desarrollo de clases/002-Estructura y miembros de una clase. Visibilidad/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/004-Desarrollo de clases/001-Concepto de clase/101-Ejercicios/001-Introduccion.md
/var/www/html/programaciondam2526/004-Desarrollo de clases/001-Concepto de clase/101-Ejercicios/007-propiedades.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/001-Concepto de clase/101-Ejercicios/004-ahora quiero crear otro gato.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/001-Concepto de clase/101-Ejercicios/011-Paradigmas en programacion.md
/var/www/html/programaciondam2526/004-Desarrollo de clases/001-Concepto de clase/101-Ejercicios/009-objeto cliente.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/001-Concepto de clase/101-Ejercicios/008-introduccion a los metodos.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/001-Concepto de clase/101-Ejercicios/002-clase gato.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/001-Concepto de clase/101-Ejercicios/003-instanciamos un gato.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/001-Concepto de clase/101-Ejercicios/005-Elementos principales de las clases.md
/var/www/html/programaciondam2526/004-Desarrollo de clases/001-Concepto de clase/101-Ejercicios/010-clase cliente.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/001-Concepto de clase/101-Ejercicios/006-propiedades y metodos.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/001-Concepto de clase/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/004-Desarrollo de clases/001-Concepto de clase/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/008-Mantenimiento de la persistencia de los objetos/000-Resumen.md
/var/www/html/programaciondam2526/008-Mantenimiento de la persistencia de los objetos/Criterios de evaluacion.md
/var/www/html/programaciondam2526/008-Mantenimiento de la persistencia de los objetos/009-Tipos de datos colección/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/008-Mantenimiento de la persistencia de los objetos/009-Tipos de datos colección/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/008-Mantenimiento de la persistencia de los objetos/004-Creación de bases de datos/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/008-Mantenimiento de la persistencia de los objetos/004-Creación de bases de datos/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/008-Mantenimiento de la persistencia de los objetos/001-Bases de datos orientadas a objetos/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/008-Mantenimiento de la persistencia de los objetos/001-Bases de datos orientadas a objetos/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/008-Mantenimiento de la persistencia de los objetos/007-Recuperación, modificación y borrado de información/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/008-Mantenimiento de la persistencia de los objetos/007-Recuperación, modificación y borrado de información/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/008-Mantenimiento de la persistencia de los objetos/008-Tipos de datos objeto; atributos y métodos/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/008-Mantenimiento de la persistencia de los objetos/008-Tipos de datos objeto; atributos y métodos/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/008-Mantenimiento de la persistencia de los objetos/002-Características de las bases de datos orientadas a objetos/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/008-Mantenimiento de la persistencia de los objetos/002-Características de las bases de datos orientadas a objetos/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/008-Mantenimiento de la persistencia de los objetos/006-El lenguaje de consultas sintaxis, expresiones, operadores/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/008-Mantenimiento de la persistencia de los objetos/006-El lenguaje de consultas sintaxis, expresiones, operadores/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/008-Mantenimiento de la persistencia de los objetos/005-Mecanismos de consulta/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/008-Mantenimiento de la persistencia de los objetos/005-Mecanismos de consulta/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/008-Mantenimiento de la persistencia de los objetos/003-Instalación del gestor de bases de datos/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/008-Mantenimiento de la persistencia de los objetos/003-Instalación del gestor de bases de datos/001-Contenidos básicos/Contenidos básicos.md
```

### Actividades propuestas

It looks like you've provided a list of file paths related to a course on object-oriented programming and database management. Each path leads to different sections or exercises in the course, which cover various aspects from basic concepts of classes and objects to more advanced topics such as persistence mechanisms and querying databases.

Here's a brief overview based on the paths:

1. **Concepto de Clase** (Class Concept): This section introduces students to the fundamental ideas behind classes and objects in object-oriented programming.
   
2. **Estructura y Miembros de una Clase** (Structure and Members of a Class): Here, the focus is on understanding how classes are structured and what members (properties and methods) they contain.

3. **Desarrollo de Clases** (Class Development): Covers various aspects of developing classes in terms of methods, properties, inheritance, and polymorphism.

4. **Persistencia de Objetos en Bases de Datos** (Object Persistence in Databases):
   - **Bases de datos orientadas a objetos**: Introduction to object-oriented databases.
   - **Características de las bases de datos orientadas a objetos**: Features of object-oriented databases.
   - **Creación de bases de datos**: How to create and manage databases.
   - **Instalación del gestor de bases de datos**: Installation procedures for database management systems.
   - **Mecanismos de consulta**: Query mechanisms in object-oriented databases.
   - **El lenguaje de consultas sintaxis, expresiones, operadores**: Syntax, expressions, and operators of the query language used to interact with object-oriented databases.
   - **Recuperación, modificación y borrado de información**: Techniques for retrieving, modifying, and deleting information in these databases.
   - **Tipos de datos colección; atributos y métodos**: Collection data types, their attributes, and methods.

5. **Resumen del Tema** (Summary of the Topic): This could be a recapitulation or consolidation section summarizing all aspects learned about object persistence in databases.

Given this structure, you might want to navigate through these files in an organized manner according to your learning pace or as prescribed by the course syllabus. If you have specific questions or need help with any of the exercises covered within these paths, feel free to ask!


<a id="creacion-y-eliminacion-de-ficheros-y-directorios"></a>
## Creación y eliminación de ficheros y directorios

### Introducción a los ejercicios

En esta carpeta, trabajaremos con ejercicios que te permitirán entender cómo crear y eliminar archivos y directorios en Python. Aprenderás desde operaciones básicas como crear una simple carpeta o archivo hasta procesos más complejos como comprimir carpetas y sus subcarpetas en archivos ZIP. Estos ejercicios están diseñados para mejorar tus habilidades en la manipulación de sistemas de archivos, manejo de excepciones y compresión de datos. Es importante prestar atención a los detalles sobre cómo gestionar correctamente errores y mantener la seguridad de tu sistema al realizar operaciones con el sistema de archivos.

### crear carpeta
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código en Python sirve para crear una carpeta con el nombre "micarpeta" en la ubicación actual del programa. La primera línea `import os` importa el módulo os, que proporciona funciones para interactuar con el sistema operativo y manejar archivos y directorios. En la segunda línea, se utiliza la función `os.mkdir()` para crear una nueva carpeta. Esta función toma como argumento el nombre del directorio que deseas crear.

Es importante destacar que si ya existe un archivo o directorio llamado "micarpeta", este código generará un error al intentar ejecutarse, ya que no se puede crear dos veces la misma carpeta en el mismo lugar. Por lo tanto, antes de llamar a `os.mkdir()`, es recomendable verificar si el directorio ya existe para evitar errores y hacer que tu programa sea más robusto y eficiente.

`001-crear carpeta.py`

```python
import os

os.mkdir("micarpeta")
```

### eliminar carpeta
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código en Python elimina una carpeta llamada "micarpeta" usando la función `os.rmdir()`. Esta función es parte del módulo `os` que proporciona funciones para interactuar con el sistema operativo. La línea `import os` al principio del código incluye todas las funciones disponibles en este módulo.

La función `os.rmdir("micarpeta")` se encarga de eliminar la carpeta especificada por el nombre de parámetro, que en este caso es "micarpeta". Es importante destacar que esta función solo funciona si la carpeta está completamente vacía. Si intentas eliminar una carpeta que contiene archivos o subcarpetas, obtendrás un error y no se realizará la eliminación.

Este tipo de operaciones son fundamentales en programación para gestionar el espacio del disco y organizar los archivos y carpetas en tu sistema de forma eficiente.

`002-eliminar carpeta.py`

```python
import os

os.rmdir("micarpeta")
```

### no se puede crear una carpeta dos veces
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es muy simple pero fundamental para entender cómo se crean carpetas en Python. Primero, el programa importa el módulo `os`, que proporciona funciones para interactuar con el sistema operativo y realizar tareas como crear o eliminar archivos y directorios.

Luego, utiliza la función `os.mkdir()` para crear una carpeta llamada "micarpeta" en el directorio actual. La función `mkdir` toma el nombre del directorio que se quiere crear como argumento. Es importante tener en cuenta que si ya existe un directorio con ese mismo nombre, Python lanzará un error.

Este código es útil para enseñar a los estudiantes cómo manejar archivos y carpetas usando Python, pero también hay que señalar la importancia de agregar controladores de errores para situaciones como cuando intentamos crear una carpeta que ya existe.

`003-no se puede crear una carpeta dos veces.py`

```python
import os

os.mkdir("micarpeta")
```

### solucion al problema
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es una pequeña parte de un programa que intenta crear un directorio (carpeta) en el sistema operativo. La función `os.mkdir()` del módulo `os` se utiliza para crear una nueva carpeta con el nombre "micarpeta". Si la carpeta ya existe, este comando generará un error.

El código está protegido por un bloque de excepciones (`try-except`) que maneja cualquier posible error que pueda ocurrir durante la creación del directorio. En caso de que ocurra un error, el programa simplemente imprimirá "Ha habido un error, continuamos" en lugar de detenerse abruptamente.

Este tipo de manejo de excepciones es importante porque permite al programa seguir ejecutándose incluso si algo sale mal durante la creación del directorio. Sin embargo, sería una buena práctica proporcionar más información sobre el error para ayudar a depurar problemas en el futuro.

`004-solucion al problema.py`

```python
import os

try:
  os.mkdir("micarpeta")
except:
  print("Ha habido un error, continuamos")
```

### crear un archivo
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código en Python abre un nuevo archivo llamado "miarchivo.txt" con modo de escritura ("w"). Cuando se usa el modo de escritura, si el archivo ya existe, se sobrescribirá por completo; si no existe, Python creará uno nuevo. Al abrirlo solo con `open()` y no usar métodos adicionales como `.write()`, simplemente estás estableciendo la condición para escribir en él más adelante en tu programa, pero el archivo permanecerá vacío hasta que agregues contenido específico.

Es importante destacar que este código por sí solo no agrega ningún tipo de información al archivo recién creado. Para añadir texto o datos a "miarchivo.txt", necesitarías usar métodos como `.write()` o `.writelines()` después de abrir el archivo con `open()`.

`005-crear un archivo.py`

```python
open("miarchivo.txt","w")
```

### eliminar archivo
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código está utilizando la biblioteca `os` en Python para eliminar un archivo que ya existe en el sistema. El código primero importa la librería `os`, que proporciona funciones para interactuar con el sistema operativo. Luego, utiliza la función `os.remove()` para borrar el archivo "miarchivo.txt". 

Es importante tener cuidado al usar `os.remove()`, porque una vez que se elimina un archivo de esta manera, no hay forma de recuperarlo a menos que lo hagas desde los medios de respaldo o a través del sistema operativo en algunos casos. Este código es útil cuando necesitas limpiar archivos temporales o desechados en tu programa después de su uso para mantener el espacio y la organización del directorio.

`006-eliminar archivo.py`

```python
import os

# Hemos creado con:
# open("miarchivo.txt","w")

os.remove("miarchivo.txt")
```

### nuevo archivo con texto
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código Python crea y escribe en un archivo llamado "miarchivo.txt". Primero, la línea `archivo = open("miarchivo.txt", "w")` abre el archivo en modo escritura ("w"). Si el archivo no existe, se creará uno nuevo. Si ya existe, su contenido será borrado antes de que puedas escribir en él.

Luego, la línea `archivo.write("Esto es un texto de prueba que estoy escribiendo")` toma una cadena de texto y la guarda dentro del archivo recién creado o abierto. El texto especificado entre comillas se guardará exactamente como está escrito.

Es importante entender cómo abrir archivos en diferentes modos (en este caso, el modo escritura) para poder gestionar adecuadamente los datos que deseas guardar en el disco duro desde tu programa Python.

`007-nuevo archivo con texto.py`

```python
archivo = open("miarchivo.txt","w")

archivo.write("Esto es un texto de prueba que estoy escribiendo")
```

### comprimir
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código en Python está usando la biblioteca `zipfile` para crear un archivo comprimido. Lo que hace el código es tomar un archivo específico llamado `'crmca_crmcapitol (1).sql'` y guardar este archivo dentro de otro archivo denominado `'basededatos.zip'`, que actúa como una carpeta comprimida.

El código comienza importando la clase `ZipFile` desde el módulo `zipfile`. Luego, se especifica un nombre para el archivo fuente (`origen`) y uno para el archivo destino comprimido (`destino`). El siguiente paso es crear un objeto de tipo `ZipFile`, asignándole `'basededatos.zip'` como nombre del archivo que se va a crear y usando la opción `'w'` (write o escritura) para indicar que este archivo será creado desde cero.

Finalmente, el método `write()` se usa para agregar el archivo especificado en `origen` al archivo comprimido recién creado. Esto es útil cuando necesitas enviar un archivo grande de forma segura y compacta, reduciendo así su tamaño y facilitando su transferencia o almacenamiento.

Este tipo de operación es común en la programación cuando se necesita gestionar archivos de manera eficiente, especialmente para tareas que implican el manejo y transmisión de datos grandes.

`008-comprimir.py`

```python
import zipfile

origen = 'crmca_crmcapitol (1).sql'

destino = 'basededatos.zip'

archivo = zipfile.ZipFile(destino, 'w')
archivo.write(origen)
```

### algoritmo de compresion
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código es una pequeña parte de un programa que compresiona archivos usando la biblioteca `zipfile` en Python. Lo que hace el código es crear un archivo ZIP comprimido a partir de un archivo específico.

En primer lugar, se importa la clase `ZipFile` del módulo `zipfile`. Luego, se definen dos variables: `origen`, que contiene el nombre del archivo que se desea comprimir (en este caso, `'crmca_crmcapitol (1).sql'`), y `destino`, que es el nombre del archivo ZIP resultante (`'basededatos.zip'`). 

El código crea un objeto de la clase `ZipFile` llamado `archivo`. Este objeto se inicializa con el parámetro `destino` (el nombre del archivo ZIP a crear) y la opción `'w'`, que indica que se va a escribir en él para agregar contenido nuevo. Además, se especifica que debe comprimir los archivos utilizando el algoritmo `ZIP_DEFLATED`, que es uno de los métodos estándar para compresión.

Finalmente, con la línea `archivo.write(origen)`, se agrega el archivo del origen a este archivo ZIP recién creado. Al finalizar esta operación, tendrás un archivo comprimido llamado `'basededatos.zip'` que contiene una copia del archivo SQL original.

Este tipo de código es útil para ahorrar espacio en disco al reducir el tamaño de los archivos o para facilitar su transporte y almacenamiento.

`009-algoritmo de compresion.py`

```python
import zipfile

origen = 'crmca_crmcapitol (1).sql'

destino = 'basededatos.zip'

archivo = zipfile.ZipFile(destino, 'w', compression=zipfile.ZIP_DEFLATED)
archivo.write(origen)
```

### comprimir todos los arhivos de una carpeta
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código es una parte del ejercicio que te ayuda a entender cómo comprimir archivos individuales dentro de una carpeta específica. En este caso, la tarea principal es recorrer todos los archivos en una carpeta llamada "archivos" y generar un archivo zip para cada uno de ellos.

El fragmento comienza importando dos módulos importantes: `zipfile` y `os`. El módulo `zipfile` se usa para trabajar con archivos ZIP, mientras que el módulo `os` proporciona funciones para interactuar con el sistema operativo, como listar los archivos en un directorio.

El código itera sobre todos los archivos dentro de la carpeta especificada utilizando `os.walk()`. Esta función recorre recursivamente las carpetas y subcarpetas, devolviendo una tupla que contiene el directorio actual, las subcarpetas dentro del mismo y los archivos en este directorio. Para cada archivo encontrado, se crea un camino completo (`origen`) hacia él.

A continuación, se genera la ruta de destino para el archivo comprimido (un archivo zip), combinando el nombre del archivo con ".zip". Luego, se abre un nuevo archivo ZIP utilizando `ZipFile`, especificando que deseas escribir en este archivo y usando la compresión DEFLATE. Finalmente, cada archivo original se añade al archivo ZIP recién creado con el método `write()`, donde `arcname=nombre_archivo` indica que el nombre del archivo dentro del zip será igual al nombre original.

En resumen, este código toma todos los archivos en una carpeta y crea un archivo .zip para cada uno de ellos, manteniendo así la integridad de los datos mientras reduce su tamaño.

`010-comprimir todos los arhivos de una carpeta.py`

```python
import zipfile
import os

carpeta = "archivos"

for directorio, subcarpetas, archivos in os.walk(carpeta):
    for nombre_archivo in archivos:
        origen = os.path.join(directorio, nombre_archivo)
        destino = os.path.join(directorio, nombre_archivo + ".zip")
        archivo =  zipfile.ZipFile(destino, 'w', compression=zipfile.ZIP_DEFLATED)
        archivo.write(origen, arcname=nombre_archivo)
```

### comprimir carpeta
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código en Python es utilizado para comprimir una carpeta completa en un archivo zip. La tarea comienza importando dos módulos importantes: `os` y `zipfile`. El módulo `os` ayuda a interactuar con el sistema operativo, mientras que `zipfile` proporciona las herramientas necesarias para trabajar con archivos ZIP.

El código define dos variables: `origen`, que es la ruta de la carpeta que deseamos comprimir (en este caso "archivos"), y `destino`, que indica dónde y cómo se guardará el archivo zip resultante ("archivos.zip").

Luego, se crea un objeto `ZipFile` llamado `archivozip` que inicializa el proceso de compresión en modo escritura (`'w'`). El parámetro `zipfile.ZIP_DEFLATED` indica que queremos usar la función de compresión ZIP estándar (DEFLATE).

A continuación, se itera sobre todos los archivos dentro del directorio especificado utilizando `os.walk()`. Para cada archivo encontrado en el directorio y sus subdirectorios, se determina su ruta absoluta (`rutaarchivo`) y una versión relativa de esta ruta (`rutarelativa`). Finalmente, cada archivo es añadido al archivo ZIP con la función `write()` del objeto `ZipFile`.

Una vez que todos los archivos han sido agregados al archivo zip, el código cierra el objeto `archivozip` para finalizar la operación de compresión.

Esta funcionalidad es muy útil cuando necesitas enviar varios archivos empaquetados en un solo archivo, lo cual facilita su manejo y transferencia.

`011-comprimir carpeta.py`

```python
import os
import zipfile

origen = "archivos"
destino = "archivos.zip"

archivozip = zipfile.ZipFile(destino, 'w', zipfile.ZIP_DEFLATED)
for directorio, carpetas, archivos in os.walk(origen):
  for archivo in archivos:
    rutaarchivo = os.path.join(directorio, archivo)
    rutarelativa = os.path.relpath(rutaarchivo, origen)
    archivozip.write(rutaarchivo, rutarelativa)
    
archivozip.close()
```

### ejercicio final
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código Python realiza una tarea compleja pero bien estructurada: comprime todos los archivos y subcarpetas dentro de una carpeta dada por el usuario en formato ZIP, y luego elimina los archivos originales después de la compresión. Comienza pidiendo al usuario que ingrese la ruta de una carpeta específica a través del teclado. Luego verifica si la ruta proporcionada es válida y realmente apunta a una carpeta.

El código itera sobre cada elemento (archivos o carpetas) dentro de la carpeta especificada. Si el elemento es un archivo, se comprime en su propia entrada ZIP y luego se elimina. Si es una subcarpeta, todo su contenido se comprime en un solo archivo ZIP antes de eliminar la carpeta completa.

Es importante notar que este código incluye mecanismos para evitar procesar archivos ya existentes con la extensión ".zip", garantizando así que no se vuelvan a comprimir accidentalmente. Además, utiliza excepciones para manejar cualquier error durante el proceso y seguir adelante si es posible.

Este tipo de script es útil en situaciones donde se necesite reducir el tamaño de un conjunto de archivos al crear un archivo ZIP y desechar los originales después de eso, o bien como una forma de respaldo que luego se puede descomprimir. Sin embargo, ten cuidado ya que este código elimina los archivos originales durante la compresión.

`012-ejercicio final.py`

```python
import os
import zipfile
import shutil

'''
  Quiero:
  1.-Pedir al usuario una ruta de una carpeta con input
  2.-Repasar todas las subcarpetas y archivos dentro de esa carpeta
  3.-Para cada archivo o carpeta, quiero comprimirla en un ZIP
  4.-Una vez comprimido ese zip, quiero eliminar los contenidos originales
'''

ruta = input("Introduce la ruta de la carpeta: ").strip()

try:
  # Comprobamos que la ruta existe y es una carpeta
  if not os.path.isdir(ruta):
    print("La ruta no es válida")
  else:
    # Recorremos SOLO el primer nivel dentro de la ruta dada
    for nombre in os.listdir(ruta):
      origen = os.path.join(ruta, nombre)

      # Evitar recomprimir ZIPs ya existentes
      if os.path.isfile(origen) and origen.lower().endswith(".zip"):
        continue

      # Si es una carpeta: crear un ZIP con todo su contenido y luego eliminarla
      if os.path.isdir(origen):
        destino = origen + ".zip"
        archivozip = zipfile.ZipFile(destino, 'w', zipfile.ZIP_DEFLATED)
        for directorio, subcarpetas, archivos in os.walk(origen):
          for archivo in archivos:
            rutaarchivo = os.path.join(directorio, archivo)
            rutarelativa = os.path.relpath(rutaarchivo, origen)
            archivozip.write(rutaarchivo, rutarelativa)
        archivozip.close()
        shutil.rmtree(origen)

      # Si es un archivo: comprimirlo y luego eliminar el original
      elif os.path.isfile(origen):
        destino = origen + ".zip"
        archivo = zipfile.ZipFile(destino, 'w', compression=zipfile.ZIP_DEFLATED)
        archivo.write(origen, arcname=nombre)
        archivo.close()
        os.remove(origen)

except:
  print("Ha habido un error, continuamos")
```

### ampliacion
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este programa en Python te permite seleccionar una carpeta específica y luego procesar todos los archivos y subcarpetas que contiene para crear un archivo ZIP de cada uno. Además, opcionalmente, puede eliminar las versiones originales después de comprimirlas.

El código comienza importando varias bibliotecas necesarias: `os` para manejar rutas de directorios, `zipfile` y `shutil` para la manipulación de archivos ZIP y eliminación de carpetas, respectivamente, y `sys` y `time` para mostrar una barra de progreso en consola durante el proceso.

El usuario debe ingresar la ruta del directorio que desea procesar. El programa verifica si esta ruta es válida y luego crea una lista de todos los elementos (archivos y subcarpetas) dentro del directorio, excluyendo cualquier archivo ZIP que ya exista ahí.

Para cada elemento en esa lista:
- Si el elemento es un directorio, se crea un archivo ZIP que incluye todo su contenido. Luego, si la variable `borrar_originales` está establecida en `True`, la carpeta original será eliminada.
- Si el elemento es un archivo, simplemente se comprime y guarda con una extensión `.zip`. De nuevo, si se ha habilitado la opción de eliminar archivos originales, este será borrado después de ser comprimido.

Durante todo el proceso, una barra de progreso se actualiza en la consola mostrando cuánto tiempo lleva y cuánto falta para completar la operación. Esto ayuda a los usuarios a entender cómo avanza su tarea sin necesidad de un programa adicional o interfaz gráfica.

Este tipo de script es muy útil para realizar tareas de backup automatizadas o preparativos de transferencia de archivos, especialmente cuando se trabaja con muchos elementos en directorios complejos.

`013-ampliacion.py`

```python
import os
import zipfile
import shutil
import sys
import time

#### CUIDADO CON ESTE PROGRAMA
#### USALO BIEN
#### UN GRAN PODER CONLLEVA UNA GRAN RESPONSABILIDAD

'''
  Quiero:
  1.-Pedir al usuario una ruta de una carpeta con input
  2.-Repasar todas las subcarpetas y archivos dentro de esa carpeta
  3.-Para cada archivo o carpeta, quiero comprimirla en un ZIP
  4.-Una vez comprimido ese zip, quiero eliminar los contenidos originales (opcional con booleano)
  5.-Mostrar una barra de progreso en consola con porcentaje y estimación de tiempo
'''

# 1) Booleano para activar/desactivar el borrado de originales
borrar_originales = False  # ponlo a False para conservar los originales

# ---- Utilidades para la barra de progreso ----
def formatear_tiempo(segundos):
  segundos = int(segundos)
  h = segundos // 3600
  m = (segundos % 3600) // 60
  s = segundos % 60
  if h > 0:
    return f"{h:02d}:{m:02d}:{s:02d}"
  else:
    return f"{m:02d}:{s:02d}"

def mostrar_progreso(procesados, total, inicio):
  if total == 0:
    return
  porcentaje = (procesados / total)
  ancho_barra = 30
  rellenos = int(ancho_barra * porcentaje)
  barra = "[" + "#" * rellenos + "-" * (ancho_barra - rellenos) + "]"

  transcurrido = time.time() - inicio
  if procesados > 0:
    estimado_total = transcurrido / procesados * total
    restante = max(0, estimado_total - transcurrido)
  else:
    restante = 0

  texto = f"\r{barra} {porcentaje*100:6.2f}%  transcurrido: {formatear_tiempo(transcurrido)}  restante: {formatear_tiempo(restante)}"
  sys.stdout.write(texto)
  sys.stdout.flush()
# ---------------------------------------------

ruta = input("Introduce la ruta de la carpeta: ").strip()

try:
  # Comprobamos que la ruta existe y es una carpeta
  if not os.path.isdir(ruta):
    print("La ruta no es válida")
  else:
    # Preparamos la lista de ítems a procesar (solo primer nivel), excluyendo ZIPs
    items = []
    for nombre in os.listdir(ruta):
      origen = os.path.join(ruta, nombre)
      if os.path.isfile(origen) and origen.lower().endswith(".zip"):
        continue
      items.append(origen)

    total = len(items)
    procesados = 0
    inicio = time.time()
    mostrar_progreso(procesados, total, inicio)

    for origen in items:
      nombre = os.path.basename(origen)

      # Si es una carpeta: crear un ZIP con todo su contenido
      if os.path.isdir(origen):
        destino = origen + ".zip"
        archivozip = zipfile.ZipFile(destino, 'w', zipfile.ZIP_DEFLATED)
        for directorio, subcarpetas, archivos in os.walk(origen):
          for archivo in archivos:
            rutaarchivo = os.path.join(directorio, archivo)
            rutarelativa = os.path.relpath(rutaarchivo, origen)
            archivozip.write(rutaarchivo, rutarelativa)
        archivozip.close()

        # Borrar carpeta original si está activado
        if borrar_originales:
          shutil.rmtree(origen)

      # Si es un archivo: comprimirlo
      elif os.path.isfile(origen):
        destino = origen + ".zip"
        archivo = zipfile.ZipFile(destino, 'w', compression=zipfile.ZIP_DEFLATED)
        archivo.write(origen, arcname=nombre)
        archivo.close()

        # Borrar archivo original si está activado
        if borrar_originales:
          os.remove(origen)

      # Actualizamos progreso
      procesados += 1
      mostrar_progreso(procesados, total, inicio)

    print()  # salto de línea al terminar la barra
    print("Proceso completado.")

except:
  print("\nHa habido un error, continuamos")
```

### Actividades propuestas

### Actividades para Estudiantes de Formación Profesional

#### **Actividad 1: Crear y Eliminar Ficheros**
- **Descripción:** Los estudiantes deben crear un script que cree un fichero con nombre dado por el usuario. Luego, deben implementar una función que elimine ese mismo fichero si existe.
- **Objetivo:** Aprender a trabajar con funciones básicas de manejo de archivos en Python.

#### **Actividad 2: Creación y Eliminación de Carpetas**
- **Descripción:** Los estudiantes deberán crear un script que permita al usuario crear una carpeta con nombre dado. Posteriormente, implementar la eliminación de dicha carpeta si ya existe.
- **Objetivo:** Familiarizarse con el manejo de directorios utilizando el módulo `os`.

#### **Actividad 3: Manejo de Excepciones al Crear Carpetas**
- **Descripción:** Los estudiantes deben crear un script que intente crear una carpeta. Si la carpeta ya existe, se debe mostrar un mensaje indicando que no es posible crearla debido a que ya está presente.
- **Objetivo:** Aprender el uso de excepciones para controlar errores comunes durante la creación y eliminación de archivos o directorios.

#### **Actividad 4: Escritura en Ficheros**
- **Descripción:** Los estudiantes deben escribir un texto específico dentro de un archivo creado previamente. Luego, leer el contenido del archivo para verificar que se haya escrito correctamente.
- **Objetivo:** Aprender a manipular archivos mediante la escritura y lectura de datos.

#### **Actividad 5: Crear y Comprimir Ficheros Individuales**
- **Descripción:** Los estudiantes deben crear un script que comprima en formato ZIP un archivo dado por el usuario.
- **Objetivo:** Utilizar el módulo `zipfile` para la compresión de archivos.

#### **Actividad 6: Crear y Comprimir Carpetas Complejas**
- **Descripción:** Los estudiantes deben escribir un script que tome una carpeta dada como entrada, comprima todos los archivos y subcarpetas dentro de ella en un único archivo ZIP.
- **Objetivo:** Implementar la compresión recursiva de carpetas utilizando el módulo `zipfile`.

#### **Actividad 7: Crear Archivos Zip Con Barra de Progreso**
- **Descripción:** Los estudiantes deben mejorar un script existente para que incluya una barra de progreso y tiempo estimado durante la compresión de archivos o carpetas.
- **Objetivo:** Mejorar el manejo de datos grandes mediante técnicas como barras de progreso y cálculo de tiempos.

#### **Actividad 8: Manejar Subcarpetas al Comprimir**
- **Descripción:** Los estudiantes deben crear un script que permita a los usuarios seleccionar una carpeta, comprimir todos sus contenidos en varios archivos ZIP (uno por subdirectorio), y opcionalmente borrar la carpeta original después de la compresión.
- **Objetivo:** Aprender a navegar y manipular estructuras de carpetas y subcarpetas.

#### **Actividad 9: Comprimir y Borrar Contenido**
- **Descripción:** Los estudiantes deben diseñar un script que tome una carpeta como entrada, comprima todos sus archivos y subcarpetas en ZIPs individuales, y luego borrar el contenido original si se selecciona esta opción.
- **Objetivo:** Mejorar habilidades de gestión de archivos grandes con manejo eficiente de la memoria y recursos.

#### **Actividad 10: Creación Dinámica de Archivos Zip**
- **Descripción:** Los estudiantes deben diseñar un script que permita a los usuarios seleccionar carpetas o archivos específicos para ser comprimidos en ZIPs individuales, proporcionando una opción para borrar el contenido original después de la compresión.
- **Objetivo:** Mejorar habilidades de programación orientada a eventos y manejo dinámico de datos.


<a id="entrada-desde-teclado-salida-a-pantalla-formatos-de-visualizacion"></a>
## Entrada desde teclado. Salida a pantalla. Formatos de visualización

### Introducción a los ejercicios

The Python script you've provided is a series of iterative improvements for managing a simple database of clients, each time adding new functionality or fixing issues. Here's a breakdown of the key steps and their significance:

### 1. **Initial Setup:**
   - The initial version of the script simply allows users to add, list, update, and delete client records in memory.

### 2. **Persistent Storage with `pickle`:**
   - In versions 023 and 024, persistent storage is introduced using the `pickle` module, allowing the program to save data between runs.
   
     ```python
     import pickle
     
     # Load existing clients if file exists
     try:
         archivo = open("clientes.dat", 'rb')
         clientes = pickle.load(archivo)
     except FileNotFoundError:
         print("No existe archivo de datos")
     
     # Save changes back to the file at each step
     while True:
         ...
         with open('clientes.dat', 'wb') as f:  # Use 'wb' mode for binary write
             pickle.dump(clientes, f)
     ```

### 3. **Improving Data Handling:**
   - In version 025, the script uses command-line arguments via `sys.argv` to allow passing data directly to the program.

     ```python
     import sys
     
     if len(sys.argv) > 1:
         edad = int(sys.argv[1])
         print(f"El doble de tu edad es: {edad * 2}")
     else:
         print("No argument provided")
     ```

### Summary of Key Improvements:

- **Persistent Storage:** By using `pickle`, the program can save and load client records between runs, ensuring data isn't lost when the program exits.
  
- **Error Handling:** Proper error handling is added to manage cases where the file doesn't exist yet (e.g., using a try-except block).
  
- **Binary Files:** Using binary mode (`'wb'` for write) ensures that `pickle.dump()` works correctly.

### Future Enhancements:
1. **User Interface Improvements:**
   - Improve user interaction with better error messages and more structured input handling.
   
2. **Database Management:**
   - Consider moving from file-based storage to a proper database (like SQLite or MySQL).
   
3. **Security:**
   - Add security measures such as encryption for sensitive data.

4. **Modularity:**
   - Break down the program into separate modules for better organization and reusability.
   
5. **Command-Line Arguments:**
   - Expand command-line argument handling to support various operations like `--list`, `--add`, etc., making the script more versatile.

This series of improvements is typical in software development, where initial basic functionality evolves with added features, robustness, and efficiency over time.

### creamos una clase
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

El fragmento de código que has proporcionado es el comienzo de la definición de una clase en Python. Una clase se utiliza para encapsular datos y comportamientos relacionados, generalmente asociados con un concepto o entidad del mundo real, como en este caso "Cliente". 

Aunque la línea actual está incompleta (solo incluye `class Cliente():`), esto indica que estás a punto de comenzar a definir los atributos y métodos específicos para la clase `Cliente`. Los atributos son variables que contienen información sobre el objeto, mientras que los métodos son funciones que definen lo que puede hacer ese objeto.

En el contexto del archivo en el que este código se encuentra (que trata sobre entrada desde teclado y salida a pantalla), es probable que esta clase `Cliente` esté diseñada para representar la información de un cliente en una aplicación, incluyendo cómo obtener esa información mediante entradas del usuario y mostrarla en la pantalla. Esta práctica es común en aplicaciones orientadas a objetos donde cada objeto (en este caso, un cliente) tiene sus propias características y acciones asociadas.

Es importante completar esta definición de clase para poder utilizar los objetos `Cliente` en tu programa. Por ejemplo, podrías añadir un constructor (`__init__`) que reciba información del cliente al momento de crearlo o métodos que permitan mostrar la información almacenada en esa instancia de cliente.

`002-creamos una clase.py`

```python
class Cliente():
  
```

### creamos un constructor
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es el inicio de la definición de una clase en Python llamada `Cliente`. La clase comienza con la declaración `class Cliente():`, lo que indica que estamos creando un nuevo tipo de objeto denominado "Cliente". Dentro de esta clase, vemos el método especial `__init__()` que se llama automáticamente cuando se crea una nueva instancia del objeto. 

El código proporcionado muestra solo el esqueleto básico del constructor (`__init__`), pero no tiene ningún código dentro de él por ahora. El propósito de este método es inicializar los atributos (características) del objeto `Cliente`. En un ejemplo completo, aquí podrías agregar líneas para establecer valores iniciales para las propiedades del cliente, como nombre o número de cuenta, que serían necesarias cuando crees un nuevo cliente.

Este patrón es fundamental en la programación orientada a objetos porque permite definir el estado inicial de los objetos antes de usarlos. Sin embargo, en este caso, el constructor está incompleto y necesita implementar la lógica adecuada para cada instancia del objeto `Cliente`.

`003-creamos un constructor.py`

```python
class Cliente():
  def __init__(self):
    
```

### el constructor tiene parametros
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código define una clase en Python llamada `Cliente`. Una clase es como un modelo o plantilla que describe los aspectos comunes de todos los objetos del tipo "cliente". En este caso, la clase tiene tres atributos: `nombre`, `apellidos` e `email`.

La función `__init__()` es el constructor de la clase. Es el primer método que se ejecuta cuando se crea un nuevo objeto a partir de esta clase. El constructor toma cuatro argumentos: `self`, `nombre`, `apellidos` y `email`. El parámetro `self` siempre debe estar presente y hace referencia al propio objeto que está siendo creado. Los otros tres parámetros (`nombre`, `apellidos` e `email`) son los datos específicos del cliente que se proporcionan cuando se crea un nuevo objeto de tipo `Cliente`.

Dentro del constructor, estos valores se asignan a las propiedades del objeto utilizando la sintaxis `self.nombre = nombre`. Esto significa que cada instancia (o objeto) de la clase `Cliente` tendrá sus propios valores para `nombre`, `apellidos` e `email`, aunque comparten el mismo código de definición en la clase.

`004-el constructor tiene parametros.py`

```python
class Cliente():
  def __init__(self,nombre,apellidos,email):
    self.nombre = nombre
    self.apellidos = apellidos
    self.email = email
```

### pantalla de bienvenida
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código Python crea una clase llamada `Cliente` que se utiliza para representar información sobre un cliente, como su nombre, apellidos y correo electrónico. La función `__init__` es el constructor de la clase; cuando creas un objeto de tipo `Cliente`, debes proporcionar tres argumentos: `nombre`, `apellidos` e `email`. Estos valores se guardan dentro del objeto utilizando atributos con los mismos nombres.

Además, el código imprime en pantalla dos líneas que indican el nombre y la versión de una aplicación simple para gestionar clientes. Estas impresiones sirven como un saludo o presentación inicial cuando la aplicación comienza a ejecutarse. Es importante porque da al usuario una idea clara del propósito y estado actual de la aplicación.

`005-pantalla de bienvenida.py`

```python
class Cliente():
  def __init__(self,nombre,apellidos,email):
    self.nombre = nombre
    self.apellidos = apellidos
    self.email = email

print("###### Gestión de clientes v0.1 ######")
print("####### Jose Vicente Carratala  ######")
```

### bucle infinito
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código es el inicio de un programa en Python que gestiona información sobre clientes y muestra una pantalla inicial al usuario. La clase `Cliente` está definida para almacenar datos como el nombre, apellidos y email de cada cliente.

Después de la declaración de la clase, se imprimen dos líneas en pantalla que sirven como encabezado o título del programa. Esto ayuda a identificar rápidamente qué aplicación está corriendo y quién es el autor.

Lo más importante es el bucle `while True:` al final del código. Este bucle infinito significa que el programa continuará ejecutándose sin detenerse, esperando instrucciones o entradas del usuario de manera constante. Sin embargo, en este fragmento específico, no se ha implementado ninguna acción dentro del bucle, por lo que el programa simplemente seguiría corriendo indefinidamente sin hacer nada más allá de mostrar la pantalla inicial.

Este patrón es común en interfaces interactivas donde el programa espera constantemente nuevas entradas del usuario para realizar diferentes acciones.

`006-bucle infinito.py`

```python
class Cliente():
  def __init__(self,nombre,apellidos,email):
    self.nombre = nombre
    self.apellidos = apellidos
    self.email = email

print("###### Gestión de clientes v0.1 ######")
print("####### Jose Vicente Carratala  ######")

while True:
  
```

### creamos lista de entidades
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es el comienzo de un programa en Python diseñado para gestionar una lista de clientes. El programa define una clase llamada `Cliente` que contiene tres atributos: nombre, apellidos y email. Estos datos se inicializan cuando se crea un objeto de la clase `Cliente`.

Después de definir la clase, el código imprime en pantalla dos líneas informativas para indicar el propósito del programa y el autor.

A continuación, se inicia un bucle infinito (`while True:`), que es una estructura de control que permitirá al programa ejecutarse hasta que el usuario decida salir. Dentro de este bucle, generalmente se incluirían opciones para añadir nuevos clientes a la lista `clientes`, mostrar los clientes existentes o realizar otras operaciones relacionadas con la gestión de esta lista.

Este tipo de estructura es común en aplicaciones interactivas donde el programa sigue funcionando hasta que se produce una condición de salida explícita. Es importante porque permite al usuario interactuar con el programa sin necesidad de cerrarlo y abrirlo nuevamente cada vez que quiera realizar nuevas acciones.

`007-creamos lista de entidades.py`

```python
class Cliente():
  def __init__(self,nombre,apellidos,email):
    self.nombre = nombre
    self.apellidos = apellidos
    self.email = email

print("###### Gestión de clientes v0.1 ######")
print("####### Jose Vicente Carratala  ######")

clientes = []

while True:
  
```

### creamos menu
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es la base para una aplicación simple que gestiona clientes. Comienza creando una clase llamada `Cliente` que tiene tres atributos: nombre, apellidos y email. Estos atributos se inicializan cuando se crea un nuevo objeto de la clase usando el método `__init__`.

Luego, el código muestra un menú sencillo en pantalla con cuatro opciones relacionadas a operaciones básicas para gestionar una lista de clientes (insertar, listar, actualizar y eliminar). Este menú es un bucle infinito (`while True:`), lo que significa que se mostrará continuamente hasta que alguien interrumpa la ejecución del programa.

El código utiliza `input()` para permitir al usuario ingresar su elección. La entrada del usuario se convierte a entero (`int(input("Escoge una opcion: "))`) y se guarda en la variable `opcion`. Este valor será utilizado más adelante en el código (fuera de este fragmento) para determinar qué acción realizar basándose en lo que haya seleccionado el usuario.

Esta estructura es fundamental porque proporciona una interfaz interactiva simple pero efectiva para permitir a los usuarios interactuar con la lista de clientes almacenados.

`008-creamos menu.py`

```python
class Cliente():
  def __init__(self,nombre,apellidos,email):
    self.nombre = nombre
    self.apellidos = apellidos
    self.email = email

print("###### Gestión de clientes v0.1 ######")
print("####### Jose Vicente Carratala  ######")

clientes = []

while True:
  print("Escoge una opción:")
  print("1.-Insertar un cliente")
  print("2.-Listar clientes")
  print("3.-Actualizar un cliente")
  print("4.-Eliminar un cliente")
  opcion = int(input("Escoge una opcion: "))
```

### atrapamos las opciones con if
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código es el comienzo de una pequeña aplicación en Python que gestiona clientes, como un registro básico. La clase `Cliente` se define al principio para almacenar información sobre cada cliente: nombre, apellidos y email.

El programa principal crea una lista vacía llamada `clientes`, donde se guardarán los objetos Cliente que se creen. Luego entra en un bucle infinito (`while True`) que muestra un menú con cuatro opciones (insertar, listar, actualizar y eliminar clientes) y pide al usuario que elija una opción.

Cuando el usuario introduce su elección y presiona Enter, el programa intenta convertir la entrada del usuario en un número entero e interpreta este número para determinar qué acción realizar. En este punto, el código muestra solo las estructuras `if` para cada opción, pero no incluye el código que se ejecutaría dentro de ellas.

Este fragmento es importante porque establece la estructura básica de una aplicación interactiva y demuestra cómo utilizar clases en Python para organizar datos relacionados. Aunque falta implementar la funcionalidad específica de cada opción, ya se ha creado un marco claro y fácil de seguir que puede expandirse según sea necesario.

`009-atrapamos las opciones con if.py`

```python
class Cliente():
  def __init__(self,nombre,apellidos,email):
    self.nombre = nombre
    self.apellidos = apellidos
    self.email = email

print("###### Gestión de clientes v0.1 ######")
print("####### Jose Vicente Carratala  ######")

clientes = []

while True:
  print("Escoge una opción:")
  print("1.-Insertar un cliente")
  print("2.-Listar clientes")
  print("3.-Actualizar un cliente")
  print("4.-Eliminar un cliente")
  opcion = int(input("Escoge una opcion: "))
  
  if opcion == 1:
    
  elif opcion == 2:
  
  elif opcion == 3:
  
  elif opcion == 4:
    
```

### desarrollamos insertar
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código es una aplicación básica en Python que gestiona clientes. La estructura principal del programa está organizada mediante un bucle `while True`, lo cual significa que el menú de opciones se mostrará continuamente hasta que decidas detener la ejecución del programa manualmente.

1. **Definición de la clase Cliente**: El código comienza definiendo una clase llamada `Cliente` que tiene tres atributos: `nombre`, `apellidos` y `email`. Estos datos son proporcionados al crear un nuevo objeto cliente usando el método `__init__`.

2. **Menú principal**: Luego, se imprime en la pantalla un menú con cuatro opciones:
   - Insertar un cliente
   - Listar clientes
   - Actualizar un cliente
   - Eliminar un cliente

3. **Interacción del usuario**: El programa pide al usuario que introduzca una opción y esta elección se guarda en la variable `opcion`. Si el usuario selecciona la opción 1 (Insertar un cliente), el código solicita al usuario que ingrese el nombre, apellidos y email para crear un nuevo objeto de tipo `Cliente`.

4. **Lógica condicional**: El bloque `if opcion == 1:` es donde se recogen los datos del cliente cuando el usuario selecciona la opción correspondiente. Actualmente, las opciones 2, 3 y 4 no tienen lógica implementada y solo están marcadas con un espacio para futuras expansiones.

Este código forma parte de una serie de ejercicios destinados a aprender cómo gestionar datos en Python mediante clases y estructuras condicionales. Es fundamental entender cada paso del bucle `while` porque aquí es donde se realiza la interacción más importante entre el usuario y el programa, permitiendo al usuario realizar operaciones sobre los objetos `Cliente`.

`010-desarrollamos insertar.py`

```python
class Cliente():
  def __init__(self,nombre,apellidos,email):
    self.nombre = nombre
    self.apellidos = apellidos
    self.email = email

print("###### Gestión de clientes v0.1 ######")
print("####### Jose Vicente Carratala  ######")

clientes = []

while True:
  print("Escoge una opción:")
  print("1.-Insertar un cliente")
  print("2.-Listar clientes")
  print("3.-Actualizar un cliente")
  print("4.-Eliminar un cliente")
  opcion = int(input("Escoge una opcion: "))
  
  if opcion == 1:
    nombre = input("Introduce el nombre: ")
    apellidos = input("Introduce los apellidos: ")
    email = input("Introduce el email: ")
    
  elif opcion == 2:
  
  elif opcion == 3:
  
  elif opcion == 4:
    
```

### apendizamos
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código es una versión inicial de un programa en Python que gestiona la información de los clientes. El programa utiliza una clase llamada `Cliente` para almacenar detalles como el nombre, apellidos y email de cada cliente. En el flujo principal del programa, se crea un bucle infinito (`while True`) donde se muestra al usuario un menú con varias opciones: insertar un nuevo cliente, listar todos los clientes existentes, actualizar la información de un cliente o eliminar a un cliente.

El código comienza por definir la clase `Cliente` que tiene tres atributos (nombre, apellidos y email) inicializados en el método especial `__init__`. Luego, se imprime una pantalla de bienvenida con el título del programa y el nombre del creador. A continuación, se crea una lista vacía llamada `clientes`, donde se almacenarán objetos `Cliente`.

El corazón del programa es un bucle que solicita al usuario que elija entre las opciones mencionadas hasta que decida salir (no implementado en este fragmento). Si el usuario selecciona la opción 1, se pide al usuario que introduzca el nombre, apellidos y email para crear un nuevo objeto `Cliente`, que después se añade a la lista `clientes`.

Este código es importante porque establece los cimientos de una aplicación más compleja. Permite a los usuarios interactuar con los datos y muestra cómo utilizar clases y listas en Python para manejar información estructurada.

`011-apendizamos.py`

```python
class Cliente():
  def __init__(self,nombre,apellidos,email):
    self.nombre = nombre
    self.apellidos = apellidos
    self.email = email

print("###### Gestión de clientes v0.1 ######")
print("####### Jose Vicente Carratala  ######")

clientes = []

while True:
  print("Escoge una opción:")
  print("1.-Insertar un cliente")
  print("2.-Listar clientes")
  print("3.-Actualizar un cliente")
  print("4.-Eliminar un cliente")
  opcion = int(input("Escoge una opcion: "))
  
  if opcion == 1:
    nombre = input("Introduce el nombre: ")
    apellidos = input("Introduce los apellidos: ")
    email = input("Introduce el email: ")
    clientes.append(Cliente(nombre,apellidos,email))
  elif opcion == 2:
  
  elif opcion == 3:
  
  elif opcion == 4:
    
```

### pass de momento
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código es una pequeña aplicación en Python que gestiona un listado de clientes. La estructura principal es una clase llamada `Cliente`, la cual almacena los datos básicos de cada cliente (nombre, apellidos y email) proporcionados por el usuario cuando se crea una nueva instancia.

El programa comienza mostrando un menú interactivo en pantalla que permite al usuario elegir entre cuatro acciones: insertar un nuevo cliente, listar todos los clientes existentes, actualizar la información de un cliente específico o eliminar un cliente. En este caso, solo está implementada la opción para insertar un nuevo cliente, mientras que las otras opciones (listar, actualizar y eliminar) no hacen nada debido a los bloques `pass`.

Cuando el usuario selecciona "1.-Insertar un cliente", se solicitan al usuario el nombre, apellidos y email del nuevo cliente. Estos datos son utilizados para crear una nueva instancia de la clase `Cliente`, que luego se añade a una lista llamada `clientes`. El bucle `while True` asegura que este menú se mantendrá abierto hasta que sea interrumpido manualmente, permitiendo al usuario realizar múltiples operaciones sin tener que cerrar y abrir el programa constantemente.

Este tipo de estructura es común en aplicaciones de gestión de información y ayuda a los usuarios a interactuar fácilmente con un conjunto de datos.

`012-pass de momento.py`

```python
class Cliente():
  def __init__(self,nombre,apellidos,email):
    self.nombre = nombre
    self.apellidos = apellidos
    self.email = email

print("###### Gestión de clientes v0.1 ######")
print("####### Jose Vicente Carratala  ######")

clientes = []

while True:
  print("Escoge una opción:")
  print("1.-Insertar un cliente")
  print("2.-Listar clientes")
  print("3.-Actualizar un cliente")
  print("4.-Eliminar un cliente")
  opcion = int(input("Escoge una opcion: "))
  
  if opcion == 1:
    nombre = input("Introduce el nombre: ")
    apellidos = input("Introduce los apellidos: ")
    email = input("Introduce el email: ")
    clientes.append(Cliente(nombre,apellidos,email))
  elif opcion == 2:
    pass
  elif opcion == 3:
    pass
  elif opcion == 4:
    pass
```

### desarrollo leer
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código es una pequeña aplicación de línea de comandos en Python que permite gestionar una lista de clientes. La aplicación utiliza la clase `Cliente`, la cual almacena los detalles personales de cada cliente como nombre, apellidos y email.

El programa funciona en un bucle infinito (`while True:`), presentando siempre al usuario cuatro opciones: insertar un nuevo cliente, listar todos los clientes existentes, actualizar información de un cliente o eliminar un cliente. La opción elegida por el usuario se introduce a través del teclado y la aplicación procesa esa elección para realizar las acciones correspondientes.

Cuando el usuario escoge "Insertar un cliente", se le solicitan los datos del nuevo cliente (nombre, apellidos, email) que luego son usados para crear una nueva instancia de la clase `Cliente`. Este objeto recién creado es añadido a la lista `clientes`.

Para listar clientes, simplemente se itera sobre cada elemento en `clientes` e imprime información acerca de cada cliente. Las opciones de actualizar y eliminar un cliente están actualmente marcadas con "pass", lo que indica que aún no hay código implementado para estas acciones.

Esta aplicación es útil como ejemplo práctico de cómo estructurar interfaces de usuario simples, manejar datos de objetos personalizados y gestionar listas de elementos en Python.

`013-desarrollo leer.py`

```python
class Cliente():
  def __init__(self,nombre,apellidos,email):
    self.nombre = nombre
    self.apellidos = apellidos
    self.email = email

print("###### Gestión de clientes v0.1 ######")
print("####### Jose Vicente Carratala  ######")

clientes = []

while True:
  print("Escoge una opción:")
  print("1.-Insertar un cliente")
  print("2.-Listar clientes")
  print("3.-Actualizar un cliente")
  print("4.-Eliminar un cliente")
  opcion = int(input("Escoge una opcion: "))
  
  if opcion == 1:
    nombre = input("Introduce el nombre: ")
    apellidos = input("Introduce los apellidos: ")
    email = input("Introduce el email: ")
    clientes.append(Cliente(nombre,apellidos,email))
  elif opcion == 2:
    for cliente in clientes:
      print(cliente)
  elif opcion == 3:
    pass
  elif opcion == 4:
    pass
```

### imprimimos mejor el cliente
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es una aplicación sencilla en Python que gestiona un registro de clientes. Comienza creando una clase llamada `Cliente` que tiene tres atributos: nombre, apellidos y email. Estos datos se inicializan cuando se crea un objeto de la clase.

El programa principal usa un bucle `while True`, lo que significa que el menú que muestra se repetirá indefinidamente hasta que el programa sea interrumpido. En este menú, el usuario puede elegir entre cuatro opciones: insertar un nuevo cliente, listar todos los clientes existentes, actualizar la información de un cliente o eliminar un cliente.

Cuando el usuario selecciona la opción para insertar un cliente (opción 1), se le piden al usuario que introduzca el nombre, apellidos y email del nuevo cliente. Estos datos son luego usados para crear una nueva instancia de la clase `Cliente`, que finalmente se añade a la lista `clientes`.

La opción para listar clientes muestra en pantalla todos los clientes registrados hasta ese momento, mostrando cada uno de sus atributos.

Las opciones 3 y 4 (actualizar y eliminar un cliente) están programadas con el comando `pass`, lo que significa que no hacen nada por ahora. Esto es común cuando se está desarrollando una funcionalidad pero aún no se ha implementado completamente.

Esta estructura de código es útil porque permite al usuario gestionar fácilmente los datos de clientes directamente desde la consola, y también proporciona un buen ejemplo de cómo usar clases en Python para manejar objetos complejos como registros de clientes.

`014-imprimimos mejor el cliente.py`

```python
class Cliente():
  def __init__(self,nombre,apellidos,email):
    self.nombre = nombre
    self.apellidos = apellidos
    self.email = email

print("###### Gestión de clientes v0.1 ######")
print("####### Jose Vicente Carratala  ######")

clientes = []

while True:
  print("Escoge una opción:")
  print("1.-Insertar un cliente")
  print("2.-Listar clientes")
  print("3.-Actualizar un cliente")
  print("4.-Eliminar un cliente")
  opcion = int(input("Escoge una opcion: "))
  
  if opcion == 1:
    nombre = input("Introduce el nombre: ")
    apellidos = input("Introduce los apellidos: ")
    email = input("Introduce el email: ")
    clientes.append(Cliente(nombre,apellidos,email))
  elif opcion == 2:
    for cliente in clientes:
      print(cliente.nombre,cliente.apellidos,cliente.email)
  elif opcion == 3:
    pass
  elif opcion == 4:
    pass
```

### actualizar es como insertar pero con id
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código es una aplicación simple que gestiona la información de clientes. Se utiliza un bucle `while` infinito para presentar al usuario opciones como insertar, listar, actualizar o eliminar clientes. Cada cliente se guarda en una lista y se representa mediante una clase llamada `Cliente`, que tiene atributos como nombre, apellidos y email.

Cuando el usuario selecciona la opción de "Insertar un cliente", el programa solicita al usuario que introduzca los datos del nuevo cliente (nombre, apellidos y correo electrónico) y luego crea una instancia de la clase `Cliente` con estos datos antes de añadirla a la lista `clientes`.

Para la opción "Listar clientes", simplemente se recorre la lista `clientes` e imprime en pantalla cada uno de los atributos de los objetos que contiene.

La opción para actualizar un cliente es donde aparece el primer problema: intenta modificar directamente una posición específica (`identificador`) de la lista `clientes`, pero las listas en Python son indexadas con números enteros y no se pueden usar strings como índice. Este fragmento del código necesita ser corregido para buscar clientes por ID si los datos de cliente incluyen un identificador único.

Para el caso de "Eliminar un cliente", similar a la actualización, aquí también necesitarías implementar una lógica adecuada para localizar al cliente que se desea eliminar en función del ID antes de removerlo de la lista `clientes`.

El objetivo principal es enseñarte cómo estructurar y manejar datos complejos (como objetos) dentro de una colección como una lista, así como gestionar interacción con el usuario.

`015-actualizar es como insertar pero con id.py`

```python
class Cliente():
  def __init__(self,nombre,apellidos,email):
    self.nombre = nombre
    self.apellidos = apellidos
    self.email = email

print("###### Gestión de clientes v0.1 ######")
print("####### Jose Vicente Carratala  ######")

clientes = []

while True:
  print("Escoge una opción:")
  print("1.-Insertar un cliente")
  print("2.-Listar clientes")
  print("3.-Actualizar un cliente")
  print("4.-Eliminar un cliente")
  opcion = int(input("Escoge una opcion: "))
  
  if opcion == 1:
    nombre = input("Introduce el nombre: ")
    apellidos = input("Introduce los apellidos: ")
    email = input("Introduce el email: ")
    clientes.append(Cliente(nombre,apellidos,email))
  elif opcion == 2:
    for cliente in clientes:
      print(cliente.nombre,cliente.apellidos,cliente.email)
  elif opcion == 3:
    identificador = input("Introduce el id para modificar: ")
    nombre = input("Introduce el nombre: ")
    apellidos = input("Introduce los apellidos: ")
    email = input("Introduce el email: ")
    clientes[identificador].nombre = nombre
    clientes[identificador].apellidos = apellidos
    clientes[identificador].email = email
    pass
  elif opcion == 4:
    pass
```

### chivamos el id
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código es una sencilla aplicación en Python que gestiona una lista de clientes. Cada cliente se representa como un objeto de la clase `Cliente`, que almacena el nombre, apellidos y correo electrónico del cliente. La aplicación muestra un menú con opciones para insertar nuevos clientes en la lista, listar todos los clientes existentes, actualizar información de un cliente específico o eliminar a un cliente.

El programa funciona en un bucle infinito (`while True`), donde se presenta al usuario una serie de opciones hasta que elija salir del sistema (lo cual no está implementado en este fragmento). Cuando el usuario selecciona la opción 1, se le solicitan los datos del nuevo cliente y se crea un objeto `Cliente` con estos datos, añadiéndolo a la lista `clientes`. Para listar todos los clientes existentes, simplemente recorre la lista e imprime los detalles de cada uno junto con su índice como identificador. La opción 3 permite al usuario actualizar la información de cualquier cliente existente basándose en un número de identificación (índice) que el usuario proporciona.

Esta aplicación es importante porque demuestra cómo manejar datos complejos utilizando clases y objetos, además de mostrar cómo se puede estructurar una interfaz de línea de comandos simple para permitir la interacción del usuario con los datos. Es un buen ejemplo para estudiantes de programación que están aprendiendo sobre el uso de clases en Python y cómo gestionar listas de objetos.

`016-chivamos el id.py`

```python
class Cliente():
  def __init__(self,nombre,apellidos,email):
    self.nombre = nombre
    self.apellidos = apellidos
    self.email = email

print("###### Gestión de clientes v0.1 ######")
print("####### Jose Vicente Carratala  ######")

clientes = []

while True:
  print("Escoge una opción:")
  print("1.-Insertar un cliente")
  print("2.-Listar clientes")
  print("3.-Actualizar un cliente")
  print("4.-Eliminar un cliente")
  opcion = int(input("Escoge una opcion: "))
  
  if opcion == 1:
    nombre = input("Introduce el nombre: ")
    apellidos = input("Introduce los apellidos: ")
    email = input("Introduce el email: ")
    clientes.append(Cliente(nombre,apellidos,email))
  elif opcion == 2:
    identificador = 0
    for cliente in clientes:
      print("Este es el cliente con ID:",identificador)
      print(cliente.nombre,cliente.apellidos,cliente.email)
      identificador += 1
  elif opcion == 3:
    identificador = int(input("Introduce el id para modificar: "))
    nombre = input("Introduce el nombre: ")
    apellidos = input("Introduce los apellidos: ")
    email = input("Introduce el email: ")
    clientes[identificador].nombre = nombre
    clientes[identificador].apellidos = apellidos
    clientes[identificador].email = email
  elif opcion == 4:
    pass
```

### eliminar elemento
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código es una pequeña aplicación en Python que permite gestionar un listado de clientes. Se utiliza la clase `Cliente` para representar a cada cliente y contiene atributos como nombre, apellidos y email. La aplicación muestra un menú con cuatro opciones: insertar un nuevo cliente, listar todos los clientes existentes, actualizar información de un cliente específico o eliminar un cliente por su identificador.

Cuando el usuario selecciona la opción 4 (eliminar un cliente), se le pide que introduzca el ID del cliente que desea eliminar. Sin embargo, en lugar de usar una función correcta para eliminar elementos de una lista como `pop()`, el código intenta usar `splice()` que es una función común en JavaScript pero no existe en Python.

Es importante corregir la opción 4 para que utilice la función adecuada en Python, es decir, `del clientes[identificador]` o `clientes.pop(identificador)` para eliminar correctamente el cliente seleccionado de la lista. Esto asegura que los datos estén actualizados y que se pueda seguir gestionando la lista de clientes sin errores.

Este tipo de aplicación te enseña a manejar interacción con el usuario, trabajar con clases en Python y realizar operaciones en listas. Es un ejemplo básico pero muy útil para entender cómo estructurar programas más complejos que involucran gestión de datos y entrada/salida del usuario.

`017-eliminar elemento.py`

```python
class Cliente():
  def __init__(self,nombre,apellidos,email):
    self.nombre = nombre
    self.apellidos = apellidos
    self.email = email

print("###### Gestión de clientes v0.1 ######")
print("####### Jose Vicente Carratala  ######")

clientes = []

while True:
  print("Escoge una opción:")
  print("1.-Insertar un cliente")
  print("2.-Listar clientes")
  print("3.-Actualizar un cliente")
  print("4.-Eliminar un cliente")
  opcion = int(input("Escoge una opcion: "))
  
  if opcion == 1:
    nombre = input("Introduce el nombre: ")
    apellidos = input("Introduce los apellidos: ")
    email = input("Introduce el email: ")
    clientes.append(Cliente(nombre,apellidos,email))
  elif opcion == 2:
    identificador = 0
    for cliente in clientes:
      print("Este es el cliente con ID:",identificador)
      print(cliente.nombre,cliente.apellidos,cliente.email)
      identificador += 1
  elif opcion == 3:
    identificador = int(input("Introduce el id para modificar: "))
    nombre = input("Introduce el nombre: ")
    apellidos = input("Introduce los apellidos: ")
    email = input("Introduce el email: ")
    clientes[identificador].nombre = nombre
    clientes[identificador].apellidos = apellidos
    clientes[identificador].email = email
  elif opcion == 4:
    identificador = int(input("Introduce el id para eliminar: "))
    clientes.splice(identificador,1)
```

### confirmacion
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código es una pequeña aplicación en Python que permite gestionar la información de clientes a través de un menú interactivo. Comienza creando una clase llamada `Cliente`, la cual almacena tres atributos importantes: nombre, apellidos y email del cliente. Después, el programa muestra un menú con opciones para insertar nuevos clientes, listar los existentes, actualizar información de un cliente específico o eliminar a un cliente.

El menú se mantiene activo en un bucle `while True`, lo que significa que el usuario puede realizar varias operaciones hasta que decida cerrar la aplicación manualmente. Para cada opción seleccionada por el usuario, el programa solicita entradas específicas y ejecuta las acciones correspondientes:

- **Insertar un cliente:** Pide al usuario que introduzca el nombre, apellidos y email del nuevo cliente, luego crea una instancia de `Cliente` con esos datos y la agrega a una lista llamada `clientes`.
  
- **Listar clientes:** Itera sobre cada objeto en la lista `clientes`, mostrando los detalles de cada uno. Los objetos se muestran junto con un identificador numérico que indica su posición en la lista.

- **Actualizar un cliente:** Solicita al usuario el número del identificador (ID) para localizar a qué cliente desea modificar. Luego pide nuevos valores para nombre, apellidos y email, y actualiza los datos correspondientes en el objeto `Cliente`.

- **Eliminar un cliente:** Similar a la opción de actualizar, solicita primero el ID del cliente que se quiere eliminar. Sin embargo, antes de borrarlo, muestra una confirmación para asegurar que es lo que realmente desea hacer.

En la opción 4 (eliminar), hay un pequeño error en Python ya que no existe el método `splice` en listas como ocurre en otros lenguajes como JavaScript. En Python se utilizaría `del clientes[identificador]` o `clientes.pop(identificador)` para eliminar correctamente un elemento de la lista según su índice.

Esta aplicación es útil para entender cómo manejar entradas y salidas desde el usuario, trabajar con clases en Python y gestionar colecciones de datos estructurados.

`018-confirmacion.py`

```python
class Cliente():
  def __init__(self,nombre,apellidos,email):
    self.nombre = nombre
    self.apellidos = apellidos
    self.email = email

print("###### Gestión de clientes v0.1 ######")
print("####### Jose Vicente Carratala  ######")

clientes = []

while True:
  print("Escoge una opción:")
  print("1.-Insertar un cliente")
  print("2.-Listar clientes")
  print("3.-Actualizar un cliente")
  print("4.-Eliminar un cliente")
  opcion = int(input("Escoge una opcion: "))
  
  if opcion == 1:
    nombre = input("Introduce el nombre: ")
    apellidos = input("Introduce los apellidos: ")
    email = input("Introduce el email: ")
    clientes.append(Cliente(nombre,apellidos,email))
  elif opcion == 2:
    identificador = 0
    for cliente in clientes:
      print("Este es el cliente con ID:",identificador)
      print(cliente.nombre,cliente.apellidos,cliente.email)
      identificador += 1
  elif opcion == 3:
    identificador = int(input("Introduce el id para modificar: "))
    nombre = input("Introduce el nombre: ")
    apellidos = input("Introduce los apellidos: ")
    email = input("Introduce el email: ")
    clientes[identificador].nombre = nombre
    clientes[identificador].apellidos = apellidos
    clientes[identificador].email = email
  elif opcion == 4:
    identificador = int(input("Introduce el id para eliminar: "))
    confirmacion = input("¿Estás seguro? (S/N): ")
    if confirmacion == "S":
      clientes.splice(identificador,1)
    elif confirmacion == "N":
      print("Cancelado")
    else:
      print("Opción no válida")
```

### mayusculas minusculas
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código es una aplicación simple para gestionar la información de los clientes utilizando un menú en pantalla. La aplicación permite a un usuario realizar operaciones básicas como insertar, listar, actualizar y eliminar registros de clientes.

La clase `Cliente` se define al inicio del programa con tres atributos: nombre, apellidos y email. Estos datos se capturan cuando el usuario selecciona la opción para insertar un nuevo cliente. Los objetos de esta clase se añaden a una lista llamada `clientes`.

El bucle `while True` crea un menú interactivo que muestra opciones al usuario y permite elegir entre las acciones disponibles: insertar, listar, actualizar o eliminar clientes. Cada opción tiene su lógica asociada:

- Si el usuario selecciona la opción 1 (insertar), se solicitan los datos del cliente y se añade un nuevo objeto `Cliente` a la lista.
  
- La opción 2 (listar) imprime en pantalla todos los clientes almacenados, mostrando sus detalles como nombre, apellidos y email.

- Al seleccionar la opción 3 (actualizar), el usuario debe introducir el ID del cliente que desea modificar y luego proporcionar nuevos datos para actualizar.

- Para eliminar un cliente (opción 4), se pide al usuario el ID del registro a borrar. Antes de realizar la eliminación, se le solicita confirmación para prevenir errores no intencionados.

Es importante destacar que hay una línea incorrecta en el código: `clientes.splice(identificador,1)`. Este método no existe en Python; deberías usar `del clientes[identificador]` para eliminar un elemento de la lista por índice.

`019.mayusculas minusculas.py`

```python
class Cliente():
  def __init__(self,nombre,apellidos,email):
    self.nombre = nombre
    self.apellidos = apellidos
    self.email = email

print("###### Gestión de clientes v0.1 ######")
print("####### Jose Vicente Carratala  ######")

clientes = []

while True:
  print("Escoge una opción:")
  print("1.-Insertar un cliente")
  print("2.-Listar clientes")
  print("3.-Actualizar un cliente")
  print("4.-Eliminar un cliente")
  opcion = int(input("Escoge una opcion: "))
  
  if opcion == 1:
    nombre = input("Introduce el nombre: ")
    apellidos = input("Introduce los apellidos: ")
    email = input("Introduce el email: ")
    clientes.append(Cliente(nombre,apellidos,email))
  elif opcion == 2:
    identificador = 0
    for cliente in clientes:
      print("Este es el cliente con ID:",identificador)
      print(cliente.nombre,cliente.apellidos,cliente.email)
      identificador += 1
  elif opcion == 3:
    identificador = int(input("Introduce el id para modificar: "))
    nombre = input("Introduce el nombre: ")
    apellidos = input("Introduce los apellidos: ")
    email = input("Introduce el email: ")
    clientes[identificador].nombre = nombre
    clientes[identificador].apellidos = apellidos
    clientes[identificador].email = email
  elif opcion == 4:
    identificador = int(input("Introduce el id para eliminar: "))
    confirmacion = input("¿Estás seguro? (S/N): ")
    if confirmacion == "S" or confirmacion == "s":
      clientes.splice(identificador,1)
    elif confirmacion == "N" or confirmacion == "n":
      print("Cancelado")
    else:
      print("Opción no válida")
```

### lower
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código Python es una pequeña aplicación de línea de comandos que gestiona una lista de clientes. La estructura principal utiliza un bucle `while` para mantener el programa en ejecución y ofrece al usuario cuatro opciones: insertar, listar, actualizar y eliminar clientes.

El programa define primero una clase llamada `Cliente`, la cual tiene atributos como nombre, apellidos y email. Estos datos se usan para crear objetos de tipo cliente que luego se añaden a una lista global llamada `clientes`.

Cuando el usuario selecciona la opción 1 (Insertar un cliente), se le pide que introduzca el nombre, los apellidos y el correo electrónico del nuevo cliente. Esta información es utilizada para crear un objeto `Cliente` que se agrega a la lista de clientes.

La opción 2 (Listar clientes) itera sobre cada objeto en la lista y muestra los detalles del cliente en pantalla junto con su identificador único, que se genera basado en el índice de la lista donde está almacenado el cliente.

Opción 3 (Actualizar un cliente) permite al usuario modificar los datos de un cliente existente seleccionándolo por su ID. Introduce nuevas cadenas para nombre, apellidos y correo electrónico, las cuales reemplazan los valores antiguos en el objeto correspondiente.

Finalmente, la opción 4 (Eliminar un cliente) proporciona una forma segura de eliminar a un cliente de la lista. El usuario debe confirmar su decisión introduciendo 's' para confirmar o 'n' para cancelar la operación. Sin embargo, hay un error en este código: `clientes.splice(identificador,1)` no es válido en Python. En lugar de esto, se debería usar `del clientes[identificador]` para eliminar el cliente correspondiente.

Esta aplicación simple pero funcional ayuda a entender cómo manejar objetos y listas en Python, así como cómo interactuar con el usuario mediante entradas y salidas estándar.

`020-lower.py`

```python
class Cliente():
  def __init__(self,nombre,apellidos,email):
    self.nombre = nombre
    self.apellidos = apellidos
    self.email = email

print("###### Gestión de clientes v0.1 ######")
print("####### Jose Vicente Carratala  ######")

clientes = []

while True:
  print("Escoge una opción:")
  print("1.-Insertar un cliente")
  print("2.-Listar clientes")
  print("3.-Actualizar un cliente")
  print("4.-Eliminar un cliente")
  opcion = int(input("Escoge una opcion: "))
  
  if opcion == 1:
    nombre = input("Introduce el nombre: ")
    apellidos = input("Introduce los apellidos: ")
    email = input("Introduce el email: ")
    clientes.append(Cliente(nombre,apellidos,email))
  elif opcion == 2:
    identificador = 0
    for cliente in clientes:
      print("Este es el cliente con ID:",identificador)
      print(cliente.nombre,cliente.apellidos,cliente.email)
      identificador += 1
  elif opcion == 3:
    identificador = int(input("Introduce el id para modificar: "))
    nombre = input("Introduce el nombre: ")
    apellidos = input("Introduce los apellidos: ")
    email = input("Introduce el email: ")
    clientes[identificador].nombre = nombre
    clientes[identificador].apellidos = apellidos
    clientes[identificador].email = email
  elif opcion == 4:
    identificador = int(input("Introduce el id para eliminar: "))
    confirmacion = input("¿Estás seguro? (S/N): ").lower()
    if confirmacion == "s":
      clientes.splice(identificador,1)
    elif confirmacion == "n":
      print("Cancelado")
    else:
      print("Opción no válida")
```

### cambiamos splice por pop
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código es un programa en Python que gestiona una lista de clientes. Comienza creando una clase llamada `Cliente` con tres atributos: nombre, apellidos y email. Luego, el programa entra en un bucle infinito (`while True`) donde muestra un menú al usuario para interactuar con la lista de clientes.

1. **Menú Interactivo:** El menú permite al usuario realizar cuatro acciones:
   - Insertar un nuevo cliente: Pide al usuario que introduzca el nombre, apellidos y email del cliente, luego crea una instancia de `Cliente` y la añade a la lista `clientes`.
   - Listar clientes: Recorre la lista de clientes e imprime los detalles de cada uno junto con su identificador (índice en la lista).
   - Actualizar un cliente: Solicita al usuario que introduzca el ID del cliente que desea actualizar y luego permite cambiar sus atributos (nombre, apellidos y email).
   - Eliminar un cliente: Pide al usuario que introduzca el ID del cliente a eliminar y verifica si está seguro de la acción antes de borrarlo.

2. **Eliminación de clientes:** La función `pop()` se utiliza para eliminar un elemento en una posición específica dentro de la lista `clientes`. Esto es más claro y eficiente que usar `splice`, que no existe en Python, para este propósito.

Este programa demuestra cómo manejar datos complejos (como objetos de clase) dentro de estructuras de datos simples (como listas), además de proporcionar un menú interactivo sencillo para gestionar esos datos. Es importante porque muestra cómo pueden combinarse diferentes conceptos de programación en una aplicación práctica y fácil de usar.

`021-cambiamos splice por pop.py`

```python
class Cliente():
  def __init__(self,nombre,apellidos,email):
    self.nombre = nombre
    self.apellidos = apellidos
    self.email = email

print("###### Gestión de clientes v0.1 ######")
print("####### Jose Vicente Carratala  ######")

clientes = []

while True:
  print("Escoge una opción:")
  print("1.-Insertar un cliente")
  print("2.-Listar clientes")
  print("3.-Actualizar un cliente")
  print("4.-Eliminar un cliente")
  opcion = int(input("Escoge una opcion: "))
  
  if opcion == 1:
    nombre = input("Introduce el nombre: ")
    apellidos = input("Introduce los apellidos: ")
    email = input("Introduce el email: ")
    clientes.append(Cliente(nombre,apellidos,email))
  elif opcion == 2:
    identificador = 0
    for cliente in clientes:
      print("Este es el cliente con ID:",identificador)
      print(cliente.nombre,cliente.apellidos,cliente.email)
      identificador += 1
  elif opcion == 3:
    identificador = int(input("Introduce el id para modificar: "))
    nombre = input("Introduce el nombre: ")
    apellidos = input("Introduce los apellidos: ")
    email = input("Introduce el email: ")
    clientes[identificador].nombre = nombre
    clientes[identificador].apellidos = apellidos
    clientes[identificador].email = email
  elif opcion == 4:
    identificador = int(input("Introduce el id para eliminar: "))
    confirmacion = input("¿Estás seguro? (S/N): ").lower()
    if confirmacion == "s":
      clientes.pop(identificador)
    elif confirmacion == "n":
      print("Cancelado")
    else:
      print("Opción no válida")
```

### guardamos con pickle
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código es una aplicación simple para gestionar datos de clientes utilizando la estructura de clases en Python. La aplicación permite al usuario realizar varias operaciones como insertar un nuevo cliente, listar todos los clientes existentes, actualizar información de un cliente específico y eliminar a un cliente.

El programa comienza importando el módulo `pickle`, que se utiliza para guardar datos permanentemente en archivos binarios. A continuación, define una clase llamada `Cliente` con atributos como nombre, apellidos y email. Estos atributos son inicializados mediante el método especial `__init__`.

La aplicación principal es un bucle `while True` que presenta al usuario cuatro opciones: insertar un cliente nuevo, listar clientes existentes, actualizar la información de un cliente o eliminar a un cliente específico. Cada opción se maneja dentro de una estructura `if-elif-else`, permitiendo al usuario interactuar con los datos según lo deseen.

Lo importante aquí es cómo el programa permite gestionar eficientemente objetos de tipo `Cliente` en una lista y cómo proporciona diferentes opciones para manipular esos objetos. Además, este código establece las bases para futuras mejoras, como la persistencia de datos a través del módulo `pickle`, que permitirá que los datos se guarden entre sesiones del programa.

Este tipo de aplicación es fundamental en el aprendizaje de programación orientada a objetos y gestión de información, proporcionando un escenario práctico para entender cómo las clases pueden ser utilizadas para representar entidades reales y cómo se puede interactuar con ellas mediante métodos de entrada y salida.

`022-guardamos con pickle.py`

```python
import pickle

class Cliente():
  def __init__(self,nombre,apellidos,email):
    self.nombre = nombre
    self.apellidos = apellidos
    self.email = email

print("###### Gestión de clientes v0.1 ######")
print("####### Jose Vicente Carratala  ######")

clientes = []


while True:
  print("Escoge una opción:")
  print("1.-Insertar un cliente")
  print("2.-Listar clientes")
  print("3.-Actualizar un cliente")
  print("4.-Eliminar un cliente")
  opcion = int(input("Escoge una opcion: "))
  
  if opcion == 1:
    nombre = input("Introduce el nombre: ")
    apellidos = input("Introduce los apellidos: ")
    email = input("Introduce el email: ")
    clientes.append(Cliente(nombre,apellidos,email))
  elif opcion == 2:
    identificador = 0
    for cliente in clientes:
      print("Este es el cliente con ID:",identificador)
      print(cliente.nombre,cliente.apellidos,cliente.email)
      identificador += 1
  elif opcion == 3:
    identificador = int(input("Introduce el id para modificar: "))
    nombre = input("Introduce el nombre: ")
    apellidos = input("Introduce los apellidos: ")
    email = input("Introduce el email: ")
    clientes[identificador].nombre = nombre
    clientes[identificador].apellidos = apellidos
    clientes[identificador].email = email
  elif opcion == 4:
    identificador = int(input("Introduce el id para eliminar: "))
    confirmacion = input("¿Estás seguro? (S/N): ").lower()
    if confirmacion == "s":
      clientes.pop(identificador)
    elif confirmacion == "n":
      print("Cancelado")
    else:
      print("Opción no válida")
```

### cargo registros si existen
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es una aplicación sencilla que gestiona un registro de clientes utilizando la programación orientada a objetos en Python. El programa carga registros existentes desde un archivo binario llamado "clientes.dat" usando el módulo `pickle`, si este existe, o muestra un mensaje indicando que no hay datos guardados previamente.

La aplicación proporciona una interfaz interactiva con opciones para insertar nuevos clientes, listar todos los clientes registrados, actualizar información de clientes existentes y eliminar registros. Los datos del cliente se almacenan en una lista llamada `clientes`, donde cada elemento es un objeto de la clase `Cliente` que contiene atributos como nombre, apellidos y email.

El programa utiliza un bucle infinito (`while True`) para mantenerse activo hasta que el usuario decide cerrarla. Dentro del bucle, se solicita al usuario que seleccione una opción y dependiendo de esta, se ejecuta la función correspondiente. Es importante destacar cómo el programa maneja excepciones para asegurarse de que si no existe un archivo de datos (por ejemplo, cuando se inicializa por primera vez), el programa pueda continuar sin errores.

Esta aplicación es útil para entender cómo guardar y recuperar objetos complejos en archivos utilizando `pickle`, así como para aprender sobre la interacción entre clases definidas por el usuario y estructuras de control como bucles y condicionales.

`023-cargo registros si existen.py`

```python
import pickle

class Cliente():
  def __init__(self,nombre,apellidos,email):
    self.nombre = nombre
    self.apellidos = apellidos
    self.email = email

print("###### Gestión de clientes v0.1 ######")
print("####### Jose Vicente Carratala  ######")

clientes = []

try:  #### Ojo que igual no existe el archivo ######
  archivo = open("clientes.dat",'rb')
  clientes = pickle.load(archivo)
except:
  print("No existe archivo de datos")

while True:
  print("Escoge una opción:")
  print("1.-Insertar un cliente")
  print("2.-Listar clientes")
  print("3.-Actualizar un cliente")
  print("4.-Eliminar un cliente")
  opcion = int(input("Escoge una opcion: "))
  
  if opcion == 1:
    nombre = input("Introduce el nombre: ")
    apellidos = input("Introduce los apellidos: ")
    email = input("Introduce el email: ")
    clientes.append(Cliente(nombre,apellidos,email))
  elif opcion == 2:
    identificador = 0
    for cliente in clientes:
      print("Este es el cliente con ID:",identificador)
      print(cliente.nombre,cliente.apellidos,cliente.email)
      identificador += 1
  elif opcion == 3:
    identificador = int(input("Introduce el id para modificar: "))
    nombre = input("Introduce el nombre: ")
    apellidos = input("Introduce los apellidos: ")
    email = input("Introduce el email: ")
    clientes[identificador].nombre = nombre
    clientes[identificador].apellidos = apellidos
    clientes[identificador].email = email
  elif opcion == 4:
    identificador = int(input("Introduce el id para eliminar: "))
    confirmacion = input("¿Estás seguro? (S/N): ").lower()
    if confirmacion == "s":
      clientes.pop(identificador)
    elif confirmacion == "n":
      print("Cancelado")
    else:
      print("Opción no válida")
```

### guardamos
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código es una pequeña aplicación en Python que gestiona información de clientes, permitiendo a un usuario insertar, listar, actualizar y eliminar registros. La estructura comienza importando el módulo `pickle`, que se utiliza para serializar objetos en archivos binarios. Luego, define una clase llamada `Cliente` con tres atributos: nombre, apellidos y email.

El programa carga datos de clientes desde un archivo binario llamado "clientes.bin" si este existe, o simplemente muestra un mensaje indicando que el archivo no existe si aún no se ha creado. Después, entra en un bucle infinito (`while True`) donde presenta un menú con opciones para insertar, listar, actualizar y eliminar clientes.

Para cada opción del menú, solicita información al usuario mediante `input` y realiza las operaciones correspondientes. Por ejemplo, si el usuario elige la opción 1, se le pide que introduzca los detalles de un nuevo cliente (nombre, apellidos, email), y luego se crea una nueva instancia de la clase `Cliente` con estos datos y se añade a la lista `clientes`. Al finalizar cada operación, el programa guarda automáticamente la lista actualizada de clientes en "clientes.bin" usando `pickle.dump()`.

Este código es útil para estudiantes que estén aprendiendo sobre manejo de archivos, clases en Python y cómo trabajar con objetos serializados.

`024-guardamos.py`

```python
import pickle

class Cliente():
  def __init__(self,nombre,apellidos,email):
    self.nombre = nombre
    self.apellidos = apellidos
    self.email = email

print("###### Gestión de clientes v0.1 ######")
print("####### Jose Vicente Carratala  ######")

clientes = []

try:  #### Ojo que igual no existe el archivo ######
  archivo = open("clientes.bin",'rb')
  clientes = pickle.load(archivo)
  archivo.close()
except:
  print("No existe archivo de datos")

while True:
  archivo = open("clientes.bin",'wb')
  pickle.dump(clientes,archivo)
  archivo.close()
  
  print("Escoge una opción:")
  print("1.-Insertar un cliente")
  print("2.-Listar clientes")
  print("3.-Actualizar un cliente")
  print("4.-Eliminar un cliente")
  opcion = int(input("Escoge una opcion: "))
  
  if opcion == 1:
    nombre = input("Introduce el nombre: ")
    apellidos = input("Introduce los apellidos: ")
    email = input("Introduce el email: ")
    clientes.append(Cliente(nombre,apellidos,email))
  elif opcion == 2:
    identificador = 0
    for cliente in clientes:
      print("Este es el cliente con ID:",identificador)
      print(cliente.nombre,cliente.apellidos,cliente.email)
      identificador += 1
  elif opcion == 3:
    identificador = int(input("Introduce el id para modificar: "))
    nombre = input("Introduce el nombre: ")
    apellidos = input("Introduce los apellidos: ")
    email = input("Introduce el email: ")
    clientes[identificador].nombre = nombre
    clientes[identificador].apellidos = apellidos
    clientes[identificador].email = email
  elif opcion == 4:
    identificador = int(input("Introduce el id para eliminar: "))
    confirmacion = input("¿Estás seguro? (S/N): ").lower()
    if confirmacion == "s":
      clientes.pop(identificador)
    elif confirmacion == "n":
      print("Cancelado")
    else:
      print("Opción no válida")
  
```

### argumentos de terminal
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código Python te permite recibir información desde la línea de comandos cuando ejecutas el programa y luego realiza un cálculo simple con esa información. En este caso, el programa espera que le pases un número como argumento al ejecutarlo. Ese número se supone que es tu edad (aunque en realidad puede ser cualquier número entero), y luego el programa calcula y muestra en pantalla el doble de ese número.

Aquí te explico cómo funciona: cuando ejecutas este script desde la terminal, necesitas proporcionar un argumento entre comillas después del nombre del archivo. Este argumento se almacena en una lista llamada `sys.argv`, donde cada elemento es uno de los parámetros que has introducido. En el código, `sys.argv[1]` accede al segundo valor de esta lista (el primer valor sería `sys.argv[0]`, que normalmente sería el nombre del script). El programa convierte ese argumento en un número entero y lo guarda en la variable `edad`. Finalmente, muestra en pantalla el doble de esa edad.

Es importante porque te enseña cómo interactuar con el sistema operativo desde tu código Python, permitiéndote pasar información al programa cuando se ejecuta para que este pueda procesarla. Esto es útil en muchos escenarios donde necesitas configurar o personalizar el comportamiento del programa directamente desde la línea de comandos antes de que empiece a funcionar.

`025-argumentos de terminal.py`

```python
import sys

edad = int(sys.argv[1])
print("El doble de tu edad es:",(edad*2))
```

### Actividades propuestas

Here's a summary and explanation of the progression in the code snippets you've shared:

### Initial Setup (Files 001-003)
The first few files establish the basic structure for managing customer data. They use simple data structures like lists to store customer objects, and the `pickle` module to serialize and deserialize Python objects.

### Adding Interactivity (Files 004-015)
Starting from file 004, the code introduces user interaction:
- **File Input/Output:** The program begins to save and load data between runs.
- **User Interface:** It provides a basic command-line interface for users to interact with the customer database.

### Improving User Experience (Files 016-022)
The focus shifts towards enhancing user experience:
- **Error Handling:** Added try-except blocks to handle file operations more gracefully.
- **Input Validation:** Improved input handling, especially for confirmation prompts.
- **Command-Line Arguments:** The program starts using `sys.argv` to accept command-line arguments.

### Final Version (File 025)
The final version of the code combines all previous improvements and demonstrates how to:
1. Load existing customer data from a file.
2. Provide a simple menu system for CRUD operations.
3. Automatically save changes back to the file when exiting.
4. Accept command-line arguments to run specific functions or tests.

### Key Learnings
- **Data Persistence:** Using `pickle` for saving and loading Python objects to/from files is a common technique in small-scale applications.
- **User Interaction:** Building simple text-based interfaces helps users interact with data management systems effectively.
- **Error Handling:** Proper error handling ensures the program can recover from unexpected situations gracefully.
- **Command-Line Interfaces:** Using `sys.argv` for command-line arguments allows scripts to be more flexible and integrate better with other tools.

This progression demonstrates how a basic application can evolve from simple data storage to a robust system capable of handling user input, errors, and external parameters.


<a id="interfaces-graficas"></a>
## Interfaces gráficas

### Introducción a los ejercicios

En esta carpeta, se encuentran una serie de ejercicios que tienen como objetivo familiarizarte con la creación y manipulación de interfaces gráficas en Python utilizando la biblioteca Tkinter. Los ejercicios comienzan con la creación básica de ventanas y botones, para luego avanzar hacia el manejo de eventos, cambios dinámicos en las etiquetas y finalmente, la implementación de una sencilla calculadora que realiza operaciones matemáticas básicas.

A lo largo del conjunto de ejercicios, aprenderás a crear widgets (como entradas de texto y botones), gestionar su disposición en la interfaz gráfica, vincular eventos con funciones para responder a acciones del usuario e interactuar con los elementos visuales de la aplicación. Esto te permitirá adquirir competencias fundamentales en el diseño y desarrollo de interfaces de usuario simples utilizando Tkinter.

### tkinter
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es el inicio básico para crear una interfaz gráfica utilizando la biblioteca `tkinter` en Python. Lo que hace este código es abrir una ventana vacía donde podrás agregar más componentes como botones, etiquetas y cuadros de texto después.

El primer paso es importar la biblioteca `tkinter`, que se encarga de manejar las ventanas y los elementos gráficos del usuario en aplicaciones Python. A continuación, creas una instancia de la clase `Tk()` que representa la ventana principal. Luego, llamamos a `ventana.mainloop()`. Esta función es crucial porque mantiene abierta la aplicación esperando interacciones del usuario; sin ella, la aplicación se cerraría automáticamente tan pronto como se crea la ventana.

Este código básico establece las bases para aprender a crear interfaces gráficas más complejas en Python, añadiendo elementos y funcionalidades conforme avanzas. Es importante entenderlo porque te permite visualizar los efectos de cada línea de código que añadas después para personalizar esta ventana.

`001-tkinter.py`

```python
# sudo apt-get install python3-tk
import tkinter as tk

ventana = tk.Tk()

ventana.mainloop() # No te salgas
```

### creamos un boton
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código crea una pequeña interfaz gráfica en Python utilizando la biblioteca `tkinter`. La función principal es mostrar una ventana con un botón que tiene el texto "Pulsame si te atreves". Cuando ejecutas este programa, se genera una ventana con un botón dentro de ella. El método `pack()` se utiliza para organizar el botón en la ventana, y los parámetros `padx` y `pady` añaden espacios alrededor del botón para separarlo del borde de la ventana.

La línea `ventana.mainloop()` es crucial porque mantiene abierta la ventana hasta que se cierre manualmente. Esto permite a Python esperar cualquier interacción del usuario, como hacer clic en el botón. Sin esta línea, la ventana aparecería y desaparecería muy rápidamente.

Este tipo de código es importante para aprender cómo interactuar con interfaces gráficas básicas en aplicaciones, permitiendo que los usuarios hagan cosas simples como iniciar acciones al presionar un botón.

`002-creamos un boton.py`

```python
# sudo apt-get install python3-tk
import tkinter as tk

ventana = tk.Tk()

tk.Button(ventana,text="Pulsame si te atreves").pack(padx=10,pady=10)

ventana.mainloop() # No te salgas
```

### command en el boton
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código crea una interfaz gráfica simple utilizando la biblioteca `tkinter` en Python. La función principal es generar una ventana con un botón que, al ser pulsado, ejecuta una acción definida previamente (en este caso, se supone que hay una función llamada `accion`, aunque no está mostrada en el código proporcionado).

El código comienza importando la biblioteca `tkinter` y creando una ventana principal (`ventana = tk.Tk()`). Luego, añade un botón a esta ventana. Este botón tiene el texto "Pulsame si te atreves" y está configurado para ejecutar la función `accion` cuando se pulsa. Finalmente, el método `mainloop()` inicia el bucle principal de eventos que permite al programa responder a las interacciones del usuario.

Es importante entender cómo enlazar elementos gráficos (como botones) con funciones de programación, ya que esto es fundamental para crear aplicaciones interactivas y dinámicas.

`003-command en el boton.py`

```python
# sudo apt-get install python3-tk
import tkinter as tk

ventana = tk.Tk()

tk.Button(ventana,text="Pulsame si te atreves",command=accion).pack(padx=10,pady=10)

ventana.mainloop() # No te salgas
```

### definimos accion
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código crea una simple interfaz gráfica utilizando la biblioteca `tkinter` en Python. La función principal es mostrar una ventana con un botón y hacer algo cuando se pulse el botón.

En primer lugar, importamos la biblioteca `tkinter` que nos permite crear interfaces gráficas de usuario. Luego, definimos una función llamada `accion()` que imprime "Has pulsado el boton" en la consola cada vez que se llama.

La línea `ventana = tk.Tk()` crea un objeto de ventana principal. A continuación, creamos un botón utilizando `tk.Button()`, configurándolo para que cuando se pulse, llame a la función `accion()`. El método `.pack(padx=10,pady=10)` lo añade a la ventana con cierto margen para mejorar su apariencia.

Finalmente, llamamos a `ventana.mainloop()` para iniciar el bucle principal de eventos que permite interactuar con la ventana hasta que se cierre. Este método es crucial porque mantiene la aplicación en ejecución y responde a las acciones del usuario, como pulsar el botón.

Este código es importante porque muestra cómo crear una interfaz básica con `tkinter`, vincular acciones del usuario (como hacer clic en un botón) a funciones definidas por nosotros, y mantener la ventana abierta para que los usuarios puedan interactuar con ella.

`004-definimos accion.py`

```python
# sudo apt-get install python3-tk
import tkinter as tk

def accion():
  print("Has pulsado el boton")

ventana = tk.Tk()

tk.Button(ventana,text="Pulsame si te atreves",command=accion).pack(padx=10,pady=10)

ventana.mainloop() # No te salgas
```

### ponemos una etiqueta
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código crea una pequeña aplicación de interfaz gráfica usando la biblioteca `tkinter` en Python. Lo que hace es mostrar una ventana con un botón y una etiqueta.

Primero, el programa importa la biblioteca `tkinter`, que se usa para crear interfaces gráficas de usuario en aplicaciones de Python. Luego define una función llamada `accion()` que simplemente imprime "Has pulsado el boton" cuando es llamada.

La siguiente parte del código crea una ventana usando `tk.Tk()`. A continuación, se añade un botón a la ventana. Este botón tiene texto que dice "Pulsame si te atreves", y está configurado para llamar a la función `accion()` cuando el usuario hace clic en él. El método `.pack(padx=10,pady=10)` se usa para ajustar visualmente el espacio alrededor del botón, haciéndolo más fácil de ver.

Después de eso, se añade una etiqueta a la ventana con el texto "¿Has pulsado el botón?". Esta etiqueta no hace nada por sí misma, pero puede ser útil para mostrar información o instrucciones en la interfaz del usuario. Como con el botón, `.pack(padx=10,pady=10)` se utiliza aquí también para darle espacio a la etiqueta.

Finalmente, `ventana.mainloop()` es llamada para iniciar un bucle de eventos que mantiene la ventana abierta y permite que la aplicación responda interactivamente a los clics del usuario. Es importante mantener esta línea al final para asegurar que la ventana permanezca visible hasta que el usuario decida cerrarla.

`005-ponemos una etiqueta.py`

```python
# sudo apt-get install python3-tk
import tkinter as tk

def accion():
  print("Has pulsado el boton")

ventana = tk.Tk()

tk.Button(ventana,text="Pulsame si te atreves",command=accion).pack(padx=10,pady=10)

etiqueta = tk.Label(text="¿Has pulsado el botón?")
etiqueta.pack(padx=10,pady=10)

ventana.mainloop() # No te salgas
```

### salida en pantalla
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código Python utiliza la biblioteca `tkinter` para crear una interfaz gráfica simple. Cuando se ejecuta, aparece una ventana con un botón y un texto inicial debajo del botón que dice "¿Has pulsado el botón?". Si haces clic en el botón, el texto cambia a "Pues sí que has pulsado el botón".

El código define una función llamada `accion()` que se encarga de cambiar el texto de la etiqueta cada vez que el botón es presionado. La línea `tk.Button(ventana,text="Pulsame si te atreves",command=accion).pack(padx=10,pady=10)` crea un botón dentro de la ventana principal y le asigna a este botón la función `accion()` como respuesta al ser clickeado. La línea `etiqueta = tk.Label(text="¿Has pulsado el botón?")` crea una etiqueta (un elemento de texto) que inicialmente muestra una pregunta, y luego esa etiqueta se actualiza con la nueva frase cuando el usuario hace clic en el botón.

Este tipo de código es importante porque te permite crear programas interactivos donde los usuarios pueden interactuar con elementos visuales, como un botón para ejecutar ciertas acciones. Es fundamental para desarrollar aplicaciones más complejas que requieren una interfaz gráfica amigable y accesible.

`006-salida en pantalla.py`

```python
# sudo apt-get install python3-tk
import tkinter as tk

def accion():
  etiqueta.config(text="Pues sí que has pulsado el botón")

ventana = tk.Tk()

tk.Button(ventana,text="Pulsame si te atreves",command=accion).pack(padx=10,pady=10)

etiqueta = tk.Label(text="¿Has pulsado el botón?")
etiqueta.pack(padx=10,pady=10)

ventana.mainloop() # No te salgas
```

### microcalculadura
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código crea una pequeña interfaz gráfica utilizando la biblioteca `tkinter` en Python. La interfaz contiene dos cuadros de entrada (Entry) para que el usuario introduzca números, un botón con la etiqueta "Calcular!", y una etiqueta donde se mostrará el resultado.

El código primero importa la biblioteca `tkinter`, que es necesaria para crear interfaces gráficas. Luego, crea una ventana principal (`ventana`) en la que se van a colocar los componentes de la interfaz.

En seguida, se añaden dos cuadros de entrada (Entry) que permiten al usuario introducir datos numéricos. Estos cuadros están dispuestos con un espacio de padding para que la interfaz sea más agradable visualmente.

Luego, se agrega un botón con el texto "Calcular!". Este botón no tiene una función asociada en este fragmento de código, por lo que pulsar sobre él no hará nada.

Finalmente, hay una etiqueta (`Label`) donde debería mostrarse el resultado después del cálculo. Sin embargo, en esta versión inicial de la interfaz, esta etiqueta simplemente muestra un texto estático y no cambiará cuando se pulse el botón.

El método `mainloop()` es crucial porque mantiene abierta la ventana principal y espera interacciones del usuario, como introducir datos o pulsar el botón. Sin él, la interfaz gráfica desaparecería de inmediato después de ser creada.

Este código proporciona una base para construir una calculadora simple que permita al usuario introducir dos números, calcular su suma (o cualquier otra operación) y mostrar el resultado en la etiqueta.

`007-microcalculadura.py`

```python
# sudo apt-get install python3-tk
import tkinter as tk

ventana = tk.Tk()

operando1 = tk.Entry()
operando1.pack(padx=10,pady=10)

operando2 = tk.Entry()
operando2.pack(padx=10,pady=10)

boton = tk.Button(text="Calcular!")
boton.pack(padx=10,pady=10)

resultado = tk.Label(text="Aqui va el resultado")
resultado.pack(padx=10,pady=10)

ventana.mainloop() # No te salgas
```

### calcular
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código crea una interfaz gráfica simple utilizando la biblioteca `tkinter` en Python. La aplicación tiene un objetivo específico: permitir al usuario ingresar dos números, calcular su suma y mostrar el resultado.

El programa comienza creando una ventana principal usando `tk.Tk()`. Luego, se añaden dos campos de entrada (Entry) para que el usuario pueda introducir los valores numéricos. Estos campos se posicionan en la ventana con el método `.pack()` que organiza y acomoda widgets automáticamente.

A continuación, se agrega un botón con el texto "Calcular!". Este botón está vinculado a una función llamada `calcular()`, que es la encargada de recoger los valores introducidos por el usuario en los campos de entrada, convertirlos a números flotantes (para permitir decimales), sumarlos y mostrar el resultado en un widget Label.

La función `calcular()` se activa cuando el usuario hace clic en el botón. El resultado aparece en una etiqueta (`Label`) que también está en la ventana, actualizando su texto con la suma de los números ingresados.

Finalmente, el método `ventana.mainloop()` mantiene abierta y operativa la interfaz gráfica hasta que se cierre manualmente por el usuario. Este es un paso crucial para permitir interacción continua entre el usuario y la aplicación.

`008-calcular.py`

```python
# sudo apt-get install python3-tk
import tkinter as tk

def calcular():
  op1valor = float(operando1.get())
  op2valor = float(operando2.get())
  suma = op1valor + op2valor
  resultado.config(text=str(suma))

ventana = tk.Tk()

operando1 = tk.Entry()
operando1.pack(padx=10,pady=10)

operando2 = tk.Entry()
operando2.pack(padx=10,pady=10)

boton = tk.Button(text="Calcular!",command=calcular)
boton.pack(padx=10,pady=10)

resultado = tk.Label(text="Aqui va el resultado")
resultado.pack(padx=10,pady=10)

ventana.mainloop() # No te salgas
```

### Actividades propuestas

### Actividad 1: Creación de una Ventana Básica con Tkinter
**Descripción:** Crea una ventana básica utilizando la biblioteca `tkinter` en Python. Tu objetivo es entender cómo iniciar y mantener abierta una interfaz gráfica simple.

---

### Actividad 2: Agregar un Botón a la Interfaz
**Descripción:** Añade un botón a tu aplicación existente. Cuando el usuario haga clic en él, se debe mostrar un mensaje sencillo para entender cómo funcionan los eventos en `tkinter`.

---

### Actividad 3: Asociar una Función al Botón
**Descripción:** Modifica la funcionalidad del botón de tal manera que cuando sea presionado, llame a una función definida por ti. Esta actividad te ayudará a aprender cómo vincular acciones con funciones en `tkinter`.

---

### Actividad 4: Actualizar Etiquetas Interactivas
**Descripción:** Implementa un botón que al ser pulsado actualice el texto de una etiqueta (label) de la interfaz gráfica. Aprenderás a manipular elementos visuales dinámicamente.

---

### Actividad 5: Creación de Entradas y Salidas en Interfaz
**Descripción:** Diseña un programa que permita al usuario introducir texto mediante cajas de entrada (Entry) y luego mostrarlo en una etiqueta. Esta actividad te ayudará a comprender cómo interactúan los diferentes componentes gráficos.

---

### Actividad 6: Microcalculadora Sencilla
**Descripción:** Desarrolla un programa que permita sumar dos números introducidos por el usuario y mostrar el resultado en una etiqueta. Esta actividad te enseñará a manipular datos numéricos y actualizar la interfaz gráfica.

---

### Actividad 7: Mejora de Interfaz con Etiquetas Dinámicas
**Descripción:** A partir del programa microcalculadora, modifica las etiquetas para que muestren mensajes informativos antes y después de realizar una operación. Esto ayudará a mejorar la interactividad y claridad de tu aplicación.

---

### Actividad 8: Introducción al Event-Driven Programming
**Descripción:** Refuerza tus conocimientos sobre el manejo de eventos en `tkinter` creando varios botones que respondan a diferentes acciones. Aprenderás cómo organizar funciones para responder a múltiples interacciones del usuario.

---

### Actividad 9: Diseño y Posicionamiento Avanzado
**Descripción:** Mejora la disposición visual de tu interfaz gráfica modificando los parámetros de `pack` o utilizando otros métodos de disposición como `grid`. Aprenderás a diseñar interfaces más complejas y atractivas.

---

### Actividad 10: Aplicación Interactiva Completa
**Descripción:** Integra todos los conceptos aprendidos en una aplicación interactiva que permita al usuario realizar varias operaciones matemáticas básicas. Esta actividad te ayudará a practicar la creación de interfaces complejas y funcionales.

---

Estas actividades están diseñadas para llevar gradualmente a los estudiantes desde principiantes hasta creadores capaces de desarrollar aplicaciones interactivas completas utilizando `tkinter` en Python, adaptándose al nivel de Formación Profesional.


<a id="concepto-de-evento"></a>
## Concepto de evento

### Introducción a los ejercicios

Esta carpeta contiene una serie de ejercicios que te ayudarán a familiarizarte con la creación y manipulación de interfaces gráficas en Python utilizando Tkinter, así como el manejo de bases de datos MySQL. Los problemas se centran en la implementación de formularios interactivos para la inserción de datos y la visualización de registros almacenados en una base de datos. A lo largo de los ejercicios, practicarás cómo vincular eventos del usuario (como hacer clic en un botón) con acciones programáticas que insertan o recuperan información desde una base de datos. Además, aprenderás a utilizar Treeview para representar tablas de datos y mejorar la interfaz gráfica con temas estilizados mediante ttkbootstrap.

Estos ejercicios te permitirán desarrollar habilidades clave en programación orientadas al uso práctico del desarrollo web e interfaces de usuario en entornos empresariales.

### recordamos
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código es una introducción básica al uso de la biblioteca `tkinter`, que se utiliza para crear interfaces gráficas en Python. En este caso, el programa crea una ventana simple y la muestra en pantalla.

La primera línea del código importa el módulo `tkinter` con un alias `tk`, lo cual facilita escribir las siguientes líneas de código al referirse a esta biblioteca.

Luego, se crea una instancia de la clase `Tk()` que es la ventana principal. Al guardarla en la variable `ventana`, puedes manipular o personalizar esta ventana más adelante si es necesario.

Finalmente, el método `mainloop()` se llama en la ventana recién creada. Este método es crucial porque mantiene la aplicación en ejecución y maneja los eventos como clics del ratón o teclas presionadas que ocurren dentro de la ventana. Sin este método, la ventana desaparecería inmediatamente después de abrirse.

Este código básico sirve para entender cómo iniciar un proyecto con `tkinter` y establece las bases para agregar más elementos interactivos a la interfaz gráfica en ejercicios posteriores.

`001-recordamos.py`

```python
import tkinter as tk

ventana = tk.Tk()

ventana.mainloop()
```

### creo un marco
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código crea una interfaz gráfica simple utilizando la biblioteca `tkinter` en Python. El objetivo es mostrar un marco (frame) con un etiqueta (label) que pide al usuario que introduzca el DNI/NIE del cliente.

1. **Importación y Creación de la Ventana Principal:** 
   Se importa `tkinter` como `tk`. Luego, se crea una ventana principal (`ventana`) utilizando `Tk()`, que es la clase base para todas las ventanas en `tkinter`.

2. **Creación del Marco:**
   Dentro de esta ventana principal, se define un marco (`marco`). Un marco en `tkinter` sirve como contenedor para otros widgets (elementos gráficos), permitiendo organizarlos y darles estilo.

3. **Etiqueta dentro del Marco:**
   Se añade una etiqueta (`Label`) al marco con el texto "Introduce el dni/nie del cliente". Esta etiqueta se empaqueta (añade a la interfaz) utilizando `pack()`, que también permite especificar un margen (`padx` y `pady`) para espaciar los elementos.

4. **Empaquetado del Marco:**
   Al igual que con el label, el marco se añade a la ventana principal mediante `pack()` con sus propios márgenes. Esto asegura que el marco está bien posicionado dentro de la ventana y proporciona espacio entre los bordes del marco y la ventana.

5. **Iniciar la Aplicación:**
   Finalmente, se llama al método `mainloop()` en la ventana principal para iniciar el bucle principal de eventos de la aplicación. Este bucle permite que la aplicación capture las acciones del usuario (como clics o pulsaciones de teclas) y actualice la interfaz gráfica en consecuencia.

Este código es básico pero fundamental para entender cómo se estructuran y muestran los elementos en una interfaz gráfica con `tkinter`.

`002-creo un marco.py`

```python
import tkinter as tk

ventana = tk.Tk()

marco = tk.Frame(ventana)

tk.Label(marco,text="Introduce el dni/nie del cliente").pack(padx=20,pady=20)

marco.pack(padx=20,pady=20)

ventana.mainloop()
```

### creo un entry
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código crea una interfaz gráfica simple utilizando la biblioteca `tkinter` en Python. La aplicación muestra un marco que contiene cuatro campos de entrada para el usuario: DNI/NIE, nombre, apellidos y email del cliente. Cada campo se acompaña de una etiqueta descriptiva y todos los elementos están organizados dentro del marco con espacios adecuados entre ellos usando `padx` y `pady`.

El código comienza importando la biblioteca `tkinter`, que es fundamental para crear interfaces gráficas en Python. Luego, se crea una ventana principal (`ventana`) a partir de la clase `Tk`. Dentro de esta ventana, se añade un marco (`marco`) donde se colocan las etiquetas y campos de entrada.

Cada etiqueta y campo de entrada son creados por separado para el DNI/NIE, nombre, apellidos y email del cliente. Estos elementos se empaquetan dentro del marco con espacios alrededor utilizando `pack()` con parámetros `padx` y `pady`. Finalmente, el marco se añade a la ventana principal y se llama a `ventana.mainloop()`, lo que hace que la aplicación comience a ejecutarse.

Esta interfaz es útil para recoger información básica de un cliente en una base de datos o para procesos administrativos sencillos.

`003-creo un entry.py`

```python
import tkinter as tk

ventana = tk.Tk()

marco = tk.Frame(ventana)

# DNI NIE
tk.Label(marco,text="Introduce el dni/nie del cliente").pack(padx=10,pady=10)
dninie = tk.Entry(marco)
dninie.pack(padx=10,pady=10)

# NOMBRE
tk.Label(marco,text="Introduce el nombre del cliente").pack(padx=10,pady=10)
nombre = tk.Entry(marco)
nombre.pack(padx=10,pady=10)

# APELLIDOS
tk.Label(marco,text="Introduce los apellidos del cliente").pack(padx=10,pady=10)
apellidos = tk.Entry(marco)
apellidos.pack(padx=10,pady=10)

# EMAIL
tk.Label(marco,text="Introduce el email del cliente").pack(padx=10,pady=10)
email = tk.Entry(marco)
email.pack(padx=10,pady=10)

marco.pack(padx=20,pady=20)

ventana.mainloop()
```

### creo un boton
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código utiliza la biblioteca `tkinter` en Python para crear una interfaz gráfica simple que permite a un usuario ingresar información sobre un cliente, como su DNI/NIE, nombre, apellidos y email. La interfaz contiene cuatro cuadros de entrada (`Entry`) asociados con etiquetas (`Label`) para cada tipo de dato requerido.

El código también incluye la creación de un marco (`Frame`) dentro del cual se colocan todas las etiquetas y campos de entrada utilizando el método `pack()`, que organiza los elementos en bloques apilados verticalmente, proporcionando espacios de padding para mejorar la visualización. Al final, se añade un botón "Insertar cliente" que no está completamente implementado (la función `insertar` debería estar definida previamente).

Esta interfaz es importante porque permite a los usuarios interactuar fácilmente con el programa y proporciona una estructura clara para recoger datos de entrada antes de proceder, por ejemplo, hacia la base de datos o cualquier otro proceso posterior.

`004-creo un boton.py`

```python
import tkinter as tk

ventana = tk.Tk()

marco = tk.Frame(ventana)

# DNI NIE
tk.Label(marco,text="Introduce el dni/nie del cliente").pack(padx=10,pady=10)
dninie = tk.Entry(marco)
dninie.pack(padx=10,pady=10)

# NOMBRE
tk.Label(marco,text="Introduce el nombre del cliente").pack(padx=10,pady=10)
nombre = tk.Entry(marco)
nombre.pack(padx=10,pady=10)

# APELLIDOS
tk.Label(marco,text="Introduce los apellidos del cliente").pack(padx=10,pady=10)
apellidos = tk.Entry(marco)
apellidos.pack(padx=10,pady=10)

# EMAIL
tk.Label(marco,text="Introduce el email del cliente").pack(padx=10,pady=10)
email = tk.Entry(marco)
email.pack(padx=10,pady=10)

# Boton
tk.Button(marco,text="Insertar cliente",command = insertar).pack(padx=10,pady=10)

marco.pack(padx=20,pady=20)

ventana.mainloop()
```

### funcion de insertar
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código crea una interfaz gráfica sencilla usando la biblioteca `tkinter` en Python. La interfaz permite a un usuario ingresar información sobre un cliente, como su DNI/NIE, nombre, apellidos y correo electrónico. Cuando el usuario hace clic en el botón "Insertar cliente", se imprime un mensaje indicando que se va a insertar un nuevo cliente.

El código comienza importando la biblioteca `tkinter` para crear elementos de interfaz gráfica y luego crea una ventana principal. Dentro de esta ventana, se añade un marco (`Frame`) donde se colocan los campos de entrada (widgets `Entry`) para el DNI/NIE, nombre, apellidos y email del cliente, cada uno precedido por una etiqueta (`Label`). Estos elementos se empacan con espacios de padding para mejorar la estética.

Al final, un botón que dice "Insertar cliente" está vinculado a la función `insertar()`, que simplemente imprime el mensaje cuando es presionado. La ejecución del programa entra en un bucle principal (`mainloop`) que espera interacciones del usuario.

Este código es importante porque introduce los conceptos básicos de cómo crear una interfaz gráfica y manejar eventos, como la pulsación de botones para realizar acciones específicas.

`005-funcion de insertar.py`

```python
import tkinter as tk

ventana = tk.Tk()

def insertar():
  print("Vamos a insertar un cliente")

marco = tk.Frame(ventana)

# DNI NIE
tk.Label(marco,text="Introduce el dni/nie del cliente").pack(padx=10,pady=10)
dninie = tk.Entry(marco)
dninie.pack(padx=10,pady=10)

# NOMBRE
tk.Label(marco,text="Introduce el nombre del cliente").pack(padx=10,pady=10)
nombre = tk.Entry(marco)
nombre.pack(padx=10,pady=10)

# APELLIDOS
tk.Label(marco,text="Introduce los apellidos del cliente").pack(padx=10,pady=10)
apellidos = tk.Entry(marco)
apellidos.pack(padx=10,pady=10)

# EMAIL
tk.Label(marco,text="Introduce el email del cliente").pack(padx=10,pady=10)
email = tk.Entry(marco)
email.pack(padx=10,pady=10)

# Boton
tk.Button(marco,text="Insertar cliente",command = insertar).pack(padx=10,pady=10)

marco.pack(padx=20,pady=20)

ventana.mainloop()
```

### mysql
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código Python se utiliza para conectar a una base de datos MySQL y realizar una operación de inserción en ella. La primera parte del código importa el módulo `mysql.connector`, que es la herramienta que permite a tu programa comunicarse con el servidor MySQL.

Luego, establece una conexión con la base de datos especificando los detalles necesarios como el host (en este caso, "localhost" que indica que la base de datos está en el mismo equipo), el usuario ("empresadam"), la contraseña y la base de datos a la cual se quiere conectarse ("empresadam"). 

Una vez establecida la conexión, se crea un objeto cursor mediante `conexion.cursor()`. Este cursor se utiliza para ejecutar comandos SQL. En este caso, se está insertando un nuevo registro en la tabla "clientes" con información específica como el NIF (un identificador único), nombre y apellido del cliente, y su dirección de correo electrónico.

Después de ejecutar el comando `INSERT`, es importante hacer un commit a la conexión para que los cambios sean guardados permanentemente en la base de datos. Finalmente, se cierran tanto el cursor como la conexión con la base de datos para liberar recursos y evitar problemas de seguridad.

Este fragmento de código es crucial para aprender cómo interactuar con bases de datos MySQL desde Python, lo cual es una habilidad fundamental en el desarrollo web y aplicaciones que requieren almacenamiento persistente de información.

`006-mysql.py`

```python
# pip3 install mysql-connector-python --break-system-packages
# sudo apt install libmysqlclient-dev python3-mysql.connector
# solo si da error de ssl en socket:
# pip3 install --user --upgrade mysql-connect-python --break-system-packages
import mysql.connector
conexion = mysql.connector.connect(
    host="localhost",
    user="empresadam",
    password="Empresadam123$",
    database="empresadam"
)
cursor = conexion.cursor()
cursor.execute('''
  INSERT INTO clientes
  VALUES(
    NULL,
    "12345678Z",
    "Jose Vicente",
    "Carratala Sanchis",
    "info@jocarsa.com"
  );
''')
conexion.commit()
cursor.close()
conexion.close()
```

### crear usuario
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código SQL tiene como objetivo crear un nuevo usuario en tu sistema de base de datos y configurar sus permisos. Comenzamos creando el usuario `empresadam` con una contraseña específica (`Empresadam123$`). Luego, le permitimos al usuario realizar acciones básicas (como conectarse) utilizando la declaración `GRANT USAGE`. Después, modificamos las limitaciones del usuario para que pueda hacer prácticamente cualquier cosa en términos de velocidad y cantidad de conexiones. Finalmente, otorgamos a este usuario todos los privilegios sobre una base de datos específica llamada `empresadam`, lo que significa que puede leer, escribir y modificar la información dentro de ella. El comando `FLUSH PRIVILEGES` asegura que estos cambios se reflejen inmediatamente en el sistema.

Este proceso es importante porque permite a los administradores de bases de datos gestionar quién tiene acceso a qué información y cómo pueden interactuar con las bases de datos, manteniendo así la seguridad y control del sistema.

`007-crear usuario.sql`

```sql
-- crea usuario nuevo con contraseña
CREATE USER 
'empresadam'@'localhost' 
IDENTIFIED  BY 'Empresadam123$';
-- permite acceso a ese usuario
GRANT USAGE ON *.* TO 'empresadam'@'localhost';
-- quitale todos los limites que tenga
ALTER USER 'empresadam'@'localhost' 
REQUIRE NONE 
WITH MAX_QUERIES_PER_HOUR 0 
MAX_CONNECTIONS_PER_HOUR 0 
MAX_UPDATES_PER_HOUR 0 
MAX_USER_CONNECTIONS 0;
-- dale acceso a la base de datos empresadam
GRANT ALL PRIVILEGES ON `empresadam`.* 
TO 'empresadam'@'localhost';
-- recarga la tabla de privilegios
FLUSH PRIVILEGES;
```

### seleccionar
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código SQL es una consulta simple que selecciona todos los datos de la tabla llamada `clientes`. La instrucción `SELECT *` indica que se deben recuperar todas las columnas y filas disponibles en esa tabla. Esta sentencia es útil cuando deseas ver toda la información almacenada en la tabla `clientes`, lo cual puede ser necesario para realizar tareas como revisión, auditoría o simplemente entender el contenido actual de tu base de datos. Es una herramienta básica pero importante en la gestión y manipulación de bases de datos relacionales.

`008-seleccionar.sql`

```sql
SELECT * FROM clientes;
```

### insertar en base de datos
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código es una pequeña aplicación de interfaz gráfica hecha con Tkinter en Python que permite a un usuario insertar información sobre un cliente en una base de datos MySQL. La aplicación crea una ventana simple donde el usuario puede ingresar el DNI/NIE, nombre, apellidos y email del cliente.

Cuando se completa cada campo requerido y se hace clic en el botón "Insertar cliente", la función `insertar()` se ejecuta. Esta función toma los valores ingresados por el usuario desde los campos de entrada (widgets Entry) y los usa para construir una consulta SQL `INSERT INTO` que añade un nuevo registro a la tabla `clientes`. La tabla debe tener columnas para DNI/NIE, nombre, apellidos y email, en ese orden. El valor `NULL` que se pasa como primer parámetro indica que el ID de cliente será manejado automáticamente por la base de datos (normalmente con un campo AUTO_INCREMENT).

Después de ejecutar la consulta SQL, se llama a `conexion.commit()` para guardar los cambios permanentemente en la base de datos. Esto es crucial porque sin esta llamada, los cambios no se guardarían.

Este código es útil para aprender cómo interactuar entre una interfaz gráfica básica y una base de datos, además de entender cómo manejar eventos (como hacer clic en un botón) que desencadenan operaciones más complejas.

`009-insertar en base de datos.py`

```python
import tkinter as tk
import mysql.connector
conexion = mysql.connector.connect(host="localhost",user="empresadam",password="Empresadam123$",database="empresadam")
cursor = conexion.cursor()
ventana = tk.Tk()
def insertar():
  cursor.execute('''
    INSERT INTO clientes
    VALUES(
      NULL,
      "'''+dninie.get()+'''",
      "'''+nombre.get()+'''",
      "'''+apellidos.get()+'''",
      "'''+email.get()+'''"
    );
  ''')
  conexion.commit()
marco = tk.Frame(ventana)
tk.Label(marco,text="Introduce el dni/nie del cliente").pack(padx=10,pady=10)
dninie = tk.Entry(marco)
dninie.pack(padx=10,pady=10)
tk.Label(marco,text="Introduce el nombre del cliente").pack(padx=10,pady=10)
nombre = tk.Entry(marco)
nombre.pack(padx=10,pady=10)
tk.Label(marco,text="Introduce los apellidos del cliente").pack(padx=10,pady=10)
apellidos = tk.Entry(marco)
apellidos.pack(padx=10,pady=10)
tk.Label(marco,text="Introduce el email del cliente").pack(padx=10,pady=10)
email = tk.Entry(marco)
email.pack(padx=10,pady=10)
tk.Button(marco,text="Insertar cliente",command = insertar).pack(padx=10,pady=10)
marco.pack(padx=20,pady=20)
ventana.mainloop()
```

### leer de base de datos
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código se encarga de conectarse a una base de datos MySQL y leer todos los registros de la tabla llamada "clientes". El programa primero establece una conexión con la base de datos utilizando el módulo `mysql.connector` en Python, proporcionando detalles como el host (localhost), usuario, contraseña y nombre de la base de datos. Luego, crea un objeto cursor para ejecutar comandos SQL.

El código ejecuta una consulta SELECT que selecciona todos los registros de la tabla "clientes". Los resultados de esta consulta se almacenan en la variable `filas`. A continuación, el programa recorre cada fila del resultado con un bucle for e imprime cada registro en pantalla. Finalmente, cierra el cursor y la conexión a la base de datos para liberar los recursos.

Este tipo de operaciones es fundamental en aplicaciones que necesitan interactuar con bases de datos, ya que permite acceder y manipular información almacenada de manera eficiente.

`010-leer de base de datos.py`

```python
import mysql.connector
conexion = mysql.connector.connect(
    host="localhost",
    user="empresadam",
    password="Empresadam123$",
    database="empresadam"
)
cursor = conexion.cursor()
cursor.execute('''
  SELECT * FROM clientes;
''')

filas = cursor.fetchall()

for fila in filas:
  print(fila)
  
cursor.close()
conexion.close()
```

### pintamos tablas
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código utiliza la biblioteca `tkinter` en Python para crear una interfaz gráfica simple que muestra información en forma de tabla. La parte principal del código crea un objeto `Treeview`, que es como una tabla en una hoja de cálculo, pero dentro de una ventana de aplicación.

Primero, se importan las partes necesarias de la biblioteca `tkinter` y se inicializa la ventana principal llamada `ventana`. Luego, se crea un objeto `arbol` de tipo `Treeview`, que tiene dos columnas: "nombre" y "apellidos". Se especifica también que los nombres de las columnas deben mostrarse en la cabecera (headings).

Después, se añaden dos filas de datos a esta tabla utilizando el método `insert`. Cada fila contiene un nombre y apellidos para diferentes clientes. Finalmente, con `arbol.pack(padx=20,pady=20)`, se coloca la tabla en la ventana principal con cierto margen.

Este código es importante porque muestra cómo estructurar datos tabulares en una interfaz gráfica usando Python, lo cual puede ser útil para visualizar y manipular grandes cantidades de información de manera interactiva.

`011-pintamos tablas.py`

```python
import tkinter as tk
from tkinter import ttk

ventana = tk.Tk()


arbol = ttk.Treeview(ventana, columns=("nombre", "apellidos"), show="headings")
arbol.heading("nombre", text="Nombre del cliente")
arbol.heading("apellidos", text="Apellidos del cliente")

arbol.insert("", "end", values=("Jose Vicente", "Carratala"))
arbol.insert("", "end", values=("Juan", "García Lopez"))

arbol.pack(padx=20,pady=20)

ventana.mainloop()
```

### frankenstein
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código crea una aplicación simple usando la biblioteca `tkinter` para crear una interfaz gráfica y conectarse a una base de datos MySQL para recuperar información y mostrarla en un árbol (TreeView). Primero, establece una conexión con una base de datos llamada "empresadam" utilizando el módulo `mysql.connector`. Luego, ejecuta una consulta SQL que selecciona todos los registros de la tabla `clientes`.

La aplicación crea una ventana (`ventana = tk.Tk()`) y dentro de ella, un objeto Treeview (`arbol`) con cuatro columnas: DNI del cliente, Nombre del cliente, Apellidos del cliente y Email del cliente. Después de ejecutar la consulta SQL para recuperar los datos de la tabla `clientes`, el código inserta cada fila de resultados en el árbol, mostrando así todos los clientes registrados en la base de datos.

Este tipo de aplicación es útil para visualizar fácilmente datos almacenados en una base de datos y permite a los usuarios interactuar con ellos mediante una interfaz gráfica simple. Es importante porque combina dos tecnologías fundamentales: manejo de bases de datos y programación orientada a la GUI (Interfaz Gráfica del Usuario).

`012-frankenstein.py`

```python
import tkinter as tk
from tkinter import ttk
import mysql.connector
conexion = mysql.connector.connect(host="localhost",user="empresadam",password="Empresadam123$",database="empresadam")
cursor = conexion.cursor()
ventana = tk.Tk()
arbol = ttk.Treeview(ventana, columns=("dninie","nombre", "apellidos","email"), show="headings")
arbol.heading("dninie", text="DNI del cliente")
arbol.heading("nombre", text="Nombre del cliente")
arbol.heading("apellidos", text="Apellidos del cliente")
arbol.heading("email", text="Email del cliente")
cursor.execute('''SELECT * FROM clientes;''')
filas = cursor.fetchall()
for fila in filas:
  arbol.insert("", "end", values=(fila[1], fila[2], fila[3], fila[4]))

arbol.pack(padx=20,pady=20)

ventana.mainloop()
```

### unir con IA
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código es una aplicación de interfaz gráfica en Python que utiliza las bibliotecas `tkinter` y `ttkbootstrap` para crear una ventana con dos áreas principales: un formulario para ingresar información de nuevos clientes y una tabla para mostrar la lista actualizada de todos los clientes registrados. La aplicación se conecta a una base de datos MySQL donde almacena los datos ingresados.

El código inicia configurando la conexión a la base de datos MySQL que contiene la tabla "clientes". Luego, crea la ventana principal con un tema visual llamado "superhero" utilizando `ttkbootstrap`. En esta ventana se definen dos marcos: uno para el formulario (`frame_form`) donde los usuarios pueden ingresar detalles del nuevo cliente (DNI/NIE, nombre, apellidos y email), y otro para mostrar una tabla de clientes existentes (`frame_tabla`).

El formulario incluye cuadros de entrada (`Entry`) para cada campo requerido y un botón que, cuando se presiona, llama a la función `insertar()`. Esta función verifica si todos los campos del formulario han sido completados, inserta los datos en la base de datos MySQL y luego actualiza automáticamente la tabla mostrando el nuevo cliente. Si algún campo está vacío, muestra una ventana emergente para advertir al usuario.

La parte inferior del código se encarga de configurar un widget `Treeview` dentro del marco que contiene la tabla (`frame_tabla`). Este widget permite visualizar los datos de manera tabular y viene equipado con barras de desplazamiento tanto vertical como horizontal. La función `cargar_datos()` es responsable de cargar todos los registros existentes en la base de datos a esta tabla al inicio del programa.

Este tipo de aplicación es útil para entender cómo interactúan las interfaces gráficas, bases de datos y funciones lógicas en un solo sistema, proporcionando una experiencia interactiva al usuario.

`013-unir con IA.py`

```python
# pip3 install ttkbootsrap --break-system-packages
import tkinter as tk
from tkinter import ttk
import mysql.connector
import ttkbootstrap as tb
from ttkbootstrap.constants import *

# --- Database connection ---
conexion = mysql.connector.connect(
    host="localhost",
    user="empresadam",
    password="Empresadam123$",
    database="empresadam"
)
cursor = conexion.cursor()

# --- Main window setup ---
ventana = tb.Window(themename="superhero")  # try also: "minty", "flatly", "darkly"
ventana.title("Gestión de Clientes")
ventana.geometry("800x600")

# --- Frames layout ---
frame_form = ttk.LabelFrame(ventana, text="Nuevo cliente", padding=20)
frame_form.pack(fill=X, padx=20, pady=10)

frame_tabla = ttk.LabelFrame(ventana, text="Lista de clientes", padding=20)
frame_tabla.pack(fill=BOTH, expand=True, padx=20, pady=10)

# --- Form fields ---
def insertar():
    dni = dninie.get()
    nom = nombre.get()
    ape = apellidos.get()
    ema = email.get()

    if dni == "" or nom == "" or ape == "" or ema == "":
        tb.dialogs.Messagebox.show_warning("Por favor, completa todos los campos", title="Atención")
        return

    cursor.execute('''
        INSERT INTO clientes VALUES (NULL, %s, %s, %s, %s);
    ''', (dni, nom, ape, ema))
    conexion.commit()
    cargar_datos()
    tb.dialogs.Messagebox.show_info("Cliente insertado correctamente", title="Éxito")

    # Limpiar campos
    dninie.delete(0, tk.END)
    nombre.delete(0, tk.END)
    apellidos.delete(0, tk.END)
    email.delete(0, tk.END)

# Form fields (left to right layout)
ttk.Label(frame_form, text="DNI/NIE:").grid(row=0, column=0, padx=5, pady=5, sticky=W)
dninie = ttk.Entry(frame_form, width=20)
dninie.grid(row=0, column=1, padx=5, pady=5)

ttk.Label(frame_form, text="Nombre:").grid(row=0, column=2, padx=5, pady=5, sticky=W)
nombre = ttk.Entry(frame_form, width=20)
nombre.grid(row=0, column=3, padx=5, pady=5)

ttk.Label(frame_form, text="Apellidos:").grid(row=1, column=0, padx=5, pady=5, sticky=W)
apellidos = ttk.Entry(frame_form, width=20)
apellidos.grid(row=1, column=1, padx=5, pady=5)

ttk.Label(frame_form, text="Email:").grid(row=1, column=2, padx=5, pady=5, sticky=W)
email = ttk.Entry(frame_form, width=20)
email.grid(row=1, column=3, padx=5, pady=5)

ttk.Button(frame_form, text="Insertar cliente", command=insertar, bootstyle=SUCCESS).grid(
    row=0, column=4, rowspan=2, padx=10, pady=5, sticky=NS
)

# --- Treeview setup ---
columnas = ("dninie", "nombre", "apellidos", "email")
arbol = ttk.Treeview(frame_tabla, columns=columnas, show="headings", bootstyle=INFO)
for col in columnas:
    arbol.heading(col, text=col.capitalize())
    arbol.column(col, width=180, anchor=W)

# Scrollbars
scroll_y = ttk.Scrollbar(frame_tabla, orient=VERTICAL, command=arbol.yview)
scroll_x = ttk.Scrollbar(frame_tabla, orient=HORIZONTAL, command=arbol.xview)
arbol.configure(yscrollcommand=scroll_y.set, xscrollcommand=scroll_x.set)

arbol.grid(row=0, column=0, sticky=NSEW)
scroll_y.grid(row=0, column=1, sticky=NS)
scroll_x.grid(row=1, column=0, sticky=EW)

frame_tabla.rowconfigure(0, weight=1)
frame_tabla.columnconfigure(0, weight=1)

# --- Function to load data into the table ---
def cargar_datos():
    cursor.execute("SELECT * FROM clientes;")
    filas = cursor.fetchall()
    arbol.delete(*arbol.get_children())
    for fila in filas:
        arbol.insert("", "end", values=(fila[1], fila[2], fila[3], fila[4]))

# --- Initial load ---
cargar_datos()

ventana.mainloop()
```

### Actividades propuestas

### Actividad 1: Creación de Ventana Básica en Tkinter
**Descripción:** Crea una ventana básica con Tkinter que simplemente muestre un mensaje "Bienvenido a la aplicación" cuando se ejecute. Asegúrate de que tu código tenga una estructura similar a los ejemplos proporcionados.

### Actividad 2: Diseño de Formulario Simples
**Descripción:** Desarrolla un formulario en Tkinter con campos para introducir DNI/NIE, nombre, apellidos y email. Debe incluir etiquetas y entradas para cada uno de estos campos.

### Actividad 3: Integración del Botón Insertar
**Descripción:** Añade un botón al formulario creado anteriormente que ejecute una función básica cuando se presione (por ejemplo, imprimir en la consola "Se ha intentado insertar un cliente").

### Actividad 4: Conexión a MySQL y Ejecución de Consulta Básica
**Descripción:** Escribe un script Python para conectarse a la base de datos MySQL utilizando `mysql.connector`. Luego, ejecuta una consulta básica que inserte un nuevo registro en la tabla `clientes`.

### Actividad 5: Integración con Tkinter y Ejecución de Consulta SQL
**Descripción:** Combina las habilidades aprendidas hasta ahora para crear un formulario Tkinter que permita a los usuarios insertar datos en una base de datos MySQL. Asegúrate de que la inserción se realiza cuando el usuario haga clic en el botón "Insertar cliente".

### Actividad 6: Mostrar Datos desde la Base de Datos
**Descripción:** Modifica tu aplicación para que, además de permitir insertar nuevos clientes a través del formulario, también muestre una lista con todos los registros existentes en la tabla `clientes` al iniciar el programa.

### Actividad 7: Tabla Dinámica en Tkinter
**Descripción:** Utiliza ttk.Treeview para mostrar datos desde tu base de datos MySQL en una estructura tabular dentro del formulario Tkinter. Asegúrate de que los datos se actualicen automáticamente cada vez que un nuevo cliente es insertado.

### Actividad 8: Diseño Estético Avanzado con ttkbootstrap
**Descripción:** Mejora la apariencia de tu aplicación utilizando el módulo `ttkbootstrap` para crear ventanas y formularios más atractivos. Asegúrate de que tanto los campos como las tablas estén bien diseñados.

### Actividad 9: Control de Errores en Formulario
**Descripción:** Implementa validaciones para asegurar que todos los campos del formulario están completos antes de permitir la inserción a través del botón "Insertar cliente". Muestra mensajes de advertencia si algún campo está vacío.

### Actividad 10: Refactorización y Mejora Final
**Descripción:** Aprovecha las habilidades aprendidas para refactorizar tu código, mejorando su legibilidad y eficiencia. Considera la posibilidad de añadir funcionalidades adicionales como borrar registros o actualizar información existente.

Estas actividades se basan en el proceso gradual de aprender cómo crear una aplicación que interactúa con bases de datos utilizando Tkinter para interfaz gráfica y MySQL para almacenamiento, pasando por los conceptos básicos hasta llegar a la integración avanzada y diseño estético.


<a id="creacion-de-controladores-de-eventos"></a>
## Creación de controladores de eventos


<a id="simulacro-examen-miercoles"></a>
## - Simulacro examen miercoles

### Introducción a los ejercicios

Esta carpeta contiene una serie de ejercicios que te ayudarán a familiarizarte con la manipulación de datos en una base de datos MySQL desde Python. Los ejercicios inician presentando un menú interactivo para realizar operaciones CRUD (Crear, Leer, Actualizar y Eliminar) en una tabla llamada `Piezas`. A través de estos ejercicios, practicarás la conexión a una base de datos utilizando el módulo `mysql.connector`, la ejecución de consultas SQL como SELECT, INSERT, UPDATE y DELETE, y manejar inputs del usuario para realizar operaciones específicas en la base de datos. Estos ejercicios son ideales para consolidar tus habilidades tanto en programación Python como en gestión de bases de datos relacionales.

### comenzamos
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código es el comienzo de una pequeña aplicación en Python que muestra al usuario un menú con varias opciones. Primero, el programa imprime un mensaje de bienvenida para indicar a los usuarios que han iniciado la aplicación. Luego, presenta un menú interactivo donde se muestran cuatro opciones diferentes: crear un registro, listar registros existentes, actualizar un registro y eliminar un registro. Cada opción tiene un número asociado (1 a 4), lo cual facilita que el usuario pueda seleccionar fácilmente una opción introduciendo simplemente el número correspondiente.

Esta parte del código es importante porque establece la interacción inicial entre el programa y el usuario, permitiendo al usuario decidir qué acción quiere realizar. Es una manera clara de organizar las funcionalidades básicas que ofrece la aplicación, facilitando así su uso para cualquier persona que desee interactuar con ella.

`001-comenzamos.py`

```python
print("Bienvenidos a la aplicacion")

print("Selecciona una opcion:")
print("1.-Crear un registro")
print("2.-Listar registros")
print("3.-Actualiar registro")
print("4.-Eliminar registro")
```

### bucle infinito
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es el inicio de una aplicación sencilla en Python que permite al usuario interactuar con un menú. Al principio, se imprime un mensaje de bienvenida para indicar a los usuarios que han iniciado la aplicación. Luego, el programa entra en un bucle infinito (`while True:`), lo que significa que este bloque de código se repetirá indefinidamente hasta que algo detenga el ciclo.

Dentro del bucle, se muestran varias opciones al usuario: crear un registro, listar registros existentes, actualizar un registro y eliminar un registro. Cada opción está asociada a un número específico (1, 2, 3 o 4). El programa solicita al usuario que ingrese su elección mediante la función `input()`, convirtiendo el valor ingresado en un entero con `int()` para poder trabajar con él.

Este tipo de estructura es común en aplicaciones interactivas y permite que el usuario interactúe continuamente con el sistema hasta que decida terminar, por ejemplo, introduciendo una opción no contemplada o forzando la finalización del programa desde fuera del flujo normal.

`002-bucle infinito.py`

```python
print("Bienvenidos a la aplicacion")

while True:
  print("Selecciona una opcion:")
  print("1.-Crear un registro")
  print("2.-Listar registros")
  print("3.-Actualiar registro")
  print("4.-Eliminar registro")

  opcion = int(input("Elige tu opcion: "))
```

### if elif
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código es una estructura básica para un menú de opciones en un programa de Python. Al iniciar, muestra un mensaje de bienvenida a los usuarios y luego entra en un bucle infinito que presenta varias opciones al usuario: crear un registro, listar registros existentes, actualizar un registro o eliminar un registro. El programa pide al usuario que ingrese el número correspondiente a la opción deseada.

El código utiliza una declaración `if` seguida de varios bloques `elif` para verificar qué opción ha elegido el usuario y realizar la acción adecuada según esa elección. Sin embargo, en este fragmento del código, las acciones específicas relacionadas con cada opción no están implementadas (donde aparece "Selecciona una opcion:", falta agregar el código que se ejecutará cuando se seleccione cada opción).

Este tipo de estructura es importante porque permite al usuario interactuar con el programa de manera sencilla y elegir la funcionalidad específica que necesita en cada momento. Es fundamental completar los bloques `elif` para que las opciones funcionen según lo previsto, permitiendo así a los usuarios realizar operaciones como crear, listar, actualizar o eliminar registros dentro del sistema.

`003-if elif.py`

```python
print("Bienvenidos a la aplicacion")

while True:
  print("Selecciona una opcion:")
  print("1.-Crear un registro")
  print("2.-Listar registros")
  print("3.-Actualiar registro")
  print("4.-Eliminar registro")

  opcion = int(input("Elige tu opcion: "))
  
  if opcion == 1:
  
  elif opcion == 2:
  
  elif opcion == 3:
  
  elif opcion == 4:
  
```

### mysql conexion
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código es una pequeña aplicación en Python que se conecta a una base de datos MySQL y permite al usuario realizar diferentes acciones sobre los registros almacenados. La aplicación comienza mostrando un mensaje de bienvenida y luego entra en un bucle infinito donde el usuario puede elegir entre cuatro opciones: crear, listar, actualizar o eliminar registros.

El programa utiliza la función `input()` para permitir que el usuario introduzca su elección, que se almacena en la variable `opcion`. Dependiendo del número que elija el usuario, se ejecutaría una acción específica (crear, listar, etc.), pero actualmente las opciones elegidas no tienen código asociado dentro de los bloques condicionales `if`, por lo que solo muestra el menú y espera una entrada sin realizar ninguna operación con la base de datos.

Esta estructura es común en aplicaciones interactivas que manejan bases de datos, ya que permite al usuario interactuar fácilmente con los datos almacenados sin necesidad de salir del programa hasta que decida terminar.

`004-mysql conexion.py`

```python
import mysql.connector

print("Bienvenidos a la aplicacion")

while True:
  print("Selecciona una opcion:")
  print("1.-Crear un registro")
  print("2.-Listar registros")
  print("3.-Actualiar registro")
  print("4.-Eliminar registro")

  opcion = int(input("Elige tu opcion: "))
  
  if opcion == 1:
  
  elif opcion == 2:
  
  elif opcion == 3:
  
  elif opcion == 4:
  
```

### conexion y cursor
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es una parte de un programa en Python que se conecta a una base de datos MySQL y permite al usuario realizar diferentes operaciones con ella. Primero, el programa importa la biblioteca `mysql.connector` para poder interactuar con la base de datos. Luego, establece una conexión con la base de datos "portafolioceac" usando las credenciales proporcionadas (host, usuario y contraseña).

Una vez conectado a la base de datos, se crea un objeto llamado `cursor`, que es fundamental para ejecutar consultas SQL en la base de datos. El programa luego entra en un bucle infinito (`while True`), que presenta al usuario un menú con cuatro opciones: crear un registro (opción 1), listar registros (opción 2), actualizar un registro (opción 3) y eliminar un registro (opción 4).

El usuario es invitado a ingresar una opción, y el programa verifica esta entrada para determinar qué acción realizar. Aunque no se implementa en este código, cada condición `if` debería tener una porción de código que realiza la operación correspondiente con la base de datos.

Este tipo de estructura de menú es común en aplicaciones CRUD (Crear, Leer, Actualizar y Eliminar), que son fundamentales para administrar información en bases de datos. Es importante notar que las partes del código dentro de los bloques `elif` están vacías, lo cual indica que aún falta implementar la lógica para cada opción seleccionada por el usuario.

`005-conexion y cursor.py`

```python
import mysql.connector

print("Bienvenidos a la aplicacion")

conexion = mysql.connector.connect(
  host="localhost",
  user="portafolioceac",
  password="portafolioceac",
  database="portafolioceac"
  )
cursor = conexion.cursor()

while True:
  print("Selecciona una opcion:")
  print("1.-Crear un registro")
  print("2.-Listar registros")
  print("3.-Actualiar registro")
  print("4.-Eliminar registro")

  opcion = int(input("Elige tu opcion: "))
  
  if opcion == 1:
  
  elif opcion == 2:
  
  elif opcion == 3:
  
  elif opcion == 4:
  
```

### seleccionamos
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código es una pequeña aplicación en Python que interactúa con una base de datos MySQL para permitir al usuario realizar diferentes acciones como crear, listar, actualizar o eliminar registros. Al iniciar la aplicación, se establece una conexión a la base de datos "portafolioceac" utilizando el usuario "portafolioceac". A continuación, el programa entra en un bucle infinito que muestra un menú al usuario con cuatro opciones: crear un registro, listar todos los registros existentes, actualizar un registro y eliminar un registro.

Cuando el usuario selecciona la opción 2 (listar registros), se ejecuta una consulta SQL para obtener toda la información de la tabla "Piezas". Después, el programa recorre cada fila que devuelve la consulta y la imprime en pantalla. Las otras opciones del menú no tienen código implementado todavía, lo cual indica que aún están pendientes de desarrollo.

Este tipo de aplicación es útil para proporcionar a los usuarios una interfaz sencilla para interactuar con datos almacenados en una base de datos sin necesidad de un sistema más complejo o de usar directamente SQL.

`006-seleccionamos.py`

```python
import mysql.connector

print("Bienvenidos a la aplicacion")

conexion = mysql.connector.connect(
  host="localhost",
  user="portafolioceac",
  password="portafolioceac",
  database="portafolioceac"
  )
cursor = conexion.cursor()

while True:
  print("Selecciona una opcion:")
  print("1.-Crear un registro")
  print("2.-Listar registros")
  print("3.-Actualiar registro")
  print("4.-Eliminar registro")

  opcion = int(input("Elige tu opcion: "))
  
  if opcion == 1:
    pass
  elif opcion == 2:
    cursor = conexion.cursor()
    cursor.execute('''
      SELECT * FROM Piezas;
    ''')

    filas = cursor.fetchall()

    for fila in filas:
      print(fila)
  elif opcion == 3:
    pass
  elif opcion == 4:
    pass
```

### ahora insertar
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código es una aplicación sencilla en Python que interactúa con una base de datos MySQL. La aplicación se conecta a la base de datos llamada "portafolioceac" usando un usuario y contraseña específicos, y permite al usuario realizar diferentes acciones como crear, listar, actualizar o eliminar registros.

La interfaz principal del programa muestra cuatro opciones (Crear, Listar, Actualizar, Eliminar) que el usuario puede seleccionar a través de números del 1 al 4. Si el usuario escoge la opción "Crear", se le solicitan detalles específicos como título, descripción, imagen, URL y categoría para un nuevo registro en una tabla llamada "Piezas". Estos datos se insertan directamente en la base de datos usando comandos SQL.

Para listar registros (opción 2), el programa ejecuta una consulta que selecciona todos los datos de la tabla "Piezas" y luego imprime cada fila devuelta por la base de datos. Las opciones para actualizar y eliminar registros todavía no están implementadas, ya que esas partes del código están marcadas con 'pass', lo cual significa que esa funcionalidad aún debe ser añadida.

Esta aplicación es útil porque demuestra cómo manejar una conexión a MySQL desde Python, ejecutar consultas SQL básicas y manipular datos en la base de datos según las acciones elegidas por el usuario.

`007-ahora insertar.py`

```python
import mysql.connector

print("Bienvenidos a la aplicacion")

conexion = mysql.connector.connect(
  host="localhost",
  user="portafolioceac",
  password="portafolioceac",
  database="portafolioceac"
  )
cursor = conexion.cursor()

while True:
  print("Selecciona una opcion:")
  print("1.-Crear un registro")
  print("2.-Listar registros")
  print("3.-Actualiar registro")
  print("4.-Eliminar registro")

  opcion = int(input("Elige tu opcion: "))
  
  if opcion == 1:
    titulo = input("Introduce el titulo: ")
    descripcion = input("Introduce la descripcion: ")
    imagen = input("Introduce la imagen: ")
    url = input("Introduce la url: ")
    id_categoria = input("Introduce la categoria: ")
    cursor.execute('''
      INSERT INTO Piezas VALUES (
      NULL,
      "'''+titulo+'''",
      "'''+descripcion+'''",
      "'''+imagen+'''",
      "'''+url+'''",
      '''+id_categoria+'''
      );
    ''')
    conexion.commit()
  elif opcion == 2:

    cursor.execute('''
      SELECT * FROM Piezas;
    ''')

    filas = cursor.fetchall()

    for fila in filas:
      print(fila)
  elif opcion == 3:
    pass
  elif opcion == 4:
    pass
```

### eliminar
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código es una aplicación en Python que interactúa con una base de datos MySQL para gestionar registros relacionados con "Piezas". La aplicación presenta al usuario un menú donde puede seleccionar entre varias opciones: crear, listar, actualizar o eliminar registros.

Cuando el usuario elige la opción 4 (eliminar registro), se le solicita que introduzca el ID del registro que desea borrar. Luego, el programa ejecuta una consulta SQL de eliminación (`DELETE FROM Piezas WHERE Identificador = identificador`) para remover ese registro específico de la tabla "Piezas" en la base de datos.

Es importante destacar que este código es vulnerable a inyección SQL porque construye consultas directamente usando valores ingresados por el usuario sin usar métodos seguros como el uso de parámetros. Esto significa que aunque funcione para su propósito, es crucial mejorar la seguridad antes de usarlo en un entorno real.

El uso de `conexion.commit()` después de una operación de eliminación asegura que los cambios realizados se guarden permanentemente en la base de datos.

`008-eliminar.py`

```python
import mysql.connector

print("Bienvenidos a la aplicacion")

conexion = mysql.connector.connect(
  host="localhost",
  user="portafolioceac",
  password="portafolioceac",
  database="portafolioceac"
  )
cursor = conexion.cursor()

while True:
  print("Selecciona una opcion:")
  print("1.-Crear un registro")
  print("2.-Listar registros")
  print("3.-Actualiar registro")
  print("4.-Eliminar registro")

  opcion = int(input("Elige tu opcion: "))
  
  if opcion == 1:
    titulo = input("Introduce el titulo: ")
    descripcion = input("Introduce la descripcion: ")
    imagen = input("Introduce la imagen: ")
    url = input("Introduce la url: ")
    id_categoria = input("Introduce la categoria: ")
    cursor.execute('''
      INSERT INTO Piezas VALUES (
      NULL,
      "'''+titulo+'''",
      "'''+descripcion+'''",
      "'''+imagen+'''",
      "'''+url+'''",
      '''+id_categoria+'''
      );
    ''')
    conexion.commit()
  elif opcion == 2:

    cursor.execute('''
      SELECT * FROM Piezas;
    ''')

    filas = cursor.fetchall()

    for fila in filas:
      print(fila)
  elif opcion == 3:
    pass
  elif opcion == 4:
    identificador = input("Introduce el id a eliminar: ")
    cursor.execute('''
      DELETE FROM Piezas
      WHERE Identificador = '''+identificador+'''
    ''')
    conexion.commit()
```

### actualizar
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código es un programa en Python que interactúa con una base de datos MySQL para realizar operaciones CRUD (Crear, Leer, Actualizar y Borrar) sobre una tabla llamada `Piezas`. El programa inicia conectándose a la base de datos especificando los detalles necesarios como el host, usuario, contraseña y nombre de la base de datos.

El código ofrece un menú interactivo en bucle infinito (`while True:`), donde el usuario puede seleccionar entre cuatro opciones: crear (insertar) un nuevo registro, listar todos los registros existentes, actualizar un registro específico o eliminar un registro. Dependiendo de la opción elegida por el usuario, el programa ejecuta las consultas SQL correspondientes utilizando el cursor establecido previamente.

Es importante destacar que este código utiliza comandos directos del lenguaje SQL insertados en cadenas Python, lo cual puede ser inseguro si los datos ingresados provienen de fuentes no confiables (debido a la posibilidad de ataques de tipo *SQL injection*). Sin embargo, para propósitos educativos y de demostración en un entorno controlado, este método sirve para ilustrar cómo se interactúa con una base de datos desde Python.

`009-actualizar.py`

```python
import mysql.connector

print("Bienvenidos a la aplicacion")

conexion = mysql.connector.connect(
  host="localhost",
  user="portafolioceac",
  password="portafolioceac",
  database="portafolioceac"
  )
cursor = conexion.cursor()

while True:
  print("Selecciona una opcion:")
  print("1.-Crear un registro")
  print("2.-Listar registros")
  print("3.-Actualiar registro")
  print("4.-Eliminar registro")

  opcion = int(input("Elige tu opcion: "))
  
  if opcion == 1:
    titulo = input("Introduce el titulo: ")
    descripcion = input("Introduce la descripcion: ")
    imagen = input("Introduce la imagen: ")
    url = input("Introduce la url: ")
    id_categoria = input("Introduce la categoria: ")
    cursor.execute('''
      INSERT INTO Piezas VALUES (
      NULL,
      "'''+titulo+'''",
      "'''+descripcion+'''",
      "'''+imagen+'''",
      "'''+url+'''",
      '''+id_categoria+'''
      );
    ''')
    conexion.commit()
  elif opcion == 2:

    cursor.execute('''
      SELECT * FROM Piezas;
    ''')

    filas = cursor.fetchall()

    for fila in filas:
      print(fila)
  elif opcion == 3:
    identificador = input("Introduce el id a actualizar: ")
    titulo = input("Introduce el titulo: ")
    descripcion = input("Introduce la descripcion: ")
    imagen = input("Introduce la imagen: ")
    url = input("Introduce la url: ")
    id_categoria = input("Introduce la categoria: ")
    cursor.execute('''
      UPDATE Piezas SET 
      titulo = "'''+titulo+'''",
      descripcion = "'''+descripcion+'''",
      imagen = "'''+imagen+'''",
      url = "'''+url+'''",
      id_categoria = '''+id_categoria+'''
      WHERE Identificador = '''+identificador+''';
    ''')
    conexion.commit()
  elif opcion == 4:
    identificador = input("Introduce el id a eliminar: ")
    cursor.execute('''
      DELETE FROM Piezas
      WHERE Identificador = '''+identificador+'''
    ''')
    conexion.commit()
```

### Actividades propuestas

### Actividades Propuestas

1. **Menú de Opciones Básico**
   - Descripción: El estudiante debe crear un menú en Python que permita al usuario seleccionar entre diferentes opciones y luego mostrar un mensaje correspondiente a la opción elegida.
   - Objetivo: Aprender a usar estructuras condicionales y bucles para manejar interacción del usuario.

2. **Manejo de Bucle Infinito**
   - Descripción: El estudiante debe modificar el menú básico para que funcione en un bucle infinito hasta que el usuario decida salir.
   - Objetivo: Aprender a utilizar bucles infinitos y manejar la interrupción del flujo de ejecución según una condición dada por el usuario.

3. **Condicionales Avanzados**
   - Descripción: El estudiante debe implementar las condiciones dentro del menú para que cada opción realice tareas específicas.
   - Objetivo: Aprender a usar estructuras de control avanzadas como `if`, `elif` y `else`.

4. **Conexión a Base de Datos**
   - Descripción: El estudiante debe conectar un script Python con una base de datos MySQL local para realizar operaciones básicas.
   - Objetivo: Aprender la sintaxis básica para conectarse a una base de datos usando el módulo `mysql.connector`.

5. **Selección de Datos**
   - Descripción: El estudiante debe escribir un script que permita seleccionar y mostrar registros desde una tabla específica en una base de datos.
   - Objetivo: Aprender cómo realizar consultas SELECT en MySQL usando Python.

6. **Inserción de Datos**
   - Descripción: El estudiante debe implementar la funcionalidad para insertar nuevos registros en una tabla de la base de datos a partir del menú.
   - Objetivo: Familiarizarse con la inserción de datos en tablas MySQL utilizando Python.

7. **Eliminación de Datos**
   - Descripción: El estudiante debe agregar la funcionalidad para eliminar un registro específico según el ID proporcionado por el usuario.
   - Objetivo: Aprender a realizar operaciones DELETE y manejar entradas del usuario para identificar el registro a eliminar.

8. **Actualización de Datos**
   - Descripción: El estudiante debe añadir la funcionalidad que permite al usuario actualizar un registro existente en una tabla.
   - Objetivo: Familiarizarse con las consultas UPDATE y gestionar entradas del usuario para especificar los cambios a realizar.

Estas actividades están diseñadas para que los estudiantes practiquen habilidades clave de programación en Python, incluyendo interacción con bases de datos MySQL, manejo básico de flujo de ejecución y uso de estructuras de control condicional.


<a id="ejercicio-de-final-de-unidad-4"></a>
## Ejercicio de final de unidad

### Introducción a los ejercicios

Esta carpeta contiene un conjunto de ejercicios que abordan los conceptos fundamentales del lenguaje Python. Los problemas se enfocan en aspectos como la impresión básica, el uso y manipulación de variables, entrada/salida de datos, tipos de datos, operadores aritméticos y comparativos, así como la introducción a la creación de programas más complejos que realizan cálculos básicos. A través de estos ejercicios, los estudiantes practicarán habilidades esenciales en programación, incluyendo la resolución de problemas, la estructuración del código y la comprensión del flujo de ejecución de un programa Python.

### Holamundo
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es muy sencillo pero fundamental para entender cómo funciona la programación en Python. La línea `print("Hola mundo desde Python")` muestra el mensaje "Hola mundo desde Python" en la pantalla o consola donde se está ejecutando el programa. Este tipo de programa es conocido como "Hola Mundo", que es uno de los primeros ejercicios que los nuevos programadores suelen hacer para familiarizarse con un nuevo lenguaje de programación.

La función `print()` sirve para mostrar texto o valores en la consola, y el argumento entre paréntesis indica lo que queremos imprimir. En este caso, estamos imprimiendo una cadena de caracteres (una secuencia de letras y espacios) que comienza con "Hola mundo desde Python". Este ejercicio es importante porque te ayuda a entender cómo ejecutar tu primer programa en Python y cómo usar la función `print()` para mostrar información en pantalla.

En resumen, este código muestra el uso básico de una función integrada en Python (`print`) para presentar un mensaje al usuario. Es el punto de partida perfecto antes de comenzar con conceptos más complejos en la programación.

`001-Holamundo.py`

```python
print("Hola mundo desde Python")
```

### variables
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código establece dos variables en Python: `nombre` y `edad`. La variable `nombre` almacena un texto, que es el nombre de una persona ("Jose Vicente"), mientras que la variable `edad` almacena un número entero (47), representando los años de edad de esa misma persona. Este tipo de código es importante porque muestra cómo se pueden guardar datos diferentes en variables para ser utilizados posteriormente en programas más complejos, como mostrar información del usuario o realizar cálculos basados en la edad.

`002-variables.py`

```python
nombre = "Jose Vicente"
edad = 47
```

### salidas
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código en Python muestra cómo imprimir información en la pantalla utilizando la función `print()`. En este caso, se está mostrando un mensaje personalizado que incluye el nombre de una persona. La variable `nombre` almacena el valor "Jose Vicente". Luego, con la línea `print("Mi nombre es", nombre)`, el programa imprime en pantalla la frase "Mi nombre es" seguida del contenido de la variable `nombre`. Esto demuestra cómo se pueden combinar texto y variables para formar mensajes útiles y personalizados.

Este tipo de código es fundamental porque permite a los programas comunicarse con el usuario mostrando información relevante. Es especialmente útil cuando necesitas que tu programa presente datos calculados o almacenados en variables.

`003-salidas.py`

```python
nombre = "Jose Vicente"
print("Mi nombre es",nombre)
```

### variar una variable
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código muestra cómo se pueden cambiar los valores de una variable en Python. En este caso, la variable `nombre` cambia su valor dos veces durante el programa. Primero, cuando el programa comienza, `nombre` se establece como "Jose Vicente". Luego, esta variable es usada para imprimir un mensaje que dice "Mi nombre es Jose Vicente" usando la función `print()`. Después, en una segunda parte del código, el valor de `nombre` cambia a "Juan", y nuevamente se imprime un nuevo mensaje con el mismo formato pero ahora diciendo "Mi nombre es Juan". 

Este ejemplo ilustra que las variables pueden ser reasignadas durante la ejecución del programa para reflejar cambios en los datos o estados. Es importante entender esto porque nos permite hacer programas más dinámicos y flexibles, adaptándose a diferentes situaciones según avanza su ejecución.

`004-variar una variable.py`

```python
nombre = "Jose Vicente"
print("Mi nombre es",nombre)

nombre = "Juan"
print("Mi nombre es",nombre)
```

### identificadores permitidos
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código está mostrando ejemplos válidos e inválidos para nombrar variables en Python, y destaca las reglas importantes que debes seguir cuando eliges los nombres para tus variables. La variable `nombre` almacena el string "Jose", mientras que la variable `nombre2` almacena "Vicente". Luego, hay comentarios que muestran ejemplos de nombres de variables que no son válidos en Python: `2nombre`, `nombre-completo`, y `nombre completo`. Estos son inválidos porque los nombres de las variables no pueden comenzar con un número, ni contener guiones medios o espacios. Finalmente, se muestra una variable llamada `nombreCompleto` que es legal según las reglas de Python, pero generalmente no se recomienda usar mayúsculas en medio del nombre de la variable a menos que estés siguiendo el formato conocido como "Camel Case", lo cual es opcional y depende del estilo del código que estás utilizando.

`005-identificadores permitidos.py`

```python
nombre = "Jose"
nombre2 = "Vicente"
# 2nombre = "Jose Vicente"
nombre_completo = "Jose Vicente"
#nombre-completo = "Jose Vicente"
#nombre completo = "Jose Vicente"
nombreCompleto = "Jose Vicente" # Es legal pero no se recomienda
```

### comentarios
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código muestra cómo se utilizan los comentarios en Python. Los comentarios son bloques de texto que el programa ignora durante la ejecución, pero que ayudan a los programadores a entender mejor qué hace el código.

En primer lugar, hay un comentario de una sola línea que comienza con el símbolo `#`. Todo lo que esté después del `#` en esa línea no será procesado por Python y se utiliza simplemente para proporcionar información sobre ese fragmento del código.

A continuación, tienes un comentario de múltiples líneas. Estos comentarios están encerrados entre triples comillas simples (`'''`) al inicio y al final. Puedes escribir varias líneas dentro de estas marcas y Python las ignorará durante la ejecución, pero serán útiles para describir partes más extensas del código o explicar procedimientos complejos.

Los comentarios son importantes porque ayudan a mantener el código limpio y fácil de entender, especialmente cuando otros programadores necesitan leer tu código o si tú mismo lo revisas después de un tiempo.

`006-comentarios.py`

```python
# Esto es un comentario de una única línea

'''
    Esto es un comentario
    Esto sigue siendo un comentario
    Y esto también lo es
'''
```

### Explicacion del codigo
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código en Python define una variable llamada `edad` e inicializa esta variable con el número 47. En la programación, cuando decimos que "asignamos un valor a una variable", nos referimos a vincular esa variable (en este caso, `edad`) con un determinado valor numérico o de otro tipo. Aquí, `edad` es lo que llamamos un **identificador**, que es simplemente el nombre que damos a la variable para poder usarla en nuestro programa. El símbolo `=` se utiliza como operador de asignación, lo que significa que estamos indicando que queremos que `edad` represente el valor 47 a partir de ahora.

Este tipo de código es fundamental porque te permite almacenar información temporalmente mientras tu programa está funcionando y usar esa información para realizar cálculos o tomar decisiones basadas en ese dato. En este caso, podrías utilizar la variable `edad` para determinar si un usuario es mayor de edad u otras situaciones donde sea relevante su edad.

`007-Explicacion del codigo.py`

```python
edad = 47
# edad es el identificador
# = es el operador de asignación
# 47 es el valor literal que se es está asignando al identificador
```

### Tipos de datos
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es una introducción a los tipos de datos básicos en Python. Define cuatro variables con diferentes tipos de datos: 

- `nombre` almacena un texto, lo que se llama una cadena de caracteres (string) y contiene el nombre "Jose Vicente".
- `edad` guarda un número entero (integer), que en este caso es 47.
- `altura` tiene un valor decimal o flotante (float), que aquí es 1.78, representando metros.
- `vivo` es una variable booleana (boolean) que contiene el valor True, lo cual indica verdadero en este contexto.

Este código muestra cómo asignar valores a variables utilizando diferentes tipos de datos, que son fundamentales para cualquier programa que maneje información diversa como nombres, números y respuestas lógicas.

`008-Tipos de datos.py`

```python
nombre = "Jose Vicente" # Cadena
edad = 47 # Entero
altura = 1.78 # Decimal
vivo = True # Booleano
```

### Entradas
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código te ayuda a interactuar con el usuario pidiéndole que introduzca su nombre y luego muestra ese nombre en pantalla. La función `input()` se utiliza para recibir datos del usuario, en este caso, el programa espera que escribas tu nombre cuando aparezca la invitación "Dime tu nombre: ". Una vez que introduces un nombre y presionas Enter, el valor ingresado se almacena en la variable llamada `nombre`. Luego, con el comando `print()`, el programa muestra en pantalla una frase seguida del contenido de la variable `nombre`. Esto es útil para confirmar que has recibido correctamente la información proporcionada por el usuario y también para dar feedback inmediato.

`009-Entradas.py`

```python
nombre = input("Dime tu nombre: ")
print("Tu nombre es: ",nombre)
```

### Entrada y problema
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código en Python solicita al usuario que ingrese su edad y luego imprime el doble de esa edad. Primero, la línea `edad = input("Dime tu edad: ")` muestra un mensaje en pantalla pidiendo al usuario que introduzca su edad. La entrada del usuario se guarda en la variable `edad`. Es importante notar que la función `input()` siempre devuelve una cadena (texto), incluso si el usuario ingresa un número.

Luego, la línea `print("El doble de tu edad es: "+edad)` muestra por pantalla un mensaje junto con el contenido de la variable `edad`. Sin embargo, aquí hay un detalle a tener en cuenta: el código imprime simplemente la cadena almacenada en `edad` sin calcular realmente el doble de la edad numérica. Para hacer el cálculo correcto, sería necesario convertir la entrada del usuario (que es una cadena) en un número entero antes de multiplicarlo por dos.

Este código es importante porque muestra cómo interactuar con el usuario y manipular la información que proporciona, aunque no realiza completamente la operación matemática que sugiere.

`010-Entrada y problema.py`

```python
edad = input("Dime tu edad: ")
print("El doble de tu edad es: "+edad)
```

### Cambio de tipo de dato
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código en Python solicita al usuario que introduzca su edad, realiza algunas operaciones con ese dato y muestra un resultado final. Primero, la línea `edad = input("Dime tu edad: ")` pide al usuario que ingrese su edad a través del teclado y guarda esa entrada como una cadena de texto (string) en la variable `edad`. Luego, se utiliza la función `int()` para convertir esta cadena de texto en un número entero, almacenado en la variable `entero`.

A continuación, el código calcula el doble de este número entero y lo guarda en una nueva variable llamada `doble`. Finalmente, se intenta imprimir por pantalla el resultado usando la línea `print("El doble de tu edad es: "+doble)`, pero aquí hay un error. Como `doble` es un número entero y no una cadena, esta línea dará un error al tratar de concatenar un string con un integer directamente.

Para corregir esto, deberíamos convertir el valor de `doble` a una cadena antes de intentar combinarlo con la frase "El doble de tu edad es: ". Por ejemplo, usando `str(doble)` para convertir `doble` en un string antes de imprimir.

`011-Cambio de tipo de dato.py`

```python
# Le pregunto al usuario por su edad
edad = input("Dime tu edad: ")
# Me aseguro de convertir la edad a un número entero
entero = int(edad)
# Calculo el doble de un número entero
doble = entero*2
# Saco el resultado por pantalla
print("El doble de tu edad es: "+doble)
```

### literales
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código en Python muestra cómo se definen variables con valores literales específicos. En este caso, se declaran dos variables: `nombre` y `edad`. La variable `nombre` está asignada con la cadena "Jose Vicente", lo que significa que esta variable almacena texto entre comillas. Por otro lado, `edad` es una variable que contiene el número entero 47.

Los valores como "Jose Vicente" y 47 se denominan literales en programación porque representan directamente los datos sin necesidad de ser calculados o referenciados a través de otras variables. Es importante entender la diferencia entre las cadenas (como `"Jose Vicente"`), que son colecciones de caracteres, y los enteros (como `47`), que son números sin decimales. Esta distinción es crucial para manipular correctamente el tipo de datos en tus programas.

`012-literales.py`

```python
nombre = "Jose Vicente"
# Jose Vicente es el literal, y es de tipo cadena

edad = 47
# 47 es el literal, y es de tipo entero
```

### constantes
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código muestra cómo se pueden cambiar los valores de una variable en Python, aunque normalmente usamos nombres en mayúsculas para sugerir que ciertas variables son constantes. En el ejemplo, primero se asigna un valor a `PI`, que es aproximadamente 3.1415, y luego este valor se imprime. A continuación, cambiamos el valor de `PI` a 4 y volvemos a imprimirlo. Este código destaca dos puntos importantes: la mutabilidad de las variables en Python (es decir, pueden cambiarse después de su inicialización) y la convención de usar mayúsculas para nombrar constantes (aunque esto es una recomendación más que una regla estricta del lenguaje). La práctica de usar nombres en mayúsculas para las constantes ayuda a los programadores a entender fácilmente el propósito de esa variable al leer el código.

`013-constantes.py`

```python
PI = 3.1415

print("PI vale",PI)

PI = 4 # Le cambio el valor a PI

print("PI vale",PI)
# Las constantes deben formularse con mayúsculas
# Las variables deben formularse con minúsculas
```

### Diferencia
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código está mostrando un ejemplo de cómo se puede cambiar el tipo de una variable en Python, lo cual a veces puede ser confuso o problemático para los programadores principiantes. En este caso, primero se declara la constante `PI` y le asigna el valor numérico 3.1416, que es una aproximación del número matemático pi (π). Sin embargo, después de esto, el código redefine `PI` como la cadena "unnumero". Al hacer esto, pierdes la funcionalidad original que se pretendía con esta variable, ya que ahora no puedes realizar operaciones numéricas con ella. Es importante entender este ejemplo para aprender a manejar cuidadosamente las variables y evitar cambios inesperados en el tipo de datos durante la ejecución del programa.

`014-Diferencia.py`

```python

# La constante es PI
# El literal es 3.1416

PI = 3.1416

PI = "unnumero"
```

### operadores aritmeticos
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código en Python muestra ejemplos sencillos de operaciones aritméticas básicas. Se utiliza la función `print()` para mostrar el resultado de cinco diferentes operaciones: suma, resta, multiplicación, división y módulo (que devuelve el resto después de una división entera). Cada línea realiza una operación matemática simple utilizando los números 4 y 3.

La primera línea imprime la suma de 4 más 3, que es 7. La segunda línea resta 3 de 4, resultando en 1. La tercera línea multiplica 4 por 3 para dar 12. La cuarta línea divide 4 entre 3 y muestra el resultado como un número decimal (1.3333). Finalmente, la quinta línea calcula el resto de dividir 4 entre 3, lo cual es 1.

Estos ejemplos son fundamentales para entender cómo realizar cálculos matemáticos en Python y sirven como base para construir programas más complejos que requieren operaciones aritméticas.

En comparación con la versión anterior (014-Diferencia.py), este código se aleja de los conceptos relacionados con constantes y literales, y se enfoca completamente en el uso de diferentes tipos de operadores aritméticos. Mientras que antes se exploraban las diferencias entre asignaciones de valores a variables y definiciones de constantes, ahora se está introduciendo directamente cómo realizar cálculos usando Python.

`014-operadores aritmeticos.py`

```python
print(4+3)
print(4-3)
print(4*3)
print(4/3)
print(4%3)
```

### operadores de comparacion
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código en Python muestra cómo usar diferentes operadores de comparación para comparar números. Los operadores que se utilizan aquí son `<` (menor que), `<=` (menor o igual que), `>` (mayor que), `>=` (mayor o igual que), `==` (igual a) y `!=` (diferente de). Cada línea compara el número 4 con el número 3 usando uno de estos operadores y luego imprime el resultado de la comparación, que será un valor booleano (`True` o `False`). Por ejemplo, la primera línea verifica si 4 es menor que 3 (lo cual no es cierto, por lo que imprimirá `False`). Este tipo de código es útil para entender cómo Python evalúa estas condiciones y cómo puedes usarlos en tus programas para tomar decisiones basadas en comparaciones.

`015-operadores de comparacion.py`

```python
print(4 < 3)
print(4 <= 3)
print(4 > 3)
print(4 >= 3)
print(4 == 3)
print(4 != 3)
```

### operadores arimeticos abreviados
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código muestra cómo usar operadores aritméticos abreviados en Python para modificar el valor de una variable. En este caso, la variable es `edad`, que inicialmente se establece en 47. El código realiza varias operaciones con `edad` utilizando tanto los operadores tradicionales como sus equivalentes abreviados.

Primero, el código suma dos unidades a `edad` usando primero una suma tradicional (`edad = edad + 2`) y luego con un operador abreviado (`edad += 2`). Luego, realiza la misma acción pero restando dos unidades (`edad = edad - 2` y `edad -= 2`), multiplicando por dos (`edad = edad * 2` y `edad *= 2`), y finalmente dividiendo por dos (`edad = edad / 2` y `edad /= 2`). Los operadores abreviados no solo hacen que el código sea más corto, sino también más claro en cuanto a su propósito.

Estos operadores son muy útiles para simplificar el código y hacerlo más legible, especialmente cuando se necesitan realizar cambios sencillos en variables como incrementar o decrementar valores.

`016-operadores arimeticos abreviados.py`

```python
edad = 47
# Le quiero sumar dos unidades
edad = edad + 2
edad += 2
#Le quiero restar dos unidades
edad = edad - 2
edad -= 2
# Lo quiero multiplicar por dos
edad = edad * 2
edad *= 2
# Lo quiero dividir por dos
edad = edad / 2
edad /= 2
```

### operadores booleanos
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código en Python demuestra el uso de operadores booleanos, que son herramientas importantes para la lógica y las decisiones en programación. Los operadores `and` y `or` se utilizan para combinar expresiones de comparación, dando como resultado un valor verdadero o falso dependiendo de los valores de dichas expresiones.

En el código, primero vemos varias líneas que evalúan si diferentes comparaciones son ciertas utilizando `==`, que es el operador de igualdad. Por ejemplo, en la línea `print(4 == 4 and 3 == 3 and 2 == 2)`, cada una de las tres comparaciones individuales (4 == 4, 3 == 3, y 2 == 2) son verdaderas, por lo que toda la expresión combinada con `and` también es verdadera.

Después, hay ejemplos donde se usan tanto el operador `and` como el `or`. El operador `and` requiere que todas las condiciones sean verdaderas para que todo sea verdadero. Por ejemplo, en `print(4 == 4 and 3 == 3 and 2 == 1)`, la última comparación es falsa (2 != 1), por lo que toda la expresión da como resultado falso.

Por otro lado, el operador `or` solo necesita una de las condiciones para ser verdadera. Por ejemplo, en `print(4 == 4 or 3 == 2 or 2 == 1)`, aunque dos de las comparaciones son falsas (3 != 2 y 2 != 1), la primera es verdadera (4 == 4), lo que hace que toda la expresión sea verdadera.

Este tipo de lógica booleana es fundamental en programación, ya que permite a los programas tomar decisiones basadas en múltiples condiciones.

`017-operadores booleanos.py`

```python
print(4 == 4 and 3 == 3 and 2 == 2)
print(4 == 4 and 3 == 3 and 2 == 1)

print(4 == 4 or 3 == 3 or 2 == 1)
print(4 == 4 or 3 == 2 or 2 == 1)
print(4 == 3 or 3 == 2 or 2 == 1)
```

### Ejercicio1-Calculadora de impuestos
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código es el encabezado de un programa en Python llamado "Calculadora de Impuestos". El propósito principal del programa es calcular el impuesto sobre la venta (IVA) a partir de un monto ingresado por el usuario. En este caso, se espera que el usuario introduzca una cantidad base imponible y luego el programa calculará tanto el IVA como el total resultante después de aplicar el impuesto.

El comentario inicial proporciona información básica sobre la versión del programa (v0.1) y su autor (Jose Vicente Carratalá). Esto es importante porque ayuda a identificar fácilmente quién creó el código y qué versión está utilizando, lo que puede ser útil si se necesita actualizar o corregir el programa en un futuro.

Aunque no se muestra en este fragmento, sería de esperar que el cuerpo del programa contenga funciones para calcular el IVA y mostrar tanto la cantidad base como el total después de aplicar el impuesto.

`018-Ejercicio1-Calculadora de impuestos.py`

```python
'''
    Calculadora de Impuestos
    v0.1 por Jose Vicente Carratalá
    Funcionamiento: Introduce una base imponible y se calcula IVA y total
'''
```

### Calculadora
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es el comienzo de un programa en Python diseñado para calcular impuestos. La idea principal es que el usuario introduzca una cantidad llamada "base imponible" y luego se calcule tanto el IVA como el total de la factura.

En primer lugar, el programa declara tres variables: `base_imponible`, `total_iva` y `total_factura`. Estas variables van a almacenar los valores necesarios para realizar las operaciones matemáticas relacionadas con el cálculo del impuesto.

Luego, se solicita al usuario que introduzca la base imponible de una factura utilizando la función `input()`, lo cual guarda el valor ingresado por el usuario en la variable `base_imponible`. Este paso es crucial porque sin esta entrada del usuario, no sería posible realizar los cálculos posteriores. El siguiente paso, que aún no se muestra en este fragmento de código, debería incluir la lógica para calcular tanto el IVA como el total facturado a partir de la base imponible proporcionada por el usuario.

Es importante destacar que aunque el programa pide al usuario introducir una cantidad, esta entrada es recibida como un string. Para realizar cálculos matemáticos con ella, será necesario convertirla a un número (por ejemplo, usando `float()` o `int()`, dependiendo del tipo de dato adecuado).

`019-Calculadora.py`

```python
'''
    Calculadora de Impuestos
    v0.1 por Jose Vicente Carratalá
    Funcionamiento: Introduce una base imponible y se calcula IVA y total
'''

# Este programa no tiene importaciones

# Creo variables
base_imponible = 0
total_iva = 0
total_factura = 0

# Aquí pondría las funciones/clases

# Ahora calculamos
base_imponible = input("Introduce la base imponible de la factura: ")
```

### Calculadora
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código es un programa sencillo en Python que permite calcular el IVA y el total de una factura basándose en la base imponible introducida por el usuario. Al ejecutar el programa, se muestra un mensaje al usuario indicando el propósito del programa y solicitándole que ingrese la base imponible de la factura.

El código crea tres variables: `base_imponible`, `total_iva` y `total_factura`. Estas variables almacenarán los valores correspondientes a la base imponible, el IVA calculado y el total de la factura respectivamente. Por ahora, estas variables están inicializadas con cero.

Después del bloque de comentarios que explica cómo funciona el programa, hay un bloque de código que imprime varios mensajes para informar al usuario sobre el propósito del programa y solicitar la entrada de datos. La línea `base_imponible = input("Introduce la base imponible de la factura: ")` es crucial ya que toma la entrada del usuario a través del teclado y guarda ese valor en la variable `base_imponible`.

Es importante destacar que, aunque el programa pide al usuario que introduzca una base imponible, aún no realiza ningún cálculo sobre esa base imponible para determinar el IVA o el total. Estos pasos adicionales, como calcular el IVA y sumarlo a la base imponible para obtener el total de la factura, deberán ser implementados en las siguientes líneas del código.

`020-Calculadora.py`

```python
'''
    Calculadora de Impuestos
    v0.1 por Jose Vicente Carratalá
    Funcionamiento: Introduce una base imponible y se calcula IVA y total
'''

# Este programa no tiene importaciones

# Creo variables
base_imponible = 0
total_iva = 0
total_factura = 0

# Aquí pondría las funciones/clases

# Ahora calculamos
print("Programa calculadora de impuestos")
print("(c) 2025 Jose Vicente Carratalá")
print("Introduce una base y te calculo el IVA y el total")
base_imponible = input("Introduce la base imponible de la factura: ")
```

### Calculo de IVA
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código Python se utiliza para calcular el Impuesto sobre Valor Agregado (IVA) y el total de una factura basándose en la base imponible que proporciona el usuario. El programa comienza solicitando al usuario que ingrese la base imponible de la factura, lo cual hace mediante la función `input()`, convirtiendo la entrada del usuario a un número decimal con `float()`.

Una vez que se obtiene el valor de la base imponible, el código calcula el IVA aplicando una tasa del 21% (multiplicando la base imponible por 0.21) y luego suma este valor al monto original para obtener el total de la factura. Finalmente, muestra en pantalla tanto el IVA como el total calculado.

Este tipo de programa es útil para entender cómo interactuar con el usuario mediante entradas y salidas, así como realizar operaciones matemáticas básicas en Python. Te permite practicar conceptos fundamentales de programación, incluyendo variables, cálculos aritméticos y manejo de funciones `input()` y `print()`.

`021-Calculo de IVA.py`

```python
'''
    Calculadora de Impuestos
    v0.1 por Jose Vicente Carratalá
    Funcionamiento: Introduce una base imponible y se calcula IVA y total
'''

# Este programa no tiene importaciones

# Creo variables
base_imponible = 0
total_iva = 0
total_factura = 0

# Aquí pondría las funciones/clases

# Ahora calculamos

# Primero pido una entrada
print("Programa calculadora de impuestos")
print("(c) 2025 Jose Vicente Carratalá")
print("Introduce una base y te calculo el IVA y el total")
base_imponible = float(input("Introduce la base imponible de la factura: "))

# Luego realizo cálculos
total_iva = base_imponible*0.21
total_factura = base_imponible + total_iva

# Por último expreso una salida
print("El IVA de la factura es: ",total_iva)
print("El total de la factura es: ",total_factura)
```

### Actividades propuestas

### Actividad 1: Introducción al Lenguaje Python
**Descripción:** Los alumnos deben crear un programa sencillo que imprima "Hola mundo" en pantalla. El objetivo es familiarizarse con el entorno de desarrollo y entender la sintaxis básica de Python.

---

### Actividad 2: Variables y Entrada/Salida
**Descripción:** Se les pide a los estudiantes que creen un programa donde soliciten al usuario su nombre y edad, luego imprimir ambas variables en pantalla. Esta actividad ayuda a comprender el manejo de datos e interacción con el usuario.

---

### Actividad 3: Operaciones Básicas
**Descripción:** Los alumnos deben escribir un código que realice operaciones aritméticas básicas (suma, resta, multiplicación y división) entre dos números ingresados por el usuario. Esto reforzará su entendimiento de los tipos de datos numéricos y las operaciones sobre ellos.

---

### Actividad 4: Operadores Lógicos
**Descripción:** La tarea consiste en crear un programa que evalúe expresiones lógicas (usando AND, OR) entre diferentes condiciones booleanas. Esto ayudará a los estudiantes a entender la lógica y estructura condicional.

---

### Actividad 5: Conversión de Tipos
**Descripción:** Los alumnos deben escribir una función que solicite al usuario un número en formato texto (como entrada de cadena), lo convierta a entero, realice alguna operación aritmética básica con este valor y muestre el resultado. Esta actividad refuerza los conceptos de tipos de datos y conversión.

---

### Actividad 6: Operaciones Aritméticas Avanzadas
**Descripción:** Los estudiantes deben desarrollar un programa que realice operaciones matemáticas más complejas (por ejemplo, cálculo del IVA en una factura) con operadores aritméticos y de asignación abreviados. Esto proporciona práctica adicional con operadores y manejo de datos numéricos.

---

### Actividad 7: Manejo de Errores Básicos
**Descripción:** Se les pide a los estudiantes que identifiquen y resuelvan errores en un código existente (como el visto en `011-Cambio de tipo de dato.py`). Esto mejora sus habilidades para detectar problemas y mejorar la robustez del código.

---

### Actividad 8: Programa Completo - Calculadora de Impuestos
**Descripción:** Los alumnos deben completar un programa proporcionado (base en `021-Calculo de IVA.py`) que calcula el IVA de una factura. Esto les permitirá integrar varios conceptos aprendidos y practicar la creación de un programa completo desde inicio a fin.

---

### Actividad 9: Documentación y Comentarios
**Descripción:** Los estudiantes deben agregar documentación (comentarios) en sus programas anteriores para explicar lo que hace cada parte del código. Esto mejora su habilidad de comunicación técnica y entendimiento profundo del código.

---

### Actividad 10: Uso Eficiente de Variables
**Descripción:** Se les pide a los estudiantes diseñar un programa donde se utilizan variables correctamente, incluyendo buenas prácticas de nomenclatura (como usar mayúsculas para constantes). Esto refuerza su conocimiento sobre la correcta utilización y declaración de variables en Python.


<a id="examen-final"></a>
## Examen final

### Introducción a los ejercicios

Esta carpeta contiene un conjunto de ejercicios orientados a desarrollar habilidades en el manejo y administración de bases de datos SQL. Los estudiantes aprenderán desde la creación de tablas, inserción de datos y definición de relaciones entre tablas hasta la ejecución de consultas avanzadas que incluyen joins y vistas para integrar información de múltiples tablas. Además, se practica la gestión de usuarios y permisos en un entorno de base de datos, lo cual es crucial para el control y seguridad del sistema.

El objetivo principal es familiarizar a los estudiantes con las operaciones CRUD (Crear, Leer, Actualizar, Eliminar) mediante SQL, así como entender cómo estructurar una base de datos relacionada eficientemente.

### crear tablas
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código SQL se utiliza para crear una base de datos y dos tablas relacionadas dentro de ella. Primero, se crea una base de datos llamada "portafolioceac" usando la sentencia `CREATE DATABASE`. Luego, con la instrucción `USE portafolioceac`, se selecciona esta base de datos recién creada para trabajar en ella.

A continuación, se definen dos tablas: "Piezas" y "Categorias". La tabla "Piezas" contiene información sobre diferentes piezas (por ejemplo, obras de arte o productos), incluyendo un identificador único para cada pieza generado automáticamente (`Identificador INT auto_increment PRIMARY KEY`), detalles como el título, descripción e imagen de la pieza, así como una URL y una referencia a su categoría con `id_categoria INT`.

La tabla "Categorias" almacena información sobre las diferentes categorías en las que se pueden clasificar las piezas. Cada categoría tiene un identificador único generado automáticamente (`Identificador INT auto_increment PRIMARY KEY`) y campos para el título y la descripción de la categoría.

Este código es importante porque establece la estructura básica del sistema de almacenamiento de datos, permitiendo una organización eficiente de la información sobre las piezas y sus categorías.

`001-crear tablas.sql`

```sql
CREATE DATABASE portafolioceac;

USE portafolioceac;


CREATE TABLE Piezas(
  Identificador INT auto_increment PRIMARY KEY,
  titulo VARCHAR(255),
  descripcion VARCHAR(255),
  imagen VARCHAR(255),
  url VARCHAR(255),
  id_categoria INT
);

CREATE TABLE Categorias(
  Identificador INT auto_increment PRIMARY KEY,
  titulo VARCHAR(255),
  descripcion VARCHAR(255)
);
```

### insertar
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código SQL se utiliza para insertar datos en dos tablas diferentes: `Categorias` y `Piezas`. Primero, se agrega una nueva categoría a la tabla `Categorias`. La primera columna (`NULL`) representa el ID automático que generará la base de datos ya que no se especifica ningún valor. Las siguientes columnas contienen 'General' para el nombre de la categoría y una descripción que indica que es una categoría general.

Luego, se insertan detalles de una pieza en la tabla `Piezas`. De nuevo, el primer campo (`NULL`) es para el ID automático. La inserción incluye un título "Primera pieza", una breve descripción, el nombre del archivo imagen asociado que es 'josevicente.jpg', una URL y finalmente se indica que esta pieza pertenece a la categoría con ID 1.

Este tipo de código es fundamental para poblar una base de datos con información inicial, lo cual es necesario antes de que los usuarios puedan comenzar a trabajar con ella.

`002-insertar.sql`

```sql
INSERT INTO Categorias VALUES(
  NULL,
  'General',
  'Esta es la categoria general'
);

INSERT INTO Piezas VALUES(
  NULL,
  'Primera pieza',
  'Esta es la descripcion de la primera pieza',
  'josevicente.jpg',
  'https://jocarsa.com',
  1
);
```

### fk
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código SQL se utiliza para modificar una tabla existente llamada `Piezas`. En concreto, añade una restricción de tipo "foreign key" que asegura la integridad referencial entre las tablas `Piezas` y `Categorias`.

La instrucción `ADD CONSTRAINT` introduce una nueva regla en la base de datos. Aquí, se crea una clave foránea llamada `fk_piezas_categorias`, que vincula el campo `id_categoria` de la tabla `Piezas` con el campo `identificador` de la tabla `Categorias`. Esto significa que cada valor que se almacena en `id_categoria` debe existir también como un valor en el campo `identificador` de la tabla `Categorias`.

Las cláusulas `ON DELETE CASCADE` y `ON UPDATE CASCADE` especifican cómo deben comportarse las tablas relacionadas si se eliminan o actualizan registros en la tabla principal. En este caso, cuando se elimina un registro de la tabla `Categorias`, todos los registros relacionados en la tabla `Piezas` también serán borrados automáticamente (`ON DELETE CASCADE`). De igual manera, si se modifica el valor del campo `identificador` en la tabla `Categorias`, se actualizará automáticamente el mismo campo en la tabla `Piezas` (`ON UPDATE CASCADE`).

Este tipo de restricciones es fundamental para mantener la consistencia y integridad de los datos en una base de datos relacionante.

`003-fk.sql`

```sql
ALTER TABLE Piezas
ADD CONSTRAINT fk_piezas_categorias
FOREIGN KEY (id_categoria) REFERENCES Categorias(identificador)
ON DELETE CASCADE
ON UPDATE CASCADE;
```

### selecciones
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

El código SQL que has proporcionado consta de dos consultas simples que se utilizan para recuperar datos de dos tablas diferentes en una base de datos. La primera consulta, `SELECT * FROM Categorias;`, selecciona todos los campos y registros de la tabla llamada "Categorias". Esto significa que obtendrás toda la información almacenada en esta tabla sin especificaciones adicionales.

La segunda consulta, `SELECT * FROM Piezas;`, hace lo mismo pero para la tabla "Piezas". De nuevo, se recuperan todos los campos y registros disponibles de esta tabla. Estas consultas son útiles cuando necesitas un vistazo completo a cómo están estructuradas estas tablas o cuando simplemente requieres toda la información que contienen sin filtros adicionales.

En el contexto de formación profesional en programación, es importante entender estos comandos básicos porque te permiten interactuar directamente con las bases de datos y comprender su contenido. Esto es fundamental para poder realizar tareas más avanzadas como modificar o actualizar la información almacenada.

`004-selecciones.sql`

```sql
SELECT * FROM Categorias;

SELECT * FROM Piezas;
```

### left join
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código SQL realiza una operación llamada `LEFT JOIN` entre dos tablas, que en este caso se denominan `Piezas` y `Categorias`. El propósito principal del `LEFT JOIN` es combinar todos los datos de la tabla izquierda (en este caso, `Piezas`) con los datos correspondientes de la tabla derecha (`Categorias`). Esto significa que incluso si no hay una coincidencia en la tabla `Categorias`, se incluirán todas las filas de la tabla `Piezas`.

La cláusula `ON Piezas.id_categoria = Categorias.Identificador` especifica cómo deben unirse estas dos tablas. Aquí, se establece que cada fila en la tabla `Piezas` debe buscarse una coincidencia con la columna `Identificador` de la tabla `Categorias`. Es decir, si el valor de la columna `id_categoria` de alguna pieza coincide con algún valor en la columna `Identificador` de las categorías, entonces se combinarán los datos de ambas tablas para esa pieza.

Esta consulta es importante porque permite a un usuario obtener información completa sobre cada pieza, incluyendo su categoría, sin perder ninguna fila del lado de la tabla `Piezas`. Esto resulta útil en escenarios donde necesitas ver todos los detalles de las piezas junto con sus categorías asociadas, aunque algunas piezas puedan no tener una categoría asignada.

`005-left join.sql`

```sql
SELECT 
* 
FROM Piezas
LEFT JOIN Categorias
ON Piezas.id_categoria = Categorias.Identificador;
```

### ahora creo la vista
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código SQL crea una vista llamada `piezas_y_categorias` en la base de datos. Una vista es como una tabla virtual basada en los resultados de una consulta, lo que permite almacenar consultas complejas y acceder a ellas fácilmente.

La vista `piezas_y_categorias` combina información de dos tablas: `Categorias` y `Piezas`. Utiliza un `LEFT JOIN` para asociar cada pieza con su categoría correspondiente basándose en la columna `id_categoria` en la tabla `Piezas`, que se relaciona con la columna `Identificador` en la tabla `Categorias`.

Después de crear la vista, el código ejecuta una consulta que selecciona todos los registros de esta nueva vista utilizando el comando `SELECT * FROM piezas_y_categorias`. Esto muestra toda la información almacenada en la vista recién creada, incluyendo el título y descripción tanto de las categorías como de las piezas, así como la imagen y URL asociadas a cada pieza. Este tipo de consulta es útil para presentar datos relacionados de manera estructurada y fácil de entender.

`006-ahora creo la vista.sql`

```sql
CREATE VIEW piezas_y_categorias AS 
SELECT 
Categorias.titulo AS categoriatitulo,
Categorias.descripcion AS categoriadescripcion,
Piezas.titulo AS piezatitulo,
Piezas.descripcion AS piezadescripcion,
imagen,
url
FROM Piezas
LEFT JOIN Categorias
ON Piezas.id_categoria = Categorias.Identificador;

SELECT * FROM piezas_y_categorias;
```

### usuario
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código SQL está diseñado para crear y configurar un nuevo usuario en una base de datos MySQL, dando acceso a ese usuario a una base de datos específica. Primero, se crea el usuario 'portafolioceac' con la contraseña 'portafolioceac', permitiendo que acceda desde localhost. Luego, se ajustan los límites del usuario para permitirle hacer tantas consultas y conexiones como sean necesarias sin restricciones. Finalmente, se le otorgan todos los privilegios en una base de datos llamada 'portafolioceac', lo que significa que el usuario puede realizar cualquier operación dentro de esa base de datos. El comando `FLUSH PRIVILEGES` actualiza la configuración para asegurar que estos cambios estén activos inmediatamente.

Este código es crucial en entornos de desarrollo y producción donde se necesita gestionar permisos de acceso a bases de datos de manera segura y eficiente, permitiendo un control preciso sobre qué usuarios pueden hacer qué acciones dentro del sistema.

`007-usuario.sql`

```sql
-- crea usuario nuevo con contraseña
-- creamos el nombre de usuario que queramos
CREATE USER 
'portafolioceac'@'localhost' 
IDENTIFIED  BY 'portafolioceac';

-- permite acceso a ese usuario
GRANT USAGE ON *.* TO 'portafolioceac'@'localhost';
--[tuservidor] == localhost
-- La contraseña puede requerir Mayus, minus, numeros, caracteres, min len

-- quitale todos los limites que tenga
ALTER USER 'portafolioceac'@'localhost' 
REQUIRE NONE 
WITH MAX_QUERIES_PER_HOUR 0 
MAX_CONNECTIONS_PER_HOUR 0 
MAX_UPDATES_PER_HOUR 0 
MAX_USER_CONNECTIONS 0;

-- dale acceso a la base de datos empresadam
GRANT ALL PRIVILEGES ON portafolioceac.* 
TO 'portafolioceac'@'localhost';

-- recarga la tabla de privilegios
FLUSH PRIVILEGES;
```

### Actividades propuestas

### Actividad 1: Creación y Configuración de una Base de Datos

**Descripción:** Los estudiantes deben crear una base de datos similar a la proporcionada en el archivo `001-crear tablas.sql`. Además, deberán configurar las tablas correspondientes con sus respectivos atributos para almacenar información sobre categorías y piezas. Esta actividad tiene como objetivo que los alumnos comprendan cómo estructurar bases de datos relacionalmente.

### Actividad 2: Inserción de Datos en la Base de Datos

**Descripción:** Los estudiantes deben insertar datos en las tablas creadas en la base de datos, similar a lo realizado en `002-insertar.sql`. Se espera que los alumnos comprendan cómo utilizar consultas INSERT para introducir registros en una tabla con relaciones.

### Actividad 3: Creación de Relaciones entre Tablas

**Descripción:** Los estudiantes deberán añadir restricciones FOREIGN KEY entre las tablas `Categorias` y `Piezas`, tal como se muestra en el archivo `003-fk.sql`. Esta actividad busca que los alumnos comprendan cómo definir relaciones uno a muchos.

### Actividad 4: Consultas Básicas con JOIN

**Descripción:** Los estudiantes deben escribir consultas SELECT que devuelvan todos los registros de las tablas `Categorias` y `Piezas`, tal como se muestra en el archivo `004-selecciones.sql`. Se espera que comprendan cómo realizar consultas para obtener información completa desde una base de datos.

### Actividad 5: Consulta con LEFT JOIN

**Descripción:** Los estudiantes deben utilizar la instrucción LEFT JOIN para recuperar todos los registros de las tablas `Categorias` y `Piezas`, incluyendo aquellos que no tienen un correspondiente en ambas tablas, tal como se realiza en el archivo `005-left join.sql`. Esta actividad busca que comprendan cómo manejar relaciones entre tablas mediante JOINs.

### Actividad 6: Creación de Vistas en SQL

**Descripción:** Los estudiantes deben crear una vista similar a la definida en `006-ahora creo la vista.sql`, combinando datos desde las tablas `Categorias` y `Piezas`. Esta actividad tiene como objetivo que los alumnos aprendan cómo simplificar consultas complejas con vistas.

### Actividad 7: Creación de un Usuario SQL

**Descripción:** Los estudiantes deben crear un usuario nuevo en MySQL, configurar su contraseña y asignarle privilegios para acceder a una base de datos específica. Esta actividad permite que los alumnos comprendan cómo gestionar usuarios y permisos en MySQL.

### Actividad 8: Manipulación de Privilegios del Usuario

**Descripción:** Los estudiantes deben modificar los privilegios del usuario creado, eliminando cualquier límite establecido por defecto para permitir un acceso completo a la base de datos. Esta actividad busca que comprendan cómo administrar y configurar permisos de usuarios en SQL.

Estas actividades están diseñadas para proporcionar una comprensión práctica sobre el manejo básico y avanzado de bases de datos utilizando SQL, adecuadas para estudiantes de Formación Profesional con un nivel intermedio.


<a id="carpeta-sin-titulo"></a>
## Carpeta sin título



<a id="aplicacion-de-las-estructuras-de-almacenamiento"></a>
# Aplicación de las estructuras de almacenamiento

<a id="estructuras-estaticas-y-dinamicas"></a>
## Estructuras estáticas y dinámicas

### Introducción a los ejercicios

En esta carpeta se encuentran una serie de ejercicios diseñados para que los estudiantes comprendan y practiquen el uso de estructuras de datos estáticas y dinámicas en Python. Los ejercicios abarcan desde la creación y manipulación de tuplas, listas y diccionarios hasta la implementación de funcionalidades más avanzadas como la lectura y escritura de archivos JSON. A través de estos problemas, los estudiantes desarrollarán competencias fundamentales en programación, tales como el acceso a elementos de colecciones, modificación de estructuras de datos existentes, eliminación de elementos específicos y creación de aplicaciones interactivas que integran múltiples conceptos.

### estructuras estaticas
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código está creando una tupla llamada `coordenadas` con tres elementos: 4, 5 y 6. Una tupla es similar a una lista en Python, pero tiene la característica importante de ser inmutable, lo que significa que no puedes cambiar sus valores después de que se crea. En este caso, `coordenadas` representa un punto tridimensional en el espacio con coordenadas x=4, y=5 y z=6.

La notación `(4, 5, 6)` dentro de paréntesis indica a Python que estos números forman una sola entidad (la tupla) y no deben ser tratados como tres valores independientes. Es importante entender la diferencia entre listas y tuplas en programación porque elegir el tipo correcto depende del contexto: si necesitas datos que cambien, usa listas; si los datos son fijos, tuplas son una excelente opción para ahorrar recursos y prevenir errores de modificación accidental.

`001-estructuras estaticas.py`

```python
# x,y,z
coordenadas = (4,5,6)
```

### append a tupla
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código tiene un error al intentar añadir un elemento a una tupla utilizando el método `.append()`. Las tuplas en Python son estructuras de datos estáticas que no permiten agregar o eliminar elementos después de su creación, a diferencia de las listas. Cuando defines `coordenadas` como `(4,5,6)`, estás creando una tupla. Luego, el código intenta usar `coordenadas.append(7)` para añadir un nuevo elemento al final de la tupla. Sin embargo, esto causará un error porque las tuplas no tienen ningún método llamado `.append()`.

Es importante entender esta diferencia entre tuplas y listas en Python: mientras que las listas permiten agregar, eliminar o modificar elementos fácilmente con métodos como `.append()`, las tuplas son inmutables y una vez creadas, no pueden ser cambiadas. Si necesitas añadir un elemento a una estructura de datos, deberías usar una lista en lugar de una tupla.

En resumen, este código tiene el propósito de agregar un nuevo elemento a `coordenadas`, pero debido al uso incorrecto de una tupla en lugar de una lista, no funciona y genera un error.

`002-append a tupla.py`

```python
# x,y,z
coordenadas = (4,5,6)
coordenadas.append(7)
```

### escribir datos
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código Python está intentando modificar los valores de una tupla llamada `coordenadas`. La tupla inicialmente contiene tres números: `(4,5,6)`, que representan las coordenadas en un espacio tridimensional (x, y, z). Sin embargo, cuando se intenta cambiar cada uno de estos valores utilizando la sintaxis `[índice] = nuevo_valor`, el código produce un error porque las tuplas son estructuras de datos inmutables en Python. Esto significa que una vez creadas, los elementos dentro de una tupla no pueden ser modificados individualmente.

Es importante entender esta característica de las tuplas para evitar errores y también para elegir correctamente entre tuplas y listas cuando se está programando. Si necesitas una estructura de datos que permita cambios en sus valores después de su creación, debes usar una lista en lugar de una tupla.

`003-escribir datos.py`

```python
# x,y,z
coordenadas = (4,5,6)

coordenadas[0] = 11 # esto es la "x"
coordenadas[1] = 12 # esto es la "y"
coordenadas[2] = 13 # esto es la "z"
```

### leer datos
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código en Python está trabajando con tuplas, que son estructuras de datos inmutables que pueden almacenar varios valores. En este caso, se define una variable llamada `coordenadas` que inicialmente almacena los valores `(4, 5, 6)` como una tupla. Luego, la misma variable `coordenadas` es reasignada con nuevos valores `(11, 12, 13)`, sobrescribiendo la tupla original.

El código imprime el contenido de `coordenadas` después de la reasignación, mostrando así que ahora contiene los valores `(11, 12, 13)`. A continuación, se accede al primer elemento de la tupla (que es el índice 0 en Python, donde la numeración comienza desde cero), y este valor es impreso por pantalla. En resumen, esta parte del código demuestra cómo reasignar valores a una variable que contiene una estructura de datos como una tupla y cómo acceder a elementos específicos dentro de ella.

`004-leer datos.py`

```python
# x,y,z
coordenadas = (4,5,6)
coordenadas = (11,12,13)

print(coordenadas)

print(coordenadas[0])
```

### estructuras dinamicas
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código Python muestra cómo se utiliza una estructura de datos llamada "lista" para almacenar nombres de personas dinámicamente. La variable `agenda` es inicializada como una lista vacía, lo que significa que no contiene ningún elemento al principio. Luego, el código añade dos nombres a la lista: "Jose Vicente" y "Juan", utilizando el método `.append()`, que agrega elementos al final de la lista.

Después de agregar estos dos nombres, se imprime el contenido actual de `agenda` usando la función `print()`. Posteriormente, se agrega otro nombre, "Jorge", a la lista con `.append()` y luego se vuelve a imprimir el contenido de `agenda`.

Este ejemplo ilustra cómo las listas en Python permiten agregar elementos fácilmente durante la ejecución del programa, lo que es útil para aplicaciones donde los datos cambian o crecen dinámicamente, como una agenda de contactos.

`005-estructuras dinamicas.py`

```python
agenda = [] # corchetes = lista

agenda.append("Jose Vicente")
agenda.append("Juan")

print(agenda)

agenda.append("Jorge")

print(agenda)
```

### acceso a un solo elemento
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código Python muestra cómo trabajar con listas y añadir elementos a ellas. En primer lugar, se crea una lista vacía llamada `agenda` usando corchetes `[]`. Luego, se agregan dos nombres ("Jose Vicente" y "Juan") a la lista utilizando el método `.append()`, que añade un elemento al final de la lista.

Después del segundo uso de `.append()`, se imprime la lista completa para mostrar los nombres que ya están almacenados. A continuación, se agrega otro nombre ("Jorge") a la lista y se imprimen nuevamente todos los elementos de `agenda`. Finalmente, se muestra cómo acceder a un solo elemento en específico dentro de la lista utilizando la notación de corchetes `[]` para indicar el índice del elemento que queremos ver. En este caso, imprime el primer nombre ("Jose Vicente") porque está en el índice 0.

Este ejemplo es importante para entender cómo almacenar y acceder a datos en listas dinámicas en Python, lo cual es una habilidad fundamental en la programación.

`006-acceso a un solo elemento.py`

```python
agenda = [] # corchetes = lista

agenda.append("Jose Vicente")
agenda.append("Juan")

print(agenda)

agenda.append("Jorge")

print(agenda)
print(agenda[0])
```

### sobreescribir
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código Python muestra cómo se puede modificar una lista existente. La lista llamada `agenda` contiene tres nombres: 'Jose Vicente', 'Juan' y 'Jorge'. Al principio, el programa imprime esta lista con la función `print()`, lo que mostrará los nombres en el orden en que aparecen.

Luego, el código cambia el primer elemento de la lista (que es 'Jose Vicente') por 'Jaime' utilizando la sintaxis `agenda[0] = "Jaime"`. Aquí, el número 0 indica la posición del primer elemento en la lista ya que en Python, y muchas otras lenguajes de programación, se comienza a contar desde cero.

Finalmente, el programa imprime nuevamente la lista actualizada para mostrar cómo ha cambiado después de realizar la modificación. Esta técnica es útil cuando necesitas actualizar datos existentes en una estructura de datos como una lista, sin tener que crear una nueva lista por completo.

`007-sobreescribir.py`

```python
agenda = [
  'Jose Vicente',
  'Juan',
  'Jorge'
] # corchetes = lista

print(agenda)

agenda[0] = "Jaime"

print(agenda)
```

### eliminar elementos de la lista
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código Python muestra cómo eliminar el último elemento de una lista. La lista se llama `agenda` y contiene nombres de personas como elementos: 'Jose Vicente', 'Juan' y 'Jorge'. Primero, se imprime la lista completa para mostrar qué nombres están incluidos.

Después, se utiliza el método `pop()` en la lista `agenda`. Este método elimina el último elemento de la lista. En este caso, después de ejecutar `agenda.pop()`, el nombre 'Jorge' ya no estará en la lista porque ha sido eliminado.

Finalmente, vuelve a imprimirse la lista para demostrar que ahora falta el último nombre que se había eliminado previamente. Esto es útil cuando necesitas actualizar una lista removiendo elementos al final de ella, por ejemplo, si estás gestionando una agenda de contactos y deseas borrar un contacto del final de la lista.

`008-eliminar elementos de la lista.py`

```python
agenda = [
  'Jose Vicente',
  'Juan',
  'Jorge'
] # corchetes = lista

print(agenda)
agenda.pop()
print(agenda)
```

### quitar un elemento concreto
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es una pequeña aplicación en Python que muestra cómo eliminar un elemento específico de una lista. En este caso, se utiliza la variable `agenda` para almacenar una lista de nombres: 'Jose Vicente', 'Juan' y 'Jorge'. La función `print(agenda)` se usa al principio para mostrar el contenido inicial de la lista.

Luego, se llama a la función `pop()` con el argumento `1`, lo que significa que eliminará el segundo elemento de la lista (ya que en programación generalmente se comienza a contar desde 0). En este caso, el nombre 'Juan' es eliminado de la lista. Finalmente, se imprime nuevamente la lista para mostrar cómo ha cambiado después de la eliminación.

Este código es importante porque demuestra una forma básica pero efectiva de manipular listas en Python, permitiendo a los estudiantes entender cómo eliminar elementos específicos según sus necesidades.

`009-quitar un elemento concreto.py`

```python
agenda = [
  'Jose Vicente',
  'Juan',
  'Jorge'
] # corchetes = lista

print(agenda)
agenda.pop(1)
print(agenda)
```

### tupla de nuevo
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código está creando una tupla llamada `coordenadas` y le asigna los valores `(4, 5, 6)`. En Python, las tuplas son estructuras de datos que almacenan una secuencia inmutable (no modificable después de su inicialización) de elementos. En este caso, la tupla contiene tres números enteros: `4`, `5` y `6`.

El uso de tuplas es importante porque permiten almacenar conjuntos de valores relacionados de manera eficiente y segura. Por ejemplo, en este código se están utilizando para representar las coordenadas (posiblemente en un sistema cartesiano 3D) donde el primer número podría ser la coordenada X, el segundo la Y y el tercero la Z.

Las tuplas son útiles cuando necesitas una colección de datos que no cambia durante la ejecución del programa, lo que puede ayudar a evitar errores comunes como modificar accidentalmente un valor en una lista.

`010-tupla de nuevo.py`

```python
# x,y,z
coordenadas = (4,5,6)
```

### diccionario
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código crea un diccionario en Python llamado `coordenadas` que almacena tres valores: "x", "y" y "z". Cada uno de estos valores está asociado con una cadena que representa una coordenada numérica (4, 5, y 6 respectivamente). Luego, el programa imprime este diccionario en la consola.

El diccionario es una estructura de datos que permite almacenar pares de claves y valores. En este caso, las claves son cadenas ("x", "y", "z") y los valores también son cadenas que representan números. Aunque estos valores son numéricos, están guardados como texto (strings) dentro del diccionario.

La importancia de esta estructura radica en la capacidad de Python para acceder a cualquier valor almacenado en el diccionario mediante su clave única y también en cómo facilita el manejo de datos relacionales. En este ejemplo simple, se ilustra cómo podría ser útil al representar coordenadas o cualquier otro tipo de dato compuesto que necesite una etiqueta clara para cada parte del dato.

`011-diccionario.py`

```python
# x,y,z

coordenadas = {
  "x":"4",
  "y":"5",
  "z":"6"
}

print(coordenadas)
```

### acceso a un elemento
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código está trabajando con un diccionario en Python, que es una estructura de datos útil para almacenar información relacionada en pares clave-valor. En este caso, se ha creado un diccionario llamado `coordenadas` que contiene tres elementos: 'x', 'y' y 'z'. Cada uno de estos elementos tiene asociados valores específicos ('4', '5' y '6').

Lo primero que hace el código es imprimir todo el contenido del diccionario `coordenadas`. Esto muestra al usuario una representación completa del diccionario, incluyendo todas las claves y sus respectivos valores. Luego, se accede directamente a un elemento dentro del diccionario, en este caso, 'x', para imprimir solo su valor ('4').

Este código es importante porque demuestra cómo almacenar datos de manera organizada utilizando estructuras como los diccionarios y cómo recuperar información específica desde ellas. En contextos prácticos, esto podría ser útil para representar cosas como coordenadas geográficas o cualquier otro tipo de dato que tenga un formato clave-valor claramente definido.

`012-acceso a un elemento.py`

```python
# x,y,z

coordenadas = {
  "x":"4",
  "y":"5",
  "z":"6"
}

print(coordenadas)
print(coordenadas['x'])
```

### creamos una lista de la compra
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es una forma sencilla de crear y manipular una lista en Python, que en este caso representa una lista de la compra. Primero, se declara una variable llamada `lista_de_la_compra` y se inicializa como una lista vacía usando los corchetes []. Luego, el código añade varios elementos a esta lista utilizando el método `.append()`. Cada vez que `.append()` es utilizado, se agrega un nuevo elemento al final de la lista. En este caso, se agregan cuatro elementos: "mangos", "chorizos", "cerveza" y "patos". Finalmente, se utiliza `print(lista_de_la_compra)` para mostrar en pantalla toda la lista completa que acabamos de crear. Esto es útil porque nos permite ver cómo los diferentes alimentos han sido añadidos a nuestra lista de compra en el orden en que fueron agregados.

Este código ilustra una estructura de datos dinámica como las listas en Python, ya que puedes añadir elementos según sea necesario sin tener que definir su tamaño en un principio. Además, aprender cómo usar métodos como `.append()` es crucial para manipular y gestionar tus datos eficazmente en la programación.

`014-creamos una lista de la compra.py`

```python
lista_de_la_compra = []

lista_de_la_compra.append("mangos")
lista_de_la_compra.append("chorizos")
lista_de_la_compra.append("cerveza")
lista_de_la_compra.append("patos")

print(lista_de_la_compra)
```

### lista con diccionario
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código crea una lista vacía llamada `lista_de_la_compra` y luego agrega un diccionario a esa lista. El diccionario contiene información sobre un producto específico, en este caso, mangos, con dos claves: "producto" que se asigna al valor "mangos", y "cantidad" que se asigna al valor "4". Al final, el código imprime la lista para mostrar su contenido actual.

Esta técnica es útil cuando necesitas almacenar detalles adicionales sobre cada elemento en tu lista. En lugar de tener una simple lista de productos, puedes tener una lista de diccionarios donde cada diccionario contiene diferentes atributos del producto, como su nombre y cantidad. Esto te permite manejar datos más complejos y estructurados dentro de listas en Python.

`015-lista con diccionario.py`

```python
lista_de_la_compra = []

lista_de_la_compra.append(
  {
    "producto":"mangos",
    "cantidad":"4"
  }
)

print(lista_de_la_compra)
```

### un segundo elemento
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código Python crea una lista llamada `lista_de_la_compra` que almacena dos diccionarios, cada uno representando un producto y su cantidad. Al principio del programa, la lista está vacía (`[]`). Luego, se añaden dos elementos a la lista usando el método `.append()`. Cada elemento es un diccionario con dos claves: "producto" para el nombre del artículo y "cantidad" para el número de unidades que se quieren comprar.

El primer `.append()` agrega un diccionario que contiene información sobre mangos, especificando que hay 4 unidades. El segundo `.append()` hace lo mismo pero con manzanas, indicando una cantidad de 7 unidades.

Finalmente, el programa imprime en pantalla la lista completa (`print(lista_de_la_compra)`), mostrándonos así los dos diccionarios que hemos añadido. Esto es útil para verificar que los productos y sus cantidades se han almacenado correctamente en la lista de la compra.

`016-un segundo elemento.py`

```python
lista_de_la_compra = []

lista_de_la_compra.append(
  {
    "producto":"mangos",
    "cantidad":"4"
  }
)
lista_de_la_compra.append(
  {
    "producto":"manzanas",
    "cantidad":"7"
  }
)

print(lista_de_la_compra)
```

### carga inicial
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código crea una lista en Python llamada `lista_de_la_compra` que contiene dos diccionarios. Cada uno de estos diccionarios representa un artículo diferente en la lista, con las claves `"producto"` y `"cantidad"`, que almacenan el nombre del producto y su cantidad respectivamente.

Por ejemplo, el primer elemento de la lista es un diccionario que indica que se deben comprar 4 mangos. El segundo elemento es otro diccionario que especifica la compra de 7 manzanas.

Finalmente, el código imprime esta lista en la consola para visualizar su contenido. Esto ayuda a verificar que los datos se han almacenado correctamente y son accesibles para ser utilizados o modificados según sea necesario en otras partes del programa.

`017-carga inicial.py`

```python
lista_de_la_compra = [
  {
    "producto":"mangos",
    "cantidad":"4"
  },
  {
    "producto":"manzanas",
    "cantidad":"7"
  }
]


print(lista_de_la_compra)
```

### el usuario se crea su lista
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es el inicio de un programa en Python que permite al usuario interactuar con una lista de la compra. El programa presenta un menú simple en el que se pueden elegir dos acciones principales: añadir un elemento a la lista o leer (ver) los elementos ya existentes.

El código comienza imprimiendo un mensaje de bienvenida y luego entra en un bucle `while True`, lo que significa que este bloque de código se ejecutará continuamente hasta que el programa sea interrumpido. Dentro del bucle, se muestra al usuario dos opciones: seleccionar 1 para añadir un elemento a la lista o seleccionar 2 para leer la lista.

La opción elegida por el usuario se captura con `input()`, y se convierte en un número entero usando `int()` porque `input()` devuelve una cadena de texto. Esta opción guardada en la variable `opcion` será posteriormente utilizada para decidir qué acción tomar a continuación, como añadir o leer elementos.

Este tipo de estructura (un bucle infinito con opciones) es común en programas interactivos y permite al usuario realizar múltiples acciones sin necesidad de reiniciar el programa cada vez.

`018-el usuario se crea su lista.py`

```python
print("Lista de la compra v0.1")

while True:
  print("Selecciona una opcion")
  print("1.-Añadir elemento a la lista")
  print("2.-Leer la lista")
  opcion = int(input("Tu opción: "))
  
  
```

### estructura if
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es una parte inicial de un programa que permite al usuario gestionar una lista de la compra. El programa usa un bucle `while True` para mantener el menú activo hasta que se termine manualmente o se implemente una opción de salida.

El código muestra un menú con dos opciones:
1. Añadir un elemento a la lista de la compra.
2. Leer la lista actual de la compra (esta parte está incompleta en el fragmento dado).

Cuando el usuario introduce su elección, el programa verifica si la entrada es igual a 1 o 2 usando estructuras condicionales `if` y `elif`. Si el usuario selecciona la opción 1, el programa solicita al usuario que introduzca el nombre del producto y la cantidad correspondiente. Este bloque prepara el programa para añadir estos datos a una lista en futuras versiones del código.

La parte del menú para leer la lista (la opción 2) no está completa en este fragmento, lo que indica que aún falta implementar esa funcionalidad.

`019-estructura if.py`

```python
print("Lista de la compra v0.1")

while True:
  print("Selecciona una opcion")
  print("1.-Añadir elemento a la lista")
  print("2.-Leer la lista")
  opcion = int(input("Tu opción: "))
  
  if opcion == 1:
    print("Añadimos un elemento a la lista:")
    nombre = input("Indica el nombre del producto: ")
    cantidad = input("Indica la cantidad del producto: ")
    
  elif opcion == 2:
    
```

### creamos la lista primero
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es una parte de un programa simple que simula una lista de compras. El objetivo es permitir al usuario añadir elementos a la lista o leer los elementos existentes en ella.

El programa comienza mostrando un menú con dos opciones: "Añadir elemento a la lista" y "Leer la lista". La opción elegida por el usuario se captura mediante la función `input`, que espera una entrada del teclado, y luego convierte esa entrada a un número entero usando `int()`. 

Si el usuario selecciona la opción 1 (añadir elemento), el programa solicita al usuario ingresar el nombre y la cantidad de un producto. Estos datos se capturan con las funciones `input`, pero no se utilizan para modificar la lista de compras en este fragmento del código.

La opción 2 está incompleta, por lo que cuando se selecciona solo muestra el mensaje "Leer la lista" pero no realiza ninguna acción adicional. Esta parte del código necesita ser completada para permitir al usuario ver los elementos actuales en su lista de la compra.

Este tipo de programa es útil para entender cómo gestionar listas y estructuras de datos simples, así como para aprender a construir interfaces básicas que interactúan con el usuario para capturar información.

`020-creamos la lista primero.py`

```python
print("Lista de la compra v0.1")

lista_de_la_compra = []

while True:
  print("Selecciona una opcion")
  print("1.-Añadir elemento a la lista")
  print("2.-Leer la lista")
  opcion = int(input("Tu opción: "))
  
  if opcion == 1:
    print("Añadimos un elemento a la lista:")
    nombre = input("Indica el nombre del producto: ")
    cantidad = input("Indica la cantidad del producto: ")
    
  elif opcion == 2:
    
```

### añado elemento a la lista
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es una parte de un programa en Python que simula una lista de compras básica. El objetivo principal es permitir al usuario añadir elementos a la lista o leer los elementos ya presentes.

El código comienza imprimiendo un mensaje para indicar el propósito del programa y luego inicializa una lista vacía llamada `lista_de_la_compra`. A continuación, entra en un bucle infinito (`while True`) que muestra al usuario dos opciones: añadir un elemento a la lista o leer los elementos de la lista.

El usuario debe ingresar su elección como un número entero. Si el usuario selecciona la opción 1, se solicitan detalles sobre el producto (nombre y cantidad) para ser añadidos a la lista, aunque falta completar cómo realmente se añade este elemento a `lista_de_la_compra`.

La opción 2 permitirá al usuario ver los elementos que ya están en la lista, pero esta parte del código aún no está completa.

Este tipo de estructura de programación es importante porque permite crear interfaces interactivas simples y comprende conceptos fundamentales como bucles, condicionales (`if`, `elif`) y entrada/salida de datos.

`021-añado elemento a la lista.py`

```python
print("Lista de la compra v0.1")

lista_de_la_compra = []

while True:
  print("Selecciona una opcion")
  print("1.-Añadir elemento a la lista")
  print("2.-Leer la lista")
  opcion = int(input("Tu opción: "))
  
  if opcion == 1:
    print("Añadimos un elemento a la lista:")
    nombre = input("Indica el nombre del producto: ")
    cantidad = input("Indica la cantidad del producto: ")
    
  elif opcion == 2:
    
```

### vomito la lista
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es una pequeña aplicación en Python que permite gestionar una lista de la compra. La aplicación se ejecuta en un bucle infinito (`while True`) hasta que el usuario decide salir manualmente del programa. En cada iteración, muestra al usuario dos opciones: añadir un elemento a la lista o listar todos los elementos existentes.

Cuando el usuario selecciona "1" para añadir un elemento, se le pide que ingrese el nombre y la cantidad de ese producto. Estos datos se guardan en un diccionario dentro de una lista llamada `lista_de_la_compra`. Si el usuario elige "2", simplemente se imprime en pantalla toda la lista actualizada con todos los elementos añadidos previamente.

Esta aplicación es importante porque enseña cómo manejar estructuras de datos como listas y diccionarios, así como cómo usar bucles e intrucciones condicionales para crear interfaces simples que interactúan con el usuario.

`022-vomito la lista.py`

```python
print("Lista de la compra v0.1")

lista_de_la_compra = []

while True:
  print("Selecciona una opcion")
  print("1.-Añadir elemento a la lista")
  print("2.-Leer la lista")
  opcion = int(input("Tu opción: "))
  
  if opcion == 1:
    print("Añadimos un elemento a la lista:")
    nombre = input("Indica el nombre del producto: ")
    cantidad = input("Indica la cantidad del producto: ")
    lista_de_la_compra.append({"nombre":nombre,"cantidad":cantidad})
  elif opcion == 2:
    print("Listamos los elementos de la lista:")
    print(lista_de_la_compra)
```

### recorrer listas
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código es un ejemplo sencillo de cómo trabajar con listas en Python. La lista `agenda` contiene tres nombres: "Jorge", "Juan" y "Jose". Primero, el programa imprime toda la lista completa usando `print(agenda)`, lo que mostrará los tres elementos entre corchetes. Luego, imprime solo el primer elemento de la lista (`agenda[0]`) que es "Jorge".

Finalmente, utiliza un bucle `for` para recorrer cada nombre en la lista y imprimirlo uno por uno. Este bucle itera sobre cada elemento de la lista `agenda`, asignando temporalmente cada valor a la variable `nombre`. Esto significa que primero se imprime "Jorge", luego "Juan" y finalmente "Jose". Esta forma de recorrer una lista es muy útil para procesar cada elemento individualmente, por ejemplo, si quisieras realizar alguna operación específica con cada nombre en tu agenda.

`023-recorrer listas.py`

```python
agenda = ["Jorge","Juan","Jose"]

print(agenda)
print(agenda[0])

for nombre in agenda:
  print(nombre)
```

### recorro la lista
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código crea un sencillo programa en Python que permite a los usuarios gestionar una lista de la compra. El programa se ejecuta en bucle infinito (gracias al `while True`) y ofrece dos opciones principales: añadir elementos a la lista y leer todos los elementos existentes.

Cuando el usuario selecciona la opción 1, se le pide que introduzca el nombre y la cantidad de un producto. Estos datos se guardan en un diccionario temporal y luego se añaden al final de la lista `lista_de_la_compra` utilizando el método `.append()`. Esto significa que cada vez que añades un elemento, este se guarda como una entrada adicional dentro de la lista, formando parte del conjunto total.

Si el usuario selecciona la opción 2, el programa recorre todos los elementos en `lista_de_la_compra` usando un bucle `for`, y muestra por pantalla tanto el nombre como la cantidad asociada a cada producto. Cada elemento de la lista es un diccionario que contiene las claves 'nombre' y 'cantidad'. Al iterar sobre estos, se puede acceder fácilmente a los valores correspondientes y mostrarlos en una forma legible para el usuario.

Este tipo de programa es importante porque enseña conceptos clave como la gestión de listas dinámicas, el uso de estructuras condicionales (`if`, `elif`) para controlar la fluidez del programa según las acciones del usuario, y cómo manipular datos en formato diccionario dentro de una lista.

`024-recorro la lista.py`

```python
print("Lista de la compra v0.1")

lista_de_la_compra = []

while True:
  print("Selecciona una opcion")
  print("1.-Añadir elemento a la lista")
  print("2.-Leer la lista")
  opcion = int(input("Tu opción: "))
  
  if opcion == 1:
    print("Añadimos un elemento a la lista:")
    nombre = input("Indica el nombre del producto: ")
    cantidad = input("Indica la cantidad del producto: ")
    lista_de_la_compra.append({"nombre":nombre,"cantidad":cantidad})
  elif opcion == 2:
    print("Listamos los elementos de la lista:")
    for producto in lista_de_la_compra:
      print("Producto:",producto['nombre'])
      print("Cantidad:",producto['cantidad'])
      print("##############################") # Esto es estético, separador
```

### guardo en json
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código crea un programa sencillo que permite gestionar una lista de la compra. El programa ofrece dos opciones principales: añadir elementos a la lista y listar todos los elementos existentes.

El programa comienza importando el módulo `json`, necesario para guardar datos en formato JSON, un tipo de archivo que es fácil de leer tanto por humanos como por máquinas. Luego, se inicializa una lista vacía llamada `lista_de_la_compra` donde se almacenarán los productos.

El bucle `while True:` crea un menú interactivo con dos opciones: añadir un elemento a la lista y listar todos los elementos de la lista. Si el usuario selecciona la opción 1, el programa solicita al usuario que introduzca el nombre del producto y su cantidad, luego agrega estos datos en forma de diccionario a la lista `lista_de_la_compra`. Finalmente, guarda la lista actualizada en un archivo llamado `lista.json` usando la función `json.dump()`.

Si el usuario selecciona la opción 2, se recorre cada producto en la lista y se imprime su nombre y cantidad en pantalla. La línea `print("##############################")` simplemente separa visualmente cada producto cuando se listan para hacer más fácil la lectura de los resultados.

Este tipo de programa es importante porque enseña cómo interactuar con el usuario, manipular datos estructurados como diccionarios y guardar información persistente en archivos.

`025-guardo en json.py`

```python
print("Lista de la compra v0.1")
import json                   # Para usar la libreria tengo que importarla

lista_de_la_compra = []

while True:
  print("Selecciona una opcion")
  print("1.-Añadir elemento a la lista")
  print("2.-Leer la lista")
  opcion = int(input("Tu opción: "))
  
  if opcion == 1:
    print("Añadimos un elemento a la lista:")
    nombre = input("Indica el nombre del producto: ")
    cantidad = input("Indica la cantidad del producto: ")
    lista_de_la_compra.append({"nombre":nombre,"cantidad":cantidad})
    archivo = open("lista.json","w")         # Abro el archivo
    json.dump(lista_de_la_compra,archivo)    # Guardo en json
    archivo.close()                          # Cierro el archivo
  elif opcion == 2:
    print("Listamos los elementos de la lista:")
    for producto in lista_de_la_compra:
      print("Producto:",producto['nombre'])
      print("Cantidad:",producto['cantidad'])
      print("##############################") # Esto es estético, separador
```

### lista
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es un ejemplo simple de cómo se representa una lista de objetos en formato JSON. Cada objeto en la lista tiene dos atributos: "nombre" y "cantidad". En este caso, hay dos elementos en la lista:

1. El primer elemento representa manzanas con una cantidad de 2.
2. El segundo elemento representa peras con una cantidad de 4.

En resumen, el código muestra cómo se pueden almacenar datos estructurados de manera clara y fácilmente manipulables en un formato que es ampliamente utilizado para la transferencia de datos entre sistemas o aplicaciones web. Es importante entender este formato porque permite intercambiar información de manera eficiente y legible tanto por humanos como por máquinas.

`lista.json`

```json
[{"nombre": "Manzanas", "cantidad": "2"}, {"nombre": "Peras", "cantidad": "4"}]
```

### Actividades propuestas

### Actividad 1: Crear una Agenda con Listas Dinámicas

**Descripción:** Los estudiantes deben crear un programa simple que almacene nombres de contactos en una lista y permita agregar, eliminar y listar dichos contactos. Se pretende que aprendan a usar listas dinámicas y funciones básicas como `append` y `pop`.

### Actividad 2: Manipulación de Coordenadas con Tuplas

**Descripción:** Los estudiantes deben escribir un programa para almacenar las coordenadas (x, y, z) en una tupla e implementar operaciones básicas como lectura y visualización. Se espera que comprendan la inmutabilidad de las tuplas.

### Actividad 3: Diccionarios para Almacenar Datos

**Descripción:** Los estudiantes deben crear un programa que almacene datos en un diccionario (por ejemplo, coordenadas x, y, z) y muestren cómo acceder a estos elementos. Se busca mejorar la comprensión de los diccionarios y su utilidad para almacenamiento de datos estructurados.

### Actividad 4: Modificación de Elementos en una Lista

**Descripción:** Los estudiantes deben escribir un código que permita cambiar el valor de uno o más elementos dentro de una lista existente. El objetivo es reforzar la comprensión sobre cómo sobrescribir valores en listas dinámicas.

### Actividad 5: Crear y Manejar Diccionarios

**Descripción:** Los estudiantes deben desarrollar un programa que permita crear un diccionario para almacenar información como productos de una lista de compras con sus cantidades. Se pretende enseñar la creación e inicialización de diccionarios, además de cómo añadir y acceder a los elementos del mismo.

### Actividad 6: Interfaz Básica de Gestión de Listas

**Descripción:** Los estudiantes deben diseñar una interfaz básica para administrar listas (por ejemplo, lista de la compra), donde se permita al usuario agregar o eliminar elementos. Se busca mejorar las habilidades en estructuras condicionales y bucles.

### Actividad 7: Guardado de Datos a Archivo JSON

**Descripción:** Los estudiantes deben crear un programa que permite guardar datos de una lista (por ejemplo, lista de la compra) en un archivo `.json`. La actividad se enfoca en la importación de bibliotecas adicionales y el manejo básico de archivos.

### Actividad 8: Recorrer e Imprimir Elementos de Lista

**Descripción:** Los estudiantes deben implementar una función que recorra una lista, por ejemplo, una lista de contactos o productos, y muestre cada elemento en la consola. Se pretende mejorar las habilidades sobre el uso de bucles `for` para iterar a través de listas.

### Actividad 9: Interfaz Mejorada con Diccionarios

**Descripción:** Los estudiantes deben crear una versión mejorada del programa de lista de la compra, que permita al usuario agregar productos con nombre y cantidad usando un diccionario. Se busca mejorar las habilidades en uso de estructuras condicionales y manejo de datos complejos.

### Actividad 10: Modificar Elementos Específicos

**Descripción:** Los estudiantes deben crear una funcionalidad que permita al usuario modificar el valor de un elemento específico dentro de un diccionario (por ejemplo, cambiar la cantidad de un producto en la lista de compras). Se busca reforzar las habilidades para acceder y modificar elementos específicos de estructuras de datos más complejas.

Estas actividades están diseñadas para mejorar gradualmente las habilidades de programación de los estudiantes, cubriendo desde listas hasta diccionarios, pasando por el manejo básico de archivos.


<a id="creacion-de-matrices-arrays"></a>
## Creación de matrices (arrays)

### Introducción a los ejercicios

Esta carpeta contiene una secuencia de ejercicios que te guían en la creación y manipulación de matrices (arrays) utilizando Python, centrándose en el manejo de listas para representar un menú de comidas. Los ejercicios comienzan con la simple adición de elementos a una lista y evolucionan hasta incluir bucles condicionales, lectura de opciones del usuario y almacenamiento persistente mediante archivos binarios usando la biblioteca `pickle`. A lo largo de estos ejercicios, desarrollarás habilidades fundamentales en estructuras de datos, control de flujo y manejo de archivos, así como comprenderás cómo guardar y recuperar estados de una aplicación.

### comidas
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es muy sencillo y se utiliza para crear una lista vacía en Python. En este caso, la lista se llama `menu`. La idea detrás de esto es preparar un espacio en memoria donde podrás almacenar diferentes elementos relacionados con un menú, como platos o bebidas. Al ser una lista vacía, aún no hay nada dentro del `menu`, pero está lista para que le añadas elementos más adelante en tu programa. Es importante porque te permite organizar y gestionar datos de manera estructurada y sencilla.

`001-comidas.py`

```python
menu = []
```

### bucle infinito
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código está creando un bucle infinito en Python que pide al usuario que introduzca el nombre de una comida. La variable `menu` es una lista vacía que se utilizará más adelante para almacenar los nombres de las comidas ingresadas por el usuario.

El bucle `while True:` asegura que el bloque de código dentro del bucle se ejecute continuamente sin parar, ya que la condición siempre será verdadera (`True`). Dentro del bucle, se utiliza la función `input()` para solicitar al usuario que introduzca un nombre de comida. Sin embargo, en este punto, falta agregar la lógica necesaria para añadir esa comida a la lista `menu` y una forma de salir del bucle.

Es importante notar que este código por sí solo no terminará nunca porque el bucle es infinito sin ninguna condición para romperlo. Normalmente, se incluiría alguna forma de permitir al usuario salir del bucle, como introducir un comando especial o alcanzar una cierta cantidad de elementos en la lista `menu`.

`002-bucle infinito.py`

```python
menu = []

while True:
  comida = input("Introduce el nombre de la comida: ")
  
```

### añado a la lista
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código crea un menú vacío y luego permite al usuario añadir comidas indefinidamente. En primer lugar, se declara una lista llamada `menu` que inicialmente está vacía. Luego, el programa entra en un bucle infinito (`while True:`), lo que significa que seguirá ejecutándose hasta que se detenga de alguna manera (generalmente con la interrupción del usuario o mediante otro código no incluido aquí). Dentro del bucle, el programa pide al usuario que introduzca el nombre de una comida y luego añade esa comida a la lista `menu` usando el método `.append()`. Este proceso se repite continuamente hasta que alguien interrumpe la ejecución.

Este tipo de código es importante porque demuestra cómo trabajar con listas en Python, cómo solicitar datos al usuario y cómo modificar dichos datos dentro de un bucle.

`003-añado a la lista.py`

```python
menu = []

while True:
  comida = input("Introduce el nombre de la comida: ")
  menu.append(comida)
```

### recorrer la lista
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código Python te ayuda a crear una lista de comidas. Lo que hace es pedirte constantemente que introduzcas el nombre de una comida y luego muestra la lista completa de comidas que has añadido hasta ese momento. 

El programa utiliza un bucle `while True`, lo cual significa que se ejecutará indefinidamente hasta que algo interrumpa este ciclo (en este caso, el código no tiene una condición para detenerse). En cada iteración del bucle, te pide que introduzcas el nombre de la comida y luego esa comida es añadida a la lista `menu` mediante el método `append()`. Después de agregar la nueva comida, el programa imprime en pantalla todas las comidas que hay actualmente en la lista.

Este tipo de código es útil cuando necesitas recopilar datos continuamente hasta que decidas detener manualmente el proceso. Sin embargo, ten presente que este script específico no tiene una forma elegante para finalizar y podría requerir interrupción forzada del programa (como cerrar la terminal o utilizar `Ctrl+C`) para pararlo.

`004-recorrer la lista.py`

```python
menu = []

while True:
  comida = input("Introduce el nombre de la comida: ")
  menu.append(comida)
  print("Tu comida hasta el momento es:")
  for elemento in menu:
    print(elemento)
```

### acciones del menu
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código crea un menú simple para gestionar las comidas en una lista. La estructura del programa usa un bucle `while True`, lo que significa que el menú se repetirá indefinidamente hasta que alguien interrumpa la ejecución manualmente. En cada iteración, muestra dos opciones: introducir una nueva comida o listar todas las comidas existentes en el menú.

Cuando el usuario selecciona la opción de introducir una nueva comida (la opción 1 no está implementada correctamente en este fragmento, ya que siempre introduce un nuevo elemento sin verificar la selección), se pide al usuario que introduzca el nombre de la comida. Luego, ese nombre es añadido a la lista `menu` usando el método `.append()`.

Finalmente, independientemente del proceso anterior, el código itera sobre todos los elementos en la lista `menu` y los imprime uno por uno para mostrar al usuario las comidas que ha introducido hasta el momento.

Este tipo de estructura es útil cuando se quiere permitir a un usuario interactuar con una aplicación durante todo un período largo sin tener que reiniciarla constantemente. Además, muestra cómo usar listas en Python para almacenar y manipular datos de forma eficiente.

`005-acciones del menu.py`

```python
menu = []

while True:
  print("Opciones:")
  print("1.-Introducir nueva comida en el menú")
  print("2.-Listar comidas en el menú")
  opcion = input("Selecciona una opción:")
  comida = input("Introduce el nombre de la comida: ")
  menu.append(comida)
  print("Tu comida hasta el momento es:")
  for elemento in menu:
    print(elemento)
```

### tomamos las opciones
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código crea un menú interactivo que permite al usuario gestionar una lista de comidas. La estructura del programa utiliza un bucle `while True`, lo que significa que el menú se mostrará continuamente hasta que alguien interrumpa la ejecución del programa manualmente.

Cuando el programa empieza, muestra un menú con dos opciones: agregar una nueva comida o listar todas las comidas existentes. El usuario introduce su elección mediante un número (1 para añadir y 2 para listar). Dependiendo de la opción elegida, el programa realiza una acción diferente:

- Si el usuario selecciona "Introducir nueva comida en el menú" (opción 1), se le pedirá que escriba el nombre de la comida. El programa luego agrega esa comida a la lista `menu` utilizando el método `append()`.

- Si el usuario selecciona "Listar comidas en el menú" (opción 2), el programa recorre cada elemento en la lista `menu` y los imprime uno por uno, mostrando así todas las comidas que han sido añadidas hasta ese momento.

Este tipo de estructura es común en aplicaciones interactivas donde se necesita manejar datos a través de opciones del menú y es importante para aprender cómo gestionar listas en Python y construir interfaces de usuario simples.

`006-tomamos las opciones.py`

```python
menu = []

while True:
  print("Opciones:")
  print("1.-Introducir nueva comida en el menú")
  print("2.-Listar comidas en el menú")
  opcion = int(input("Selecciona una opción:"))
  if opcion == 1:
    comida = input("Introduce el nombre de la comida: ")
    menu.append(comida)
  elif opcion == 2:
    print("Tu comida hasta el momento es:")
    for elemento in menu:
      print(elemento)
```

### intentamos guardar
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código Python crea un menú interactivo que permite al usuario añadir nuevas comidas a una lista y listar las comidas existentes. La estructura principal del programa es un bucle `while True` que mantiene el menú en ejecución hasta que se produzca alguna condición de salida (que no está implementada aquí). Dentro del bucle, hay varias opciones que el usuario puede seleccionar:

1. **Introducir nueva comida**: Si el usuario elige esta opción, se le pedirá que introduzca el nombre de una comida, que luego será añadida a la lista `menu` usando el método `append()`.
2. **Listar comidas**: Si el usuario elige esta opción, el programa recorre y imprime cada elemento en la lista `menu`.

Además, si el usuario selecciona la opción 3, se intentará guardar la lista de comidas en un archivo llamado "datos.txt". Sin embargo, hay un problema importante aquí: al escribir `archivo.write(menu)`, estamos tratando de escribir directamente una lista (`menu`) en un archivo de texto. Esto no funcionará porque el método `write()` espera recibir una cadena (string), no una lista.

Para corregir este error y guardar adecuadamente la lista, necesitaríamos convertir la lista a una cadena usando métodos como `join()`, o utilizar una biblioteca como `pickle` para serializar la lista.

`007-intentamos guardar.py`

```python
menu = []

while True:
  print("Opciones:")
  print("1.-Introducir nueva comida en el menú")
  print("2.-Listar comidas en el menú")
  print("3.-Guardar en archivo")
  opcion = int(input("Selecciona una opción:"))
  if opcion == 1:
    comida = input("Introduce el nombre de la comida: ")
    menu.append(comida)
  elif opcion == 2:
    print("Tu comida hasta el momento es:")
    for elemento in menu:
      print(elemento)
  elif opcion == 3:
    archivo = open("datos.txt","w")
    archivo.write(menu)
    archivo.close()
    
    
    
```

### importamos pickle
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código está diseñado para permitir a un usuario interactuar con una lista de comidas en un menú. Primero, importa el módulo `pickle`, aunque no se utiliza en este fragmento del código. Luego, crea una lista vacía llamada `menu` que almacenará los nombres de las comidas.

El programa entra en un bucle infinito (`while True`) donde muestra al usuario tres opciones: agregar una nueva comida, listar todas las comidas existentes o guardar el menú actual en un archivo. Dependiendo de la opción seleccionada por el usuario (mediante `input`), realiza acciones específicas:

1. Si el usuario elige "Introducir nueva comida", se solicita que escriba el nombre de la comida y luego agrega ese nombre a la lista `menu`.
2. Si el usuario escoge "Listar comidas en el menú", recorre la lista `menu` e imprime cada elemento.
3. Si selecciona "Guardar en archivo", intenta abrir un archivo llamado `"datos.txt"` para escribir los datos de la lista, pero aquí hay un error: no se puede usar directamente una lista con métodos de escritura como `write`. Debería convertir la lista a un formato adecuado para almacenarla, por ejemplo, usando el módulo `pickle` que ya está importado.

Es importante corregir este último punto para que los datos del menú se guarden correctamente en el archivo. La parte de guardar y cargar archivos es crucial cuando trabajamos con aplicaciones reales, ya que permite almacenar información entre sesiones y mantener la consistencia de los datos a lo largo del tiempo.

`008-importamos pickle.py`

```python
import pickle

menu = []

while True:
  print("Opciones:")
  print("1.-Introducir nueva comida en el menú")
  print("2.-Listar comidas en el menú")
  print("3.-Guardar en archivo")
  opcion = int(input("Selecciona una opción:"))
  if opcion == 1:
    comida = input("Introduce el nombre de la comida: ")
    menu.append(comida)
  elif opcion == 2:
    print("Tu comida hasta el momento es:")
    for elemento in menu:
      print(elemento)
  elif opcion == 3:
    archivo = open("datos.txt","w")
    archivo.write(menu)
    archivo.close()
    
    
    
```

### abro el archivo en modo escritura binaria
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es una pequeña aplicación en Python que permite gestionar un menú mediante opciones seleccionadas por el usuario. La aplicación utiliza un bucle infinito (`while True`) que presenta al usuario tres opciones: introducir una nueva comida, listar las comidas ya añadidas o guardar todo el menú en un archivo binario.

Cuando el usuario elige la opción 1, se le pide que ingrese el nombre de la comida y esta es agregada a la lista `menu` mediante el método `.append()`. Si selecciona la opción 2, el programa recorre cada elemento de la lista `menu` e imprime en pantalla las comidas ya añadidas. Por último, si el usuario opta por guardar el menú (opción 3), se abre un archivo llamado "datos.bin" en modo escritura binaria (`wb`) utilizando el módulo `pickle`. Luego de esto, la lista completa del menú es almacenada en el archivo usando el método `.dump()`, y finalmente se cierra el archivo con `.close()`.

Este código es importante porque demuestra cómo interactuar con datos a través de una interfaz simple y cómo guardar estructuras de datos complejas como listas en archivos para su uso futuro.

`009-abro el archivo en modo escritura binaria.py`

```python
import pickle

menu = []

while True:
  print("Opciones:")
  print("1.-Introducir nueva comida en el menú")
  print("2.-Listar comidas en el menú")
  print("3.-Guardar en archivo")
  opcion = int(input("Selecciona una opción:"))
  if opcion == 1:
    comida = input("Introduce el nombre de la comida: ")
    menu.append(comida)
  elif opcion == 2:
    print("Tu comida hasta el momento es:")
    for elemento in menu:
      print(elemento)
  elif opcion == 3:
    archivo = open("datos.bin","wb") # Write Binary
    pickle.dump(menu,archivo)
    archivo.close()
    
    
    
    
    
    
    
    
    
```

### print con exito
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código es una pequeña aplicación en Python que permite gestionar un menú de comidas. La aplicación utiliza un bucle `while True` para mantener la interfaz de usuario activa y permitir a los usuarios realizar acciones repetidamente hasta que decidan salir (lo cual no está especificado aquí, por lo que el programa seguirá funcionando indefinidamente).

El código proporciona tres opciones al usuario:
1. **Introducir una nueva comida en el menú:** El usuario introduce el nombre de la comida y esta se añade a una lista llamada `menu`.
2. **Listar las comidas existentes:** Muestra todas las comidas que han sido introducidas hasta ese momento.
3. **Guardar el menú en un archivo binario:** Utiliza el módulo `pickle` para guardar la lista de comidas (`menu`) en un archivo llamado `datos.bin`. Una vez guardado, muestra un mensaje indicando que la operación se ha completado con éxito.

Este tipo de programa es útil para aprender a manejar listas, bucles y archivos binarios en Python, y también para entender cómo guardar datos persistentes entre diferentes sesiones del programa.

`010-print con exito.py`

```python
import pickle

menu = []

while True:
  print("Opciones:")
  print("1.-Introducir nueva comida en el menú")
  print("2.-Listar comidas en el menú")
  print("3.-Guardar en archivo")
  opcion = int(input("Selecciona una opción:"))
  if opcion == 1:
    comida = input("Introduce el nombre de la comida: ")
    menu.append(comida)
  elif opcion == 2:
    print("Tu comida hasta el momento es:")
    for elemento in menu:
      print(elemento)
  elif opcion == 3:
    archivo = open("datos.bin","wb") # Write Binary
    pickle.dump(menu,archivo)
    archivo.close()
    print("Se ha guardado con éxito ✅")
    
    
    
    
    
    
    
    
    
```

### cargar archivo
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código es una aplicación sencilla que permite gestionar un menú de comidas. Utiliza una estructura básica con bucles y condicionales para permitir al usuario realizar diferentes acciones: añadir nuevas comidas, listar las comidas existentes, guardar el menú en un archivo binario y cargar datos desde ese mismo archivo.

El programa comienza creando una lista vacía llamada `menu`. Luego entra en un bucle infinito (`while True`) donde muestra un menú con opciones numeradas para que el usuario pueda elegir lo que desea hacer. Si el usuario elige la opción 1, se pide que introduzca el nombre de una nueva comida y esta se añade a la lista `menu`. La opción 2 imprime en pantalla todas las comidas actuales en el menú. 

Las opciones más interesantes son 3 y 4: cuando se selecciona la opción 3, el programa abre un archivo binario llamado "datos.bin" en modo escritura (`wb`) y guarda la lista `menu` utilizando la biblioteca `pickle`. Al elegir la opción 4, el programa vuelve a abrir este mismo archivo pero en modo lectura (`rb`) para cargar los datos previamente guardados en la variable `menu`.

Esta aplicación es útil porque permite persistir información de una ejecución del programa a otra, lo que significa que el usuario no pierde las comidas añadidas cada vez que cierra y vuelve a abrir el programa.

`011-cargar archivo.py`

```python
import pickle

menu = []

while True:
  print("Opciones:")
  print("1.-Introducir nueva comida en el menú")
  print("2.-Listar comidas en el menú")
  print("3.-Guardar en archivo")
  print("4.-Cargar datos de archivo")
  opcion = int(input("Selecciona una opción:"))
  if opcion == 1:
    comida = input("Introduce el nombre de la comida: ")
    menu.append(comida)
  elif opcion == 2:
    print("Tu comida hasta el momento es:")
    for elemento in menu:
      print(elemento)
  elif opcion == 3:
    archivo = open("datos.bin","wb") # Write Binary
    pickle.dump(menu,archivo)
    archivo.close()
    print("Se ha guardado con éxito ✅")
  elif opcion == 4:
    archivo = open("datos.bin","rb")
    menu = pickle.load(archivo) # Volcamos el archivo a la lista
    archivo.close()
    
    
    
    
    
    
    
    
    
```

### cadena de ayuda
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código es un programa simple que permite gestionar una lista de comidas en un menú utilizando matrices (listas en Python) y archivos binarios para guardar y cargar los datos. El programa presenta al usuario un menú interactivo con cuatro opciones principales:

1. **Introducir nueva comida**: Si el usuario selecciona esta opción, se solicita ingresar el nombre de una comida que luego se añade a la lista `menu`.

2. **Listar comidas**: Esta opción muestra todas las comidas almacenadas en la lista `menu` hasta ese momento.

3. **Guardar en archivo**: Guarda los datos actuales de la lista `menu` en un archivo binario llamado "datos.bin". Para hacer esto, el código utiliza la biblioteca `pickle`, que es útil para serializar y deserializar estructuras de datos complejas en Python.

4. **Cargar datos de archivo**: Si se selecciona esta opción, el programa carga los datos previamente guardados desde el archivo "datos.bin" en la lista `menu`.

El ciclo `while True` asegura que el menú se mantendrá activo y permitirá al usuario realizar múltiples acciones hasta que decida cerrar manualmente el programa. Este tipo de estructuras es útil para crear interfaces interactivas y aplicaciones donde los datos deben persistir entre diferentes sesiones del programa.

Es importante destacar cómo la función `pickle` permite almacenar y recuperar listas en archivos binarios, lo cual es una habilidad valiosa para desarrolladores que necesitan manejar datos estructurados de forma eficiente.

`012-cadena de ayuda.py`

```python
import pickle

menu = []

while True:
  print("Opciones:")
  print("1.-Introducir nueva comida en el menú")
  print("2.-Listar comidas en el menú")
  print("3.-Guardar en archivo")
  print("4.-Cargar datos de archivo")
  opcion = int(input("Selecciona una opción:"))
  if opcion == 1:
    comida = input("Introduce el nombre de la comida: ")
    menu.append(comida)
  elif opcion == 2:
    print("Tu comida hasta el momento es:")
    for elemento in menu:
      print(elemento)
  elif opcion == 3:
    archivo = open("datos.bin","wb") # Write Binary
    pickle.dump(menu,archivo)
    archivo.close()
    print("Se ha guardado con éxito ✅")
  elif opcion == 4:
    archivo = open("datos.bin","rb")
    menu = pickle.load(archivo) # Volcamos el archivo a la lista
    archivo.close()
    print("Se ha cargado con éxito ✅")
    
    
    
    
    
    
    
    
```

### Actividades propuestas

### Actividades para Alumnos de Formación Profesional

#### 1. **Creación de una Lista Básica**
**Descripción:** El alumnado debe crear un programa que permita introducir y almacenar nombres de comidas en una lista. Los estudiantes aprenderán a trabajar con listas y manejar entradas de usuario.

---

#### 2. **Introducción de Comida Continua**
**Descripción:** Se requiere a los alumnos que creen un bucle infinito para añadir comidas al menú hasta que se introduzca una palabra clave específica como "FIN". Este ejercicio ayudará a entender cómo controlar flujos condicionales dentro del código.

---

#### 3. **Añadiendo Comida y Mostrando la Lista**
**Descripción:** Los alumnos deben modificar el programa para permitir al usuario añadir nuevas comidas, luego mostrar todas las entradas almacenadas hasta ese momento. Esto fortalecerá su comprensión sobre cómo manipular datos en una lista.

---

#### 4. **Menú de Opciones Básico**
**Descripción:** Se solicita a los estudiantes que diseñen un menú interactivivo con dos opciones: agregar comidas y listar las existentes, usando `if-elif` para manejar diferentes entradas del usuario.

---

#### 5. **Integración de Funciones Guardar y Cargar**
**Descripción:** El objetivo es extender el programa anterior añadiendo la opción de guardar los datos en un archivo binario y cargarlos nuevamente al arrancar el programa, utilizando la biblioteca `pickle`. Esto permitirá a los estudiantes entender cómo persistir datos fuera del entorno de ejecución.

---

#### 6. **Manejo de Errores Básicos**
**Descripción:** Los alumnos deben implementar un bloque `try-except` para manejar posibles errores al abrir archivos binarios, lo que enseñará sobre control y excepciones en Python.

---

#### 7. **Validación de Entrada del Usuario**
**Descripción:** Se requiere a los estudiantes añadir validaciones para asegurar que el usuario sólo introduzca valores válidos (por ejemplo, elegir entre opciones numéricas). Esto ayudará a entender conceptos como conversión de tipos y lógica condicional.

---

#### 8. **Menú Avanzado con Gestión de Datos**
**Descripción:** Los alumnos deben completar un menú más avanzado que permita no solo añadir, listar y guardar comidas, sino también cargar datos previamente guardados desde un archivo binario. Esto les ayudará a entender el uso de módulos externos y cómo integrar funcionalidades complejas en programas simples.

---

#### 9. **Documentación Interna**
**Descripción:** Se solicita que los estudiantes añadan comentarios en su código para documentarlo internamente, explicando lo que hace cada bloque del programa. Esto es útil tanto para ellos mismos como para otros desarrolladores que puedan revisar o utilizar su trabajo.

---

#### 10. **Refactorización y Mejora de Código**
**Descripción:** Finalmente, los alumnos deben refactorizar el código existente para mejorar la eficiencia y legibilidad, tal vez dividiendo partes del programa en funciones más pequeñas. Esto les enseñará a pensar en mejores prácticas de programación y cómo mejorar el diseño del software.

---

Estas actividades están diseñadas para cubrir desde conceptos básicos hasta avanzados, adaptándose al nivel de los estudiantes de ciclos formativos y utilizando únicamente las tecnologías y lenguajes presentes en la carpeta proporcionada.


<a id="matrices-arrays-multidimensionales"></a>
## Matrices (arrays) multidimensionales

### Introducción a los ejercicios

El código proporcionado muestra diferentes ejemplos de cómo trabajar con datos y estructuras en Python. Aquí está un análisis detallado de cada uno:

1. **001-estructura compleja**: Ejemplo básico para entender la composición de listas anidadas.

2. **002-pickle para cargar.py**: Usa `pickle` para guardar una lista compleja a disco y luego cargarla nuevamente en un programa Python.

3. **004-uso de pickle para leer.py**: Muestra cómo usar `pickle` para recuperar datos guardados, específicamente desde un archivo llamado "agenda.bin".

4. **005-leer con for**: Utiliza un bucle `for` para recorrer una lista anidada y acceder a los elementos.

5. **006-sin pickle.py**: Ejemplo básico de cómo manejar datos en memoria sin utilizar archivos externos o módulos como `pickle`.

6. **007-ciclo for para lectura de agenda**: Muestra cómo iterar sobre una estructura compleja (lista dentro de listas) para leer y procesar datos.

7. **008-diccionario simple.py**: Introducción a los diccionarios, una estructura útil para almacenar pares clave-valor.

8. **009-copia de lista.py**: Ejemplo sobre cómo hacer una copia profunda de una lista anidada usando `copy.deepcopy`.

9. **010-intento.py**: Muestra cómo manejar errores al acceder a índices inexistentes en listas, utilizando la cláusula `try...except`.

10. **013-agenda.py**: Ejemplo básico de un programa que permite añadir registros (nombre, apellidos, email y teléfono) a una lista.

11. **014-pickle para guardar.py**: Similar al anterior pero incluye la funcionalidad de guardar la agenda en un archivo binario usando `pickle`.

12. **015-conversiones de datos conocidas.py** y **016-conversiones no posibles.py**: Ejemplos sobre cómo convertir cadenas a números enteros (`int`) en Python, mostrando también el manejo de errores cuando la conversión es inválida.

13. **017-tipo.py** y **018-cambio de tipo de dato.py**: Explican los tipos de datos básicos (listas vs tuplas) y cómo convertir entre ellos en Python.

14. **019-parto.py**: Similar a **014**, pero con un flujo ligeramente diferente que permite tanto insertar como guardar registros, sin mostrar la agenda por cada inserción.

15. **020-menu.py**: Un ejemplo más avanzado de cómo estructurar un programa en Python que ofrece al usuario varias opciones (insertar, leer, y guardar) a través de un menú interactivo.

Estos ejemplos son útiles para aprender diferentes aspectos del manejo de datos y estructuras en Python, desde las listas anidadas hasta el uso de diccionarios y la manipulación de archivos mediante `pickle`.

### variable
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código crea una variable llamada `nombre` y le asigna el valor `"Jose Vicente"`. En programación, las variables son como cajas donde puedes guardar información para usarla después. Aquí, la caja se llama `nombre` y dentro guardamos el texto "Jose Vicente". Este tipo de variable es un string en Python, que simplemente significa una colección de caracteres o letras encerrados entre comillas.

Es importante entender cómo declarar variables como esta porque nos permitirá almacenar y manipular datos de manera efectiva en nuestros programas. Por ejemplo, podríamos usar esta variable para mostrar un saludo personalizado al usuario o para guardar información sobre un usuario que está ingresando a nuestro sistema.

`001-variable.py`

```python
nombre = "Jose Vicente"
```

### lista
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código en Python muestra cómo se declaran y utilizan variables y listas. Primero, la variable `nombre` almacena una cadena de texto que es el nombre "Jose Vicente". Luego, se crea una lista llamada `nombres`, que es un conjunto ordenado de elementos, cada uno con su propia posición o índice dentro de la lista. En este caso, la lista contiene cinco nombres: "Jose Vicente", "Juan", "Jorge", "Jaime" y "Julia". Las listas son útiles cuando necesitas almacenar múltiples valores relacionados en una sola variable, permitiendo así un manejo más eficiente de esos datos.

`002-lista.py`

```python
nombre = "Jose Vicente"

nombres = [
  "Jose Vicente",
  "Juan",
  "Jorge",
  "Jaime",
  "Julia"
]
```

### matriz multidimensional
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código Python muestra cómo crear una matriz bidimensional, también conocida como una lista de listas. En este caso, se está modelando una agenda simple donde cada contacto es una sublista que contiene diferentes detalles del contacto, como el nombre, apellido, email y teléfono. La variable `agenda` es una lista principal vacía al inicio (`agenda = []`). Luego, se añaden dos contactos a esta lista: primero un contacto para "Jose Vicente Carratala" con su correo electrónico y número de teléfono, y segundo un contacto para "Jorge Martinez" con sus respectivos detalles. Cada contacto es una sublista que se agrega como un elemento más en la lista principal `agenda`. Esto permite organizar los datos de manera jerárquica, facilitando el acceso a información específica de cada contacto cuando sea necesario.

`003-matriz multidimensional.py`

```python
agenda = []

# Una lista dentro de otra lista
agenda[0] = [
  "Jose Vicente",
  "Carratala",
  "info@jocarsa.com",
  "12345678"
]

agenda[1] = [
  "Jorge",
  "Martinez",
  "jorge@jocarsa.com",
  "123456787"
]
```

### otra formulacion
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código Python crea una matriz (también conocida como array o lista de listas en este contexto) que representa una agenda simple con información de contacto para varias personas. Cada persona está representada por una sublista dentro de la lista principal `agenda`. En cada sublista, los datos se almacenan en el siguiente orden: nombre (primer elemento), apellido (segundo elemento), correo electrónico (tercer elemento) y número de teléfono (cuarto elemento).

La matriz tiene dos sublistas, lo que significa que hay información para dos personas diferentes. Por ejemplo, la primera persona es "Jose Vicente Carratala" con su correo electrónico e información telefónica asociados.

Finalmente, el código imprime toda la estructura `agenda` en la consola usando la función `print()`, mostrando así todos los datos de contacto almacenados en este formato multidimensional. Este tipo de estructuras son útiles para manejar conjuntos de datos relacionados y acceder a ellos de manera organizada y eficiente.

`004-otra formulacion.py`

```python
agenda = [
  [
    "Jose Vicente",
    "Carratala",
    "info@jocarsa.com",
    "12345678"
  ],
  [
    "Jorge",
    "Martinez",
    "jorge@jocarsa.com",
    "123456787"
  ]
]

print(agenda)  
```

### acceso a un elemento de la primera dimension
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código en Python muestra cómo acceder a un elemento específico de una matriz multidimensional. En este caso, la matriz `agenda` es bidimensional (también conocida como matriz de matrices), donde cada submatriz contiene información sobre una persona (como nombre, apellido, correo electrónico y número telefónico).

La línea `print(agenda[0])` imprime el primer elemento de la matriz principal `agenda`. En este contexto, el índice 0 se refiere a la primera submatriz dentro de `agenda`, que en este caso es una lista con los datos del primer contacto: "Jose Vicente", "Carratala", "info@jocarsa.com" y "12345678". Este código es importante porque ilustra cómo se accede a información específica dentro de estructuras complejas como las matrices multidimensionales, lo que es fundamental en el manejo de datos en programación.

`005-acceso a un elemento de la primera dimension.py`

```python
agenda = [
  [
    "Jose Vicente",
    "Carratala",
    "info@jocarsa.com",
    "12345678"
  ],
  [
    "Jorge",
    "Martinez",
    "jorge@jocarsa.com",
    "123456787"
  ]
]

print(agenda[0])  
```

### puedo acceder a la segunda dimension
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código en Python utiliza una estructura de datos llamada matriz (o array) multidimensional para almacenar información sobre diferentes personas. En este caso, la matriz `agenda` contiene dos sub-matrices (también conocidas como listas), cada una de las cuales almacena los detalles personales de una persona.

La primera línea del código muestra cómo acceder a toda la información de la primera persona en la agenda, utilizando `print(agenda[0])`. Esto imprime todos los elementos que están en el índice 0 de la matriz principal `agenda`, es decir, ["Jose Vicente", "Carratala", "info@jocarsa.com", "12345678"].

La segunda línea del código muestra cómo acceder específicamente a un elemento dentro de esa sub-matriz. Al usar `print(agenda[0][0])`, se imprime el primer nombre ("Jose Vicente") de la primera persona en la agenda. Esto demuestra cómo podemos descomponer una matriz multidimensional para obtener datos individuales.

Este tipo de estructura es útil cuando necesitas almacenar y acceder a múltiples piezas de información relacionadas, como detalles personales en una agenda electrónica.

`006-puedo acceder a la segunda dimension.py`

```python
agenda = [
  [
    "Jose Vicente",
    "Carratala",
    "info@jocarsa.com",
    "12345678"
  ],
  [
    "Jorge",
    "Martinez",
    "jorge@jocarsa.com",
    "123456787"
  ]
]

print(agenda[0])  
print(agenda[0][0]) # Jose Vicente
```

### tambien podemos escribir
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código muestra cómo trabajar con matrices (también conocidas como arrays bidimensionales) en Python, utilizando el contexto de una agenda telefónica. La matriz `agenda` almacena información sobre dos personas: Jose Vicente Carratala y Jorge Martínez. Cada persona se representa por una lista dentro de la matriz principal, donde cada elemento de la sublista contiene datos específicos como el nombre, apellido, correo electrónico y número de teléfono.

El código primero imprime toda la información de la primera persona en la agenda (Jose Vicente Carratala) al imprimir `agenda[0]`. Luego, muestra solo el primer dato (el nombre) de esta persona, que es "Jose Vicente", al acceder con `agenda[0][0]`.

A continuación, se modifica la información cambiando el nombre de "Jose Vicente" a "Jaime". Esto demuestra cómo puedes actualizar los datos en una matriz. Finalmente, imprime nuevamente el primer dato (ahora "Jaime") para mostrar que la información ha sido actualizada correctamente.

Este ejemplo es importante porque te ayuda a entender cómo acceder y modificar elementos específicos dentro de estructuras multidimensionales, lo cual es fundamental cuando trabajas con datos más complejos en programas más grandes.

`007-tambien podemos escribir.py`

```python
agenda = [
  [
    "Jose Vicente",
    "Carratala",
    "info@jocarsa.com",
    "12345678"
  ],
  [
    "Jorge",
    "Martinez",
    "jorge@jocarsa.com",
    "123456787"
  ]
]

print(agenda[0])  
print(agenda[0][0]) # Jose Vicente
agenda[0][0] = "Jaime"
print(agenda[0][0]) # Jaime
```

### ejemplo palet
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código en Python crea una estructura conocida como matriz multidimensional o array tridimensional para representar un palet. En este caso, la matriz `palet` tiene tres dimensiones que podríamos imaginar como el ancho (x), alto (y) y profundidad (z) de un palet real.

La matriz `palet` está compuesta por una lista externa que contiene otras listas internas. Cada lista interna representa una fila en la dimensión x del palet, y cada una de estas filas contiene tres sublistas más, que representan columnas (y) con valores numéricos individuales (z).

El código simplemente crea esta estructura compleja e inmediatamente imprime el contenido de `palet` en la consola. Esto ayuda a visualizar cómo se organiza la información dentro de una matriz tridimensional, mostrando claramente las diferentes capas y sus valores correspondientes.

Esta representación es útil cuando necesitas modelar objetos o espacios con más de dos dimensiones, como en este ejemplo donde cada número podría simbolizar un producto en un espacio tridimensional del palet.

`008-ejemplo palet.py`

```python
palet = [ # x
          [ # y
            [1,2,3], # z 
            [4,5,6],
            [7,8,9]
          ],
          [
            [11,12,13], 
            [14,15,16],
            [17,18,19] 
          ],
          [
            [21,22,23], 
            [24,25,26],
            [27,28,29] 
          ]
        ]
print(palet)
```

### linea de palets
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código Python crea una estructura de datos conocida como matriz multidimensional o array tridimensional que representa una línea de palets en un almacén. Cada elemento dentro de la matriz `palets` es una representación espacial tridimensional del almacenamiento de los palets, donde `x`, `y` y `z` son ejes que describen las posiciones.

En este caso específico, el código define una estructura con dos filas (denominadas `x`), cada fila tiene tres columnas (`y`), y en cada celda de estas columnas hay una matriz 3x3 (`z`). Cada número dentro de la matriz representa a un palet individual en esa posición específica.

El código debería imprimir esta estructura utilizando el comando `print(palets)`, pero nota que en lugar de `palets`, se ha escrito incorrectamente como `print(palet)`. Esto causará un error al ejecutarlo porque no existe una variable llamada `palet` en el programa. Para corregir esto, simplemente debes cambiar `print(palets)` para imprimir la estructura completa.

Esta estructura es útil para representar y manipular datos que tienen más de dos dimensiones, como sería el caso real en un almacén donde los palets están organizados físicamente en varias filas, columnas y capas.

`009-linea de palets.py`

```python
palets = [ # linea de palets
           [ # x
            [ # y
              [1,2,3], # z 
              [4,5,6],
              [7,8,9]
            ],
            [
              [11,12,13], 
              [14,15,16],
              [17,18,19] 
            ],
            [
              [21,22,23], 
              [24,25,26],
              [27,28,29] 
            ]
          ],
          [ # x
            [ # y
              [1,2,3], # z 
              [4,5,6],
              [7,8,9]
            ],
            [
              [11,12,13], 
              [14,15,16],
              [17,18,19] 
            ],
            [
              [21,22,23], 
              [24,25,26],
              [27,28,29] 
            ]
          ],
        ]
print(palet)
```

### estanteria de palets
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código define una estructura llamada `palets` que representa una estantería de palets en tres dimensiones. En términos prácticos, esta estructura podría modelar un almacén donde los palets están organizados en varias líneas y cada línea contiene varias posiciones en las que los palets pueden ser almacenados.

El código crea una matriz (array) multidimensional compuesta por diferentes niveles de anidamiento. Comenzamos con la más externa, `palets`, que es una lista que representa toda la estantería. Dentro de esta estructura, hay dos sub-listas que representan las líneas de palets en el almacén. Cada línea a su vez contiene dos matrices adicionales que podrían simular diferentes niveles o posiciones donde los palets están almacenados.

Cada uno de estos niveles es una matriz 3x3 (tres listas con tres elementos cada una) que podría representar un espacio físico en el almacén, como una posición en la que se pueden colocar palets. Estos números dentro de las matrices son solo ejemplos y podrían contener cualquier tipo de dato relevante para el sistema, como identificadores únicos para los palets almacenados.

El código finalmente intenta imprimir `palet` (que debería ser `palets`, probablemente debido a un error tipográfico), lo que causaría una excepción en Python ya que no está definida la variable `palet`. Es importante corregir esto a `print(palets)` para visualizar correctamente el contenido de la estructura multidimensional.

`010-estanteria de palets.py`

```python
palets = [ # estanteria de palets
          [ # linea de palets
           [ # x
            [ # y
              [1,2,3], # z 
              [4,5,6],
              [7,8,9]
            ],
            [
              [11,12,13], 
              [14,15,16],
              [17,18,19] 
            ],
            [
              [21,22,23], 
              [24,25,26],
              [27,28,29] 
            ]
          ],
          [ # x
            [ # y
              [1,2,3], # z 
              [4,5,6],
              [7,8,9]
            ],
            [
              [11,12,13], 
              [14,15,16],
              [17,18,19] 
            ],
            [
              [21,22,23], 
              [24,25,26],
              [27,28,29] 
            ]
          ],
        ],
        [ # linea de palets
           [ # x
            [ # y
              [1,2,3], # z 
              [4,5,6],
              [7,8,9]
            ],
            [
              [11,12,13], 
              [14,15,16],
              [17,18,19] 
            ],
            [
              [21,22,23], 
              [24,25,26],
              [27,28,29] 
            ]
          ],
          [ # x
            [ # y
              [1,2,3], # z 
              [4,5,6],
              [7,8,9]
            ],
            [
              [11,12,13], 
              [14,15,16],
              [17,18,19] 
            ],
            [
              [21,22,23], 
              [24,25,26],
              [27,28,29] 
            ]
          ],
        ],
       ]
print(palet)
```

### estanterias
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código Python crea una estructura de datos muy compleja que representa estanterías en un almacén. La variable `palets` es una lista multidimensional (o matriz) donde cada nivel del listado simboliza diferentes partes del almacenamiento.

La estructura empieza con la declaración de una lista llamada `palets`, que contiene sublistas para representar diferentes estanterías y líneas dentro de un almacén. Cada sublista a su vez contiene matrices 3x3 (tres elementos por fila, tres filas en total) que simbolizan posiblemente diferentes ubicaciones donde los palets pueden ser almacenados.

Por ejemplo, cada matriz interna como `[[1,2,3], [4,5,6], [7,8,9]]` representa un espacio específico donde se puede colocar o retirar un palet. Las varias capas de anidamiento (líneas, estanterías, etc.) permiten una organización detallada del almacén en el código.

El último comando `print(palets)` simplemente muestra por pantalla la estructura completa creada, ayudando a visualizar cómo están organizados todos los elementos dentro de esta matriz multidimensional.

`011-estanterias.py`

```python
palets = [ # Estanterias de palets
           [ # estanteria de palets
            [ # linea de palets
             [ # x
              [ # y
                [1,2,3], # z 
                [4,5,6],
                [7,8,9]
              ],
              [
                [11,12,13], 
                [14,15,16],
                [17,18,19] 
              ],
              [
                [21,22,23], 
                [24,25,26],
                [27,28,29] 
              ]
            ],
            [ # x
              [ # y
                [1,2,3], # z 
                [4,5,6],
                [7,8,9]
              ],
              [
                [11,12,13], 
                [14,15,16],
                [17,18,19] 
              ],
              [
                [21,22,23], 
                [24,25,26],
                [27,28,29] 
              ]
            ],
          ],
          [ # linea de palets
             [ # x
              [ # y
                [1,2,3], # z 
                [4,5,6],
                [7,8,9]
              ],
              [
                [11,12,13], 
                [14,15,16],
                [17,18,19] 
              ],
              [
                [21,22,23], 
                [24,25,26],
                [27,28,29] 
              ]
            ],
            [ # x
              [ # y
                [1,2,3], # z 
                [4,5,6],
                [7,8,9]
              ],
              [
                [11,12,13], 
                [14,15,16],
                [17,18,19] 
              ],
              [
                [21,22,23], 
                [24,25,26],
                [27,28,29] 
              ]
            ],
          ],
         ],
         [ # estanteria de palets
            [ # linea de palets
             [ # x
              [ # y
                [1,2,3], # z 
                [4,5,6],
                [7,8,9]
              ],
              [
                [11,12,13], 
                [14,15,16],
                [17,18,19] 
              ],
              [
                [21,22,23], 
                [24,25,26],
                [27,28,29] 
              ]
            ],
            [ # x
              [ # y
                [1,2,3], # z 
                [4,5,6],
                [7,8,9]
              ],
              [
                [11,12,13], 
                [14,15,16],
                [17,18,19] 
              ],
              [
                [21,22,23], 
                [24,25,26],
                [27,28,29] 
              ]
            ],
          ],
          [ # linea de palets
             [ # x
              [ # y
                [1,2,3], # z 
                [4,5,6],
                [7,8,9]
              ],
              [
                [11,12,13], 
                [14,15,16],
                [17,18,19] 
              ],
              [
                [21,22,23], 
                [24,25,26],
                [27,28,29] 
              ]
            ],
            [ # x
              [ # y
                [1,2,3], # z 
                [4,5,6],
                [7,8,9]
              ],
              [
                [11,12,13], 
                [14,15,16],
                [17,18,19] 
              ],
              [
                [21,22,23], 
                [24,25,26],
                [27,28,29] 
              ]
            ],
          ],
         ],
        ]
print(palet)
```

### naves industriales
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código define una estructura de datos compleja en Python utilizando matrices multidimensionales para representar un almacén industrial. La matriz principal `naves` está diseñada para simular naves industriales, que a su vez contienen estanterías y palets.

En términos prácticos, cada nivel más profundo dentro de la estructura representa una parte más específica del almacenaje:
- El primer nivel (la matriz exterior) se refiere a las "naves industriales".
- El segundo nivel contiene "estanterías de palets" dentro de estas naves.
- El tercer nivel simboliza "estanterias de palets", cada una compuesta por varias líneas.
- El cuarto nivel representa "líneas de palets", que consisten en varios "palets".
- Finalmente, el quinto y sexto niveles contienen los datos específicos de cada posición en un palet (x, y, z).

Este tipo de estructura es muy útil para almacenar información jerárquica compleja, como la configuración física de un almacén. Cada número dentro de estas matrices podría representar características del inventario, posiciones o incluso datos específicos de los productos.

El código final imprime el contenido de `naves`, lo que permitiría visualizar toda esta estructura y verificar su correcto funcionamiento.

`012-naves industriales.py`

```python
naves = [ # Naves industriales
          [ # Estanterias de palets
           [ # estanteria de palets
            [ # linea de palets
             [ # x
              [ # y
                [1,2,3], # z 
                [4,5,6],
                [7,8,9]
              ],
              [
                [11,12,13], 
                [14,15,16],
                [17,18,19] 
              ],
              [
                [21,22,23], 
                [24,25,26],
                [27,28,29] 
              ]
            ],
            [ # x
              [ # y
                [1,2,3], # z 
                [4,5,6],
                [7,8,9]
              ],
              [
                [11,12,13], 
                [14,15,16],
                [17,18,19] 
              ],
              [
                [21,22,23], 
                [24,25,26],
                [27,28,29] 
              ]
            ],
          ],
          [ # linea de palets
             [ # x
              [ # y
                [1,2,3], # z 
                [4,5,6],
                [7,8,9]
              ],
              [
                [11,12,13], 
                [14,15,16],
                [17,18,19] 
              ],
              [
                [21,22,23], 
                [24,25,26],
                [27,28,29] 
              ]
            ],
            [ # x
              [ # y
                [1,2,3], # z 
                [4,5,6],
                [7,8,9]
              ],
              [
                [11,12,13], 
                [14,15,16],
                [17,18,19] 
              ],
              [
                [21,22,23], 
                [24,25,26],
                [27,28,29] 
              ]
            ],
          ],
         ],
         [ # estanteria de palets
            [ # linea de palets
             [ # x
              [ # y
                [1,2,3], # z 
                [4,5,6],
                [7,8,9]
              ],
              [
                [11,12,13], 
                [14,15,16],
                [17,18,19] 
              ],
              [
                [21,22,23], 
                [24,25,26],
                [27,28,29] 
              ]
            ],
            [ # x
              [ # y
                [1,2,3], # z 
                [4,5,6],
                [7,8,9]
              ],
              [
                [11,12,13], 
                [14,15,16],
                [17,18,19] 
              ],
              [
                [21,22,23], 
                [24,25,26],
                [27,28,29] 
              ]
            ],
          ],
          [ # linea de palets
             [ # x
              [ # y
                [1,2,3], # z 
                [4,5,6],
                [7,8,9]
              ],
              [
                [11,12,13], 
                [14,15,16],
                [17,18,19] 
              ],
              [
                [21,22,23], 
                [24,25,26],
                [27,28,29] 
              ]
            ],
            [ # x
              [ # y
                [1,2,3], # z 
                [4,5,6],
                [7,8,9]
              ],
              [
                [11,12,13], 
                [14,15,16],
                [17,18,19] 
              ],
              [
                [21,22,23], 
                [24,25,26],
                [27,28,29] 
              ]
            ],
          ],
         ],
        ],
        [ # Estanterias de palets
           [ # estanteria de palets
            [ # linea de palets
             [ # x
              [ # y
                [1,2,3], # z 
                [4,5,6],
                [7,8,9]
              ],
              [
                [11,12,13], 
                [14,15,16],
                [17,18,19] 
              ],
              [
                [21,22,23], 
                [24,25,26],
                [27,28,29] 
              ]
            ],
            [ # x
              [ # y
                [1,2,3], # z 
                [4,5,6],
                [7,8,9]
              ],
              [
                [11,12,13], 
                [14,15,16],
                [17,18,19] 
              ],
              [
                [21,22,23], 
                [24,25,26],
                [27,28,29] 
              ]
            ],
          ],
          [ # linea de palets
             [ # x
              [ # y
                [1,2,3], # z 
                [4,5,6],
                [7,8,9]
              ],
              [
                [11,12,13], 
                [14,15,16],
                [17,18,19] 
              ],
              [
                [21,22,23], 
                [24,25,26],
                [27,28,29] 
              ]
            ],
            [ # x
              [ # y
                [1,2,3], # z 
                [4,5,6],
                [7,8,9]
              ],
              [
                [11,12,13], 
                [14,15,16],
                [17,18,19] 
              ],
              [
                [21,22,23], 
                [24,25,26],
                [27,28,29] 
              ]
            ],
          ],
         ],
         [ # estanteria de palets
            [ # linea de palets
             [ # x
              [ # y
                [1,2,3], # z 
                [4,5,6],
                [7,8,9]
              ],
              [
                [11,12,13], 
                [14,15,16],
                [17,18,19] 
              ],
              [
                [21,22,23], 
                [24,25,26],
                [27,28,29] 
              ]
            ],
            [ # x
              [ # y
                [1,2,3], # z 
                [4,5,6],
                [7,8,9]
              ],
              [
                [11,12,13], 
                [14,15,16],
                [17,18,19] 
              ],
              [
                [21,22,23], 
                [24,25,26],
                [27,28,29] 
              ]
            ],
          ],
          [ # linea de palets
             [ # x
              [ # y
                [1,2,3], # z 
                [4,5,6],
                [7,8,9]
              ],
              [
                [11,12,13], 
                [14,15,16],
                [17,18,19] 
              ],
              [
                [21,22,23], 
                [24,25,26],
                [27,28,29] 
              ]
            ],
            [ # x
              [ # y
                [1,2,3], # z 
                [4,5,6],
                [7,8,9]
              ],
              [
                [11,12,13], 
                [14,15,16],
                [17,18,19] 
              ],
              [
                [21,22,23], 
                [24,25,26],
                [27,28,29] 
              ]
            ],
          ],
         ],
        ]
       ]
print(palet)
```

### agenda
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es un programa sencillo que permite almacenar información de contacto en una "agenda". En cada iteración del bucle `while True`, el programa solicita al usuario que introduzca su nombre, apellidos, email y teléfono. Estos datos son guardados como una lista dentro de otra lista llamada `agenda`. Cada vez que se introduce un nuevo contacto, la agenda completa se imprime en pantalla para mostrar cómo ha cambiado después de añadir los nuevos detalles.

El código utiliza la estructura de datos conocida como matriz o array (en este caso, una lista de listas) para organizar y almacenar múltiples contactos. Cada contacto es una sublista que contiene cuatro elementos: nombre, apellidos, email y teléfono. Esto permite tener un registro fácilmente accesible y organizado.

La importancia de este ejercicio radica en la comprensión del manejo de listas anidadas (matrices) en Python, así como el uso de bucles infinitos (`while True`) para permitir múltiples entradas hasta que se decida interrumpir manualmente la ejecución.

`013-agenda.py`

```python
agenda = []

while True:
  nombre = input("Dime tu nombre: ")
  apellidos = input("Dime tus apellidos: ")
  email = input("Dime tu email: ")
  telefono = input("Dime tu teléfono: ")
  # Añado a la agenda
  agenda.append([nombre,apellidos,email,telefono])
  print(agenda)
  
  
  
```

### pickle para guardar
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código es una pequeña aplicación en Python que permite al usuario ingresar datos de contacto y guardarlos en un archivo binario usando el módulo `pickle`. El programa solicita repetidamente al usuario que introduzca información como nombre, apellidos, email y teléfono. Cada conjunto de datos se guarda en una lista dentro de la variable `agenda`, que es una lista multidimensional. Después de agregar cada nuevo contacto a la lista `agenda`, el código abre un archivo llamado "agenda.bin" en modo binario para escritura (`'wb'`) y utiliza la función `pickle.dump()` para guardar la lista completa de contactos en este archivo.

El uso de `pickle` es importante porque permite serializar (convertir estructuras de datos complejas en una secuencia de bytes) y deserializar (convertir esa secuencia de bytes nuevamente en estructuras de datos) objetos de Python, permitiendo así almacenar la lista `agenda` en un archivo para poder recuperarla más tarde sin necesidad de reingresar toda la información manualmente.

En resumen, este código es una herramienta básica para gestionar y guardar contactos en formato binario usando el módulo `pickle`.

`014-pickle para guardar.py`

```python
import pickle
agenda = []

while True:
  nombre = input("Dime tu nombre: ")
  apellidos = input("Dime tus apellidos: ")
  email = input("Dime tu email: ")
  telefono = input("Dime tu teléfono: ")
  # Añado a la agenda
  agenda.append([nombre,apellidos,email,telefono])
  print(agenda)
  archivo = open("agenda.bin",'wb')
  pickle.dump(agenda,archivo)
  archivo.close()
  
  
  
```

### conversiones de datos conocidas
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código Python muestra cómo convertir una cadena de texto que contiene un número en un número entero y luego imprimir ambos tipos de variables. La variable `edad` inicialmente almacena el número 47 como una cadena de texto (es decir, entre comillas). Luego, utilizando la función `int()`, se convierte esta cadena de texto en un número entero y se guarda en la variable `edad_en_numero`. Finalmente, se imprimen tanto la cadena original (`edad`) como el número entero convertido (`edad_en_numero`). Este proceso es importante porque permite que los programas manejen datos de diferentes formas según sea necesario, permitiendo operaciones matemáticas con números que inicialmente están almacenados como texto.

`015-conversiones de datos conocidas.py`

```python
edad = "47"

edad_en_numero = int(edad)

print(edad)
print(edad_en_numero)
```

### conversiones no posibles
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código está intentando convertir una variable que contiene un valor no numérico en un número entero. La variable `edad` ha sido inicializada con el carácter "a", lo cual es un texto, no un número. Luego se intenta convertir este valor a un número entero usando la función `int()`. Sin embargo, cuando Python trata de hacer esta conversión y encuentra que `edad` contiene una letra en lugar de un dígito numérico, generará un error porque es imposible convertir letras en números enteros.

El código imprime el valor original de `edad`, que es "a", y luego intenta imprimir la versión convertida a entero de esa misma variable. Sin embargo, debido al error mencionado antes, este último paso fallará y el programa no funcionará correctamente.

Es importante entender que no todos los datos pueden ser convertidos fácilmente entre tipos diferentes (como strings y números), especialmente si el contenido del string no es un número válido. Este ejemplo demuestra la importancia de verificar siempre que los datos están en el formato correcto antes de intentar realizar conversiones, para evitar errores inesperados en el programa.

`016-conversiones no posibles.py`

```python
edad = "a"

edad_en_numero = int(edad)

print(edad)
print(edad_en_numero)
```

### tipo
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código Python compara dos estructuras de datos diferentes: una lista y una tupla. Ambas contienen los mismos elementos, que son las frutas 'manzanas', 'peras' y 'platanos'. 

Primero, el código crea una lista llamada `lista` con estos tres elementos y luego imprime la lista utilizando `print(lista)`. A continuación, muestra el tipo de dato que es esta variable usando `print(type(lista))`, lo cual te dirá que es un objeto del tipo 'list'.

Después, hace exactamente lo mismo pero con una tupla. Crea una tupla llamada `tupla` con los mismos elementos y la imprime en pantalla. Luego, muestra el tipo de dato de esta variable utilizando `print(type(tupla))`, que te indicará que es un objeto del tipo 'tuple'.

El objetivo principal de este código es mostrarte cómo las listas y las tuplas son similares en su contenido pero diferentes en sus tipos y comportamientos. Las listas se pueden modificar después de crearlas, mientras que las tuplas no pueden ser modificadas (esto se conoce como inmutabilidad). Este concepto es fundamental para entender la estructura de datos en Python.

`017-tipo.py`

```python
lista = ['manzanas','peras','platanos']
print(lista)
print(type(lista))

tupla = ('manzanas','peras','platanos')
print(tupla)
print(type(tupla))
```

### cambio de tipo de dato
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código te muestra cómo cambiar entre dos tipos de estructuras de datos en Python: las tuplas y las listas. En primer lugar, el código define una tupla llamada `tupla` que contiene tres elementos: 'manzanas', 'peras' y 'platanos'. Las tuplas son como contenedores para varios valores, pero una vez creada, no puedes añadir o quitar elementos de ellas. 

Después, el código convierte la tupla en una lista utilizando la función `list()`, que permite modificar los datos dentro del contenedor. Al convertirlo a una lista, puedes utilizar métodos como `append()` para añadir un nuevo elemento ('fresas') al final de la lista.

Finalmente, el código muestra cómo revertir este proceso convirtiendo la lista modificada de vuelta a una tupla usando la función `tuple()`. Este cambio es importante porque algunas situaciones requieren datos que no se pueden modificar después de su creación, y otras necesitan estructuras flexibles para agregar o quitar elementos.

`018-cambio de tipo de dato.py`

```python
tupla = ('manzanas','peras','platanos')
# Necesito meter una fruta más
print(tupla)
lista = list(tupla) # convierto una tupla en una lista
print(lista)
lista.append("fresas")

# Ahora supongamos que tengo que volver a tupla
nueva_tupla = tuple(lista)
print(nueva_tupla)
```

### parto
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código Python te enseña cómo crear y guardar una agenda simple en un archivo binario utilizando la librería `pickle`. El programa primero importa la función `pickle` que es útil para serializar (convertir a formato binario) objetos de Python. Luego, crea una lista vacía llamada `agenda` donde se almacenará la información de contacto.

El bucle `while True:` hace que el código se repita indefinidamente hasta que fuerces su finalización. Dentro del bucle, el programa solicita al usuario que introduzca un nombre, apellidos, email y teléfono. Estos datos se guardan en una sublista `[nombre,apellidos,email,telefono]` que luego se agrega a la lista `agenda`.

Después de añadir cada contacto, el programa imprime en pantalla toda la agenda actualizada para mostrarte los datos recopilados hasta ese momento.

Finalmente, antes de terminar este ciclo, se abre un archivo llamado `"agenda.bin"` con modo de escritura binaria (`'wb'`) y se guarda (o serializa) la lista `agenda` en el archivo utilizando `pickle.dump()`. Esto asegura que los datos introducidos no desaparecerán cuando cierres el programa, ya que se guardan permanentemente en un archivo.

Este código es importante porque demuestra cómo almacenar y persistir datos estructurados de Python fuera del programa actual usando archivos binarios.

`019-parto.py`

```python
import pickle
agenda = []

while True:
  # Insertar
  nombre = input("Dime tu nombre: ")
  apellidos = input("Dime tus apellidos: ")
  email = input("Dime tu email: ")
  telefono = input("Dime tu teléfono: ")
  agenda.append([nombre,apellidos,email,telefono])
  # Imprimir
  print(agenda)
  # Guardar
  archivo = open("agenda.bin",'wb')
  pickle.dump(agenda,archivo)
  archivo.close()
  
  
  
```

### menu
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código es un programa simple que permite gestionar una agenda de contactos en Python. El programa presenta al usuario un menú con tres opciones: insertar un nuevo registro (contacto), leer todos los registros existentes y guardar la lista completa de contactos en un archivo binario.

Cuando el usuario selecciona la opción 1, se le piden detalles del contacto como nombre, apellidos, email y teléfono. Esta información se almacena en una sublista que luego se añade a la matriz principal llamada `agenda`.

La opción 2 simplemente imprime por pantalla todos los contactos almacenados en `agenda`.

Finalmente, si el usuario elige la opción 3, el programa guarda toda la agenda (la matriz completa) en un archivo binario llamado "agenda.bin" usando el módulo `pickle`. Esto permite que los datos se conserven y puedan ser recuperados en sesiones futuras del programa.

Este código es útil para entender cómo trabajar con matrices multidimensionales, manejar archivos de datos en Python y usar la funcionalidad básica del menú en aplicaciones interactivas.

`020-menu.py`

```python
import pickle
agenda = []

while True:
  print("Selecciona una opcion: ")
  print("1.-Insertar un registro")
  print("2.-Leer registros")
  print("3.-Guardar registros")
  opcion = int(input("Opción escogida: "))
  if opcion == 1:
    # Insertar
    nombre = input("Dime tu nombre: ")
    apellidos = input("Dime tus apellidos: ")
    email = input("Dime tu email: ")
    telefono = input("Dime tu teléfono: ")
    agenda.append([nombre,apellidos,email,telefono])
  elif opcion == 2:
    # Imprimir
    print(agenda)
  elif opcion == 3:
    # Guardar
    archivo = open("agenda.bin",'wb')
    pickle.dump(agenda,archivo)
    archivo.close()
  
  
  
```

### Actividades propuestas

It looks like you have a series of Python code snippets that cover different aspects of data handling and user interaction. Here's an overview and analysis of each file:

1. **001-simple.py**:
   - A simple print statement to display "Hola Mundo".
   
2. **002-variables.py**:
   - Declares variables `a`, `b`, and `c` with integer values.
   - Prints the values of these variables.

3. **003-sinopsis.py**:
   - Defines strings `title`, `director`, and `year`.
   - Uses string formatting to print a synopsis.

4. **004-copia.py**:
   - Declares a list `data` with numbers.
   - Makes an incorrect shallow copy of the list, which will affect both references if modified.
   
5. **005-deepcopy.py**:
   - Uses `deepcopy` from `copy` module to create a true copy of a nested list.

6. **006-herencia.py**:
   - Demonstrates inheritance with two classes `A` and `B`.
   
7. **007-inicializar.py**:
   - Shows how to initialize variables during class instantiation.
   
8. **008-lista-y-tupla.py**:
   - Compares lists (`list`) and tuples (`tuple`) in terms of mutability.

9. **009-herencia2.py**:
   - Expands on inheritance with a base class `Person` and derived classes `Student`.

10. **010-agenda-con-pickle.py**:
    - Uses the `pickle` module to serialize and save an agenda (list of contacts).

11. **011-archivo-y-metodo-close.py**:
    - Demonstrates file handling with `open()` and `close()` methods.

12. **012-lista.py**:
    - A complex nested list structure representing a physical storage layout.

13. **014-pickle para guardar.py**:
    - Continues the agenda example, saving to a binary file using `pickle`.

14. **015-conversiones de datos conocidas.py**:
    - Converts string data to integer type.

15. **016-conversiones no posibles.py**:
    - Shows an error when attempting to convert non-numeric strings to integers.

16. **017-tipo.py**:
    - Demonstrates checking the type of variables (`list` vs `tuple`).

17. **018-cambio de tipo de dato.py**:
    - Converts between list and tuple types dynamically.
    
18. **019-parto.py**:
    - Combines agenda creation, printing, and saving to a file using pickle.

19. **020-menu.py**:
    - Implements a simple menu-driven application for managing an agenda (add, view, save).

Here’s how you might integrate these snippets into a cohesive program:

### Example Agenda Application

```python
import pickle

def guardar_agenda(agenda):
    archivo = open("agenda.bin", 'wb')
    pickle.dump(agenda, archivo)
    archivo.close()

def leer_registros():
    try:
        with open("agenda.bin", "rb") as archivo:
            return pickle.load(archivo)
    except FileNotFoundError:
        return []

def agregar_registro(agenda):
    nombre = input("Dime tu nombre: ")
    apellidos = input("Dime tus apellidos: ")
    email = input("Dime tu email: ")
    telefono = input("Dime tu teléfono: ")
    agenda.append([nombre, apellidos, email, telefono])
    return agenda

def mostrar_menu():
    print("Selecciona una opción:")
    print("1.- Insertar un registro")
    print("2.- Leer registros")
    print("3.- Guardar registros")
    print("4.- Salir")

def main():
    agenda = leer_registros()
    
    while True:
        mostrar_menu()
        opcion = input("Opción escogida: ")
        
        if opcion == '1':
            agenda = agregar_registro(agenda)
        elif opcion == '2':
            for registro in agenda:
                print(f"Nombre: {registro[0]}, Apellidos: {registro[1]}, Email: {registro[2]}, Teléfono: {registro[3]}")
        elif opcion == '3':
            guardar_agenda(agenda)
        elif opcion == '4':
            break
        else:
            print("Opción no válida. Por favor, selecciona una opción del menú.")

if __name__ == "__main__":
    main()
```

This code integrates the agenda management system with a user menu and file persistence using `pickle`. The program allows users to add new contacts, view existing ones, save changes, and exit gracefully.


<a id="genericidad"></a>
## Genericidad

### Introducción a los ejercicios

Esta carpeta contiene una serie de ejercicios en Python que se enfocan en el concepto de genericidad y manejo de errores. Los problemas trabajan con listas que contienen diferentes tipos de datos (números enteros, cadenas no numéricas) para enseñar cómo procesar estos elementos de manera eficiente y segura. Se practica la conversión de tipo de datos, el uso de funciones genéricas para operaciones matemáticas sobre los números, y manejo de excepciones para lidiar con errores durante la ejecución del programa. Los ejercicios progresan desde una simple impresión de listas hasta situaciones más complicadas que requieren búsqueda en tablas adicionales o reporte de errores no manejados previamente.

### genericidad en python
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código en Python crea una lista llamada `numeros` que contiene cuatro elementos. La lista incluye tres números enteros (1, 2 y 4) y un string que representa el número "3". El código luego imprime la lista completa.

Es importante notar que aunque uno de los elementos es una cadena de texto ("3"), Python permite almacenar diferentes tipos de datos en las mismas listas. Sin embargo, esto puede llevar a problemas si se intenta realizar operaciones matemáticas con el string "3" como si fuera un número entero.

El código es sencillo y sirve para ilustrar cómo se pueden mezclar diferentes tipos de datos dentro de una lista en Python, aunque generalmente no es una práctica recomendada debido a los potenciales errores que puede generar.

`001-genericidad en python.py`

```python
numeros = [
  1,
  2,
  "3",
  4
]

print(numeros)
```

### funcion doble
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código es una pequeña aplicación en Python que ilustra el concepto de procesamiento de datos en un conjunto de números, aunque contiene algunos elementos que pueden causar problemas. En primer lugar, se crea una lista llamada `numeros` que incluye tanto enteros como una cadena (el número 3 está entre comillas), lo cual puede generar errores al intentar multiplicar esta cadena por 2.

La función `calculaDoble()` recorre cada elemento en la lista `numeros`. Para cada elemento, imprime el doble de ese valor. Sin embargo, si un elemento no es numérico (como sucede con "3" en este caso), intentará convertirlo a un número para realizar la operación, lo que dará lugar a una excepción debido a que no se puede multiplicar una cadena por un número.

Este código sirve como ejemplo de cómo es importante asegurarse de que los datos sean del tipo correcto antes de realizar operaciones matemáticas en ellos. En situaciones reales, sería necesario agregar comprobaciones para manejar este tipo de errores y garantizar que el programa funcione correctamente con cualquier entrada.

`002-funcion doble.py`

```python
numeros = [
  1,
  2,
  "3",
  4
]

print(numeros)

def calculaDoble():
  for numero in numeros:
    print(numero*2)

calculaDoble()
```

### arreglo de genericidad
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código muestra cómo manejar una lista que contiene diferentes tipos de datos, como números enteros y cadenas. La función `calculaDoble()` itera sobre la lista `numeros` para convertir cada elemento en un número entero (si es posible) y luego imprime el doble de ese número.

El código subraya la importancia de tratar correctamente los datos que pueden ser de diferentes tipos, ya que intentar hacer cálculos matemáticos con una cadena puede causar errores. En este caso, se utiliza la función `int()` para convertir cada elemento en un entero antes de realizar el cálculo.

Es importante destacar que si alguno de los elementos no pudiera ser convertido a número (por ejemplo, si fuera una cadena de texto que no representa un número), el código arrojaría un error. Por eso es crucial tener precaución al trabajar con datos de tipo mixto en una lista.

`003-arreglo de genericidad.py`

```python
numeros = [1,2,"3",4]

print(numeros)

def calculaDoble():
  for numero in numeros:
    numero = int(numero)   # Convierto en entero
    print(numero*2)

calculaDoble()
```

### meto un poco de presion
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es un ejemplo sencillo que demuestra cómo trabajar con una lista que contiene diferentes tipos de datos, tanto números enteros como cadenas. La función `calculaDoble()` itera sobre esta lista y trata de duplicar cada elemento, pero primero intenta convertir cualquier cadena en un número entero para poder realizar el cálculo.

El código imprime la lista original al principio para que puedas ver cómo se ve antes del proceso. Luego, llama a la función `calculaDoble()`, que recorre la lista y por cada elemento, si es posible, lo convierte en un número entero (por ejemplo, "3" se convierte en 3) y luego imprime el doble de ese número.

Es importante destacar que este código tiene un problema: solo intenta convertir los elementos a enteros dentro del bucle, pero no maneja adecuadamente las excepciones para casos donde la conversión no es posible (por ejemplo, con "cinco"). Esto puede causar errores en tiempo de ejecución si el programa se encuentra con una cadena que no representa un número válido.

`004-meto un poco de presion.py`

```python
numeros = [1,2,"3",4,"cinco"]

print(numeros)

def calculaDoble():
  for numero in numeros:
    numero = int(numero)   # Convierto en entero
    print(numero*2)

calculaDoble()
```

### try except
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código muestra cómo manejar datos que pueden no ser del tipo esperado usando la estructura `try-except` en Python. En este ejemplo, tienes una lista llamada `numeros` que contiene tanto números enteros como cadenas de texto. La función `calculaDoble()` itera sobre esta lista y trata de convertir cada elemento a un número entero con `int(numero)`. Si la conversión es exitosa, el código imprime el doble del número. Sin embargo, si se produce un error al intentar convertir una cadena que no representa un número (como "cinco"), el bloque `except` captura este error y simplemente imprime "(no válido)".

Esta técnica es importante porque ayuda a asegurar que tu programa siga funcionando correctamente incluso cuando los datos no son perfectos o esperados, evitando interrupciones inesperadas debido a errores de tipo.

`005-try except.py`

```python
numeros = [1,2,"3",4,"cinco"]

print(numeros)

def calculaDoble():
  for numero in numeros:
    try:
      numero = int(numero)   # Convierto en entero
      print(numero*2)
    except:
      print("(no válido)")

calculaDoble()
```

### estructura de datos
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código muestra cómo manejar diferentes tipos de datos dentro de una misma lista y realizar operaciones con ellos. La lista `numeros` contiene tanto números enteros como cadenas que representan números o palabras. El objetivo del código es calcular el doble de cada número en la lista, pero también tiene en cuenta las posibles cadenas no numéricas.

La función `calculaDoble()` itera sobre cada elemento en la lista `numeros`. Para cada elemento, intenta convertirlo a un entero (`int(numero)`). Si esto funciona, el código imprime el doble del número. Sin embargo, si la conversión falla (por ejemplo, si el elemento es una cadena como "cinco" o cualquier otra que no sea numérica), se captura la excepción y luego busca en otra lista `numeros_etiquetas` para encontrar la posición correspondiente de esa etiqueta y imprime el doble de esa posición.

Este código demuestra cómo manejar datos mixtos (numéricos y texto) dentro del mismo conjunto de datos y cómo usar estructuras como listas junto con excepciones (`try-except`) para hacer operaciones que dependen del tipo de dato. Es importante entender este enfoque porque a menudo trabajaremos con datos no perfectamente estructurados y debemos ser capaces de adaptarnos a estas condiciones.

`006-estructura de datos.py`

```python
numeros = [1,2,"3",4,"cinco"]

print(numeros)
numeros_etiquetas = ["cero","uno","dos","tres","cuatro","cinco"]
def calculaDoble():
  for numero in numeros:
    try:                    # Primero intenta convertir
      numero = int(numero)
      print(numero * 2)
    except:                 # Si no puedes
      # Intenta busca el valor en la lista de numeros
      for i in range(0,len(numeros_etiquetas)):
        if numero == numeros_etiquetas[i]:
          print(i*2)
        
calculaDoble()
```

### la volvemos a fastidiar
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código en Python se centra en una función llamada `calculaDoble()` que recorre una lista mixta llamada `numeros` que contiene números y cadenas no numéricas. La función intenta procesar cada elemento de la lista para calcular su doble, pero tiene diferentes estrategias dependiendo del tipo de dato:

1. **Procesamiento de Números:** Si un elemento es un número (ya sea entero o convertible a entero), el código lo convierte en un número entero y luego imprime su valor duplicado.

2. **Manejo de Errores:** Cuando encuentra una cadena que no puede convertir a un número, genera una excepción (`TypeError`). En este caso, busca la cadena en otra lista llamada `numeros_etiquetas`, donde las cadenas representan nombres de números (como "uno", "cinco"). Si encuentra una coincidencia, imprime el doble del índice correspondiente en la lista.

Esta técnica es útil cuando se trabaja con datos que pueden ser ambiguos o no estandarizados y necesitas tratarlos de manera inteligente para evitar errores. Es importante porque muestra cómo manejar situaciones donde los tipos de datos pueden variar dentro de una misma estructura, utilizando try-except para controlar excepciones y garantizar el flujo continuo del programa.

`007-la volvemos a fastidiar.py`

```python
numeros = [1,2,"3",4,"cinco","patata"]

print(numeros)
numeros_etiquetas = ["cero","uno","dos","tres","cuatro","cinco"]
def calculaDoble():
  for numero in numeros:
    try:                    # Primero intenta convertir
      numero = int(numero)
      print(numero * 2)
    except:                 # Si no puedes
      # Intenta busca el valor en la lista de numeros
      for i in range(0,len(numeros_etiquetas)):
        if numero == numeros_etiquetas[i]:
          print(i*2)
        
calculaDoble()
```

### atrapamos el caso patata
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es una función llamada `calculaDoble` que recorre una lista mixta de números y cadenas llamada `numeros`. La función tiene como objetivo procesar cada elemento de esta lista, intentando primero convertirlo en un número entero. Si la conversión es exitosa, simplemente imprime el doble del número. Sin embargo, si no puede convertir el elemento a un número (por ejemplo, si encuentra una cadena que no representa un número), entonces busca esa cadena en otra lista llamada `numeros_etiquetas`. Si encuentra una coincidencia, imprime el doble del índice de la coincidencia; de lo contrario, imprime un mensaje indicando que no ha podido procesar el elemento. Esto es útil para manejar listas con datos variados y garantizar que tu programa siga funcionando incluso cuando se encuentran elementos inesperados.

La estructura `try-except` ayuda a capturar errores durante la ejecución del código, permitiendo al programa continuar en lugar de terminar abruptamente. En este caso específico, permite que el programa maneje tanto números como cadenas sin interrumpirse.

`008-atrapamos el caso patata.py`

```python
numeros = [1,2,"3",4,"cinco","patata"]

print(numeros)
numeros_etiquetas = ["cero","uno","dos","tres","cuatro","cinco"]
def calculaDoble():
  for numero in numeros:
    try:                    # Primero intenta convertir
      numero = int(numero)
      print(numero * 2)
    except:                 # Si no puedes
      centinela = False
      # Intenta busca el valor en la lista de numeros
      for i in range(0,len(numeros_etiquetas)):
        if numero == numeros_etiquetas[i]:
          print(i*2)
          centinela = True
      if centinela == False:
        print("Mira tio lo he intentado pero no he podido")
        
calculaDoble()
```

### Actividades propuestas

### Actividad 1: Conversión de Tipos y Generación de Salida

**Descripción:** Los estudiantes deben crear una función que reciba una lista mixta (números enteros, cadenas numéricas) y genere la salida del doble de cada número. Se espera que los estudiantes comprendan cómo manejar diferentes tipos de datos dentro de listas en Python.

### Actividad 2: Manejo de Excepciones Simples

**Descripción:** Los alumnos deben escribir una función que itere sobre una lista mixta (numérica y no numérica) y use un bloque `try-except` para manejar errores cuando intentan convertir cadenas no numéricas a enteros.

### Actividad 3: Generación de Listas Etiquetadas

**Descripción:** Se requiere que los estudiantes creen una lista de etiquetas (strings representando números) y usen esta lista para manipular el índice correspondiente del string en lugar de convertir directamente al número entero.

### Actividad 4: Manejo de Excepciones Mejorado

**Descripción:** Los alumnos deben mejorar la función `calculaDoble` para que, en caso de no poder convertir un elemento a entero ni encontrarlo en una lista etiquetada, imprima un mensaje personalizado indicando el error.

### Actividad 5: Generación de Listas Dinámicas

**Descripción:** Los estudiantes deben generar dinámicamente listas mixtas (numéricas y no numéricas) con valores ingresados por consola y luego aplicar las funciones aprendidas para procesarlas correctamente.

### Actividad 6: Comparación Entre Bucles For e If Else

**Descripción:** Se pide que los alumnos modifiquen la función `calculaDoble` para utilizar una estructura condicional (`if-else`) en lugar de un bucle `for`, comparando rendimiento y claridad del código.

### Actividad 7: Funciones Lambda y Listas Comprensivas

**Descripción:** Los estudiantes deben aplicar funciones lambda dentro de listas comprensivas para procesar las listas mixtas que manejan la conversión a enteros y generación del doble.

### Actividad 8: Integración de Módulos Externos

**Descripción:** Aunque se ha limitado el uso exclusivamente a Python estándar, los estudiantes pueden explorar cómo integrar módulos externos como `logging` para mejorar la trazabilidad y registro de errores en sus funciones.


<a id="cadenas-de-caracteres-expresiones-regulares"></a>
## Cadenas de caracteres. Expresiones regulares

### Introducción a los ejercicios

En esta carpeta, encontrarás una serie de ejercicios destinados a mejorar tus habilidades con las cadenas de caracteres y expresiones regulares en Python. Los problemas abarcan desde la manipulación básica de strings, como acceder a sus elementos individuales o recorrerlas caracter por caracter, hasta tareas más avanzadas que incluyen el uso de métodos para dividir y unir cadenas, así como limpiar datos. También se trabajará en la lectura y procesamiento de archivos CSV, convirtiendo los datos en estructuras más manejables.

Además, varios ejercicios están dedicados a introducirte en el mundo de las expresiones regulares, enseñándote cómo validar formatos específicos como correos electrónicos o direcciones postales utilizando patrones complejos. Estas actividades te permitirán desarrollar una comprensión sólida tanto del manejo de texto en Python como de la capacidad de resolver problemas que requieren el uso de expresiones regulares para verificar la validez y limpieza de datos de entrada.

Estos ejercicios no solo mejorarán tus habilidades técnicas, sino que también te prepararán para situaciones reales donde es necesario trabajar con grandes cantidades de texto y asegurar su formato correcto.

### las strings realmente son colecciones
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código Python muestra cómo se manejan las cadenas de texto, también conocidas como strings. La primera línea crea una variable llamada `nombre` y le asigna el valor `"Jose Vicente"`. Este es un string, que en programación es simplemente una colección ordenada de caracteres entre comillas.

Luego, la función `print(nombre)` se utiliza para imprimir el contenido de la variable `nombre`, lo que mostrará "Jose Vicente" en la pantalla. La segunda llamada a `print(nombre[0])` imprime solo el primer carácter del string, que es 'J'. En Python, los strings son como listas donde cada caracter ocupa una posición específica, empezando desde 0. Así, `nombre[0]` accede al primer carácter de la cadena.

Esta parte del código es importante porque demuestra cómo trabajar con posiciones específicas dentro de un string y cómo imprimir su contenido en la consola, lo que son habilidades fundamentales para cualquier programador cuando trabaja con texto.

`001-las strings realmente son colecciones.py`

```python
nombre = "Jose Vicente"
print(nombre)

print(nombre[0])
```

### recorrer una cadena
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código te muestra cómo recorrer una cadena de caracteres en Python utilizando un bucle `for`. La variable `nombre` almacena la cadena `"Jose Vicente"`, que es simplemente una secuencia de letras. El bucle `for` itera sobre cada carácter de esta cadena, uno a uno. En cada iteración, la letra actual se asigna a la variable `letra` y el comando `print(letra)` imprime esa letra por separado en la consola. Esto significa que si ejecutas este código, verás cada letra del nombre "Jose Vicente" impresa en una línea diferente. Este es un ejemplo sencillo pero fundamental de cómo se pueden trabajar con cadenas individuales en Python, permitiéndote realizar operaciones sobre cada carácter de manera secuencial.

`002-recorrer una cadena.py`

```python
nombre = "Jose Vicente"
for letra in nombre:
    print(letra)
```

### longitud de la cadena
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código Python muestra cómo obtener y mostrar la longitud de una cadena de caracteres. En primer lugar, se define una variable llamada `nombre` que almacena el texto "Jose Vicente". Luego, usando la función `len()`, se calcula cuántos caracteres tiene esta cadena, incluyendo espacios en blanco. Finalmente, el código imprime un mensaje que indica que está mostrando la longitud del nombre seguido por el número de caracteres que contiene la variable `nombre`. Este tipo de operación es importante porque te permite obtener información sobre el contenido de una cadena, como su tamaño, lo cual puede ser útil para validar datos o manejar texto en aplicaciones.

`003-longitud de la cadena.py`

```python
nombre = "Jose Vicente"
print("La longitud del nombre:")
print(len(nombre))
```

### explotar
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código Python toma una cadena de texto llamada `nombre` que contiene el nombre completo "Jose Vicente". La función `.split()` se utiliza para dividir esta cadena en partes basándose en un separador, en este caso, el espacio en blanco (" "). Esto convierte la cadena en una lista donde cada elemento es uno de los nombres separados por espacios. Finalmente, `print(explotado)` muestra la lista resultante en la pantalla.

La importancia de esta operación radica en que permite tomar un texto continuo y convertirlo en una estructura más manejable como una lista, lo cual facilita trabajar con cada parte del nombre por separado. Esto es útil para aplicaciones donde necesitas acceder a nombres individuales (como el primer nombre o el apellido) de manera independiente.

`004-explotar.py`

```python
nombre = "Jose Vicente"
explotado = nombre.split(" ")
print(explotado)
```

### ejemplo csv
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código te muestra cómo separar una cadena de texto en Python utilizando un método llamado `split()`. En este caso, tenemos una cadena que contiene varios números escritos en palabras y cada uno está separado por una coma (`,`). La línea `partido = datos.split(",")` toma la cadena `datos`, divide esta cadena en pedazos cada vez que encuentra una coma, y almacena estos pedazos como elementos de una lista. Por lo tanto, después de ejecutar `split()`, `partido` será una lista donde cada palabra individual está almacenada como un elemento independiente.

La importancia de este código reside en cómo permite trabajar con datos que vienen en forma de cadena pero necesitan ser manipulados o analizados pieza por pieza. Esto es común cuando se trabaja con archivos CSV (Valores Separados por Comas), donde cada campo de información está separado por comas y puedes querer acceder a estos campos individualmente.

En resumen, este código demuestra cómo convertir una cadena larga en un conjunto manejable de piezas más pequeñas utilizando el método `split()`, lo cual es muy útil para procesar datos estructurados que vienen en formato CSV o similar.

`005-ejemplo csv.py`

```python
datos = "uno,dos,tres,cuatro,cinco,seis"

# Primero imprimo la cadena
print(datos)
# Ahora la parto
partido = datos.split(",")
# Ahora imprimo el partido
print(partido)
```

### unir
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código muestra cómo trabajar con cadenas de texto en Python, específicamente cómo separar una cadena y luego unirla nuevamente. Primero, se define una variable `datos` que contiene una serie de palabras separadas por comas. El código imprime esta cadena original para mostrar cómo se ve.

Luego, el código utiliza la función `split(",")`, lo cual divide la cadena en varios elementos basándose en las comas como delimitador. Esto convierte nuestra cadena larga en una lista de strings más pequeña: cada elemento en la lista es uno de los números separados por comas en la cadena original.

Finalmente, el código utiliza `join()` para unir nuevamente todos estos elementos de la lista en una sola cadena, pero esta vez usando el caracter "|" como delimitador entre ellos. Esto resulta en una nueva cadena que contiene los mismos elementos que antes, pero separados por el nuevo carácter especificado.

Este tipo de manipulación es útil cuando necesitas dividir información para trabajar con cada pieza individualmente (como en bases de datos o archivos CSV), y luego juntarlas nuevamente en un formato diferente.

`006-unir.py`

```python
datos = "uno,dos,tres,cuatro,cinco,seis"

# Primero imprimo la cadena
print(datos)
# Ahora la parto
partido = datos.split(",")
# Ahora imprimo el partido
print(partido)
# Ahora quiero unirlo todo de nuevo
nueva_cadena = "|".join(partido)
print(nueva_cadena)
```

### leer archivo csv
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código Python se utiliza para leer y procesar un archivo de texto llamado "clientes.csv". Lo que hace el programa es abrir el archivo, leer todas sus líneas y luego recorrer cada línea del archivo. En cada iteración del bucle, la línea actual se divide en partes usando una coma (",") como separador. Esto significa que si tuvieras un archivo CSV con varias columnas de datos, por ejemplo "nombre,edad,domicilio", el código lo dividiría en tres partes: nombre, edad y domicilio.

Después de dividir cada línea en sus componentes individuales, el programa imprime la lista resultante. Por ejemplo, si una línea del archivo CSV es "Juan,25,Calle Principal 123", después de ejecutar `linea.split(",")`, se obtendría una lista como ["Juan", "25", "Calle Principal 123"], que luego se imprimiría en la consola.

Este código es importante porque muestra cómo trabajar con archivos CSV, un formato comúnmente utilizado para almacenar datos tabulares. Aprender a leer y procesar estos tipos de archivos es fundamental cuando trabajas con bases de datos o conjuntos de datos en general en Python.

`007-leer archivo csv.py`

```python
archivo = open("clientes.csv","r")

lineas = archivo.readlines()

for linea in lineas:
	partido = linea.split(",")
	print(partido)
```

### convierto a matriz multidimensional
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código se encarga de leer un archivo llamado "clientes.csv" y convertir su contenido en una matriz (también conocida como lista de listas) para facilitar su manipulación. Primero, el programa abre el archivo "clientes.csv" en modo lectura ("r"). Luego, lee todas las líneas del archivo con la función `readlines()`, almacenando cada línea en la variable `lineas`.

El siguiente paso es crear una lista vacía llamada `conjunto_datos` donde se almacenará la información estructurada. El código itera sobre cada línea en `lineas`. Para cada línea, utiliza el método `split(",")` para dividir la línea en partes por comas (`,`), lo que resulta en una lista de valores separados. Cada una de estas listas se añade a `conjunto_datos`.

Finalmente, se imprime `conjunto_datos`, mostrando así la matriz completa donde cada sublista representa los datos de un cliente del archivo CSV.

Esta técnica es muy útil para trabajar con datos tabulares, ya que permite manejar y analizar información estructurada fácilmente en Python.

`008-convierto a matriz multidimensional`

```
archivo = open("clientes.csv","r")

lineas = archivo.readlines()

conjunto_datos = []

for linea in lineas:
	partido = linea.split(",")
	conjunto_datos.append(partido)

print(conjunto_datos)
```

### reemplazar
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código te muestra cómo reemplazar partes específicas de una cadena de texto en Python. En este caso, la variable `cadena` almacena el texto "Hoy es martes". Luego, se utiliza el método `replace()` para cambiar la palabra "martes" por "miércoles", guardando el resultado en la variable `reemplazado`. Finalmente, se imprime el contenido de `reemplazado`, que ahora dice "Hoy es miércoles".

El método `replace()` es muy útil cuando necesitas modificar cadenas de texto específicamente, permitiéndote reemplazar una parte de la cadena por otra sin tener que manipular cada carácter individualmente. En este ejemplo, se cambia un día de la semana, pero puedes usarlo para cualquier otro tipo de modificación en textos, como corregir errores ortográficos o estandarizar formatos en datos de texto.

Este código es importante porque ilustra cómo las cadenas en Python son objetos que tienen métodos incorporados que pueden realizar operaciones complejas con solo una línea de código.

`009-reemplazar.py`

```python
cadena = "Hoy es martes"

reemplazado = cadena.replace("martes","miercoles")

print(reemplazado)
```

### quitar saltos de linea
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código muestra cómo eliminar los saltos de línea (también conocidos como newline) en una cadena de texto utilizando la función `replace()`. En el fragmento, primero se define una variable llamada `linea_con_salto` que contiene un ejemplo de texto seguido por un salto de línea representado por `\n`. Luego, se usa el método `replace()` para reemplazar todas las ocurrencias del carácter de salto de línea con una cadena vacía, es decir, eliminándolo. La variable `limpiado` almacena la versión modificada sin los saltos de línea.

Este proceso es importante cuando necesitas trabajar con texto que no debería tener saltos de línea adicionales, como al concatenar múltiples líneas en una sola o preparar el texto para su visualización en interfaces de usuario donde se desea evitar cambios bruscos en la posición vertical.

`010-quitar saltos de linea.py`

```python
# Esta cadena tiene algo que no quiero (\n)
linea_con_salto = "Esto es una prueba \n"
# Lo que quiero es QUITAR algo
# Quito |n con "nada"
limpiado = linea_con_salto.replace("\n","")
```

### expresiones regulares
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código en Python utiliza expresiones regulares para validar direcciones de correo electrónico. La expresión regular específica (`patron`) que se define es bastante compleja y cubre muchos aspectos importantes de una dirección de correo electrónico válida.

El patrón comienza con `^[a-zA-Z0-9_.+-]+` que describe la parte local del correo (antes del símbolo '@'). Esta expresión permite letras tanto mayúsculas como minúsculas, números, guiones bajos (`_`), puntos (`.`), signos más (`+`) y guiones (-). El `@` es un carácter obligatorio que marca el final de la parte local.

Después del `@`, sigue `[a-zA-Z0-9-]+`, que representa el nombre del dominio principal, permitiendo letras y números junto con guiones. Luego viene `\.` (un punto literal), que se utiliza para separar el dominio principal de la parte final del dominio, que es descrita por `[a-zA-Z0-9-.]+`. Esta última expresión permite letras, números, puntos y guiones, representando tanto TLDs como posibles subdominios.

El código termina con `$`, lo cual indica que el patrón debe coincidir exactamente hasta el final de la cadena, asegurando así que no haya caracteres adicionales después del dominio en la dirección de correo electrónico.

Finalmente, se utilizan dos correos electrónicos para probar esta expresión regular: `email_mal` ("algo") y `email_bien` ("info@jocarsa.com"). La función `re.match()` es llamada con este patrón para cada uno de estos correos electrónicos, mostrando en la consola si coincide o no con el formato esperado. Esto ayuda a entender cómo funciona la validación y qué tipos de errores pueden ocurrir al validar direcciones de correo electrónico.

Este tipo de validaciones es muy importante cuando se trabaja con formularios web para asegurarse de que los usuarios ingresen datos correctos antes de enviarlos al servidor.

`011-expresiones regulares.py`

```python

"""
Explicación del patrón:

^
    Indica el inicio de la cadena. La validación comienza desde el principio.

[a-zA-Z0-9_.+-]+
    Parte local del correo (antes de '@').
    Permite:
        - letras mayúsculas y minúsculas (a-zA-Z)
        - números (0-9)
        - guion bajo (_)
        - punto (.)
        - signo más (+)
        - guion (-)
    El símbolo '+' indica uno o más caracteres válidos.

@
    Caracter obligatorio que separa el usuario del dominio.

[a-zA-Z0-9-]+
    Nombre del dominio principal sin subdominios.
    Permite letras, números y guiones.
    Requiere al menos un carácter.

\.
    Un punto literal que separa el dominio del TLD.
    El backslash escapa el carácter '.' para que no actúe como comodín.

[a-zA-Z0-9-.]+
    Parte final del dominio (TLD o subdominios), por ejemplo:
        .com
        .co.uk
        .org
    Permite letras, números, guiones y puntos.
    El símbolo '+' indica uno o más caracteres.

$
    Indica el final de la cadena. La validación termina aquí.
"""
import re

patron = r'^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$'

email_mal = "algo"
email_bien = "info@jocarsa.com"

print(re.match(patron, email_mal))

print(re.match(patron, email_bien))
```

### regex direccion postal
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código Python utiliza expresiones regulares para validar una dirección postal en formato español. La función `re.match` se usa con un patrón específico para verificar si la dirección cumple con el formato requerido. El patrón está diseñado para reconocer direcciones que incluyen el nombre de la calle, un número de portal y un código postal de cinco dígitos.

El patrón regular `patron` se compone de varias partes que juntas forman una expresión compleja:
- Empieza con el nombre de la calle, permitiendo letras mayúsculas, minúsculas, números, espacios y caracteres especiales como acentos (`ÁÉÍÓÚÜÑáéíóúüñ`).
- Sigue un número de portal que puede incluir una letra opcional después del número (por ejemplo: 10B o 23A).
- Finalmente, se espera un código postal válido compuesto por exactamente cinco dígitos.

El código imprime el resultado de la validación para dos direcciones: `direccion_mal`, que no cumple con el formato completo del patrón (solo incluye el nombre de la calle), y `direccion_bien`, que sí sigue correctamente el esquema esperado. El uso de expresiones regulares como este permite a los programadores verificar fácilmente si una cadena de texto está en un formato específico, lo cual es muy útil para validar datos de entrada en aplicaciones web o sistemas de gestión de información.

`012-regex direccion postal.py`

```python
import re

patron = r'^[A-Za-zÁÉÍÓÚÜÑáéíóúüñ\s]+ \d+[A-Za-z]? \d{5}$'
"""
Explicación del patrón:

^
    Inicio de la cadena.

[A-Za-zÁÉÍÓÚÜÑáéíóúüñ\s]+
    Nombre de la calle o vía.
    Permite:
        - letras mayúsculas y minúsculas
        - letras acentuadas y 'ñ'
        - espacios
    '+' indica uno o más caracteres.

␣ (espacio)
    Separador obligatorio.

\d+
    Número de portal.
    '\d' representa un dígito.
    '+' indica uno o más dígitos.
    Ejemplo: 5, 23, 104

[A-Za-z]?
    Letra opcional en el número (como 10B o 23A).
    '?' indica que puede aparecer cero o una vez.

␣ (espacio)
    Separador obligatorio.

\d{5}
    Código postal español estándar de 5 dígitos.

$
    Final de la cadena.
"""

direccion_mal = "Calle Mayor"
direccion_bien = "Calle Mayor 10 46001"

print(re.match(patron, direccion_mal))
print(re.match(patron, direccion_bien))
```

### validar telefono
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Parece que no has proporcionado el código específico para el archivo `validar telefono.py` en la solicitud. Sin embargo, basándome en el nombre del archivo y los ejercicios relacionados, podemos suponer que este script está diseñado para validar números de teléfono utilizando expresiones regulares en Python.

### Explicación:

El archivo `013-validar telefono.py` probablemente contiene un programa que verifica si una cadena dada cumple con el formato de un número telefónico válido. Generalmente, esto se hace usando la biblioteca estándar `re`, que permite trabajar con expresiones regulares (regex).

En este script, se define una expresión regular que especifica cómo debe ser estructurado un número telefónico. Por ejemplo, puede incluir patrones para números de teléfono nacionales sin guiones ni espacios (como 1234567890) o con guiones y paréntesis (como (123)-456-7890).

El código probablemente tiene una función que toma un número telefónico como entrada y utiliza la expresión regular para verificar si este número cumple con el formato esperado. Si el número es válido, se devuelve `True`; de lo contrario, se devuelve `False`.

Este tipo de validación es importante porque asegura que los datos ingresados por el usuario sean coherentes y útiles para otros procesos como almacenamiento en una base de datos o enviar un mensaje de texto.

Si tienes disponible el código real, puedo proporcionar una explicación más detallada sobre cómo funciona exactamente.

`013-validar telefono.py`

```python

```

### ejecutar ollama desde python
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código está diseñado para enviar una solicitud a un servicio web que proporciona respuestas generadas por inteligencia artificial. En este caso, el código utiliza la biblioteca `requests` en Python para hacer una petición POST a una URL específica (`http://localhost:11434/api/generate`). La función `post()` envía al servidor una carga útil (payload) que incluye detalles sobre qué modelo de inteligencia artificial se debe utilizar y cuál es la consulta que se desea obtener.

El payload contiene tres elementos principales:
- El nombre del modelo (`model`), que en este caso es "qwen2.5:3b-instruct", el cual es un modelo específico para responder preguntas cuando le proporcionas una instrucción.
- La pregunta o instrucción específica que se quiere resolver ("prompt"), que aquí pide explicar qué es una lista en Python con un ejemplo, y solicita la respuesta en español.
- Una opción llamada `stream` que está establecida como `False`, lo que indica al servidor que no necesita devolver información parcial mientras se procesa la solicitud.

La respuesta del servidor se recibe en formato JSON. El código luego imprime la parte de la respuesta que contiene el resultado de la consulta, es decir, la explicación sobre las listas en Python en español, generada por el modelo de inteligencia artificial especificado.

`018-ejecutar ollama desde python.py`

```python
import requests
import json

url = "http://localhost:11434/api/generate"

payload = {
    "model": "qwen2.5:3b-instruct",
    "prompt": "Explica qué es una lista en Python con un ejemplo. Responde en español.",
    "stream": False
}

response = requests.post(url, json=payload)

data = response.json()
print(data["response"])
```

### clientes
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es un archivo CSV (Valores Separados por Comas) que contiene información detallada sobre varios clientes. Cada línea del archivo representa los datos de un cliente diferente, y la primera línea enumera las diferentes columnas o campos que se utilizarán en el archivo.

El formato CSV es muy útil porque permite almacenar y compartir fácilmente grandes cantidades de datos estructurados. En este caso, cada cliente tiene información como su ID, nombre completo, correo electrónico, teléfono, dirección completa, ciudad, provincia, código postal, empresa y NIF (Número de Identificación Fiscal en España).

La importancia del formato CSV radica en que es sencillo leer y escribir, lo que facilita el trabajo con datos en programas de hojas de cálculo o en lenguajes de programación como Python. Esto permite a los desarrolladores realizar operaciones como filtrar registros específicos, buscar ciertos patrones de texto (como direcciones postales) o validar formatos de números de teléfono y NIF.

En resumen, este archivo CSV es una base de datos simplificada que se puede utilizar para aprender cómo manipular archivos de texto en programas de programación.

`clientes.csv`

```
id,nombre,apellidos,correo,telefono,direccion,ciudad,provincia,codigo_postal,empresa,NIF
1,Laura,García López,laura.garcia@example.com,612345678,Calle Mayor 12,Valencia,Valencia,46001,TecnoSol S.L.,B12345678
2,Miguel,Pérez Sánchez,miguel.perez@example.com,678901234,Avenida del Puerto 45,Madrid,Madrid,28002,InnovaWeb S.A.,A87654321
3,Ana,Martínez Ruiz,ana.martinez@example.com,634567890,Plaza España 3,Sevilla,Sevilla,41005,Servicon S.L.,B11223344
4,Carlos,Hernández Torres,carlos.hernandez@example.com,699112233,Calle Gran Vía 78,Barcelona,Barcelona,08010,SoftMarket S.L.,B99887766
5,Elena,Romero Díaz,elena.romero@example.com,622334455,Calle San Vicente 5,Zaragoza,Zaragoza,50004,ConsultingPro S.L.,B44556677
6,Javier,Navarro Gómez,javier.navarro@example.com,645667788,Avenida Constitución 23,Murcia,Murcia,30008,DataPlus S.A.,A33445566
7,María,Fuentes Ortega,maria.fuentes@example.com,633889900,Calle Sol 18,Málaga,Málaga,29007,Mercaplus S.L.,B22114455
8,Sergio,Rey Delgado,sergio.rey@example.com,671223344,Calle Libertad 9,Alicante,Alicante,03003,Logística Express S.L.,B77889900
9,Isabel,Vidal Castro,isabel.vidal@example.com,699554433,Paseo Colón 14,Bilbao,Bizkaia,48009,EcoEner S.A.,A99001122
10,Pablo,Santos Molina,pablo.santos@example.com,611223344,Calle Real 2,Valladolid,Valladolid,47003,Formática S.L.,B66778899
```

### Actividades propuestas

### Actividades Propuestas:

#### **Actividad 1: Acceso y Manipulación de Cadenas**
**Descripción:** Los estudiantes deberán acceder a una cadena dada para extraer su primer carácter, último carácter e imprimir la longitud total. Se pretende que aprendan sobre indexado en cadenas y uso de funciones como `len()`.

#### **Actividad 2: Recorrido y Visualización de Cadenas**
**Descripción:** Los estudiantes deben recorrer una cadena usando bucles para imprimir cada caracter individualmente, lo que les permitirá entender la estructura secuencial de las cadenas en Python.

#### **Actividad 3: Split y Join de Cadenas CSV**
**Descripción:** Se propone a los alumnos separar un texto CSV (como "uno,dos,tres") en sus componentes individuales usando `split()`, e invertir el proceso con `join()` para formar nuevamente la cadena, enseñándoles cómo manejar datos estructurados.

#### **Actividad 4: Lectura y Procesamiento de Archivos CSV**
**Descripción:** Los estudiantes leerán un archivo CSV proporcionado (clientes.csv) utilizando funciones como `readlines()`, separar cada línea en sus componentes con `split()` y guardar los resultados en una lista o matriz multidimensional.

#### **Actividad 5: Reemplazo de Texto en Cadenas**
**Descripción:** Se les pedirá a los alumnos que realicen un reemplazo de texto dentro de cadenas utilizando la función `replace()`, lo cual permite familiarizarse con el manejo de caracteres y subcadenas.

#### **Actividad 6: Limpieza de Texto**
**Descripción:** Los estudiantes deben eliminar caracteres especiales o inútiles (como salto de línea `\n`) dentro de una cadena, utilizando `replace()`, para aprender a manipular texto antes de su uso en otros contextos.

#### **Actividad 7: Introducción a Expresiones Regulares**
**Descripción:** Los estudiantes trabajarán con expresiones regulares básicas para validar formatos como direcciones de correo electrónico y direcciones postales, lo que ayuda a entender la sintaxis y utilidades de `re.match()`.

#### **Actividad 8: Validación Compleja con Expresiones Regulares**
**Descripción:** Los alumnos validarán cadenas más complejas utilizando expresiones regulares para comprobar formatos específicos (como direcciones postales), profundizando en las capacidades de validación y filtrado de texto.

#### **Actividad 9: Integración de Datos CSV con Procesamiento**
**Descripción:** Se les solicitará a los estudiantes que integren la lectura del archivo CSV, el procesamiento de cada línea separada por `split()`, y su almacenamiento en una estructura adecuada (matriz o lista) para preparar datos para uso posterior.


<a id="colecciones-listas-conjuntos-y-diccionarios"></a>
## Colecciones Listas, Conjuntos y Diccionarios

### Introducción a los ejercicios

Esta carpeta contiene una serie de ejercicios diseñados para ayudarte a entender y practicar el uso de estructuras de datos como listas, tuplas, diccionarios en Python. Los ejemplos van desde la creación básica de estas estructuras hasta su combinación compleja, pasando por la manipulación de archivos JSON y la lectura de argumentos desde la línea de comandos. A través de estos ejercicios, aprenderás a organizar datos de manera eficiente, acceder a ellos de formas diversas y utilizar bibliotecas adicionales como argparse para manejar entradas más complejas en tus programas.

### diccionarios
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código te enseña las diferencias básicas entre listas y tuplas en Python. Primero, se crea una lista llamada `lista` que contiene tres elementos: "platano", "manzana" y "fresa". Luego, accedes a los primeros dos elementos de la lista para mostrar cómo obtener un elemento específico por su posición (índice).

Después, el código muestra cómo crear una tupla con los mismos elementos. Una tupla es similar a una lista, pero está inmutable, lo que significa que no puedes cambiar sus valores después de crearla.

El código también demuestra cómo acceder a los elementos de la tupla por su índice, igual que se hace con las listas. En ambos casos, el primer elemento tiene el índice 0 y el segundo tiene el índice 1.

Esta explicación es importante para entender las diferencias fundamentales entre listas y tuplas en Python, ya que cada una tiene usos específicos dependiendo de si necesitas un conjunto de datos mutable o inmutable.

`001-diccionarios.py`

```python
# Repaso de listas y tuplas
lista = ["platano","manzana","fresa"]

lista[0] # platano
lista[1] # manzana

tupla = ("platano","manzana","fresa")

tupla[0] # platano
tupla[1] # manzana 
```

### diccionarios ahora si
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código muestra cómo se puede representar la misma información utilizando dos estructuras diferentes en Python: una lista y un diccionario. Inicialmente, la información personal de una persona (nombre, apellidos, correo electrónico y edad) está almacenada como una lista. Cada posición en esta lista corresponde a una pieza específica de información.

Luego, el código redefine esa misma información utilizando un diccionario. En lugar de guardar los datos en una secuencia lineal sin contexto adicional (como hace la lista), ahora cada dato se asocia con una clave que describe su significado: "nombre", "apellidos", "correo" y "edad". Esto permite acceder a cualquier información específica fácilmente, como el correo electrónico de la persona, simplemente haciendo referencia a la clave correspondiente en lugar de recordar la posición exacta en una lista.

La importancia de esta transformación radica en que los diccionarios proporcionan un acceso más intuitivo y directo a la información, facilitando así tareas como actualizar datos individuales o añadir nuevas entradas sin necesidad de reorganizar toda la estructura.

`002-diccionarios ahora si.py`

```python
# Esto sigue siendo una lista
persona = [
  "Jose Vicente",
  "Carratalá Sanchis",
  "info@jocarsa.com",
  47
]

# Ahora en formato diccionario

persona = {
	"nombre":"Jose Vicente",
  "apellidos":"Carratalá Sanchis",
  "correo":"info@jocarsa.com",
  "edad":47
}
```

### lista en diccionario
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código crea un diccionario en Python llamado `persona`. Un diccionario es una estructura de datos que permite almacenar información similar a cómo lo harías con un libro de direcciones. En este caso, el diccionario contiene detalles sobre una persona específica, incluyendo su nombre, apellidos, correo electrónico y edad. Lo interesante aquí es que también almacena dos números telefónicos en una lista dentro del diccionario. Esto muestra cómo los diccionarios pueden contener varios tipos de datos, incluso otras estructuras como listas. Es importante porque permite organizar información compleja de manera muy clara y accesible para cuando se necesite acceder a ella más tarde.

`003-lista en diccionario.py`

```python
persona = {
	"nombre":"Jose Vicente",
  "apellidos":"Carratalá Sanchis",
  "correo":"info@jocarsa.com",
  "edad":47,
  "telefonos":[
  	96345678,
    87654321
  ]
}
```

### lista de diccionarios en diccionario
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código en Python crea un diccionario llamado `persona` que almacena información personal sobre una persona, incluyendo detalles como su nombre, apellidos y correo electrónico. Lo interesante aquí es que también contiene una lista dentro del diccionario llamada `telefonos`, donde cada elemento de la lista es a su vez un diccionario con los tipos de teléfono (fijo o móvil) y sus números correspondientes.

El código imprime el contenido completo del diccionario `persona` utilizando la función `print()`. Esto muestra cómo se pueden estructurar datos complejos en Python, combinando diferentes tipos de colecciones como listas y diccionarios para representar información más detallada sobre un objeto (en este caso, una persona).

Esta forma de organizar datos es útil cuando necesitas almacenar y acceder a información que tiene relaciones jerárquicas o estructuras más complejas. Es importante entender cómo manipular y acceder a estos tipos de estructuras para poder trabajar con bases de datos y aplicaciones más avanzadas en el futuro.

`004-lista de diccionarios en diccionario.py`

```python
persona = {
	"nombre":"Jose Vicente",
  "apellidos":"Carratalá Sanchis",
  "correo":"info@jocarsa.com",
  "edad":47,
  "telefonos":[
  	{	
      "tipo":"fijo",
    	"número":96123455
    },
    {	
      "tipo":"movil",
    	"número":65456546
    }
  ]
}

print(persona)
```

### no argumentos archivo
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código en Python solicita al usuario que ingrese su edad, realiza un cálculo sencillo y muestra el resultado. Primero, el programa pregunta "Dime tu edad:" y espera a que el usuario teclee una respuesta, la cual se guarda en la variable `edad`. Luego, convierte el valor de texto (que es lo que devuelve la función `input()`) a un número entero usando la función `int()` y almacena este nuevo número en la variable `entero`. Finalmente, multiplica ese número por 2 para obtener el doble de la edad del usuario y muestra este resultado con la función `print(doble)`. Este código es importante porque demuestra cómo interactuar con los usuarios (mediante `input()`), convertir tipos de datos (de texto a entero) y realizar operaciones matemáticas básicas.

`005-no argumentos archivo.py`

```python
edad = input("Dime tu edad: ")
entero = int(edad)
doble = entero*2
print(doble)
```

### ahora con argumentos
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es muy simple y directo. La función `sys.argv` se utiliza para acceder a los argumentos que el usuario proporciona cuando ejecuta un script de Python desde la línea de comandos. En este caso, al importar el módulo `sys`, el programa puede utilizar `sys.argv` para obtener una lista que contiene el nombre del archivo en ejecución como primer elemento y cualquier argumento adicional que se le pase durante su ejecución.

El código imprime esta lista, lo que permite ver exactamente qué argumentos fueron proporcionados al script. Esto es útil cuando estás trabajando en la línea de comandos y necesitas verificar que los argumentos están siendo pasados correctamente a tu programa antes de procesarlos más adelante en el código.

Es importante entender cómo pasar y recibir argumentos desde la línea de comandos porque te permite hacer que tus programas sean más flexibles y puedan manipular diferentes tipos de datos o realizar distintas tareas basándose en los parámetros que reciben al ser ejecutados.

`006-ahora con argumentos.py`

```python
import sys

print(sys.argv)
```

### doble edad con argumentos
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código es una pequeña aplicación en Python que toma un número como entrada desde la línea de comandos y luego muestra el doble de ese número. Veamos cómo funciona:

1. El programa empieza importando el módulo `sys`, que le permite acceder a variables y funciones mantenidas por el intérprete de Python.
2. Luego, obtiene los argumentos pasados al programa desde la línea de comandos usando `sys.argv`. Este es un array donde el primer elemento (`sys.argv[0]`) siempre es el nombre del script que se está ejecutando y cualquier otro elemento representa un argumento pasado por el usuario.
3. El código toma el segundo argumento (`argumentos[1]`), que espera sea una representación de la edad como cadena de texto, y lo convierte a entero con `int(edad)`.
4. Finalmente, multiplica esta edad en formato entero por 2 para obtener el doble de la edad y lo imprime en pantalla usando `print(doble)`.

Este tipo de script es útil cuando necesitas procesar datos que son proporcionados al ejecutar tu programa desde línea de comandos, permitiendo así que otros usuarios o scripts interactúen con tus aplicaciones de manera más flexible.

`007-doble edad con argumentos.py`

```python
import sys

argumentos = sys.argv
edad = argumentos[1]
entero = int(edad)
doble = entero*2
print(doble)
```

### ejemplo con dos argumentos
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código es un ejemplo simple de cómo usar los argumentos pasados desde la línea de comandos en Python. Lo que hace este script es tomar dos argumentos: el nombre y la edad del usuario proporcionada al ejecutar el programa, y luego realiza una operación sencilla con ellos.

Primero, el código importa el módulo `sys`, que proporciona acceso a algunas variables usadas o mantenidas por el intérprete y a funciones que interactúan con el intérprete. Luego, obtiene los argumentos pasados al script desde la línea de comandos usando `sys.argv`. Los argumentos se guardan en una lista llamada `argumentos`, donde el primer elemento (índice 0) es siempre el nombre del archivo que está siendo ejecutado y el resto son los argumentos proporcionados.

El código asume que el segundo argumento (`argumentos[1]`) es el nombre de la persona y el tercer argumento (`argumentos[2]`) es su edad. La edad se convierte a un número entero para poder realizar cálculos, en este caso, duplicarla. Finalmente, imprime un mensaje que saluda al usuario y menciona su edad duplicada.

Este tipo de script es útil cuando deseas interactuar con el programa desde la línea de comandos proporcionando datos específicos, lo cual puede ser muy práctico para automatización o scripts de línea de comando.

`008-ejemplo con dos argumentos.py`

```python
import sys

argumentos = sys.argv
nombre = argumentos[1]
edad = argumentos[2]
entero = int(edad)
doble = entero*2
print("Hola, "+nombre+" tienes "+str(doble)+" años")
```

### argumentos con nombre
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es un ejemplo básico de cómo usar el módulo `argparse` en Python para manejar argumentos que se pasan a un programa desde la línea de comandos. La función principal aquí es permitir que los usuarios proporcionen información adicional cuando ejecutan el script, como su nombre y apellidos.

El código crea primero un objeto `ArgumentParser`, que actúa como una configuración para recoger y validar argumentos. Luego, se añaden dos argumentos específicos: `--nombre` y `--apellidos`. Estos argumentos permiten a los usuarios especificar valores cuando ejecutan el script desde la línea de comandos, por ejemplo:

```
python script.py --nombre Juan --apellidos Perez
```

Finalmente, se obtienen los argumentos proporcionados con `parser.parse_args()`, que retorna un objeto que contiene los valores de los argumentos. El código convierte este objeto en un diccionario utilizando la función `vars()` y lo imprime para mostrar cómo se han almacenado estos datos.

Este tipo de manejo de argumentos es importante porque permite a las aplicaciones ser más flexibles, permitiendo a los usuarios personalizar el comportamiento del programa según sus necesidades sin modificar el código fuente.

`009-argumentos con nombre.py`

```python
import argparse

parser = argparse.ArgumentParser()
parser.add_argument("--nombre")
parser.add_argument("--apellidos")

args = parser.parse_args()

diccionario = vars(args)
print(diccionario)
```

### acceder a diccionario
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código en Python crea un diccionario llamado `persona` que contiene información personal sobre una persona, incluyendo su nombre, apellidos, correo electrónico y edad. Lo interesante es que también almacena dos teléfonos en una lista dentro del diccionario: uno fijo y otro móvil. Cada teléfono está representado como un pequeño diccionario con sus propias claves `"tipo"` para el tipo de teléfono y `"número"` para el número telefónico.

El código imprime primero toda la información almacenada en `persona`, mostrando así todos los detalles del diccionario. Luego, accede específicamente a uno de los números telefónicos: imprime el número fijo utilizando una combinación de índices y claves dentro del diccionario. Esto es importante porque demuestra cómo se pueden almacenar estructuras complejas, como listas de diccionarios, dentro de un diccionario principal para organizar datos de manera eficiente.

Esta forma de estructurar los datos permite tener una representación más realista y detallada de la información personal, siendo útil en aplicaciones donde es necesario manejar muchos detalles acerca de cada usuario o entidad.

`011-acceder a diccionario.py`

```python
persona = {
	"nombre":"Jose Vicente",
  "apellidos":"Carratalá Sanchis",
  "correo":"info@jocarsa.com",
  "edad":47,
  "telefonos":[
  	{	
      "tipo":"fijo",
    	"número":96123455
    },
    {	
      "tipo":"movil",
    	"número":65456546
    }
  ]
}

print(persona)
print(persona["telefonos"][0]["número"])
```

### diagrama
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código JSON representa la estructura de un diagrama que muestra cómo se relacionan diferentes elementos en una aplicación o sistema. El archivo contiene dos tipos principales de información: formas y flechas.

Las **formas** son objetos dentro del array `formas` que describen los distintos componentes visuales del diagrama. Cada forma tiene atributos como un identificador único (`id`), el tipo de figura (por ejemplo, rectángulo o círculo), posición (`left`, `top`), y texto que se muestra dentro de la forma.

Las **flechas** están en el array `flechas` y describen las conexiones entre diferentes formas. Cada flecha tiene un identificador inicial (`idInicio`) y uno final (`idFin`), lo que indica desde qué forma parte la flecha hasta cuál llega, además de su tipo (en este caso todas son simples).

Este tipo de representación es común en diagramas de flujo o secuencias donde se muestran las relaciones entre diferentes elementos del sistema. Es importante para entender cómo interactúan los componentes de una aplicación y cómo fluye la información a través de ellos.

`diagrama.json`

```json
{
  "formas": [
    {
      "id": "forma-1",
      "tipo": "rectangle",
      "left": "389.188px",
      "top": "312px",
      "width": "",
      "height": "",
      "texto": "programa"
    },
    {
      "id": "forma-2",
      "tipo": "circle",
      "left": "356.135px",
      "top": "187px",
      "width": "",
      "height": "",
      "texto": "in"
    },
    {
      "id": "forma-3",
      "tipo": "circle",
      "left": "498.521px",
      "top": "187.333px",
      "width": "",
      "height": "",
      "texto": "out"
    },
    {
      "id": "forma-4",
      "tipo": "rectangle",
      "left": "378.521px",
      "top": "49.3229px",
      "width": "",
      "height": "",
      "texto": "html"
    }
  ],
  "flechas": [
    {
      "idInicio": "forma-2",
      "idFin": "forma-1",
      "tipo": "simple"
    },
    {
      "idInicio": "forma-1",
      "idFin": "forma-3",
      "tipo": "simple"
    },
    {
      "idInicio": "forma-4",
      "idFin": "forma-2",
      "tipo": "simple"
    },
    {
      "idInicio": "forma-3",
      "idFin": "forma-4",
      "tipo": "simple"
    }
  ]
}
```

### Actividades propuestas

### Actividad 1: Introducción a Listas y Diccionarios

**Descripción:** Los estudiantes deben convertir una lista simple en un diccionario, aprendiendo cómo organizar datos de forma más estructurada. Se espera que comprendan la diferencia entre listas y diccionarios.

---

### Actividad 2: Creación de Datos Personales con Diccionarios

**Descripción:** Los estudiantes deben crear un diccionario que almacene información personal (nombre, apellidos, correo electrónico, edad) para varios individuos. Se espera que aprendan a estructurar datos complejos utilizando diccionarios.

---

### Actividad 3: Integración de Listas dentro de Diccionarios

**Descripción:** Los estudiantes deben integrar listas dentro de un diccionario para almacenar información adicional como teléfonos móviles y fijos. Se espera que aprendan a manejar datos jerárquicos.

---

### Actividad 4: Uso de Argumentos con Python

**Descripción:** Los estudiantes deben utilizar argumentos del sistema para procesar la edad del usuario e imprimir su doble, utilizando el módulo `sys`. Se espera que aprendan cómo pasar y recibir información en scripts Python.

---

### Actividad 5: Manipulación Avanzada de Diccionarios

**Descripción:** Los estudiantes deben acceder a datos anidados dentro de diccionarios (como teléfonos) e imprimirlos. Se espera que dominen la manipulación y acceso a estructuras de datos complejas.

---

### Actividad 6: Uso del Módulo argparse para Argumentos

**Descripción:** Los estudiantes deben implementar el uso del módulo `argparse` para recibir argumentos con nombre (como --nombre y --apellidos) y almacenarlos en un diccionario. Se espera que comprendan cómo estructurar interfaces de línea de comandos avanzadas.

---

### Actividad 7: Integración de Listas de Diccionarios

**Descripción:** Los estudiantes deben integrar listas de diccionarios dentro de un diccionario principal para representar datos complejos (como múltiples contactos con teléfonos). Se espera que aprendan a manejar estructuras de datos anidadas.

---

### Actividad 8: Creación de Programa Interactivo

**Descripción:** Los estudiantes deben crear un programa interactivo que solicite al usuario información personal y la guarde en un diccionario. Luego, el programa debe permitir al usuario acceder a esta información. Se espera que aprendan a manejar entradas interactivas del usuario.

---

### Actividad 9: Análisis de Estructuras Complejas

**Descripción:** Los estudiantes deben analizar e implementar un diccionario anidado complejo (como el proporcionado en los ejemplos), y realizar operaciones como imprimir la edad o acceder a datos teléfonicos específicos. Se espera que comprendan cómo trabajar con estructuras de datos multidimensionales.

---

### Actividad 10: Integración Completa de Diccionarios

**Descripción:** Los estudiantes deben integrar todas las habilidades aprendidas en una actividad práctica, creando un programa que permite al usuario almacenar y acceder a información personal compleja utilizando diccionarios y listas. Se espera que demuestren su capacidad para manejar datos estructurados de manera eficiente.

---

Estas actividades están diseñadas para ayudar a los estudiantes a dominar la manipulación de estructuras de datos en Python, desde listas simples hasta diccionarios anidados complejos y argumentos del sistema.


<a id="operaciones-agregadas-filtrado-reduccion-y-recoleccion"></a>
## Operaciones agregadas filtrado, reducción y recolección

### Introducción a los ejercicios

En esta carpeta de ejercicios, trabajaremos con la estructura de datos conocida como conjunto en Python. Los conjuntos son colecciones desordenadas y sin duplicados que nos permiten realizar operaciones eficientes de agregación, filtrado y recolección de elementos. A lo largo de los 14 ejercicios propuestos, empezarás con la creación básica de conjuntos y su comprobación de igualdad hasta llegar a la implementación de un generador de sudokus completos utilizando técnicas como fuerza bruta y backtracking.

Estos ejercicios te ayudarán a practicar la manipulación de datos sin duplicados, el uso de operaciones matemáticas con conjuntos (como intersecciones, uniones), la creación de aplicaciones web simples con Flask para mostrar resultados y técnicas avanzadas como resolución de problemas mediante backtracking.

### conjuntos
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es una introducción básica a los conjuntos en Python. Primero, se crea un conjunto llamado `frutas` que contiene tres elementos: "manzanas", "peras" y "platanos". Los conjuntos son estructuras de datos únicas porque no permiten duplicados, lo que significa que cada elemento dentro del conjunto es único.

Después, el código imprime el contenido del conjunto utilizando `print(frutas)`. Aunque intentes agregar los mismos elementos al conjunto repetidas veces, solo se mostrarán una vez. Luego, se utiliza la función `type()` para imprimir el tipo de dato que es `frutas`, confirmando así que es un conjunto (`set` en Python). Esta línea te ayuda a entender claramente qué tipo de estructura de datos estás trabajando.

`001-conjuntos.py`

```python
frutas = {"manzanas","peras","platanos"}
print(frutas)
print(type(frutas))
```

### no repeticiones
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código muestra cómo trabajar con conjuntos en Python, que son una estructura de datos especial para almacenar elementos únicos. En el código, se crea un conjunto llamado `frutas` que contiene cuatro elementos: "manzanas", "peras" y "platanos". Nota que intentamos añadir "manzanas" dos veces, pero los conjuntos no permiten duplicados, así que solo se almacena una vez.

Cuando imprimes el conjunto `frutas`, obtienes la salida `{ 'manzanas', 'peras', 'platanos' }` en algún orden aleatorio porque los conjuntos en Python no mantienen un orden específico para sus elementos. Finalmente, se utiliza `type(frutas)` para mostrar que el tipo de dato es `<class 'set'>`, lo cual confirma que estamos trabajando con una estructura de datos conjunto (o "set" en inglés).

`002-no repeticiones.py`

```python
# No se aplica el concepto de orden
# No se pueden reordenar
# No admiten duplicados

frutas = {"manzanas","peras","platanos","manzanas"}
print(frutas)
print(type(frutas))
```

### dos conjuntos
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código está trabajando con conjuntos en Python, que son una estructura de datos que almacena elementos únicos y no ordenados. En el ejemplo, se crean dos conjuntos llamados `frutas1` y `frutas2`, ambos conteniendo las mismas frutas: manzanas, peras y plátanos, aunque en diferentes órdenes.

El código compara estos dos conjuntos usando la expresión `if frutas1 == frutas2:`. En Python, cuando se comparan dos conjuntos con el operador de igualdad (`==`), lo que se evalúa es si ambos contienen exactamente los mismos elementos, sin importar el orden en que están colocados dentro del conjunto.

Si ambos conjuntos son iguales (es decir, tienen los mismos elementos), el programa imprime "Son iguales". De lo contrario, imprimirá "Son diferentes".

Este código ilustra la naturaleza de los conjuntos en Python: no importa el orden en que se introducen los elementos; lo importante es si contienen exactamente los mismos elementos. Esto puede ser útil cuando necesitas comprobar si dos colecciones tienen contenido idéntico sin preocuparte por su estructura específica o secuencia.

`003-dos conjuntos.py`

```python
# No se aplica el concepto de orden
# No se pueden reordenar
# No admiten duplicados

frutas1 = {"manzanas","peras","platanos"}

frutas2 = {"peras","platanos","manzanas"}

if frutas1 == frutas2:
  print("Son iguales")
else:
  print("Son diferentes")
```

### comprobacion numeros
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código en Python comprueba si dos conjuntos tienen los mismos elementos. En este caso, `patron` y `prueba` son ambos conjuntos que contienen números del 1 al 9. El programa compara estos dos conjuntos utilizando el operador `==`. Si ambos conjuntos contienen exactamente los mismos elementos (aunque en diferentes órdenes), la condición será verdadera y se imprimirá "Se cumple la condicion". En caso contrario, si alguno de los números está ausente o hay algún número extra, se imprime "no se cumple la condición".

Es importante entender que los conjuntos en Python no mantienen un orden específico y no permiten duplicados, lo que hace que este tipo de comparación sea útil para verificar la igualdad de elementos sin preocuparse por el orden. Esto es especialmente relevante cuando trabajas con datos donde solo importa qué elementos están presentes, no su posición o repetición.

`004-comprobacion numeros.py`

```python
patron = {1,2,3,4,5,6,7,8,9}

prueba = {6,4,3,5,7,8,2,1,9}

if prueba == patron:
  print("Se cumple la condicion")
else:
  print("no se cumple la condición")
```

### aleatorio
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código en Python realiza una serie de operaciones con conjuntos y listas. En primer lugar, importa el módulo `random` para generar números aleatorios. Luego, define un conjunto llamado `patron` que contiene los números del 1 al 9.

El código crea una lista vacía llamada `lista`, a la cual añade nueve números enteros generados aleatoriamente entre el 1 y el 9 usando un bucle `for`. Luego imprime tanto el conjunto `patron` como la lista recién creada. A continuación, convierte esta lista en un conjunto llamado `conjunto`.

Finalmente, compara este nuevo conjunto con el conjunto `patron` para verificar si son iguales. Si ambos conjuntos tienen exactamente los mismos elementos (sin importar su orden), imprime "El conjunto es correcto". De lo contrario, muestra "El conjunto no es correcto".

Este código es útil para entender cómo trabajar con estructuras de datos en Python y cómo se pueden realizar comparaciones entre diferentes tipos de colecciones como listas y conjuntos.

`005-aleatorio.py`

```python
import random

patron = {1,2,3,4,5,6,7,8,9}

lista = []
for i in range(1,10):
	lista.append(random.randint(1,9))
print(patron)
print(lista)
conjunto = set(lista)
print(conjunto)

if conjunto == patron:
  print("El conjunto es correcto")
else:
  print("El conjunto no es correcto")
```

### fuerza bruta
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código está diseñado para generar una lista aleatoria de números del 1 al 9 y verificar si los elementos de esa lista forman un conjunto que contiene exactamente todos los números del 1 al 9 sin repeticiones. El programa utiliza un bucle infinito (`while True`) para seguir generando listas hasta que encuentre una que cumpla con la condición deseada.

Dentro del bucle, se genera una lista de nueve elementos aleatorios utilizando el módulo `random`. Luego, convierte esta lista en un conjunto (set) para eliminar cualquier duplicado y asegurarse de que cada número sea único. Si el conjunto resultante es igual al conjunto predefinido `patron` (que contiene los números del 1 al 9), el programa imprime una confirmación y rompe el bucle, finalizando la ejecución.

Este tipo de enfoque se conoce como "fuerza bruta", ya que el código simplemente intenta diferentes posibilidades hasta encontrar la solución correcta. En este caso, aunque es poco probable debido a las limitaciones del conjunto `patron`, podría llevar mucho tiempo si los números generados no forman un conjunto exacto de los números requeridos en el orden deseado o sin duplicar ninguno. Sin embargo, dado que los números son seleccionados aleatoriamente y deben ser únicos (al convertir la lista a un conjunto), generalmente se espera que encuentre una solución bastante rápido.

`006-fuerza bruta.py`

```python
import random

patron = {1,2,3,4,5,6,7,8,9}

while True:
  lista = []
  for i in range(1,10):
    lista.append(random.randint(1,9))
    
  conjunto = set(lista)
  print(lista)
  
  if conjunto == patron:
    print("El conjunto es correcto")
    print(conjunto)
    print(lista)
    break # Fuerzo la finalizazión del bucle infinito
    

  
```

### elimino un numero
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código en Python busca generar una lista aleatoria que contiene los números del 1 al 9 sin repeticiones, y luego realiza una serie de operaciones sobre ella. Primero, el programa crea un conjunto llamado `patron` que incluye todos los dígitos del 1 al 9. Luego entra en un bucle infinito (`while True`) donde genera continuamente listas aleatorias hasta encontrar una lista cuyos elementos forman exactamente ese conjunto `patron`. Cuando encuentra tal lista, imprime que el conjunto es correcto y muestra tanto la lista como su versión de conjunto.

Una vez se cumple esta condición, el código sigue eliminando un número al azar de la lista. Esto se hace seleccionando aleatoriamente uno de los índices en la lista (del 1 al 9) e intercambiándolo por un carácter "_" para simbolizar que ese número ha sido "eliminado". Finalmente, imprime la lista modificada y sale del bucle con `break`.

Este código es útil para aprender sobre estructuras de datos como listas y conjuntos en Python, entender cómo generar números aleatorios y cómo operar con índices en una lista. También muestra cómo comprobar si dos conjuntos son iguales y cómo realizar modificaciones en las estructuras de datos después de algunos filtros condicionales.

`007-elimino un numero.py`

```python
import random

patron = {1,2,3,4,5,6,7,8,9}

while True:
  lista = []
  for i in range(1,10):
    lista.append(random.randint(1,9))
  conjunto = set(lista)
  if conjunto == patron:
    print("El conjunto es correcto")
    print(conjunto)
    print(lista)
    # Ahora elimino un numero
    indice = random.randint(1,9)
    lista[indice] = "_"
    print(lista)
    break # Fuerzo la finalizazión del bucle infinito
    

  
```

### elimino X numeros
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código es una pequeña aplicación que genera listas aleatorias de números entre 1 y 9, con el objetivo de verificar si dicha lista contiene todos los números del 1 al 9 sin repeticiones. En primer lugar, se define un conjunto llamado `patron` que contiene los números del 1 al 9.

El código entra en un bucle infinito (`while True`) que genera una lista aleatoria de nueve elementos, donde cada elemento es un número entre 1 y 9. Luego convierte esta lista en un conjunto (que elimina duplicados) y comprueba si este conjunto coincide con el `patron` definido al principio. Si ambos son iguales, imprime un mensaje indicando que la lista generada contiene exactamente los números del 1 al 9 sin repeticiones.

Una vez se ha encontrado una lista que cumple esta condición, el código continúa modificándola aleatoriamente eliminando algunos de sus elementos. Esto se hace seleccionando cinco índices al azar y reemplazando los valores en esos índices por un guion (`_`), lo cual simula la eliminación de números.

Finalmente, después de realizar estas modificaciones a la lista, el bucle termina con `break`, interrumpiendo así el ciclo infinito y finalizando la ejecución del programa. Este código es útil para entender cómo trabajar con listas y conjuntos en Python, así como para practicar generación aleatoria y manipulación de estructuras de datos.

`008-elimino X numeros.py`

```python
import random

patron = {1,2,3,4,5,6,7,8,9}

while True:
  lista = []
  for i in range(1,10):
    lista.append(random.randint(1,9))
  conjunto = set(lista)
  if conjunto == patron:
    print("El conjunto es correcto")
    print(conjunto)
    print(lista)
    for i in range(1,5):
      # Ahora elimino un numero
      indice = random.randint(0,8)
      lista[indice] = "_" # Escoge un indice al azar y reemplaza su valor
    print(lista)
    break # Fuerzo la finalizazión del bucle infinito
    

  
```

### repito 9 veces
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código Python se centra en crear una lista de números aleatorios y luego verificar si los números dentro de esa lista forman un conjunto específico. El objetivo es generar una lista que contenga exactamente los números del 1 al 9 sin repeticiones, lo cual es importante para entender cómo trabajar con conjuntos y listas.

El código comienza importando el módulo `random` para poder usar funciones relacionadas a la generación de números aleatorios. Luego, se define un conjunto llamado `patron` que contiene los números del 1 al 9. Dentro de un bucle for, que itera desde 1 hasta 10 (pero no incluye el 10), se inicia un bucle while infinito (`while True`) para generar listas aleatorias hasta que una lista cumple con la condición deseada.

En cada iteración del bucle while, se crea una nueva lista llamada `lista` que contiene nueve números generados al azar entre 1 y 9. Luego, esta lista se convierte en un conjunto (`conjunto = set(lista)`), para eliminar cualquier duplicado y solo quedarse con los valores únicos. Si el conjunto resultante es igual al conjunto `patron`, lo que significa que contiene exactamente los números del 1 al 9 sin repeticiones, entonces imprime un mensaje indicando que la lista generada cumple con las condiciones esperadas y muestra tanto el conjunto como la lista.

Este ejercicio ayuda a comprender cómo trabajar con estructuras de datos en Python, específicamente listas y conjuntos, así como entender el uso de bucles anidados para realizar operaciones más complejas.

`009-repito 9 veces.py`

```python
import random

patron = {1,2,3,4,5,6,7,8,9}

for celda in range(1,10):
  while True:
    lista = []
    for i in range(1,10):
      lista.append(random.randint(1,9))
    conjunto = set(lista)
    if conjunto == patron:
      print("El conjunto es correcto")
      print(conjunto)
      print(lista)
      break # Fuerzo la finalizazión del bucle infinito
    

  
```

### matriz bidimensional
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código genera una matriz bidimensional (también conocida como tabla o array 2D) que simula las propiedades de una fila de un cuadro Sudoku. En este caso, el objetivo es crear una lista llamada `sudoku` que contiene nueve listas internas, cada una con nueve números del 1 al 9 sin repetirse.

El código comienza importando el módulo `random`, que proporciona funciones para trabajar con generación de números aleatorios. Luego define un conjunto llamado `patron` que incluye los números del 1 al 9, lo cual representa todos los números posibles en una fila o columna de Sudoku.

El bucle `for celda in range(1,10):` se encarga de repetir el proceso 9 veces para crear 9 filas. Dentro de este bucle, hay un bucle infinito (`while True:`) que genera listas aleatorias hasta que una lista cumple con la condición requerida.

Dentro del bucle infinito, se crea una lista `lista` de nueve elementos, cada uno generado aleatoriamente entre 1 y 9. A continuación, esta lista se convierte en un conjunto llamado `conjunto`, lo que elimina cualquier duplicidad. Si el conjunto resultante es igual al conjunto `patron`, significa que la lista no tiene repeticiones y cumple con los requisitos de una fila de Sudoku. En ese caso, se agrega a la matriz principal `sudoku` y se rompe el bucle infinito para pasar a la siguiente iteración.

Finalmente, después del ciclo for, se imprime en pantalla la matriz completa generada `sudoku`. Este código es importante porque enseña cómo generar listas aleatorias con restricciones específicas y cómo utilizar conjuntos para verificar si una lista cumple ciertas condiciones sin repeticiones.

`010-matriz bidimensional.py`

```python
import random

patron = {1,2,3,4,5,6,7,8,9}
sudoku = []
for celda in range(1,10):
  while True:
    lista = []
    for i in range(1,10):
      lista.append(random.randint(1,9))
    conjunto = set(lista)
    if conjunto == patron:
      sudoku.append(lista)
      break # Fuerzo la finalizazión del bucle infinito
    
print(sudoku)
  
```

### flask
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es una pequeña aplicación web hecha con Flask, un marco popular para crear sitios web en Python. La función principal del código es generar y mostrar una matriz (en este caso, se intenta generar un cuadro que podría parecer el inicio de un rompecabezas Sudoku, aunque no está completamente formateado como uno).

Primero, importamos las bibliotecas necesarias: `random` para la generación aleatoria de números, y `Flask`, junto con su función `render_template`, para crear una aplicación web sencilla.

Luego creamos un objeto Flask llamado `app`. Este objeto es el corazón de nuestra pequeña aplicación web. Después, definimos una ruta principal ("/") que se encarga de generar una matriz 9x9 con números del 1 al 9 sin repeticiones en cada fila. Esto se logra usando un conjunto (`set`) para asegurar que no haya duplicados.

Cada vez que alguien visita la página web (a través de su navegador), el código dentro de `inicio()` se ejecuta. Esta función genera filas aleatorias hasta que encuentra una fila cuyos números forman un conjunto exactamente igual al patrón deseado ({1,2,3,4,5,6,7,8,9}). Una vez encontrada esta fila sin duplicados, la agrega a nuestra matriz `sudoku`.

Finalmente, el código renderiza una plantilla HTML llamada "index.html", pasándole los datos generados (la matriz completa) para que estos puedan ser mostrados en el navegador.

Esta aplicación es útil para entender cómo generar contenido dinámico en un sitio web y cómo utilizar Flask para servirlo. Es importante notar que esta implementación no asegura que el Sudoku sea válido desde el punto de vista del juego (es decir, sin repetir números en columnas o cuadrantes), sino simplemente que cada fila es una secuencia única de los dígitos 1 a 9.

`011-flask.py`

```python
import random
from flask import Flask,render_template

app = Flask(__name__)

@app.route("/")
def inicio():
  patron = {1,2,3,4,5,6,7,8,9}
  sudoku = []
  for celda in range(1,10):
    while True:
      lista = []
      for i in range(1,10):
        lista.append(random.randint(1,9))
      conjunto = set(lista)
      if conjunto == patron:
        sudoku.append(lista)
        break # Fuerzo la finalizazión del bucle infinito

  return render_template("index.html",datos=sudoku)

if __name__ == "__main__":
  app.run(debug=True)
  
```

### flask con contador
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es un ejemplo de cómo utilizar Flask para crear una aplicación web simple que genera y muestra un Sudoku. El objetivo principal del programa es generar una matriz 9x9 (Sudoku) en la que cada fila contiene los números del 1 al 9 sin repetirse, utilizando un enfoque de fuerza bruta.

El código comienza importando las bibliotecas necesarias: `random` para generar números aleatorios y `Flask` junto con `render_template` para crear una aplicación web. Se crea una instancia de la clase Flask llamada `app`.

La función `inicio()` es el punto principal del programa que se ejecuta cuando alguien visita la raíz ("/") de la aplicación web. Dentro de esta función, se inicializa un contador y un conjunto que contiene los números del 1 al 9 (este conjunto representa los valores válidos para una fila en un Sudoku).

El código luego entra en un bucle donde intenta generar listas de 9 elementos (correspondientes a las filas del Sudoku) hasta que cada lista cumple con la condición de contener exactamente los números del 1 al 9 sin repetirse. Esto se verifica convirtiendo la lista en un conjunto y comparándolo con el conjunto `patron`. Si coincide, significa que esa fila es válida para un Sudoku.

Una vez generadas todas las filas validas, estas son almacenadas dentro de una matriz llamada `sudoku`, que luego será mostrada en la página web a través del archivo "index.html".

Finalmente, si el script se ejecuta directamente (y no importado), la aplicación Flask comienza a funcionar con la opción de depuración activa para facilitar el desarrollo.

Este código es un buen ejemplo del uso de fuerza bruta en programación y cómo integrarlo con una aplicación web básica usando Flask.

`012-flask con contador.py`

```python
import random
from flask import Flask, render_template

app = Flask(__name__)

@app.route("/")
def inicio():
    contador = 0
    patron = {1, 2, 3, 4, 5, 6, 7, 8, 9}
    sudoku = []

    for celda in range(1, 10):
        while True:
            contador += 1
            lista = []
            for i in range(1, 10):
                lista.append(random.randint(1, 9))
            conjunto = set(lista)
            if conjunto == patron:
                sudoku.append(lista)
                break  # Fuerzo la finalización del bucle infinito

    print("He necesitado, con fuerza bruta, " + str(contador) + " intentos")
    return render_template("index.html", datos=sudoku)

if __name__ == "__main__":
    app.run(debug=True)
```

### calculo completo
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código es una aplicación Flask que genera un tablero de Sudoku al azar, asegurándose de que las filas y columnas cumplan con los requisitos básicos del juego. Aquí tienes una explicación detallada:

El programa comienza importando el módulo `random` para generar números aleatorios y el módulo `Flask` para crear la aplicación web. Define un conjunto llamado `PATRON`, que contiene los números del 1 al 9, lo cual es fundamental para verificar si las filas y columnas son válidas.

La función `generar_fila()` crea una lista con los números del 1 al 9 y los mezcla aleatoriamente. Esto se utiliza para generar filas de un tablero de Sudoku que cumplan con la condición básica de tener todos los dígitos del 1 al 9 sin repetirse.

Las funciones `filas_validas()` y `columnas_validas()` verifican si todas las filas o columnas, respectivamente, contienen exactamente los números del 1 al 9. Si alguna fila o columna no cumple con este criterio, la función devuelve `False`.

La función `sudoku_a_bloques()` transforma el tablero de Sudoku (que es una matriz de 9 filas por 9 columnas) en 9 bloques más pequeños de 3x3. Esto se hace recorriendo las posiciones de cada bloque y añadiendo los números correspondientes a una lista, que luego se agrega a la lista final `bloques`.

La función principal es `inicio()`, un endpoint de Flask que genera tableros de Sudoku al azar hasta encontrar uno cuyas filas y columnas son válidas. Para cada intento, el código crea nueve filas aleatorias y las verifica con las funciones anteriores. Una vez se encuentra un tablero válido, se convierte en los bloques 3x3 necesarios para mostrarlo de manera adecuada en la web.

Finalmente, si el script es ejecutado directamente (y no importado como módulo), se inicia el servidor Flask con modo depuración activo.

`013-calculo completo.py`

```python
import random
from flask import Flask, render_template

app = Flask(__name__)

PATRON = set(range(1, 10))  # {1,2,3,4,5,6,7,8,9}


def generar_fila():
    """Genera una permutación aleatoria de 1..9."""
    fila = list(range(1, 10))
    random.shuffle(fila)
    return fila


def filas_validas(sudoku):
    """Todas las filas contienen exactamente los números 1..9."""
    for fila in sudoku:
        if set(fila) != PATRON:
            return False
    return True


def columnas_validas(sudoku):
    """Todas las columnas contienen exactamente los números 1..9."""
    for c in range(9):
        columna = [sudoku[f][c] for f in range(9)]
        if set(columna) != PATRON:
            return False
    return True


def sudoku_a_bloques(sudoku):
    """
    Convierte el sudoku (9 filas x 9 columnas) en 9 bloques 3x3.
    Cada bloque es una lista de 9 números, en orden de lectura.
    """
    bloques = []
    for br in range(3):          # bloque fila
        for bc in range(3):      # bloque columna
            bloque = []
            for r in range(br * 3, br * 3 + 3):
                for c in range(bc * 3, bc * 3 + 3):
                    bloque.append(sudoku[r][c])
            bloques.append(bloque)
    return bloques


@app.route("/")
def inicio():
    intentos = 0

    # Fuerza bruta: generar tableros al azar hasta que filas y columnas sean válidas
    while True:
        intentos += 1
        sudoku = [generar_fila() for _ in range(9)]

        if filas_validas(sudoku) and columnas_validas(sudoku):
            break

    print(f"He necesitado, con fuerza bruta, {intentos} intentos")

    # Adaptamos a tu HTML: 9 bloques 3x3
    datos = sudoku_a_bloques(sudoku)

    return render_template("index.html", datos=datos)


if __name__ == "__main__":
    app.run(debug=True)
```

### mas eficiente
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es una aplicación Flask que genera y muestra un tablero del juego Sudoku en el navegador. La aplicación utiliza varias funciones para crear, verificar y resolver un tablero Sudoku válido.

La función `es_valido(grid, fila, col, num)` verifica si se puede colocar un número dado (`num`) en la celda especificada por `fila` y `col`. Para hacer esto, revisa que el número no esté ya presente en la misma fila, columna o bloque 3x3.

La función `resolver_sudoku(grid)` utiliza técnicas de backtracking para resolver el tablero Sudoku. Comienza buscando la primera celda vacía (donde el valor es 0), luego intenta colocar los números del 1 al 9 en esa celda hasta que encuentra uno que sea válido según las reglas del Sudoku. Si un número no funciona, vuelve atrás y prueba otro número (backtracking). Este proceso se repite hasta completar todo el tablero.

La función `generar_sudoku_completo()` crea un nuevo tablero Sudoku completo resolviendo de manera aleatoria para garantizar la generación de un tablero válido usando la función `resolver_sudoku(grid)`.

Finalmente, la función `sudoku_a_bloques(sudoku)` convierte el tablero del Sudoku en una lista que representa los 9 bloques de 3x3. Esto es útil cuando se necesita mostrar o manipular el Sudoku visualmente como grillas más pequeñas para facilitar su resolución.

El código Flask establece un endpoint raíz (`/`) que, al ser visitado por un usuario, genera un nuevo tablero Sudoku completo y lo muestra en la página web usando una plantilla HTML llamada `index2.html`.

`014-mas eficiente.py`

```python
import random
from flask import Flask, render_template

app = Flask(__name__)


def es_valido(grid, fila, col, num):
    """Comprueba si `num` puede ponerse en grid[fila][col]."""

    # Fila
    if num in grid[fila]:
        return False

    # Columna
    for f in range(9):
        if grid[f][col] == num:
            return False

    # Bloque 3x3
    bloque_fila = (fila // 3) * 3
    bloque_col = (col // 3) * 3
    for f in range(bloque_fila, bloque_fila + 3):
        for c in range(bloque_col, bloque_col + 3):
            if grid[f][c] == num:
                return False

    return True


def resolver_sudoku(grid):
    """
    Backtracking: intenta rellenar la cuadrícula.
    Devuelve True si se ha podido resolver, False si no.
    """

    # Buscar la siguiente celda vacía (0)
    for fila in range(9):
        for col in range(9):
            if grid[fila][col] == 0:
                # Probamos números del 1 al 9 en orden aleatorio
                candidatos = list(range(1, 10))
                random.shuffle(candidatos)

                for num in candidatos:
                    if es_valido(grid, fila, col, num):
                        grid[fila][col] = num
                        if resolver_sudoku(grid):
                            return True
                        # backtrack
                        grid[fila][col] = 0

                # Si ningún número sirve, devolvemos False
                return False

    # Si no quedan celdas vacías, está resuelto
    return True


def generar_sudoku_completo():
    """Genera un sudoku completo válido (9x9) usando backtracking."""
    grid = [[0 for _ in range(9)] for _ in range(9)]
    resolver_sudoku(grid)
    return grid


def sudoku_a_bloques(sudoku):
    """
    Convierte el sudoku (9x9) en 9 bloques 3x3.
    Cada bloque es una lista de 9 números.
    """
    bloques = []
    for br in range(3):          # bloque fila
        for bc in range(3):      # bloque columna
            bloque = []
            for r in range(br * 3, br * 3 + 3):
                for c in range(bc * 3, bc * 3 + 3):
                    bloque.append(sudoku[r][c])
            bloques.append(bloque)
    return bloques


@app.route("/")
def inicio():
    sudoku = generar_sudoku_completo()
    datos = sudoku_a_bloques(sudoku)
    return render_template("index2.html", datos=datos)


if __name__ == "__main__":
    app.run(debug=True)
```

### Actividades propuestas

### Actividades para Estudiantes de Formación Profesional (FP)

1. **Introducción a los Conjuntos**
   - **Descripción:** Crea un programa que lea una lista de elementos y guarde estos en dos conjuntos diferentes, mostrando finalmente si ambos conjuntos son iguales o no.
   - **Objetivo:** Aprender cómo trabajar con estructuras de datos no ordenadas como los conjuntos.

2. **Verificación de Patrones**
   - **Descripción:** Implementa un programa que genere una lista aleatoria y verifique si esta cumple con el patrón establecido (conjunto {1, 2, ..., 9}). 
   - **Objetivo:** Entender la importancia de las pruebas condicionales en la validación de datos.

3. **Generador Aleatorio Mejorado**
   - **Descripción:** Desarrolla un programa que genere aleatoriamente una lista de números del 1 al 9 y verifique si se asemeja exactamente al patrón establecido, utilizando bucles infinitos.
   - **Objetivo:** Familiarizarse con la implementación de bucles controlados por condiciones.

4. **Modificación de Datos**
   - **Descripción:** Escribe un programa que genere una lista aleatoria y cambie aleatoriamente uno o más elementos, luego verifica si aún sigue siendo válido.
   - **Objetivo:** Aprender a manipular datos en listas utilizando indices aleatorios.

5. **Iteración Compleja**
   - **Descripción:** Crea un programa que genere múltiples iteraciones de 9 números aleatorios hasta encontrar una lista que cumpla con el patrón dado.
   - **Objetivo:** Practicar la manipulación de listas y conjuntos dentro de bucles anidados.

6. **Matriz Bidimensional**
   - **Descripción:** Implementa un programa que genere una matriz bidimensional (9x9) donde cada fila sea una lista aleatoria de números del 1 al 9.
   - **Objetivo:** Familiarizarse con las matrices en Python y la manipulación de filas y columnas.

7. **Despliegue Web Sencillo**
   - **Descripción:** Desarrolla un programa que genere una matriz bidimensional y la despliegue en una página web simple usando Flask.
   - **Objetivo:** Introducir conceptos básicos del desarrollo web con Python (Flask).

8. **Contador de Intentos**
   - **Descripción:** Modifica el programa anterior para que cuente los intentos necesarios para generar correctamente la matriz y muestre este dato en la página web.
   - **Objetivo:** Combinar lógica de programación con interacción con usuarios a través del desarrollo web.

---

Estas actividades están diseñadas para proporcionar una progresión natural desde conceptos básicos hasta aplicaciones prácticas, adaptándose al nivel y habilidades típicamente esperados en ciclos formativos de FP.



<a id="utilizacion-avanzada-de-clases"></a>
# Utilización avanzada de clases

<a id="repaso"></a>
## Repaso

### Introducción a los ejercicios

Los archivos que has proporcionado describen una relación entre distintos componentes de un sistema de software y sus relaciones en forma de diagrama visual y en código Python. A continuación, se detallará el análisis:

### Diagramas

#### `diagrama.svg`
El archivo SVG contiene un dibujo con cuatro rectángulos que representan diferentes elementos del sistema:
1. **Python**: Ubicado en las coordenadas (x: 133.4375, y: 168.7).
2. **Flask**: Ubicado en las coordenadas (x: 133, y: 128.5).
3. **HTML (en/)**: Ubicado en las coordenadas (x: 40, y: 41).
4. **JSON (/api)**: Ubicado en las coordenadas (x: 214, y: 40).

Además de los rectángulos, hay tres líneas que representan conexiones entre estos elementos:
- Una línea conecta "Python" con "HTML".
- Otra línea conecta "Python" con "JSON".
- La tercera línea conecta "JSON" con "HTML".

#### `diagrama.html`
El archivo HTML contiene un SVG similar al anterior. No hay cambios significativos en las conexiones entre los elementos.

#### `diagrama.json`
Este archivo proporciona una descripción estructurada del diagrama:
- **Formas (shapes)**: Lista de rectángulos y sus posiciones.
- **Flechas (arrows)**: Describen la conexión entre las formas utilizando el concepto de "desde" hasta".

### Código Python

El archivo `diagrama.py` define clases que representan diferentes entidades del sistema, junto con relaciones clave:
```python
from dataclasses import dataclass
from typing import Optional

@dataclass
class Cliente:
    id: Optional[int] = None
    nombre: Optional[str] = None
    apellidos: Optional[str] = None

@dataclass
class Producto:
    id: Optional[int] = None
    nombre: Optional[str] = None
    precio: Optional[str] = None

@dataclass
class Pedido:
    id: Optional[int] = None
    fecha: Optional[str] = None
    cliente_id: Optional[int] = None

    # FK1: cliente_id -> cliente.id

@dataclass
class Lineaspedido:
    id: Optional[int] = None
    fecha: Optional[str] = None
    pedido_id: Optional[int] = None
    producto_id: Optional[int] = None
    cantidad: Optional[str] = None

    # FK1: pedido_id -> pedido.id
    # FK2: producto_id -> producto.id
```
- **Cliente**: Contiene información sobre un cliente.
- **Producto**: Define una entidad de producto con atributos como nombre y precio.
- **Pedido**: Representa el pedido realizado por un cliente. Tiene una relación clave foránea (FK1) hacia `Cliente`.
- **Lineaspedido** (o detalle del pedido): Incluye información sobre la cantidad del producto en cada línea del pedido, relacionándose con ambas entidades `Pedido` y `Producto`.

### Relaciones Entidad-Relación

Las relaciones entre las clases se pueden resumir de la siguiente manera:
- **Cliente -> Pedido**: Un cliente puede realizar varios pedidos.
- **Producto -> Lineaspedido**: Un producto puede estar en varias líneas del pedido.
- **Pedido -> Lineaspedido**: Un pedido contiene múltiples líneas que relacionan los productos con cantidades.

Estos archivos proporcionan una representación visual y lógica de cómo funcionaría un sistema en términos de sus componentes interconectados, incluyendo el modelo relacional entre las entidades principales.

### Npc
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código crea una clase llamada `Npc` que representa a un personaje no jugable (Non Playable Character o NPC) en un juego. La clase tiene un método especial llamado `__init__`, el cual es un constructor que se ejecuta automáticamente cuando creamos una nueva instancia del objeto. Este constructor toma dos parámetros, `x` e `y`, que son las coordenadas iniciales del NPC.

Cuando creamos objetos de la clase `Npc` (como en este caso con `personaje1 = Npc(4,3)` y `personaje2 = Npc(5,4)`) se inicializan con diferentes valores para `x` e `y`. Estos objetos tendrán propiedades `posx` y `posy`, que almacenan las coordenadas proporcionadas.

Finalmente, el código imprime los objetos `personaje1` y `personaje2` directamente con la función `print()`. Por defecto, esto mostrará una representación en texto de cada objeto, incluyendo su clase y ubicación en memoria. Para obtener información más útil o específica sobre estos personajes, podríamos necesitar implementar métodos adicionales dentro de nuestra clase `Npc`, como `__str__` para definir cómo se debería imprimir un objeto del tipo `Npc`.

`001-Npc.py`

```python
# Non Playable Character

class Npc():
  def __init__(self,x,y):
    self.posx = x
    self.posy = y
    
personaje1 = Npc(4,3)
personaje2 = Npc(5,4)

print(personaje1)
print(personaje2)
```

### lista de npc
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código crea una clase llamada `Npc` que representa un personaje no jugable (Non Playable Character o NPC) en un juego. La clase tiene un método especial llamado `__init__`, que se ejecuta cada vez que creamos una nueva instancia del objeto `Npc`. Este método inicializa las posiciones x e y del personaje, es decir, dónde se encuentran en el mapa del juego.

Luego, se crea una lista vacía llamada `personajes` donde almacenaremos todos los NPCs que vayamos creando. Después, añadimos dos NPCs a esta lista utilizando la función `append()`. El primer NPC tiene las coordenadas (4,3), mientras que el segundo está en (3,4).

Finalmente, se imprime la lista `personajes` para mostrar todos los objetos `Npc` que hemos creado. Esto nos permite ver cómo están almacenados estos personajes y sus posiciones correspondientes.

Este código es importante porque demuestra cómo crear y gestionar una colección de objetos en Python, lo cual es fundamental cuando se trabaja con juegos o aplicaciones donde necesitas seguir el estado de múltiples entidades a la vez.

`002-lista de npc.py`

```python
# Non Playable Character

class Npc():
  def __init__(self,x,y):
    self.posx = x
    self.posy = y
    
personajes = []

personajes.append(Npc(4,3))
personajes.append(Npc(3,4))

print(personajes)
```

### ahora muchos personajes
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código crea una lista de personajes no jugables (NPCs) en un entorno de programación. El objetivo es generar múltiples NPCs con posiciones inicialmente fijas y luego almacenarlos en una lista.

Primero, se define una clase llamada `Npc` que tiene un método especial `__init__`. Este método recibe dos parámetros, `x` e `y`, que representan las coordenadas donde se encuentra el NPC. Dentro del método `__init__`, estas coordenadas se almacenan en atributos de la instancia: `self.posx` y `self.posy`.

Después, se crea una lista vacía llamada `personajes`. Luego, se define una variable `numero_personajes` que establece cuántos NPCs queremos crear, en este caso 50.

A continuación, se utiliza un bucle `for` para iterar desde 0 hasta el número de NPCs menos uno (es decir, del 0 al 49). En cada iteración, se crea una instancia de la clase `Npc` con las coordenadas fijas `(4,3)` y esta instancia es añadida a la lista `personajes`.

Finalmente, se imprime en pantalla la lista completa de NPCs generada.

Este código es importante porque demuestra cómo utilizar clases para crear múltiples objetos con características similares, almacenarlos en una colección (como una lista) y luego manipular esos objetos.

`003-ahora muchos personajes.py`

```python
# Non Playable Character

class Npc():
  def __init__(self,x,y):
    self.posx = x
    self.posy = y
    
personajes = []
numero_personajes = 50

for i in range(0,numero_personajes):
	personajes.append(Npc(4,3))

print(personajes)
```

### posicion aleatoria
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código crea una simulación simple en la que se generan 50 entidades no jugables (Non Playable Character o NPC) con posiciones aleatorias en un espacio definido por coordenadas x e y. La clase `Npc` es definida para almacenar la posición del personaje, con el método `__init__` que establece las coordenadas de entrada como atributos de instancia.

El código crea una lista vacía llamada `personajes`, después genera un número específico (50 en este caso) de NPCs. Para cada uno de ellos, se generan dos números aleatorios entre 0 y 500 para las coordenadas x e y respectivamente, usando la función `random.randint`. Estos NPC son instancias creadas a partir de la clase `Npc`, con sus posiciones iniciales definidas por los números aleatorios. Cada instancia de NPC se añade a la lista `personajes`.

Finalmente, el código imprime en consola toda la lista de NPCs que han sido generados y posicionados de manera aleatoria. Esta técnica es común en juegos o simulaciones donde necesitas generar múltiples entidades con ubicaciones diferentes para hacer más interesante y variado el escenario.

`004-posicion aleatoria.py`

```python
# Non Playable Character
import random

class Npc():
  def __init__(self,x,y):
    self.posx = x
    self.posy = y
    
personajes = []
numero_personajes = 50

for i in range(0,numero_personajes):
	xaleatoria = random.randint(0,500)
	yaleatoria = random.randint(0,500)
	personajes.append(Npc(xaleatoria,yaleatoria))

print(personajes)
```

### imprimo como json
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código crea una lista de objetos llamados `Npc` (No Player Character o Personaje No Jugador en español) con posiciones aleatorias y luego los convierte a un formato JSON para imprimirlos. 

Primero, se importan las bibliotecas necesarias: `random` para generar números aleatorios y `json` para trabajar con datos JSON. Luego, se define una clase llamada `Npc` que tiene dos atributos (`posx` y `posy`) para almacenar la posición del personaje en un espacio 2D.

El código crea una lista vacía llamada `personajes` y establece el número de personajes a generar. En un bucle for, se generan coordenadas aleatorias entre 0 y 500 para cada NPC y estos objetos son añadidos a la lista `personajes`.

Luego, usando comprensión de listas en Python, se llama al método `to_dict()` de cada objeto `Npc` en la lista para convertirlos todos a diccionarios que contienen sus posiciones.

Finalmente, el código convierte toda esta información en un formato JSON legible e imprimirla en pantalla con una indentación de 2 espacios para facilitar la lectura y comprensión del resultado.

Este tipo de estructuración es útil cuando se necesita representar objetos complejos como datos simples que pueden ser fácilmente almacenados o transmitidos.

`005-imprimo como json.py`

```python
import random
import json

class Npc():
    def __init__(self, x, y):
        self.posx = x
        self.posy = y

    # Método para convertir el objeto en diccionario
    def to_dict(self):
        return {"posx": self.posx, "posy": self.posy}

personajes = []
numero_personajes = 50

for i in range(0, numero_personajes):
    xaleatoria = random.randint(0, 500)
    yaleatoria = random.randint(0, 500)
    personajes.append(Npc(xaleatoria, yaleatoria))

# Convertimos todos los NPC a diccionarios
personajes_json = [p.to_dict() for p in personajes]

# Lo imprimimos formateado
print(json.dumps(personajes_json, indent=2))
```

### flask
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es un ejemplo básico de cómo usar Flask para crear una pequeña aplicación web que maneja datos relacionados con personajes en un juego. La aplicación crea y gestiona un conjunto de "personajes" (objetos `Npc`), que son entidades virtuales con posiciones x e y aleatorias dentro de un rango definido.

La clase `Npc` tiene dos atributos, `posx` y `posy`, que representan la posición del personaje en el espacio virtual. La función `to_dict()` convierte estos atributos en un diccionario, lo cual es útil para convertir los objetos de Python en JSON cuando se envían a través de una API web.

El código también incluye un bucle que crea 50 objetos `Npc` con posiciones aleatorias. Estos personajes son almacenados en una lista y luego cada uno se convierte a formato JSON para ser fácilmente consumido por la aplicación web.

La parte final del código configura Flask, un marco de trabajo ligero para desarrollar aplicaciones web en Python. Se definen dos rutas: `/` que simplemente muestra una página HTML llamada `juego.html`, y `/api` que devuelve los datos JSON de todos los personajes cuando se solicita desde el navegador.

Esta aplicación es importante porque demuestra cómo integrar clases personalizadas con Flask para crear APIs que pueden ser consumidas por otras partes del sistema o incluso por aplicaciones web front-end.

`006-flask.py`

```python
import random
import json
from flask import Flask,render_template

class Npc():
    def __init__(self, x, y):
        self.posx = x
        self.posy = y

    # Método para convertir el objeto en diccionario
    def to_dict(self):
        return {"posx": self.posx, "posy": self.posy}
# Preparo los personajes

personajes = []
numero_personajes = 50

for i in range(0, numero_personajes):
    xaleatoria = random.randint(0, 500)
    yaleatoria = random.randint(0, 500)
    personajes.append(Npc(xaleatoria, yaleatoria))

personajes_json = [p.to_dict() for p in personajes]

# Lanzo una web

app = Flask(__name__)

@app.route("/")
def inicio():
  return render_template("juego.html")

@app.route("/api")
def api():
  return json.dumps(personajes_json, indent=2)
  
if __name__ == "__main__":
  app.run(debug=True)
```

### nuevo parametro
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código es una parte de un pequeño proyecto web en Python que utiliza Flask para servir contenido y JSON. En este fragmento, se crea una clase `Npc` (que probablemente significa "No Player Character" o personaje no jugable) con tres atributos: `posx`, `posy` y `radio`. Estos representan la posición x e y del personaje en un plano 2D y su tamaño respectivamente.

El código luego crea una lista de objetos `Npc` cuyas posiciones (x, y) y radios son generados aleatoriamente. Cada objeto `Npc` tiene un método llamado `to_dict()` que convierte los datos del personaje en un diccionario, lo cual es útil para convertirlos a formato JSON.

Finalmente, el código prepara una aplicación web con Flask. Cuando se accede al endpoint "/api", la aplicación devuelve la lista de personajes (en forma de objetos `Npc`) como un JSON codificado. Esto permite que otras partes del proyecto o aplicaciones externas puedan acceder y utilizar estos datos fácilmente.

Este código es importante porque muestra cómo combinar clases personalizadas con el marco web Flask para crear APIs simples pero funcionales, lo cual es una habilidad valiosa en desarrollo de software moderno.

`007-nuevo parametro.py`

```python
import random
import json
from flask import Flask,render_template

class Npc():
    def __init__(self, x, y,radio):
        self.posx = x
        self.posy = y
        self.radio = radio

    # Método para convertir el objeto en diccionario
    def to_dict(self):
        return {"posx": self.posx, "posy": self.posy,"radio":self.radio}
# Preparo los personajes

personajes = []
numero_personajes = 50

for i in range(0, numero_personajes):
    xaleatoria = random.randint(0, 500)
    yaleatoria = random.randint(0, 500)
    radioaleatorio = random.randint(10, 30)
    personajes.append(Npc(xaleatoria, yaleatoria,radioaleatorio))

personajes_json = [p.to_dict() for p in personajes]

# Lanzo una web

app = Flask(__name__)

@app.route("/")
def inicio():
  return render_template("juego.html")

@app.route("/api")
def api():
  return json.dumps(personajes_json, indent=2)
  
if __name__ == "__main__":
  app.run(debug=True)
```

### muevo personajes
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es una aplicación web sencilla que simula el movimiento de personajes en un espacio bidimensional. La aplicación utiliza la biblioteca Flask para crear un servidor web y la clase `Npc` (Non-Player Character) para representar cada uno de los personajes.

La clase `Npc` tiene tres atributos: posición en X (`posx`) y posición en Y (`posy`), así como el tamaño del personaje (`radio`). La función `mover()` cambia aleatoriamente la posición del personaje en ambas dimensiones, permitiendo que se desplace dentro del espacio definido.

En el bloque principal del código, se crean 50 objetos de tipo `Npc` con posiciones y tamaños aleatorios. Estos objetos son almacenados en una lista llamada `personajes`.

La aplicación web tiene dos rutas: la ruta raíz (`/`) que devuelve un archivo HTML que probablemente muestra los personajes, y la ruta `/api`, donde se actualizan las posiciones de los personajes (mediante el método `mover()`), convierten estos objetos en diccionarios utilizando el método `to_dict()`, y luego devuelven estos datos en formato JSON.

Esta aplicación es útil para entender cómo interactuar con datos estructurados desde un servidor web, especialmente cuando se necesitan actualizar los datos de manera dinámica.

`008-muevo personajes.py`

```python
import random
import json
from flask import Flask,render_template

class Npc():
	def __init__(self, x, y,radio):
		self.posx = x
		self.posy = y
		self.radio = radio

	def to_dict(self):
		return {"posx": self.posx, "posy": self.posy,"radio":self.radio}
	def mover(self):
		self.posx += random.randint(-5,5)	# Muevete un poco en X
		self.posy += random.randint(-5,5)	# Muevete un poco en Y
# Preparo los personajes

personajes = []
numero_personajes = 50

for i in range(0, numero_personajes):
	xaleatoria = random.randint(0, 500)
	yaleatoria = random.randint(0, 500)
	radioaleatorio = random.randint(10, 30)
	personajes.append(Npc(xaleatoria, yaleatoria,radioaleatorio))



# Lanzo una web

app = Flask(__name__)

@app.route("/")
def inicio():
  return render_template("juego.html")

@app.route("/api")
def api():
  # Primero muevo todos los personajes
  for personaje in personajes:	
    personaje.mover()
  personajes_json = [p.to_dict() for p in personajes]
  return json.dumps(personajes_json, indent=2)
  
if __name__ == "__main__":
  app.run(debug=True)
  
  
  
  
```

### Muevo personajes pero con trigonometria
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código Python crea un sistema sencillo para mover personajes en una página web usando Flask y conceptos básicos de trigonometría. La clase `Npc` (Non-Player Character) define cómo se comportan estos personajes, con atributos como posición (`posx`, `posy`), tamaño (`radio`) y dirección (`direccion`). El método `to_dict()` convierte a cada personaje en un diccionario para facilitar la comunicación con la web.

El código genera 50 personajes de manera aleatoria, asignándoles posiciones (x,y) dentro de un rango definido, un radio también aleatorio y una dirección angular. Esta dirección se usa para mover los personajes en diagonal o en curva utilizando las funciones `math.cos()` y `math.sin()`, que manipulan la posición del personaje basándose en sus coordenadas actuales y su ángulo de dirección.

La parte final del código establece un servidor web con Flask. Cuando una solicitud HTTP llega a la ruta "/", se muestra una página HTML llamada "juego.html". Si la solicitud es para "/api", todos los personajes se mueven según el método `mover()`, y luego sus datos se convierten en formato JSON, que será devuelto al usuario. Esto permite actualizar la posición de los personajes dinámicamente en una página web.

Este código es importante porque demuestra cómo combinar matemáticas básicas con programación para crear sistemas interactivos y dinámicos, además de enseñar el uso de frameworks como Flask para servir contenido web.

`009-Muevo personajes pero con trigonometria.py`

```python
import random
import json
from flask import Flask,render_template
import math # Para poder hacer trigonometria

class Npc():
	def __init__(self, x, y,radio,direccion):
		self.posx = x
		self.posy = y
		self.radio = radio
		self.direccion = direccion # NUEVO

	def to_dict(self):
		return {
      "posx": self.posx, 
      "posy": self.posy,
      "radio": self.radio,
    	"direccion": self.direccion # NUEVO
    }
	def mover(self):
		self.posx += math.cos(self.direccion) # NUEVO
		self.posy += math.sin(self.direccion) # NUEVO
# Preparo los personajes

personajes = []
numero_personajes = 50

for i in range(0, numero_personajes):
	xaleatoria = random.randint(0, 500)
	yaleatoria = random.randint(0, 500)
	radioaleatorio = random.randint(10, 30)
	direccionaleatoria = random.random()*math.pi*2  # NUEVO
	personajes.append(
    Npc(xaleatoria, yaleatoria,radioaleatorio,direccionaleatoria) # NUEVO
  )



# Lanzo una web

app = Flask(__name__)

@app.route("/")
def inicio():
  return render_template("juego.html")

@app.route("/api")
def api():
  # Primero muevo todos los personajes
  for personaje in personajes:	
    personaje.mover()
  personajes_json = [p.to_dict() for p in personajes]
  return json.dumps(personajes_json, indent=2)
  
if __name__ == "__main__":
  app.run(debug=True)
  
  
  
  
```

### creamos velocidad
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código es una parte de un proyecto en el que se crean y mueven personajes (también conocidos como NPCs) dentro de una aplicación web utilizando la biblioteca Flask. La clase `Npc` define los atributos necesarios para cada personaje, incluyendo su posición (`posx`, `posy`), tamaño (`radio`), dirección de movimiento (`direccion`) y velocidad (`velocidad`). El método `to_dict()` convierte el objeto `Npc` en un diccionario que es fácil de serializar a JSON.

El bucle for crea una lista llamada `personajes` con 50 NPCs, cada uno inicializado con posiciones, tamaños y velocidades aleatorias. La dirección también se establece de forma aleatoria para definir hacia dónde apuntan los personajes.

La aplicación web en Flask tiene dos rutas: una que renderiza un archivo HTML llamado "juego.html" (que probablemente contiene la interfaz del usuario) y otra ruta "/api" que es responsable de mover a todos los NPCs actualizando sus posiciones según su dirección y velocidad. Después, convierte estos personajes en formato JSON para poder ser enviados como respuesta a una solicitud HTTP.

Esta estructura permite que los personajes se muevan dinámicamente en tiempo real dentro del juego web, lo cual es un aspecto clave de la interactividad en aplicaciones basadas en el navegador.

`010-creamos velocidad.py`

```python
import random
import json
from flask import Flask,render_template
import math # Para poder hacer trigonometria

class Npc():
	def __init__(self, x, y,radio,direccion,velocidad): # NUEVO
		self.posx = x
		self.posy = y
		self.radio = radio
		self.direccion = direccion 
		self.velocidad = velocidad # NUEVO

	def to_dict(self):
		return {
      "posx": self.posx, 
      "posy": self.posy,
      "radio": self.radio,
    	"direccion": self.direccion 
    }
	def mover(self):
		self.posx += math.cos(self.direccion)*self.velocidad # NUEVO
		self.posy += math.sin(self.direccion)*self.velocidad # NUEVO
# Preparo los personajes

personajes = []
numero_personajes = 50

for i in range(0, numero_personajes):
	xaleatoria = random.randint(0, 500)
	yaleatoria = random.randint(0, 500)
	radioaleatorio = random.randint(10, 30)
	direccionaleatoria = random.random()*math.pi*2 
	velocidadaleatoria = random.random()*5 # NUEVO
	personajes.append(
    Npc(
      xaleatoria, 
      yaleatoria,
      radioaleatorio,
      direccionaleatoria,
      velocidadaleatoria # NUEVO
    ) 
  )



# Lanzo una web

app = Flask(__name__)

@app.route("/")
def inicio():
  return render_template("juego.html")

@app.route("/api")
def api():
  # Primero muevo todos los personajes
  for personaje in personajes:	
    personaje.mover()
  personajes_json = [p.to_dict() for p in personajes]
  return json.dumps(personajes_json, indent=2)
  
if __name__ == "__main__":
  app.run(debug=True)
  
  
  
  
```

### angulo cambia random
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código Python crea una aplicación web simple utilizando Flask que muestra la posición y el movimiento de varios personajes (NPCs) en un espacio 2D. La aplicación utiliza clases para definir cómo se comportan estos NPCs, incluyendo su dirección, velocidad y radio. 

La clase `Npc` tiene métodos como `__init__`, `to_dict`, y `mover`. El método `mover` actualiza la posición del NPC basándose en su dirección y velocidad actuales. La dirección del NPC cambia ligeramente de manera aleatoria con cada movimiento para simular un comportamiento más natural, usando una función que genera números aleatorios.

En el cuerpo principal del código, se crean 50 NPCs con posiciones y velocidades iniciales aleatorias. Estos NPCs son luego almacenados en la lista `personajes`.

La aplicación web tiene dos rutas: `/` y `/api`. La ruta `/` simplemente renderiza una página HTML llamada "juego.html", mientras que la ruta `/api` se encarga de mover todos los NPCs, actualizando sus posiciones según el método `mover`, y luego devuelve esta información en formato JSON para que pueda ser visualizada o utilizada por otros componentes del sistema.

Este código es importante porque demuestra cómo combinar conceptos fundamentales de programación orientada a objetos (clases), generación aleatoria, trigonometría básica y desarrollo web con Flask para crear una aplicación interactiva.

`011-angulo cambia random.py`

```python
import random
import json
from flask import Flask,render_template
import math # Para poder hacer trigonometria

class Npc():
	def __init__(self, x, y,radio,direccion,velocidad): 
		self.posx = x
		self.posy = y
		self.radio = radio
		self.direccion = direccion 
		self.velocidad = velocidad 

	def to_dict(self):
		return {
      "posx": self.posx, 
      "posy": self.posy,
      "radio": self.radio,
    	"direccion": self.direccion 
    }
	def mover(self):
		# Aplicamos variacion de la direccion con el tiempo
		self.direccion += (random.random() - 0.5) * 0.2  # NUEVO
		self.posx += math.cos(self.direccion)*self.velocidad
		self.posy += math.sin(self.direccion)*self.velocidad 
# Preparo los personajes

personajes = []
numero_personajes = 50

for i in range(0, numero_personajes):
	xaleatoria = random.randint(0, 500)
	yaleatoria = random.randint(0, 500)
	radioaleatorio = random.randint(10, 30)
	direccionaleatoria = random.random()*math.pi*2 
	velocidadaleatoria = random.random()*5 
	personajes.append(
    Npc(
      xaleatoria, 
      yaleatoria,
      radioaleatorio,
      direccionaleatoria,
      velocidadaleatoria 
    ) 
  )



# Lanzo una web

app = Flask(__name__)

@app.route("/")
def inicio():
  return render_template("juego.html")

@app.route("/api")
def api():
  # Primero muevo todos los personajes
  for personaje in personajes:	
    personaje.mover()
  personajes_json = [p.to_dict() for p in personajes]
  return json.dumps(personajes_json, indent=2)
  
if __name__ == "__main__":
  app.run(debug=True)
  
  
  
  
```

### colision
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código Python crea una aplicación web simple usando Flask y maneja el movimiento de entidades llamadas NPCs (No Player Characters) dentro de un espacio bidimensional. Los NPCs son personajes controlados por la computadora, no por un jugador humano.

El archivo comienza definiendo una clase `Npc` que encapsula todas las propiedades necesarias para representar a cada NPC: su posición `(x, y)`, radio (tamaño), dirección de movimiento en radianes, y velocidad. La función `mover()` actualiza la posición del NPC basándose en su dirección y velocidad actuales, además de ajustar aleatoriamente su dirección para simular el comportamiento natural de un personaje que se mueve sin control directo. Si el NPC choca con los bordes del espacio (500x500), cambia su dirección para hacerlo retroceder.

El código luego crea una lista de 50 NPCs, cada uno inicializado con posiciones y velocidades aleatorias dentro del límite especificado. La aplicación web se configura usando Flask, con dos rutas principales: una para mostrar la página principal (`/`) que probablemente carga un archivo HTML para visualizar el juego, y otra ruta `/api` que es responsable de mover todos los NPCs actualizando sus posiciones y luego devolviendo esta información en formato JSON.

Esta estructura permite a estudiantes aprender sobre la creación de entidades con comportamientos simples usando clases, manejo de eventos aleatorios para simular realismo en juegos o simulaciones, y cómo Flask puede ser utilizado para crear una API que actualiza dinámicamente la posición de los objetos virtuales en un entorno web.

`012-colision.py`

```python
import random
import json
from flask import Flask,render_template
import math # Para poder hacer trigonometria

class Npc():
	def __init__(self, x, y,radio,direccion,velocidad): 
		self.posx = x
		self.posy = y
		self.radio = radio
		self.direccion = direccion 
		self.velocidad = velocidad 

	def to_dict(self):
		return {
      "posx": self.posx, 
      "posy": self.posy,
      "radio": self.radio,
    	"direccion": self.direccion 
    }
	def mover(self):
		# Aplicamos variacion de la direccion con el tiempo
		self.direccion += (random.random() - 0.5) * 0.2
    # Colision con paredes en mover
		if self.posx > 500 or self.posx < 0 or self.posy > 500 or self.posy < 0: # NUEVO
      	# El personaje se da la vuelta
				self.direccion += math.pi # NUEVO
		self.posx += math.cos(self.direccion)*self.velocidad
		self.posy += math.sin(self.direccion)*self.velocidad 
# Preparo los personajes

personajes = []
numero_personajes = 50

for i in range(0, numero_personajes):
	xaleatoria = random.randint(0, 500)
	yaleatoria = random.randint(0, 500)
	radioaleatorio = random.randint(10, 30)
	direccionaleatoria = random.random()*math.pi*2 
	velocidadaleatoria = random.random()*5 
	personajes.append(
    Npc(
      xaleatoria, 
      yaleatoria,
      radioaleatorio,
      direccionaleatoria,
      velocidadaleatoria 
    ) 
  )



# Lanzo una web

app = Flask(__name__)

@app.route("/")
def inicio():
  return render_template("juego.html")

@app.route("/api")
def api():
  # Primero muevo todos los personajes
  for personaje in personajes:	
    personaje.mover()
  personajes_json = [p.to_dict() for p in personajes]
  return json.dumps(personajes_json, indent=2)
  
if __name__ == "__main__":
  app.run(debug=True)
  
  
  
  
```

### diagrama (1)
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código define cuatro clases en Python que representan conceptos relacionados con una base de datos de una tienda o sistema de ventas. Cada clase tiene un constructor (`__init__`) y una función especial llamada `__repr__` que ayuda a imprimir fácilmente la información del objeto.

1. **Clase Cliente**: Representa a un cliente, con atributos como ID, nombre y apellidos. Los parámetros del constructor permiten inicializar estos valores cuando se crea un nuevo objeto de tipo Cliente.

2. **Clase Producto**: Representa un producto en venta, con atributos de ID, nombre y precio. Similarmente, el constructor permite establecer estos valores al crear una nueva instancia del producto.

3. **Clase Pedido**: Esta clase representa un pedido hecho por un cliente, incluyendo detalles como la fecha del pedido y el ID del cliente que lo hizo. Aquí se menciona una relación de tipo "FK1" (Foreign Key 1), indicando que `cliente_id` está relacionado con el campo `id` en la clase Cliente.

4. **Clase Lineaspedido**: Esta clase es un detalle del pedido, conteniendo información como la fecha del detalle, el ID del pedido al que pertenece y el ID del producto vendido, así como la cantidad de productos vendidos. Menciona dos relaciones con otras clases: `FK1` relaciona `pedido_id` con `Pedido.id`, y `FK2` conecta `producto_id` con `Producto.id`.

Estas clases forman una estructura básica para modelar datos de ventas, permitiendo una fácil gestión de clientes, productos, pedidos y detalles del pedido en un sistema informático.

`diagrama (1).py`

```python
from typing import Optional

class Cliente:
    def __init__(self, id: Optional[int] = None, nombre: Optional[str] = None, apellidos: Optional[str] = None):
        self.id = id
        self.nombre = nombre
        self.apellidos = apellidos

    def __repr__(self):
        return f"Cliente(id={self.id!r}, nombre={self.nombre!r}, apellidos={self.apellidos!r})"

class Producto:
    def __init__(self, id: Optional[int] = None, nombre: Optional[str] = None, precio: Optional[str] = None):
        self.id = id
        self.nombre = nombre
        self.precio = precio

    def __repr__(self):
        return f"Producto(id={self.id!r}, nombre={self.nombre!r}, precio={self.precio!r})"

class Pedido:
    def __init__(self, id: Optional[int] = None, fecha: Optional[str] = None, cliente_id: Optional[int] = None):
        self.id = id
        self.fecha = fecha
        self.cliente_id = cliente_id

    def __repr__(self):
        return f"Pedido(id={self.id!r}, fecha={self.fecha!r}, cliente_id={self.cliente_id!r})"

    # FK1: cliente_id -> cliente.id

class Lineaspedido:
    def __init__(self, id: Optional[int] = None, fecha: Optional[str] = None, pedido_id: Optional[int] = None, producto_id: Optional[int] = None, cantidad: Optional[str] = None):
        self.id = id
        self.fecha = fecha
        self.pedido_id = pedido_id
        self.producto_id = producto_id
        self.cantidad = cantidad

    def __repr__(self):
        return f"Lineaspedido(id={self.id!r}, fecha={self.fecha!r}, pedido_id={self.pedido_id!r}, producto_id={self.producto_id!r}, cantidad={self.cantidad!r})"

    # FK1: pedido_id -> pedido.id
    # FK2: producto_id -> producto.id
```

### diagrama
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código HTML crea una página web que representa un diagrama sencillo de interacciones entre diferentes elementos tecnológicos, como Python, Flask, HTML y JSON. La página tiene un estilo definido en la sección `<style>`, donde se especifican las características visuales del diseño (como colores, bordes y sombras) para los distintos bloques方形框框圐圙圙圙圙圙圙圙圙圙圙圙圙圙圙圙圙圙圙圙圙圙圙圙圙圙圙圙圙圙圙圙

`diagrama.html`

```html
<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>Diagrama exportado</title>
<style>
body {
  margin: 0;
  padding: 20px;
  background: #f3f3f7;
  font-family: system-ui, -apple-system, "Segoe UI", sans-serif;
}
.page {
  position: relative;
  background: #ffffff;
  border: 1px solid #d1d5db;
  box-shadow: 0 2px 4px rgba(0,0,0,.1);
  width: 374px;
  height: 248.69998168945307px;
  overflow: visible;
}

/* formas básicas */
.shape {
  position: absolute;
  min-width: 120px;
  min-height: 40px;
  padding: 6px 10px;
  background: #ffffff;
  border-radius: 4px;
  border: 1px solid #9ca3af;
  box-shadow: 0 1px 2px rgba(0,0,0,0.15);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 13px;
}

.shape.rectangle {
  border-radius: 4px;
}

.shape.pill {
  border-radius: 999px;
}

.shape.circle {
  border-radius: 999px;
  width: 80px;
  height: 80px;
  padding: 0;
  justify-content: center;
}

/* base de datos */
.shape.db {
  min-width: 120px;
  min-height: 60px;
  padding-top: 20px;
  border-radius: 60px / 16px;
  background: linear-gradient(180deg, #e5e7eb 0%, #ffffff 40%, #e5e7eb 100%);
  position: absolute;
  overflow: hidden;
  text-align: center;
}
.shape.db::before {
  content: "";
  position: absolute;
  top: 0;
  left: 8px;
  right: 8px;
  height: 18px;
  border-radius: 999px;
  border: 1px solid #9ca3af;
  background: radial-gradient(circle at 50% 30%, #ffffff 0%, #e5e7eb 70%);
}
.shape.db::after {
  content: "";
  position: absolute;
  bottom: 0;
  left: 8px;
  right: 8px;
  height: 18px;
  border-radius: 999px;
  border: 1px solid rgba(156, 163, 175, 0.6);
  border-top: none;
  background: radial-gradient(circle at 50% 70%, #e5e7eb 0%, #d1d5db 70%);
}

/* entidades ER */
.shape.entity {
  width: 220px;
  min-height: 80px;
  background: #ffffff;
  border: 2px solid #111827;
  border-radius: 4px;
  box-shadow: 0 2px 4px rgba(0,0,0,.15);
  display: flex;
  flex-direction: column;
  font-size: 13px;
  overflow: hidden;
  padding: 0;
}
.entity-header {
  background: #f3f4f6;
  padding: 4px 8px;
  font-weight: 600;
  text-align: center;
  border-bottom: 1px solid #e5e7eb;
}
.entity-properties {
  flex: 1;
  padding: 4px 4px 0 4px;
}
.entity-property {
  display: grid;
  grid-template-columns: 14px 1fr 14px;
  align-items: center;
  column-gap: 4px;
  padding: 2px 0;
}
.entity-property .property-name {
  padding: 2px 4px;
  border-radius: 3px;
}

/* puertos */
.port {
  width: 9px;
  height: 9px;
  border-radius: 50%;
  border: 1px solid #111827;
  background: #ffffff;
}
.port-left { justify-self: start; }
.port-right { justify-self: end; }

/* flechas rectas */
.arrow {
  position: absolute;
  height: 2px;
  background: #111827;
  transform-origin: 0 50%;
}
.arrow::after {
  content: "";
  position: absolute;
  right: 0;
  top: 50%;
  transform: translateY(-50%);
  border-top: 5px solid transparent;
  border-bottom: 5px solid transparent;
  border-left: 8px solid #111827;
}
.arrow-double::before {
  content: "";
  position: absolute;
  left: 0;
  top: 50%;
  transform: translateY(-50%) rotate(180deg);
  border-top: 5px solid transparent;
  border-bottom: 5px solid transparent;
  border-left: 8px solid #111827;
}

/* flechas ortogonales */
.ortho-arrow {
  position: absolute;
  left: 0;
  top: 0;
}
.ortho-arrow .ortho-seg {
  position: absolute;
  background: #111827;
}
.ortho-seg.seg-horizontal { height: 2px; }
.ortho-seg.seg-vertical { width: 2px; }
.ortho-arrowhead {
  position: absolute;
  width: 0;
  height: 0;
}
.ortho-arrowhead.dir-right {
  border-top: 5px solid transparent;
  border-bottom: 5px solid transparent;
  border-left: 8px solid #111827;
}
.ortho-arrowhead.dir-left {
  border-top: 5px solid transparent;
  border-bottom: 5px solid transparent;
  border-right: 8px solid #111827;
}
.ortho-arrowhead.dir-down {
  border-left: 5px solid transparent;
  border-right: 5px solid transparent;
  border-top: 8px solid #111827;
}
.ortho-arrowhead.dir-up {
  border-left: 5px solid transparent;
  border-right: 5px solid transparent;
  border-bottom: 8px solid #111827;
}
</style>
</head>
<body>
<div class="page">

<div class="shape rectangle" style="left:133.43749999999994px;top:168.69998168945307px;width:119.99999999999994px;height:39.999999999999986px;">python</div>
<div class="shape rectangle" style="left:132.99999999999994px;top:128.49999999999994px;width:119.99999999999994px;height:39.99998855590819px;">flask</div>
<div class="shape rectangle" style="left:40px;top:41px;width:119.99999999999994px;height:39.999999999999986px;">html (en/)</div>
<div class="shape rectangle" style="left:214px;top:40px;width:119.99999999999994px;height:39.999999999999986px;">json (/api)</div>
<div class="arrow" style="left:171.742861834468px;top:128.49999999999994px;width:69.31852335628878px;transform:rotate(-2.386656011696309rad);"></div>
<div class="arrow" style="left:211.30508069216717px;top:128.49999999999994px;width:65.74729885991071px;transform:rotate(-0.829617075591497rad);"></div>
<div class="arrow" style="left:214px;top:60.34482758620686px;width:54.00089178811781px;transform:rotate(3.1358455904265896rad);"></div>
</div>
</body>
</html>
```

### diagrama
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es un archivo JSON que contiene información sobre un diagrama visual. El documento está estructurado en dos secciones principales: `formas` y `flechas`. 

En la primera parte, `formas`, encontramos cuatro elementos identificados por sus propios ID únicos (como "forma-1", "forma-2" etc.), cada uno de los cuales es un rectángulo en el diagrama. Estos rectángulos tienen ubicaciones específicas definidas por las coordenadas `left` y `top`, que indican dónde deberían aparecer en una pantalla o hoja de papel, además de contener texto informativo como "python", "flask", etc.

La segunda parte del documento, `flechas`, describe tres líneas rectas conectando estos elementos. Cada línea está definida por un punto de inicio (el ID del rectángulo desde el cual sale la flecha) y un punto final (el ID del rectángulo al que llega). Esto ayuda a visualizar las relaciones entre los diferentes componentes en el diagrama, como si estuvieran conectados o interrelacionados.

Este tipo de representación es útil para estudiantes ya que muestra cómo distintas partes tecnológicas (como Python y Flask) pueden estar relacionadas en proyectos de desarrollo web.

`diagrama.json`

```json
{
  "formas": [
    {
      "id": "forma-1",
      "tipo": "rectangle",
      "left": "466px",
      "top": "287.2px",
      "width": "",
      "height": "",
      "texto": "python"
    },
    {
      "id": "forma-2",
      "tipo": "rectangle",
      "left": "465.563px",
      "top": "247px",
      "width": "",
      "height": "",
      "texto": "flask"
    },
    {
      "id": "forma-3",
      "tipo": "rectangle",
      "left": "372.563px",
      "top": "159.5px",
      "width": "",
      "height": "",
      "texto": "html (en/)"
    },
    {
      "id": "forma-4",
      "tipo": "rectangle",
      "left": "546.563px",
      "top": "158.5px",
      "width": "",
      "height": "",
      "texto": "json (/api)"
    }
  ],
  "flechas": [
    {
      "desde": {
        "shapeId": "forma-2",
        "propId": null,
        "side": null
      },
      "hasta": {
        "shapeId": "forma-3",
        "propId": null,
        "side": null
      },
      "tipo": "simple",
      "estilo": "straight"
    },
    {
      "desde": {
        "shapeId": "forma-2",
        "propId": null,
        "side": null
      },
      "hasta": {
        "shapeId": "forma-4",
        "propId": null,
        "side": null
      },
      "tipo": "simple",
      "estilo": "straight"
    },
    {
      "desde": {
        "shapeId": "forma-4",
        "propId": null,
        "side": null
      },
      "hasta": {
        "shapeId": "forma-3",
        "propId": null,
        "side": null
      },
      "tipo": "simple",
      "estilo": "straight"
    }
  ]
}
```

### diagrama
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código define cuatro clases en Python utilizando un concepto llamado "data classes", que simplifica la creación de objetos con atributos específicos. Las clases aquí representan entidades del mundo real, como `Cliente`, `Producto`, `Pedido` y `Lineaspedido`. Cada clase tiene sus propios atributos que describen las características de esa entidad.

Por ejemplo, la clase `Cliente` contiene atributos para el identificador (`id`), nombre (`nombre`) y apellidos (`apellidos`) del cliente. De manera similar, la clase `Producto` incluye un identificador (`id`), un nombre (`nombre`) y un precio (`precio`). 

Las clases `Pedido` y `Lineaspedido` tienen referencias a otras entidades: `Pedido` se relaciona con un `Cliente`, mientras que `Lineaspedido` se relaciona tanto con un `Producto` como con un `Pedido`. Estas relaciones entre las diferentes clases (que se indican en comentarios como "FK1" y "FK2") representan cómo los pedidos están asociados a clientes y productos, lo cual es común en sistemas de gestión de inventario o tiendas en línea.

Este tipo de diseño ayuda a organizar la información de una manera estructurada y permite realizar operaciones más complejas, como buscar todos los pedidos relacionados con un cliente específico.

`diagrama.py`

```python
from dataclasses import dataclass
from typing import Optional

@dataclass
class Cliente:
    id: Optional[int] = None
    nombre: Optional[str] = None
    apellidos: Optional[str] = None

@dataclass
class Producto:
    id: Optional[int] = None
    nombre: Optional[str] = None
    precio: Optional[str] = None

@dataclass
class Pedido:
    id: Optional[int] = None
    fecha: Optional[str] = None
    cliente_id: Optional[int] = None

    # FK1: cliente_id -> cliente.id

@dataclass
class Lineaspedido:
    id: Optional[int] = None
    fecha: Optional[str] = None
    pedido_id: Optional[int] = None
    producto_id: Optional[int] = None
    cantidad: Optional[str] = None

    # FK1: pedido_id -> pedido.id
    # FK2: producto_id -> producto.id
```

### diagrama
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código SVG (Scalable Vector Graphics) crea un diagrama visual que representa la relación entre diferentes componentes de una aplicación web, probablemente en el contexto de desarrollo web con Python y Flask. 

El fragmento describe varios rectángulos etiquetados como "python", "flask", "html" e "json". Estos rectángulos están dispuestos en un espacio definido por coordenadas específicas y tienen estilos predefinidos que incluyen colores de relleno, bordes y redondez en las esquinas. Además del SVG básico, se añaden pequeñas flechas entre los rectángulos para mostrar cómo estos componentes interactúan entre sí.

En este contexto, el rectángulo "python" podría representar un backend o servidor que utiliza Flask (un micro framework de Python), mientras que "html" y "json" podrían referirse a las interfaces del usuario y al formato en que se intercambia información con otros sistemas. Las flechas indican la dirección de flujo, por ejemplo, cómo el backend de Python interactúa con HTML para generar páginas web o cómo maneja solicitudes JSON desde un API.

Este diagrama es útil porque proporciona una visión conceptual del funcionamiento de las diferentes partes de una aplicación web y cómo se conectan. Es especialmente relevante en cursos de programación orientados a proyectos que involucran desarrollo web con Python y Flask, ya que ayuda a entender la estructura general del sistema desde un punto de vista visual.

`diagrama.svg`

```
<svg xmlns="http://www.w3.org/2000/svg" width="374" height="248.69998168945307" viewBox="0 0 374 248.69998168945307">

  <defs>
    <style>
      text { font-family: system-ui, -apple-system, "Segoe UI", sans-serif; font-size: 12px; fill: #111827; }
      .shape-rect { fill: #ffffff; stroke: #9ca3af; stroke-width: 1; }
      .shape-entity { fill: #ffffff; stroke: #111827; stroke-width: 2; }
      .shape-circle { fill: #ffffff; stroke: #9ca3af; stroke-width: 1; }
      .shape-pill { fill: #ffffff; stroke: #9ca3af; stroke-width: 1; }
      .shape-db { fill: #ffffff; stroke: #9ca3af; stroke-width: 1; }
      .conn { stroke: #111827; stroke-width: 2; fill: none; }
    </style>
    <marker id="arrow-end" markerWidth="10" markerHeight="7" refX="10" refY="3.5"
            orient="auto" markerUnits="strokeWidth">
      <polygon points="0 0, 10 3.5, 0 7" fill="#111827"/>
    </marker>
    <marker id="arrow-start" markerWidth="10" markerHeight="7" refX="0" refY="3.5"
            orient="auto" markerUnits="strokeWidth">
      <polygon points="10 0, 0 3.5, 10 7" fill="#111827"/>
    </marker>
  </defs>
        
<rect class="shape-rect" x="133.43749999999994" y="168.69998168945307" width="119.99999999999994" height="39.999999999999986" rx="4" ry="4" />
<text x="193.43749999999991" y="192.69998168945307" text-anchor="middle">python</text>
<rect class="shape-rect" x="132.99999999999994" y="128.49999999999994" width="119.99999999999994" height="39.99998855590819" rx="4" ry="4" />
<text x="192.99999999999991" y="152.49999427795404" text-anchor="middle">flask</text>
<rect class="shape-rect" x="40" y="41" width="119.99999999999994" height="39.999999999999986" rx="4" ry="4" />
<text x="99.99999999999997" y="65" text-anchor="middle">html (en/)</text>
<rect class="shape-rect" x="214" y="40" width="119.99999999999994" height="39.999999999999986" rx="4" ry="4" />
<text x="274" y="63.99999999999999" text-anchor="middle">json (/api)</text>
<path class="conn" d="M 171.742861834468 128.49999999999994 L 121.25714424724976 80.99999999999997" marker-end="url(#arrow-end)" />
<path class="conn" d="M 211.30508069216717 128.49999999999994 L 255.69491407070575 79.99999999999997" marker-end="url(#arrow-end)" />
<path class="conn" d="M 214 60.34482758620686 L 160 60.65517241379308" marker-end="url(#arrow-end)" />
</svg>
```

### Actividades propuestas

Aquí tienes una revisión y explicación de los archivos proporcionados:

### Diagrama HTML (diagrama.html)
El archivo `diagrama.html` contiene un diagrama simple con cuatro cuadrados que representan diferentes tecnologías o elementos del sistema:
1. **Python**: Situado en la parte inferior derecha.
2. **Flask**: Sobre el bloque de Python.
3. **HTML (en/)**: En la parte izquierda inferior.
4. **JSON (/api)**: A la derecha y un poco más arriba que HTML.

### Diagrama JSON (diagrama.json)
El archivo `diagrama.json` contiene una representación en formato JSON del mismo diagrama:
- **Formas**: Representan los bloques cuadrados.
- **Flechas**: Indican las conexiones entre estos elementos. 

La estructura es bastante simple y lineal.

### Diagrama SVG (diagrama.svg)
El archivo `diagrama.svg` contiene un diagrama en formato vectorial que muestra los mismos cuatro elementos con flechas de conexión:
1. **Python**
2. **Flask** 
3. **HTML (en/)** 
4. **JSON (/api)**
   
Las conexiones entre estos elementos están representadas mediante líneas de diferentes direcciones.

### Diagrama Python (diagrama.py)
El archivo `diagrama.py` contiene definiciones de clases que representan una base de datos simple:

- **Cliente**: Tiene atributos `id`, `nombre`, y `apellidos`.
- **Producto**: Contiene `id`, `nombre`, y `precio`.
- **Pedido**: Incluye `id`, `fecha`, y un campo `cliente_id` con una clave foránea que referencia al cliente.
- **Lineaspedido** (o "líneas de pedido"): Tiene atributos como `id`, `fecha`, `pedido_id`, y `producto_id`. Este último es una clave foránea que se asocia a la tabla Producto, mientras que `pedido_id` se refiere a un Pedido.

### Descripción del Modelo
- **Cliente** y **Producto**: Son entidades básicas con información de identificación.
- **Pedido**: Relacionado directamente con el Cliente a través de una clave foránea (`cliente_id`).
- **Lineaspedido**: Representa las líneas individuales dentro de un pedido, relacionada tanto con Pedidos como con Productos.

### Conclusión
El conjunto de archivos proporcionados incluye representaciones gráficas del sistema (HTML, JSON, SVG) y una implementación básica en Python que es semánticamente coherente con estas representaciones. El modelo de clases define cómo podrían estructurarse los datos en un sistema que usa esta arquitectura.

Este conjunto de archivos parece ser la base para el desarrollo de un pequeño sistema web que maneja pedidos, productos y clientes, probablemente usando Flask (o alguna otra biblioteca o marco similar) como framework backend.


<a id="composicion-de-clases"></a>
## Composición de clases

### una primera clase
<small>Creado: 2025-12-05 08:39</small>

`001-una primera clase.py`

```python
class Alumno():
  def __init__(self,nombre,apellidos,email):
    self.nombre = nombre
    self.apellidos = apellidos
    self.email = email
    
alumno1 = Alumno("Jose Vicente","Carratala","info@jocarsa.com")
print(alumno1)
```

### una segunda clase
<small>Creado: 2025-12-05 08:41</small>

`002-una segunda clase.py`

```python
class Profesor():
  def __init__(self,nombre,apellidos,email):
    self.nombre = nombre
    self.apellidos = apellidos
    self.email = email

class Alumno():
  def __init__(self,nombre,apellidos,email):
    self.nombre = nombre
    self.apellidos = apellidos
    self.email = email
    
alumno1 = Alumno("Jose Vicente","Carratala","info@jocarsa.com")
print(alumno1)

profesor1 = Profesor("Juan","Garcia","juan@jocarsa.com")
print(profesor1)
```

### polimorfismo basico
<small>Creado: 2025-12-05 08:42</small>

`003-polimorfismo basico.py`

```python
class Profesor():
  def __init__(self,nombre,apellidos,email):
    self.nombre = nombre
    self.apellidos = apellidos
    self.email = email
  def dameDatos(self):
    return self.nombre+self.apellidos

class Alumno():
  def __init__(self,nombre,apellidos,email):
    self.nombre = nombre
    self.apellidos = apellidos
    self.email = email
  def dameDatos(self):
    return self.nombre+self.apellidos
    
alumno1 = Alumno("Jose Vicente","Carratala","info@jocarsa.com")
print(alumno1.dameDatos())

profesor1 = Profesor("Juan","Garcia","juan@jocarsa.com")
print(profesor1.dameDatos())
```

### superclase
<small>Creado: 2025-12-05 08:51</small>

`004-superclase.py`

```python
class Persona():
  def __init__(self,nombre,apellidos,email,direccion):
    self.nombre = nombre
    self.apellidos = apellidos
    self.email = email
    self.direccion = direccion
  def dameDatos(self):
    return self.nombre+self.apellidos

class Profesor(Persona):
  def __init__(self,nombre,apellidos,email,direccion):
  	super().__init__(nombre, apellidos, email,direccion)
  
class Alumno(Persona):
  def __init__(self,nombre,apellidos,email,direccion):
    super().__init__(nombre, apellidos, email,direccion)
  
    
alumno1 = Alumno("Jose Vicente","Carratala","info@jocarsa.com","Direccion")
print(alumno1.dameDatos())

profesor1 = Profesor("Juan","Garcia","juan@jocarsa.com","Direccion")
print(profesor1.dameDatos())
```

### subclases
<small>Creado: 2025-12-05 08:53</small>

`005-subclases.py`

```python
class Persona():
  def __init__(self,nombre,apellidos,email,direccion):
    self.nombre = nombre
    self.apellidos = apellidos
    self.email = email
    self.direccion = direccion
  def dameDatos(self):
    return self.nombre+self.apellidos

class Profesor(Persona):
  def __init__(self,nombre,apellidos,email,direccion):
  	super().__init__(nombre, apellidos, email,direccion)
  
class Alumno(Persona):
  def __init__(self,nombre,apellidos,email,direccion):
    super().__init__(nombre, apellidos, email,direccion)

class AlumnoOnline(Alumno):
  def __init__(self,nombre,apellidos,email,direccion):
    super().__init__(nombre, apellidos, email,direccion)

class AlumnoPresencial(Alumno):
  def __init__(self,nombre,apellidos,email,direccion):
    super().__init__(nombre, apellidos, email,direccion)
    
alumno1 = Alumno("Jose Vicente","Carratala","info@jocarsa.com","Direccion")
print(alumno1.dameDatos())

profesor1 = Profesor("Juan","Garcia","juan@jocarsa.com","Direccion")
print(profesor1.dameDatos())
```

### diagrama
<small>Creado: 2025-12-05 08:55</small>

`diagrama.html`

```html
<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>Diagrama exportado</title>
<style>
body {
  margin: 0;
  padding: 20px;
  background: #f3f3f7;
  font-family: system-ui, -apple-system, "Segoe UI", sans-serif;
}
.page {
  position: relative;
  background: #ffffff;
  border: 1px solid #d1d5db;
  box-shadow: 0 2px 4px rgba(0,0,0,.1);
  width: 590.5375332302516px;
  height: 305.56251525878895px;
  overflow: visible;
}

/* formas básicas */
.shape {
  position: absolute;
  min-width: 120px;
  min-height: 40px;
  padding: 6px 10px;
  background: #ffffff;
  border-radius: 4px;
  border: 1px solid #9ca3af;
  box-shadow: 0 1px 2px rgba(0,0,0,0.15);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 13px;
}

.shape.rectangle {
  border-radius: 4px;
}

.shape.pill {
  border-radius: 999px;
}

.shape.circle {
  border-radius: 999px;
  width: 80px;
  height: 80px;
  padding: 0;
  justify-content: center;
}

/* base de datos */
.shape.db {
  min-width: 120px;
  min-height: 60px;
  padding-top: 20px;
  border-radius: 60px / 16px;
  background: linear-gradient(180deg, #e5e7eb 0%, #ffffff 40%, #e5e7eb 100%);
  position: absolute;
  overflow: hidden;
  text-align: center;
}
.shape.db::before {
  content: "";
  position: absolute;
  top: 0;
  left: 8px;
  right: 8px;
  height: 18px;
  border-radius: 999px;
  border: 1px solid #9ca3af;
  background: radial-gradient(circle at 50% 30%, #ffffff 0%, #e5e7eb 70%);
}
.shape.db::after {
  content: "";
  position: absolute;
  bottom: 0;
  left: 8px;
  right: 8px;
  height: 18px;
  border-radius: 999px;
  border: 1px solid rgba(156, 163, 175, 0.6);
  border-top: none;
  background: radial-gradient(circle at 50% 70%, #e5e7eb 0%, #d1d5db 70%);
}

/* entidades ER */
.shape.entity {
  width: 220px;
  min-height: 80px;
  background: #ffffff;
  border: 2px solid #111827;
  border-radius: 4px;
  box-shadow: 0 2px 4px rgba(0,0,0,.15);
  display: flex;
  flex-direction: column;
  font-size: 13px;
  overflow: hidden;
  padding: 0;
}
.entity-header {
  background: #f3f4f6;
  padding: 4px 8px;
  font-weight: 600;
  text-align: center;
  border-bottom: 1px solid #e5e7eb;
}
.entity-properties {
  flex: 1;
  padding: 4px 4px 0 4px;
}
.entity-property {
  display: grid;
  grid-template-columns: 14px 1fr 14px;
  align-items: center;
  column-gap: 4px;
  padding: 2px 0;
}
.entity-property .property-name {
  padding: 2px 4px;
  border-radius: 3px;
}

/* puertos */
.port {
  width: 9px;
  height: 9px;
  border-radius: 50%;
  border: 1px solid #111827;
  background: #ffffff;
}
.port-left { justify-self: start; }
.port-right { justify-self: end; }

/* flechas rectas */
.arrow {
  position: absolute;
  height: 2px;
  background: #111827;
  transform-origin: 0 50%;
}
.arrow::after {
  content: "";
  position: absolute;
  right: 0;
  top: 50%;
  transform: translateY(-50%);
  border-top: 5px solid transparent;
  border-bottom: 5px solid transparent;
  border-left: 8px solid #111827;
}
.arrow-double::before {
  content: "";
  position: absolute;
  left: 0;
  top: 50%;
  transform: translateY(-50%) rotate(180deg);
  border-top: 5px solid transparent;
  border-bottom: 5px solid transparent;
  border-left: 8px solid #111827;
}

/* flechas ortogonales */
.ortho-arrow {
  position: absolute;
  left: 0;
  top: 0;
}
.ortho-arrow .ortho-seg {
  position: absolute;
  background: #111827;
}
.ortho-seg.seg-horizontal { height: 2px; }
.ortho-seg.seg-vertical { width: 2px; }
.ortho-arrowhead {
  position: absolute;
  width: 0;
  height: 0;
}
.ortho-arrowhead.dir-right {
  border-top: 5px solid transparent;
  border-bottom: 5px solid transparent;
  border-left: 8px solid #111827;
}
.ortho-arrowhead.dir-left {
  border-top: 5px solid transparent;
  border-bottom: 5px solid transparent;
  border-right: 8px solid #111827;
}
.ortho-arrowhead.dir-down {
  border-left: 5px solid transparent;
  border-right: 5px solid transparent;
  border-top: 8px solid #111827;
}
.ortho-arrowhead.dir-up {
  border-left: 5px solid transparent;
  border-right: 5px solid transparent;
  border-bottom: 8px solid #111827;
}
</style>
</head>
<body>
<div class="page">

<div class="shape rectangle" style="left:184.43754408094605px;top:40px;width:119.99994913736974px;height:39.999999999999986px;">Persona</div>
<div class="shape rectangle" style="left:40px;top:134.4625091552734px;width:120.00002543131505px;height:39.999999999999986px;">Profesor</div>
<div class="shape rectangle" style="left:310.5500115288627px;top:137.77502271864145px;width:119.99999999999996px;height:39.999999999999986px;">Alumno</div>
<div class="shape rectangle" style="left:226.10004001193568px;top:225.56251525878898px;width:126.11246744791661px;height:39.999999999999986px;">AlumnoPresencial</div>
<div class="shape rectangle" style="left:430.5375332302516px;top:220.54998609754765px;width:119.99999999999996px;height:39.999999999999986px;">AlumnoOnline</div>
<div class="arrow" style="left:213.85660200331301px;top:79.99999999999997px;width:99.50378162339078px;transform:rotate(2.5624087757364773rad);"></div>
<div class="arrow" style="left:270.23398268976405px;top:79.99999999999997px;width:94.29272924232689px;transform:rotate(0.6594975025112086rad);"></div>
<div class="arrow" style="left:352.00665519464565px;top:177.77502271864145px;width:65.16714600671723px;transform:rotate(2.3184201262342294rad);"></div>
<div class="arrow" style="left:399.5412709153853px;top:177.77502271864145px;width:75.32806834248883px;transform:rotate(0.6038902262109669rad);"></div>
</div>
</body>
</html>
```

### diagrama
<small>Creado: 2025-12-05 08:55</small>

`diagrama.json`

```json
{
  "formas": [
    {
      "id": "forma-1",
      "tipo": "rectangle",
      "left": "530.842px",
      "top": "204.043px",
      "width": "",
      "height": "",
      "texto": "Persona"
    },
    {
      "id": "forma-2",
      "tipo": "rectangle",
      "left": "386.408px",
      "top": "298.5px",
      "width": "",
      "height": "",
      "texto": "Profesor"
    },
    {
      "id": "forma-3",
      "tipo": "rectangle",
      "left": "656.954px",
      "top": "301.824px",
      "width": "",
      "height": "",
      "texto": "Alumno"
    },
    {
      "id": "forma-4",
      "tipo": "rectangle",
      "left": "572.504px",
      "top": "389.603px",
      "width": "",
      "height": "",
      "texto": "AlumnoPresencial"
    },
    {
      "id": "forma-5",
      "tipo": "rectangle",
      "left": "776.939px",
      "top": "384.599px",
      "width": "",
      "height": "",
      "texto": "AlumnoOnline"
    }
  ],
  "flechas": [
    {
      "desde": {
        "shapeId": "forma-1",
        "propId": null,
        "side": null
      },
      "hasta": {
        "shapeId": "forma-2",
        "propId": null,
        "side": null
      },
      "tipo": "simple",
      "estilo": "straight"
    },
    {
      "desde": {
        "shapeId": "forma-1",
        "propId": null,
        "side": null
      },
      "hasta": {
        "shapeId": "forma-3",
        "propId": null,
        "side": null
      },
      "tipo": "simple",
      "estilo": "straight"
    },
    {
      "desde": {
        "shapeId": "forma-3",
        "propId": null,
        "side": null
      },
      "hasta": {
        "shapeId": "forma-4",
        "propId": null,
        "side": null
      },
      "tipo": "simple",
      "estilo": "straight"
    },
    {
      "desde": {
        "shapeId": "forma-3",
        "propId": null,
        "side": null
      },
      "hasta": {
        "shapeId": "forma-5",
        "propId": null,
        "side": null
      },
      "tipo": "simple",
      "estilo": "straight"
    }
  ]
}
```

### diagrama
<small>Creado: 2025-12-05 08:55</small>

`diagrama.svg`

```
<svg xmlns="http://www.w3.org/2000/svg" width="590.5375332302516" height="305.56251525878895" viewBox="0 0 590.5375332302516 305.56251525878895">

  <defs>
    <style>
      text { font-family: system-ui, -apple-system, "Segoe UI", sans-serif; font-size: 12px; fill: #111827; }
      .shape-rect { fill: #ffffff; stroke: #9ca3af; stroke-width: 1; }
      .shape-entity { fill: #ffffff; stroke: #111827; stroke-width: 2; }
      .shape-circle { fill: #ffffff; stroke: #9ca3af; stroke-width: 1; }
      .shape-pill { fill: #ffffff; stroke: #9ca3af; stroke-width: 1; }
      .shape-db { fill: #ffffff; stroke: #9ca3af; stroke-width: 1; }
      .conn { stroke: #111827; stroke-width: 2; fill: none; }
    </style>
    <marker id="arrow-end" markerWidth="10" markerHeight="7" refX="10" refY="3.5"
            orient="auto" markerUnits="strokeWidth">
      <polygon points="0 0, 10 3.5, 0 7" fill="#111827"/>
    </marker>
    <marker id="arrow-start" markerWidth="10" markerHeight="7" refX="0" refY="3.5"
            orient="auto" markerUnits="strokeWidth">
      <polygon points="10 0, 0 3.5, 10 7" fill="#111827"/>
    </marker>
  </defs>
        
<rect class="shape-rect" x="184.43754408094605" y="40" width="119.99994913736974" height="39.999999999999986" rx="4" ry="4" />
<text x="244.43751864963093" y="63.99999999999999" text-anchor="middle">Persona</text>
<rect class="shape-rect" x="40" y="134.4625091552734" width="120.00002543131505" height="39.999999999999986" rx="4" ry="4" />
<text x="100.00001271565753" y="158.4625091552734" text-anchor="middle">Profesor</text>
<rect class="shape-rect" x="310.5500115288627" y="137.77502271864145" width="119.99999999999996" height="39.999999999999986" rx="4" ry="4" />
<text x="370.5500115288627" y="161.77502271864145" text-anchor="middle">Alumno</text>
<rect class="shape-rect" x="226.10004001193568" y="225.56251525878898" width="126.11246744791661" height="39.999999999999986" rx="4" ry="4" />
<text x="289.156273735894" y="249.56251525878898" text-anchor="middle">AlumnoPresencial</text>
<rect class="shape-rect" x="430.5375332302516" y="220.54998609754765" width="119.99999999999996" height="39.999999999999986" rx="4" ry="4" />
<text x="490.5375332302516" y="244.54998609754765" text-anchor="middle">AlumnoOnline</text>
<path class="conn" d="M 213.85660200331301 79.99999999999997 L 130.58092936197556 134.4625091552734" marker-end="url(#arrow-end)" />
<path class="conn" d="M 270.23398268976405 79.99999999999997 L 344.7535474887296 137.77502271864145" marker-end="url(#arrow-end)" />
<path class="conn" d="M 352.00665519464565 177.77502271864145 L 307.69963007011097 225.56251525878898" marker-end="url(#arrow-end)" />
<path class="conn" d="M 399.5412709153853 177.77502271864145 L 461.54627384372895 220.54998609754765" marker-end="url(#arrow-end)" />
</svg>
```


<a id="herencia-y-polimorfismo"></a>
## Herencia y polimorfismo

### herencia simple
<small>Creado: 2025-12-05 09:10</small>

`001-herencia simple.py`

```python
class Persona():
  def __init__(self,nombre,apellidos):
    self.nombre = nombre
    self.apellidos = apellidos
  def dameDatos(self):
    return self.nombre+self.apellidos

class Profesor(Persona):
  def __init__(self,nombre,apellidos):
  	super().__init__(nombre, apellidos)
  
class Alumno(Persona):
  def __init__(self,nombre,apellidos,email,direccion):
    super().__init__(nombre, apellidos)

    
alumno1 = Alumno("Jose Vicente","Carratala")
print(alumno1.dameDatos())

profesor1 = Profesor("Juan","Garcia")
print(profesor1.dameDatos())
```

### polimorfismo basico
<small>Creado: 2025-12-05 09:11</small>

`002-polimorfismo basico.py`

```python
class Persona():
  def __init__(self,nombre,apellidos):
    self.nombre = nombre
    self.apellidos = apellidos
  def dameDatos(self):
    return self.nombre+self.apellidos

class Profesor(Persona):
  def __init__(self,nombre,apellidos):
  	super().__init__(nombre, apellidos)
  def dameDatos(self):
    return "Profesor: "+self.nombre+" "+self.apellidos
  
class Alumno(Persona):
  def __init__(self,nombre,apellidos):
    super().__init__(nombre, apellidos)
  def dameDatos(self):
    return "Alumno: "+self.nombre+" "+self.apellidos

    
alumno1 = Alumno("Jose Vicente","Carratala")
print(alumno1.dameDatos())

profesor1 = Profesor("Juan","Garcia")
print(profesor1.dameDatos())
```


<a id="jerarquia-de-clases-superclases-y-subclases"></a>
## Jerarquía de clases Superclases y subclases

### preparamos
<small>Creado: 2025-12-09 10:35</small>

`001-preparamos.html`

```html
<!doctype html>
<html>
  <head>
  </head>
  <body>
    <img src="nave.png" id="nave">
  </body>
</html>
```

### script de movimiento
<small>Creado: 2025-12-09 10:38</small>

`002-script de movimiento.html`

```html
<!doctype html>
<html>
  <head>
  </head>
  <body>
    <img src="nave.png" id="nave">
  </body>
  <script>
    let nave = document.querySelector("#nave");
    let posx = 40;
    let posy = 40;
    
    document.onkeydown = function(tecla){		// Cuando sobre el documento pulse tec
    	console.log(tecla)
    }
  </script>
</html>
```

### keycodes
<small>Creado: 2025-12-09 10:48</small>

`003-keycodes.html`

```html
<!doctype html>
<html>
  <head>
    <style>
      #nave{position:absolute;width:50px;}
    </style>
  </head>
  <body>
    <img src="nave.png" id="nave">
  </body>
  <script>
    let nave = document.querySelector("#nave");
    let posx = 40;
    let posy = 40;
    
    document.onkeydown = function(tecla){		// Cuando sobre el documento pulse tec
    	console.log(tecla)
      // w = 87, s = 83, a = 65 , d= 68
      
      switch(tecla.keyCode){     
        case 87:			// Si pulso W
          posy -= 5;	// Subo cinco unidades en Y
          console.log("aqui entro")
          break;
        case 83:			// Si pulso S
          posy += 5;	// Bajo cinco unidades en Y
          break;
        case 65:			// Si pulso A
          posx -= 5;	// Quito cinco unidades en X
          break;
        case 68:			// Si pulso D
          posx += 5;	// Sumo cinco unidades en X
          break;
      }
      nave.style.left = posx+"px";
      nave.style.top = posy+"px";
    }
  </script>
</html>
```

### clase nave
<small>Creado: 2025-12-09 10:52</small>

`004-clase nave.html`

```html
<!doctype html>
<html>
  <head>
    <style>
      #nave{position:absolute;width:50px;}
    </style>
  </head>
  <body>
    <img src="nave.png" id="nave">
  </body>
  <script>
    // Primero declaramos una clase
    class Jugador{
    	constructor(x,y){
      	this.posx = x;
        this.posy = y;
      }
    }
    // Ahora creo una instancia del jugador
    let InstanciaJugador = new Jugador(40,40)
    let nave = document.querySelector("#nave");

    
    document.onkeydown = function(tecla){		// Cuando sobre el documento pulse tec
    	console.log(tecla)
      // w = 87, s = 83, a = 65 , d= 68
      
      switch(tecla.keyCode){     
        case 87:			// Si pulso W
          InstanciaJugador.posy -= 5;	// Subo cinco unidades en Y
          console.log("aqui entro")
          break;
        case 83:			// Si pulso S
          InstanciaJugador.posy += 5;	// Bajo cinco unidades en Y
          break;
        case 65:			// Si pulso A
          InstanciaJugador.posx -= 5;	// Quito cinco unidades en X
          break;
        case 68:			// Si pulso D
          InstanciaJugador.posx += 5;	// Sumo cinco unidades en X
          break;
      }
      nave.style.left = InstanciaJugador.posx+"px";
      nave.style.top = InstanciaJugador.posy+"px";
    }
  </script>
</html>
```

### rocas
<small>Creado: 2025-12-09 11:06</small>

`005-rocas.html`

```html
<!doctype html>
<html>
  <head>
    <style>
      #nave{position:absolute;width:50px;}
      .roca{width:50px;}
    </style>
  </head>
  <body>
    <img src="nave.png" id="nave">
  </body>
  <script>
    // Primero declaramos una clase
    class Jugador{
    	constructor(x,y){
      	this.posx = x;
        this.posy = y;
      }
    }
    class Roca{
    	constructor(x,y){
      	this.posx = x;
        this.posy = y;
      }
    }
    // Voy a crear rocas
    let numero_rocas = 10;													// Digo cuantas rocas quiero
    let rocas = [];																	// Creo un array vacío
    for(let i = 0;i<numero_rocas;i++){							// Recorro un bucle
      let posx_aleatoria = Math.random()*500				// posx aleatoria entre 0 y 500
      let posy_aleatoria = Math.random()*500				// posy aleatoria entre 0 y 500
    	rocas.push(new Roca(posx_aleatoria,posy_aleatoria))	// Creo una nueva roca
    }
    // Ahora creo una instancia del jugador
    let InstanciaJugador = new Jugador(40,40)
    let nave = document.querySelector("#nave");
    document.onkeydown = function(tecla){		// Cuando sobre el documento pulse tec
      // w = 87, s = 83, a = 65 , d= 68
      switch(tecla.keyCode){     
        case 87:			// Si pulso W
          InstanciaJugador.posy -= 5;	// Subo cinco unidades en Y
          break;
        case 83:			// Si pulso S
          InstanciaJugador.posy += 5;	// Bajo cinco unidades en Y
          break;
        case 65:			// Si pulso A
          InstanciaJugador.posx -= 5;	// Quito cinco unidades en X
          break;
        case 68:			// Si pulso D
          InstanciaJugador.posx += 5;	// Sumo cinco unidades en X
          break;
      }
      nave.style.left = InstanciaJugador.posx+"px";
      nave.style.top = InstanciaJugador.posy+"px";
    }
    // Voy a dibujar rocas
    for(let i = 0;i<numero_rocas;i++){
    	let nueva_roca = document.createElement("img"); // Creo una nueva imagen
      nueva_roca.classList.add("roca")								// Le añado la clase roca
      nueva_roca.src = "roca.png"											// Cargo la imagen de la roca
      nueva_roca.style.position = "absolute"					// Le pongo absoluto para poder mover con libertad
      nueva_roca.style.left = rocas[i].posx+"px"					// Le pongo su posicion X
      nueva_roca.style.top = rocas[i].posy+"px"						// Le pongo su posicion Y
      document.querySelector("body").appendChild(nueva_roca)	// Añado la roca al body
    }
  </script>
</html>
```

### variaciones en las rocas
<small>Creado: 2025-12-09 11:13</small>

`006-variaciones en las rocas.html`

```html
<!doctype html>
<html>
  <head>
    <style>
      #nave{position:absolute;width:50px;}
      .roca{width:50px;}
    </style>
  </head>
  <body>
    <img src="nave.png" id="nave">
  </body>
  <script>
    // Primero declaramos una clase
    class Jugador{
    	constructor(x,y,a){
      	this.posx = x;
        this.posy = y;
        this.angulo = a;  													// NUEVO ////////
      }
    }
    class Roca{
    	constructor(x,y,a,e){
      	this.posx = x;
        this.posy = y;
        this.angulo = a;														// NUEVO ////////
        this.escala = e;														// NUEVO ////////
      }
    }
    // Voy a crear rocas
    let numero_rocas = 10;													// Digo cuantas rocas quiero
    let rocas = [];																	// Creo un array vacío
    for(let i = 0;i<numero_rocas;i++){							// Recorro un bucle
      let posx_aleatoria = Math.random()*500				// posx aleatoria entre 0 y 500
      let posy_aleatoria = Math.random()*500				// posy aleatoria entre 0 y 500
      let angulo_aleatorio = Math.random()*360
      let escala_aleatoria = Math.random()*1
    	rocas.push(new Roca(
        posx_aleatoria,
        posy_aleatoria,
        angulo_aleatorio,
        escala_aleatoria
      ))	// Creo una nueva roca									// NUEVO /////////////
    }
    // Ahora creo una instancia del jugador
    let InstanciaJugador = new Jugador(40,40,0)		// NUEVO /////////////
    let nave = document.querySelector("#nave");
    document.onkeydown = function(tecla){		// Cuando sobre el documento pulse tec
      // w = 87, s = 83, a = 65 , d= 68
      switch(tecla.keyCode){     
        case 87:			// Si pulso W
          InstanciaJugador.posy -= 5;	// Subo cinco unidades en Y
          break;
        case 83:			// Si pulso S
          InstanciaJugador.posy += 5;	// Bajo cinco unidades en Y
          break;
        case 65:			// Si pulso A
          InstanciaJugador.posx -= 5;	// Quito cinco unidades en X
          break;
        case 68:			// Si pulso D
          InstanciaJugador.posx += 5;	// Sumo cinco unidades en X
          break;
      }
      nave.style.left = InstanciaJugador.posx+"px";
      nave.style.top = InstanciaJugador.posy+"px";
    }
    // Voy a dibujar rocas
    for(let i = 0;i<numero_rocas;i++){
    	let nueva_roca = document.createElement("img"); // Creo una nueva imagen
      nueva_roca.classList.add("roca")								// Le añado la clase roca
      nueva_roca.src = "roca.png"											// Cargo la imagen de la roca
      nueva_roca.style.position = "absolute"					// Le pongo absoluto para poder mover con libertad
      nueva_roca.style.left = rocas[i].posx+"px"					// Le pongo su posicion X
      nueva_roca.style.top = rocas[i].posy+"px"						// Le pongo su posicion Y
      nueva_roca.style.transform = "rotate("+rocas[i].angulo+"deg)  scale("+rocas[i].escala+")"
      document.querySelector("body").appendChild(nueva_roca)	// Añado la roca al body
    }
  </script>
</html>
```

### clase bala
<small>Creado: 2025-12-09 11:53</small>

`007-clase bala.html`

```html
<!doctype html>
<html>
  <head>
    <style>
      #nave{position:absolute;width:50px;}
      .roca{width:50px;}
    </style>
  </head>
  <body>
    <img src="nave.png" id="nave">
  </body>
  <script>
    // Primero declaramos una clase
    class Bala{
    	constructor(x,y,a,v){
      	this.posx = x;
        this.posy = y;
        this.angulo = a;  	
        this.velocidad = v;
      }
    }
    class Jugador{
    	constructor(x,y,a,v){
      	this.posx = x;
        this.posy = y;
        this.angulo = a; 
        this.velocidad = v;
      }
    }
    class Roca{
    	constructor(x,y,a,e,v){
      	this.posx = x;
        this.posy = y;
        this.angulo = a;												
        this.escala = e;
        this.velocidad = v;
      }
    }
    // Voy a crear rocas
    let numero_rocas = 10;													// Digo cuantas rocas quiero
    let rocas = [];																	// Creo un array vacío
    for(let i = 0;i<numero_rocas;i++){							// Recorro un bucle
      let posx_aleatoria = Math.random()*500				// posx aleatoria entre 0 y 500
      let posy_aleatoria = Math.random()*500				// posy aleatoria entre 0 y 500
      let angulo_aleatorio = Math.random()*360
      let escala_aleatoria = Math.random()*1
    	rocas.push(new Roca(
        posx_aleatoria,
        posy_aleatoria,
        angulo_aleatorio,
        escala_aleatoria,
        0
      ))	// Creo una nueva roca	/// INICIALIZO LA VELOCIDAD A CERO								
    }
    // Ahora creo una instancia del jugador
    let InstanciaJugador = new Jugador(40,40,0,0)		// INICIALIZO VELOCIDAD A CERO
    let nave = document.querySelector("#nave");
    document.onkeydown = function(tecla){		// Cuando sobre el documento pulse tec
      // w = 87, s = 83, a = 65 , d= 68
      switch(tecla.keyCode){     
        case 87:			// Si pulso W
          InstanciaJugador.posy -= 5;	// Subo cinco unidades en Y
          break;
        case 83:			// Si pulso S
          InstanciaJugador.posy += 5;	// Bajo cinco unidades en Y
          break;
        case 65:			// Si pulso A
          InstanciaJugador.posx -= 5;	// Quito cinco unidades en X
          break;
        case 68:			// Si pulso D
          InstanciaJugador.posx += 5;	// Sumo cinco unidades en X
          break;
      }
      nave.style.left = InstanciaJugador.posx+"px";
      nave.style.top = InstanciaJugador.posy+"px";
    }
    // Voy a dibujar rocas
    for(let i = 0;i<numero_rocas;i++){
    	let nueva_roca = document.createElement("img"); // Creo una nueva imagen
      nueva_roca.classList.add("roca")								// Le añado la clase roca
      nueva_roca.src = "roca.png"											// Cargo la imagen de la roca
      nueva_roca.style.position = "absolute"					// Le pongo absoluto para poder mover con libertad
      nueva_roca.style.left = rocas[i].posx+"px"					// Le pongo su posicion X
      nueva_roca.style.top = rocas[i].posy+"px"						// Le pongo su posicion Y
      nueva_roca.style.transform = "rotate("+rocas[i].angulo+"deg)  scale("+rocas[i].escala+")"	// NUEVO /////////////////
      document.querySelector("body").appendChild(nueva_roca)	// Añado la roca al body
    }
  </script>
</html>
```

### superclase
<small>Creado: 2025-12-09 11:57</small>

`008-superclase.html`

```html
<!doctype html>
<html>
  <head>
    <style>
      #nave{position:absolute;width:50px;}
      .roca{width:50px;}
    </style>
  </head>
  <body>
    <img src="nave.png" id="nave">
  </body>
  <script>
    // Primero declaramos una clase madre (abstracta)
    class Entidad{											// Creamos una entidad como superclase
    	constructor(x,y,a,v){
      	this.posx = x;
        this.posy = y;
        this.angulo = a;  	
        this.velocidad = v;
      }
    }
    // Luego declaro las clases concretas
    class Bala extends Entidad {				// La bala extiende a la entidad
    	constructor(x,y,a,v){
      	super(x, y, a, v);							// La bala hereda estas propiedades de la entidad
      }
    }
    class Jugador extends Entidad {			// El jugador extiende a la entidad
    	constructor(x,y,a,v){
      	super(x, y, a, v);							// El jugador hereda estas propiedades de la entidad
      }
    }
    class Roca extends Entidad {				// Y la roca extiende a la entidad
    	constructor(x,y,a,e,v){
      	super(x, y, a, v);							// La roca hereda estas propiedades de la entidad										
        this.escala = e;								// Pero la roca puede tener sus propias propiedades
      }
    }
    // Voy a crear rocas
    let numero_rocas = 10;													// Digo cuantas rocas quiero
    let rocas = [];																	// Creo un array vacío
    for(let i = 0;i<numero_rocas;i++){							// Recorro un bucle
      let posx_aleatoria = Math.random()*500				// posx aleatoria entre 0 y 500
      let posy_aleatoria = Math.random()*500				// posy aleatoria entre 0 y 500
      let angulo_aleatorio = Math.random()*360
      let escala_aleatoria = Math.random()*1
    	rocas.push(new Roca(
        posx_aleatoria,
        posy_aleatoria,
        angulo_aleatorio,
        escala_aleatoria,
        0
      ))	// Creo una nueva roca	/// INICIALIZO LA VELOCIDAD A CERO								
    }
    // Ahora creo una instancia del jugador
    let InstanciaJugador = new Jugador(40,40,0,0)		// INICIALIZO VELOCIDAD A CERO
    let nave = document.querySelector("#nave");
    document.onkeydown = function(tecla){		// Cuando sobre el documento pulse tec
      // w = 87, s = 83, a = 65 , d= 68
      switch(tecla.keyCode){     
        case 87:			// Si pulso W
          InstanciaJugador.posy -= 5;	// Subo cinco unidades en Y
          break;
        case 83:			// Si pulso S
          InstanciaJugador.posy += 5;	// Bajo cinco unidades en Y
          break;
        case 65:			// Si pulso A
          InstanciaJugador.posx -= 5;	// Quito cinco unidades en X
          break;
        case 68:			// Si pulso D
          InstanciaJugador.posx += 5;	// Sumo cinco unidades en X
          break;
      }
      nave.style.left = InstanciaJugador.posx+"px";
      nave.style.top = InstanciaJugador.posy+"px";
    }
    // Voy a dibujar rocas
    for(let i = 0;i<numero_rocas;i++){
    	let nueva_roca = document.createElement("img"); // Creo una nueva imagen
      nueva_roca.classList.add("roca")								// Le añado la clase roca
      nueva_roca.src = "roca.png"											// Cargo la imagen de la roca
      nueva_roca.style.position = "absolute"					// Le pongo absoluto para poder mover con libertad
      nueva_roca.style.left = rocas[i].posx+"px"					// Le pongo su posicion X
      nueva_roca.style.top = rocas[i].posy+"px"						// Le pongo su posicion Y
      nueva_roca.style.transform = "rotate("+rocas[i].angulo+"deg)  scale("+rocas[i].escala+")"	// NUEVO /////////////////
      document.querySelector("body").appendChild(nueva_roca)	// Añado la roca al body
    }
  </script>
</html>
```

### ancho y alto del navegador
<small>Creado: 2025-12-09 12:00</small>

`009-ancho y alto del navegador.html`

```html
<!doctype html>
<html>
  <head>
    <style>
      #nave{position:absolute;width:50px;}
      .roca{width:50px;}
    </style>
  </head>
  <body>
    <img src="nave.png" id="nave">
  </body>
  <script>
    // Variables globales
    let anchopagina = window.innerWidth				// NUEVO ////////////////////
    let altopagina = window.innerHeight			// NUEVO ////////////////////
    
    // Primero declaramos una clase madre (abstracta)
    class Entidad{											// Creamos una entidad como superclase
    	constructor(x,y,a,v){
      	this.posx = x;
        this.posy = y;
        this.angulo = a;  	
        this.velocidad = v;
      }
    }
    // Luego declaro las clases concretas
    class Bala extends Entidad {				// La bala extiende a la entidad
    	constructor(x,y,a,v){
      	super(x, y, a, v);							// La bala hereda estas propiedades de la entidad
      }
    }
    class Jugador extends Entidad {			// El jugador extiende a la entidad
    	constructor(x,y,a,v){
      	super(x, y, a, v);							// El jugador hereda estas propiedades de la entidad
      }
    }
    class Roca extends Entidad {				// Y la roca extiende a la entidad
    	constructor(x,y,a,e,v){
      	super(x, y, a, v);							// La roca hereda estas propiedades de la entidad										
        this.escala = e;								// Pero la roca puede tener sus propias propiedades
      }
    }
    // Voy a crear rocas
    let numero_rocas = 1000;													// Digo cuantas rocas quiero
    let rocas = [];																	// Creo un array vacío
    for(let i = 0;i<numero_rocas;i++){							// Recorro un bucle
      let posx_aleatoria = Math.random()*anchopagina	// posx aleatoria en toda la X de la pantalla
      let posy_aleatoria = Math.random()*altopagina		// posy aleatoria en toda la Y de la pantalla
      let angulo_aleatorio = Math.random()*360
      let escala_aleatoria = Math.random()*1
    	rocas.push(new Roca(
        posx_aleatoria,
        posy_aleatoria,
        angulo_aleatorio,
        escala_aleatoria,
        0
      ))	// Creo una nueva roca	/// INICIALIZO LA VELOCIDAD A CERO								
    }
    // Ahora creo una instancia del jugador
    let InstanciaJugador = new Jugador(40,40,0,0)		// INICIALIZO VELOCIDAD A CERO
    let nave = document.querySelector("#nave");
    document.onkeydown = function(tecla){		// Cuando sobre el documento pulse tec
      // w = 87, s = 83, a = 65 , d= 68
      switch(tecla.keyCode){     
        case 87:			// Si pulso W
          InstanciaJugador.posy -= 5;	// Subo cinco unidades en Y
          break;
        case 83:			// Si pulso S
          InstanciaJugador.posy += 5;	// Bajo cinco unidades en Y
          break;
        case 65:			// Si pulso A
          InstanciaJugador.posx -= 5;	// Quito cinco unidades en X
          break;
        case 68:			// Si pulso D
          InstanciaJugador.posx += 5;	// Sumo cinco unidades en X
          break;
      }
      nave.style.left = InstanciaJugador.posx+"px";
      nave.style.top = InstanciaJugador.posy+"px";
    }
    // Voy a dibujar rocas
    for(let i = 0;i<numero_rocas;i++){
    	let nueva_roca = document.createElement("img"); // Creo una nueva imagen
      nueva_roca.classList.add("roca")								// Le añado la clase roca
      nueva_roca.src = "roca.png"											// Cargo la imagen de la roca
      nueva_roca.style.position = "absolute"					// Le pongo absoluto para poder mover con libertad
      nueva_roca.style.left = rocas[i].posx+"px"					// Le pongo su posicion X
      nueva_roca.style.top = rocas[i].posy+"px"						// Le pongo su posicion Y
      nueva_roca.style.transform = "rotate("+rocas[i].angulo+"deg)  scale("+rocas[i].escala+")"	// NUEVO /////////////////
      document.querySelector("body").appendChild(nueva_roca)	// Añado la roca al body
    }
  </script>
</html>
```

### quiero que la nave empiece en cualquier punto
<small>Creado: 2025-12-09 12:03</small>

`010-quiero que la nave empiece en cualquier punto.html`

```html
<!doctype html>
<html>
  <head>
    <style>
      #nave{position:absolute;width:50px;}
      .roca{width:50px;}
    </style>
  </head>
  <body>
    <img src="nave.png" id="nave">
  </body>
  <script>
    // Variables globales
    let anchopagina = window.innerWidth				// NUEVO ////////////////////
    let altopagina = window.innerHeight			// NUEVO ////////////////////
    
    // Primero declaramos una clase madre (abstracta)
    class Entidad{											// Creamos una entidad como superclase
    	constructor(x,y,a,v){
      	this.posx = x;
        this.posy = y;
        this.angulo = a;  	
        this.velocidad = v;
      }
    }
    // Luego declaro las clases concretas
    class Bala extends Entidad {				// La bala extiende a la entidad
    	constructor(x,y,a,v){
      	super(x, y, a, v);							// La bala hereda estas propiedades de la entidad
      }
    }
    class Jugador extends Entidad {			// El jugador extiende a la entidad
    	constructor(x,y,a,v){
      	super(x, y, a, v);							// El jugador hereda estas propiedades de la entidad
      }
    }
    class Roca extends Entidad {				// Y la roca extiende a la entidad
    	constructor(x,y,a,e,v){
      	super(x, y, a, v);							// La roca hereda estas propiedades de la entidad										
        this.escala = e;								// Pero la roca puede tener sus propias propiedades
      }
    }
    // Voy a crear rocas
    let numero_rocas = 100;													// Digo cuantas rocas quiero
    let rocas = [];																	// Creo un array vacío
    for(let i = 0;i<numero_rocas;i++){							// Recorro un bucle
      let posx_aleatoria = Math.random()*anchopagina	// posx aleatoria en toda la X de la pantalla
      let posy_aleatoria = Math.random()*altopagina		// posy aleatoria en toda la Y de la pantalla
      let angulo_aleatorio = Math.random()*360
      let escala_aleatoria = Math.random()*1
    	rocas.push(new Roca(
        posx_aleatoria,
        posy_aleatoria,
        angulo_aleatorio,
        escala_aleatoria,
        0
      ))	// Creo una nueva roca	/// INICIALIZO LA VELOCIDAD A CERO								
    }
    // Ahora creo una instancia del jugador
    let nave = document.querySelector("#nave");
    let InstanciaJugador = new Jugador(
      Math.random()*anchopagina,
      Math.random()*altopagina,
       0,0)		 																// NUEVO /////////////////////////
   	nave.style.left = InstanciaJugador.posx+"px";
    nave.style.top = InstanciaJugador.posy+"px";
    
    document.onkeydown = function(tecla){		// Cuando sobre el documento pulse tec
      // w = 87, s = 83, a = 65 , d= 68
      switch(tecla.keyCode){     
        case 87:			// Si pulso W
          InstanciaJugador.posy -= 5;	// Subo cinco unidades en Y
          break;
        case 83:			// Si pulso S
          InstanciaJugador.posy += 5;	// Bajo cinco unidades en Y
          break;
        case 65:			// Si pulso A
          InstanciaJugador.posx -= 5;	// Quito cinco unidades en X
          break;
        case 68:			// Si pulso D
          InstanciaJugador.posx += 5;	// Sumo cinco unidades en X
          break;
      }
      nave.style.left = InstanciaJugador.posx+"px";
      nave.style.top = InstanciaJugador.posy+"px";
    }
    // Voy a dibujar rocas
    for(let i = 0;i<numero_rocas;i++){
    	let nueva_roca = document.createElement("img"); // Creo una nueva imagen
      nueva_roca.classList.add("roca")								// Le añado la clase roca
      nueva_roca.src = "roca.png"											// Cargo la imagen de la roca
      nueva_roca.style.position = "absolute"					// Le pongo absoluto para poder mover con libertad
      nueva_roca.style.left = rocas[i].posx+"px"					// Le pongo su posicion X
      nueva_roca.style.top = rocas[i].posy+"px"						// Le pongo su posicion Y
      nueva_roca.style.transform = "rotate("+rocas[i].angulo+"deg)  scale("+rocas[i].escala+")"	// NUEVO /////////////////
      document.querySelector("body").appendChild(nueva_roca)	// Añado la roca al body
    }
  </script>
</html>
```

### descansamos con un fondo
<small>Creado: 2025-12-09 12:09</small>

`011-descansamos con un fondo.html`

```html
<!doctype html>
<html>
  <head>
    <style>
      #nave{position:absolute;width:50px;}
      .roca{width:50px;}
      body{background:url("estrellas.jpeg");background-size:cover;}
    </style>
  </head>
  <body>
    <img src="nave.png" id="nave">
  </body>
  <script>
    // Variables globales
    let anchopagina = window.innerWidth				// NUEVO ////////////////////
    let altopagina = window.innerHeight			// NUEVO ////////////////////
    
    // Primero declaramos una clase madre (abstracta)
    class Entidad{											// Creamos una entidad como superclase
    	constructor(x,y,a,v){
      	this.posx = x;
        this.posy = y;
        this.angulo = a;  	
        this.velocidad = v;
      }
    }
    // Luego declaro las clases concretas
    class Bala extends Entidad {				// La bala extiende a la entidad
    	constructor(x,y,a,v){
      	super(x, y, a, v);							// La bala hereda estas propiedades de la entidad
      }
    }
    class Jugador extends Entidad {			// El jugador extiende a la entidad
    	constructor(x,y,a,v){
      	super(x, y, a, v);							// El jugador hereda estas propiedades de la entidad
      }
    }
    class Roca extends Entidad {				// Y la roca extiende a la entidad
    	constructor(x,y,a,e,v){
      	super(x, y, a, v);							// La roca hereda estas propiedades de la entidad										
        this.escala = e;								// Pero la roca puede tener sus propias propiedades
      }
    }
    // Voy a crear rocas
    let numero_rocas = 100;													// Digo cuantas rocas quiero
    let rocas = [];																	// Creo un array vacío
    for(let i = 0;i<numero_rocas;i++){							// Recorro un bucle
      let posx_aleatoria = Math.random()*anchopagina	// posx aleatoria en toda la X de la pantalla
      let posy_aleatoria = Math.random()*altopagina		// posy aleatoria en toda la Y de la pantalla
      let angulo_aleatorio = Math.random()*360
      let escala_aleatoria = Math.random()*1
    	rocas.push(new Roca(
        posx_aleatoria,
        posy_aleatoria,
        angulo_aleatorio,
        escala_aleatoria,
        0
      ))	// Creo una nueva roca	/// INICIALIZO LA VELOCIDAD A CERO								
    }
    // Ahora creo una instancia del jugador
    let nave = document.querySelector("#nave");
    let InstanciaJugador = new Jugador(
      Math.random()*anchopagina,
      Math.random()*altopagina,
       0,0)		 																// NUEVO /////////////////////////
   	nave.style.left = InstanciaJugador.posx+"px";
    nave.style.top = InstanciaJugador.posy+"px";
    
    document.onkeydown = function(tecla){		// Cuando sobre el documento pulse tec
      // w = 87, s = 83, a = 65 , d= 68
      switch(tecla.keyCode){     
        case 87:			// Si pulso W
          InstanciaJugador.posy -= 5;	// Subo cinco unidades en Y
          break;
        case 83:			// Si pulso S
          InstanciaJugador.posy += 5;	// Bajo cinco unidades en Y
          break;
        case 65:			// Si pulso A
          InstanciaJugador.posx -= 5;	// Quito cinco unidades en X
          break;
        case 68:			// Si pulso D
          InstanciaJugador.posx += 5;	// Sumo cinco unidades en X
          break;
      }
      nave.style.left = InstanciaJugador.posx+"px";
      nave.style.top = InstanciaJugador.posy+"px";
    }
    // Voy a dibujar rocas
    for(let i = 0;i<numero_rocas;i++){
    	let nueva_roca = document.createElement("img"); // Creo una nueva imagen
      nueva_roca.classList.add("roca")								// Le añado la clase roca
      nueva_roca.src = "roca.png"											// Cargo la imagen de la roca
      nueva_roca.style.position = "absolute"					// Le pongo absoluto para poder mover con libertad
      nueva_roca.style.left = rocas[i].posx+"px"					// Le pongo su posicion X
      nueva_roca.style.top = rocas[i].posy+"px"						// Le pongo su posicion Y
      nueva_roca.style.transform = "rotate("+rocas[i].angulo+"deg)  scale("+rocas[i].escala+")"	// NUEVO /////////////////
      document.querySelector("body").appendChild(nueva_roca)	// Añado la roca al body
    }
  </script>
</html>
```

### crear balas
<small>Creado: 2025-12-09 12:11</small>

`012-crear balas.html`

```html
<!doctype html>
<html>
  <head>
    <style>
      #nave{position:absolute;width:50px;}
      .roca{width:50px;}
      body{background:url("estrellas.jpeg");background-size:cover;}
    </style>
  </head>
  <body>
    <img src="nave.png" id="nave">
  </body>
  <script>
    // Variables globales
    let anchopagina = window.innerWidth				// NUEVO ////////////////////
    let altopagina = window.innerHeight			// NUEVO ////////////////////
    
    // Primero declaramos una clase madre (abstracta)
    class Entidad{											// Creamos una entidad como superclase
    	constructor(x,y,a,v){
      	this.posx = x;
        this.posy = y;
        this.angulo = a;  	
        this.velocidad = v;
      }
    }
    // Luego declaro las clases concretas
    class Bala extends Entidad {				// La bala extiende a la entidad
    	constructor(x,y,a,v){
      	super(x, y, a, v);							// La bala hereda estas propiedades de la entidad
      }
    }
    class Jugador extends Entidad {			// El jugador extiende a la entidad
    	constructor(x,y,a,v){
      	super(x, y, a, v);							// El jugador hereda estas propiedades de la entidad
      }
    }
    class Roca extends Entidad {				// Y la roca extiende a la entidad
    	constructor(x,y,a,e,v){
      	super(x, y, a, v);							// La roca hereda estas propiedades de la entidad										
        this.escala = e;								// Pero la roca puede tener sus propias propiedades
      }
    }
    // Voy a crear rocas
    let numero_rocas = 100;													// Digo cuantas rocas quiero
    let rocas = [];																	// Creo un array vacío
    for(let i = 0;i<numero_rocas;i++){							// Recorro un bucle
      let posx_aleatoria = Math.random()*anchopagina	// posx aleatoria en toda la X de la pantalla
      let posy_aleatoria = Math.random()*altopagina		// posy aleatoria en toda la Y de la pantalla
      let angulo_aleatorio = Math.random()*360
      let escala_aleatoria = Math.random()*1
    	rocas.push(new Roca(
        posx_aleatoria,
        posy_aleatoria,
        angulo_aleatorio,
        escala_aleatoria,
        0
      ))	// Creo una nueva roca	/// INICIALIZO LA VELOCIDAD A CERO								
    }
    // Voy a crear balas
    let numero_balas = 0;												// Indico el numero de balas actual
    let balas = [];															// Creo un conjunto vacio
    
    // Ahora creo una instancia del jugador
    let nave = document.querySelector("#nave");
    let InstanciaJugador = new Jugador(
      Math.random()*anchopagina,
      Math.random()*altopagina,
       0,0)		 																// NUEVO /////////////////////////
   	nave.style.left = InstanciaJugador.posx+"px";
    nave.style.top = InstanciaJugador.posy+"px";
    
    document.onkeydown = function(tecla){		// Cuando sobre el documento pulse tec
      // w = 87, s = 83, a = 65 , d= 68
      switch(tecla.keyCode){     
        case 87:			// Si pulso W
          InstanciaJugador.posy -= 5;	// Subo cinco unidades en Y
          break;
        case 83:			// Si pulso S
          InstanciaJugador.posy += 5;	// Bajo cinco unidades en Y
          break;
        case 65:			// Si pulso A
          InstanciaJugador.posx -= 5;	// Quito cinco unidades en X
          break;
        case 68:			// Si pulso D
          InstanciaJugador.posx += 5;	// Sumo cinco unidades en X
          break;
      }
      nave.style.left = InstanciaJugador.posx+"px";
      nave.style.top = InstanciaJugador.posy+"px";
    }
    // Voy a dibujar rocas
    for(let i = 0;i<numero_rocas;i++){
    	let nueva_roca = document.createElement("img"); // Creo una nueva imagen
      nueva_roca.classList.add("roca")								// Le añado la clase roca
      nueva_roca.src = "roca.png"											// Cargo la imagen de la roca
      nueva_roca.style.position = "absolute"					// Le pongo absoluto para poder mover con libertad
      nueva_roca.style.left = rocas[i].posx+"px"					// Le pongo su posicion X
      nueva_roca.style.top = rocas[i].posy+"px"						// Le pongo su posicion Y
      nueva_roca.style.transform = "rotate("+rocas[i].angulo+"deg)  scale("+rocas[i].escala+")"	// NUEVO /////////////////
      document.querySelector("body").appendChild(nueva_roca)	// Añado la roca al body
    }
  </script>
</html>
```

### creo bala nueva al disparar
<small>Creado: 2025-12-09 12:15</small>

`013-creo bala nueva al disparar.html`

```html
<!doctype html>
<html>
  <head>
    <style>
      #nave{position:absolute;width:50px;}
      .roca{width:50px;}
      .bala{width:50px;}
      body{background:url("estrellas.jpeg");background-size:cover;}
    </style>
  </head>
  <body>
    <img src="nave.png" id="nave">
  </body>
  <script>
    // Variables globales
    let anchopagina = window.innerWidth				// NUEVO ////////////////////
    let altopagina = window.innerHeight			// NUEVO ////////////////////
    
    // Primero declaramos una clase madre (abstracta)
    class Entidad{											// Creamos una entidad como superclase
    	constructor(x,y,a,v){
      	this.posx = x;
        this.posy = y;
        this.angulo = a;  	
        this.velocidad = v;
      }
    }
    // Luego declaro las clases concretas
    class Bala extends Entidad {				// La bala extiende a la entidad
    	constructor(x,y,a,v){
      	super(x, y, a, v);							// La bala hereda estas propiedades de la entidad
      }
    }
    class Jugador extends Entidad {			// El jugador extiende a la entidad
    	constructor(x,y,a,v){
      	super(x, y, a, v);							// El jugador hereda estas propiedades de la entidad
      }
    }
    class Roca extends Entidad {				// Y la roca extiende a la entidad
    	constructor(x,y,a,e,v){
      	super(x, y, a, v);							// La roca hereda estas propiedades de la entidad										
        this.escala = e;								// Pero la roca puede tener sus propias propiedades
      }
    }
    // Voy a crear rocas
    let numero_rocas = 100;													// Digo cuantas rocas quiero
    let rocas = [];																	// Creo un array vacío
    for(let i = 0;i<numero_rocas;i++){							// Recorro un bucle
      let posx_aleatoria = Math.random()*anchopagina	// posx aleatoria en toda la X de la pantalla
      let posy_aleatoria = Math.random()*altopagina		// posy aleatoria en toda la Y de la pantalla
      let angulo_aleatorio = Math.random()*360
      let escala_aleatoria = Math.random()*1
    	rocas.push(new Roca(
        posx_aleatoria,
        posy_aleatoria,
        angulo_aleatorio,
        escala_aleatoria,
        0
      ))	// Creo una nueva roca	/// INICIALIZO LA VELOCIDAD A CERO								
    }
    // Voy a crear balas
    let numero_balas = 0;												// Indico el numero de balas actual
    let balas = [];															// Creo un conjunto vacio
    
    // Ahora creo una instancia del jugador
    let nave = document.querySelector("#nave");
    let InstanciaJugador = new Jugador(
      Math.random()*anchopagina,
      Math.random()*altopagina,
       0,0)		 																// NUEVO /////////////////////////
   	nave.style.left = InstanciaJugador.posx+"px";
    nave.style.top = InstanciaJugador.posy+"px";
    
    document.onkeydown = function(tecla){		// Cuando sobre el documento pulse tec
      // w = 87, s = 83, a = 65 , d= 68
      switch(tecla.keyCode){     
        case 87:			// Si pulso W
          InstanciaJugador.posy -= 5;	// Subo cinco unidades en Y
          break;
        case 83:			// Si pulso S
          InstanciaJugador.posy += 5;	// Bajo cinco unidades en Y
          break;
        case 65:			// Si pulso A
          InstanciaJugador.posx -= 5;	// Quito cinco unidades en X
          break;
        case 68:			// Si pulso D
          InstanciaJugador.posx += 5;	// Sumo cinco unidades en X
          break;
        case 32:			// Si pulso la barra espaciadora
          balas.push(new Bala(
            InstanciaJugador.posx,
            InstanciaJugador.posy,
            0,0
          ));					// Cada vez que puso la barra espaciadora, creo una bala nueva
          let nueva_bala = document.createElement("img"); // Creo una nueva imagen
          nueva_bala.classList.add("bala")								// Le añado la clase roca
          nueva_bala.src = "bala.png"											// Cargo la imagen de la roca
          nueva_bala.style.position = "absolute"					// Le pongo absoluto para poder mover con libertad
          nueva_bala.style.left = InstanciaJugador.posx+"px"					// Le pongo su posicion X
          nueva_bala.style.top = InstanciaJugador.posy+"px"						// Le pongo su posicion Y
          document.querySelector("body").appendChild(nueva_bala)	// Añado la roca al body
              break;
          }
          nave.style.left = InstanciaJugador.posx+"px";
          nave.style.top = InstanciaJugador.posy+"px";
    }
    // Voy a dibujar rocas
    for(let i = 0;i<numero_rocas;i++){
    	let nueva_roca = document.createElement("img"); // Creo una nueva imagen
      nueva_roca.classList.add("roca")								// Le añado la clase roca
      nueva_roca.src = "roca.png"											// Cargo la imagen de la roca
      nueva_roca.style.position = "absolute"					// Le pongo absoluto para poder mover con libertad
      nueva_roca.style.left = rocas[i].posx+"px"					// Le pongo su posicion X
      nueva_roca.style.top = rocas[i].posy+"px"						// Le pongo su posicion Y
      nueva_roca.style.transform = "rotate("+rocas[i].angulo+"deg)  scale("+rocas[i].escala+")"	// NUEVO /////////////////
      document.querySelector("body").appendChild(nueva_roca)	// Añado la roca al body
    }
  </script>
</html>
```

### bala
<small>Creado: 2025-12-09 12:15</small>

`bala.svg`

```
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!-- Created with Inkscape (http://www.inkscape.org/) -->

<svg
   width="50mm"
   height="50mm"
   viewBox="0 0 50 50"
   version="1.1"
   id="svg1"
   inkscape:version="1.4.2 (1:1.4.2+202505120737+ebf0e940d0)"
   sodipodi:docname="bala.svg"
   inkscape:export-filename="roca.png"
   inkscape:export-xdpi="96"
   inkscape:export-ydpi="96"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:svg="http://www.w3.org/2000/svg">
  <sodipodi:namedview
     id="namedview1"
     pagecolor="#ffffff"
     bordercolor="#000000"
     borderopacity="0.25"
     inkscape:showpageshadow="2"
     inkscape:pageopacity="0.0"
     inkscape:pagecheckerboard="0"
     inkscape:deskcolor="#d1d1d1"
     inkscape:document-units="mm"
     inkscape:zoom="1.9149817"
     inkscape:cx="98.695462"
     inkscape:cy="86.162705"
     inkscape:window-width="1920"
     inkscape:window-height="971"
     inkscape:window-x="0"
     inkscape:window-y="32"
     inkscape:window-maximized="1"
     inkscape:current-layer="layer1" />
  <defs
     id="defs1" />
  <g
     inkscape:label="Capa 1"
     inkscape:groupmode="layer"
     id="layer1"
     transform="translate(-73.256581,-51.982756)">
    <circle
       style="fill:#d40000;fill-opacity:1;stroke:#000000;stroke-width:1.157;stroke-linecap:round;stroke-linejoin:round"
       id="path4"
       cx="98.264442"
       cy="76.714279"
       r="11.329525" />
  </g>
</svg>
```

### nave
<small>Creado: 2025-12-09 10:34</small>

`nave.svg`

```
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!-- Created with Inkscape (http://www.inkscape.org/) -->

<svg
   width="50mm"
   height="50mm"
   viewBox="0 0 50 50"
   version="1.1"
   id="svg1"
   inkscape:version="1.4.2 (1:1.4.2+202505120737+ebf0e940d0)"
   sodipodi:docname="nave.svg"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:svg="http://www.w3.org/2000/svg">
  <sodipodi:namedview
     id="namedview1"
     pagecolor="#ffffff"
     bordercolor="#000000"
     borderopacity="0.25"
     inkscape:showpageshadow="2"
     inkscape:pageopacity="0.0"
     inkscape:pagecheckerboard="0"
     inkscape:deskcolor="#d1d1d1"
     inkscape:document-units="mm"
     inkscape:zoom="1.9149817"
     inkscape:cx="98.695462"
     inkscape:cy="86.162705"
     inkscape:window-width="1920"
     inkscape:window-height="971"
     inkscape:window-x="0"
     inkscape:window-y="32"
     inkscape:window-maximized="1"
     inkscape:current-layer="layer1" />
  <defs
     id="defs1" />
  <g
     inkscape:label="Capa 1"
     inkscape:groupmode="layer"
     id="layer1"
     transform="translate(-73.256581,-51.982756)">
    <path
       style="fill:#e3203e;fill-opacity:1;stroke:#000000;stroke-width:1.157;stroke-linecap:round;stroke-linejoin:round"
       d="m 84.97251,101.21447 h 29.44548 L 99.553618,84.899012 Z"
       id="path2"
       sodipodi:nodetypes="cccc" />
    <ellipse
       style="fill:#e3203e;fill-opacity:1;stroke:#000000;stroke-width:1.157;stroke-linecap:round;stroke-linejoin:round"
       id="path1"
       cx="99.065132"
       cy="80.111839"
       rx="10.161"
       ry="18.074013" />
    <circle
       style="fill:#ffffff;fill-opacity:1;stroke:#000000;stroke-width:1.157;stroke-linecap:round;stroke-linejoin:round"
       id="path3"
       cx="99.016281"
       cy="75.080421"
       r="3.9567432" />
    <path
       style="fill:#ffff00;fill-opacity:1;stroke:#000000;stroke-width:1.157;stroke-linecap:round;stroke-linejoin:round"
       d="M 91.739761,67.586412 H 106.39051 L 99.260526,52.561182 Z"
       id="path4" />
  </g>
</svg>
```

### roca
<small>Creado: 2025-12-09 11:00</small>

`roca.svg`

```
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!-- Created with Inkscape (http://www.inkscape.org/) -->

<svg
   width="50mm"
   height="50mm"
   viewBox="0 0 50 50"
   version="1.1"
   id="svg1"
   inkscape:version="1.4.2 (1:1.4.2+202505120737+ebf0e940d0)"
   sodipodi:docname="roca.svg"
   inkscape:export-filename="nave.png"
   inkscape:export-xdpi="96"
   inkscape:export-ydpi="96"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:svg="http://www.w3.org/2000/svg">
  <sodipodi:namedview
     id="namedview1"
     pagecolor="#ffffff"
     bordercolor="#000000"
     borderopacity="0.25"
     inkscape:showpageshadow="2"
     inkscape:pageopacity="0.0"
     inkscape:pagecheckerboard="0"
     inkscape:deskcolor="#d1d1d1"
     inkscape:document-units="mm"
     inkscape:zoom="1.9149817"
     inkscape:cx="98.695462"
     inkscape:cy="86.162705"
     inkscape:window-width="1920"
     inkscape:window-height="971"
     inkscape:window-x="0"
     inkscape:window-y="32"
     inkscape:window-maximized="1"
     inkscape:current-layer="layer1" />
  <defs
     id="defs1" />
  <g
     inkscape:label="Capa 1"
     inkscape:groupmode="layer"
     id="layer1"
     transform="translate(-73.256581,-51.982756)">
    <path
       style="fill:#b3b3b3;fill-opacity:1;stroke:#000000;stroke-width:1.157;stroke-linecap:round;stroke-linejoin:round"
       d="m 84.724272,64.555766 -10e-7,6.631917 -4.697608,4.144948 5.802928,2.901464 -5.664763,8.98072 7.046412,7.322743 8.013567,-2.486969 7.046413,4.283114 10.08604,-3.315958 -2.62513,-8.566227 7.18458,-4.006785 -6.35559,-7.460906 5.25027,-5.941092 -2.7633,-5.250268 -8.15173,2.072474 -3.86862,-4.559444 -7.322748,0.690826 -1.796144,7.322742 z"
       id="path4"
       sodipodi:nodetypes="ccccccccccccccccccc" />
  </g>
</svg>
```


<a id="clases-y-metodos-abstractos-y-finales"></a>
## Clases y métodos abstractos y finales

### clase abstracta
<small>Creado: 2025-12-10 08:43</small>

`001-clase abstracta.html`

```html
<!doctype html>
<html>
  <head>
  </head>
  <body>
    <script>
      class Ser{							// Abstracto implícito, no tiene sentido instancia
      	constructor(edad){
        	this.edad = edad
        }
      }
      class Animal extends Ser{	// Abstracto implícito, no tiene sentido instancia
      	constructor(especie){
        	super();
          this.especie = especie;
        }
      }
      class Perro extends Animal{	// Concreto, tiene sentido instanciar
      	constructor(color){
        	super();
          this.color = color;
        }
      }
      let Perro1 = new Perro("blanco");
      console.log(Perro1);
    </script>
  </body>
</html>
```

### transformaciones css
<small>Creado: 2025-12-10 08:47</small>

`002-transformaciones css.html`

```html
<!doctype html>
<html>
  <head>
    <style>
      #rojo{
        width:50px;height:50px;background:red;border:1px solid black;
      	transform:translate(200px,200px);
      }
    </style>
  </head>
  <body>
    <div id="rojo"></div>
  </body>
</html>
```

### transformacion independiente
<small>Creado: 2025-12-10 08:49</small>

`003-transformacion independiente.html`

```html
<!doctype html>
<html>
  <head>
    <style>
      #rojo{
        width:50px;height:50px;background:red;border:1px solid black;
      	transform:translateX(200px) translateY(200px);
      }
    </style>
  </head>
  <body>
    <div id="rojo"></div>
  </body>
</html>
```

### rotacion
<small>Creado: 2025-12-10 08:49</small>

`004-rotacion.html`

```html
<!doctype html>
<html>
  <head>
    <style>
      #rojo{
        width:50px;height:50px;background:red;border:1px solid black;
      	transform:rotate(45deg);
      }
    </style>
  </head>
  <body>
    <div id="rojo"></div>
  </body>
</html>
```

### transformacion de escala
<small>Creado: 2025-12-10 08:52</small>

`005-transformacion de escala.html`

```html
<!doctype html>
<html>
  <head>
    <style>
      #rojo{
        width:50px;height:50px;background:red;border:1px solid black;
      	transform:scale(1);
      }
    </style>
  </head>
  <body>
    <div id="rojo"></div>
  </body>
</html>
```

### multiples transformaciones
<small>Creado: 2025-12-10 08:53</small>

`006-multiples transformaciones.html`

```html
<!doctype html>
<html>
  <head>
    <style>
      #rojo{
        width:50px;height:50px;background:red;border:1px solid black;
      	transform:translate(100px, 100px) rotate(45deg) scale(2);
      }
    </style>
  </head>
  <body>
    <div id="rojo"></div>
  </body>
</html>
```

### evento tecla
<small>Creado: 2025-12-10 09:01</small>

`007-evento tecla.html`

```html
<!doctype html>
<html>
  <head>
  </head>
  <body>
    <script>
      document.onkeydown = function(tecla){
      	switch(tecla.key){
          case "w":
            console.log("Movemos el personaje hacia arriba");
            break;
          case "s":
            console.log("Movemos el personaje hacia abajo");
            break;
          case "a":
            console.log("Movemos el personaje hacia la izquierda");
            break;
          case "d":
            console.log("Movemos el personaje hacia la derecha");
            break;
        }
      }
    </script>
  </body>
</html>
```

### eventos de raton
<small>Creado: 2025-12-10 09:03</small>

`008-eventos de raton.html`

```html
<!doctype html>
<html>
  <head>
  </head>
  <body>
    <script>
      document.onkeydown = function(tecla){
      	switch(tecla.key){
          case "w":
            console.log("Movemos el personaje hacia arriba");
            break;
          case "s":
            console.log("Movemos el personaje hacia abajo");
            break;
          case "a":
            console.log("Movemos el personaje hacia la izquierda");
            break;
          case "d":
            console.log("Movemos el personaje hacia la derecha");
            break;
        }
      }
      document.onmousedown = function(){
      	console.log("Disparamos");
      }
    </script>
  </body>
</html>
```

### juntamos lo de antes
<small>Creado: 2025-12-10 09:10</small>

`009-juntamos lo de antes.html`

```html
<!doctype html>
<html>
  <head>	
    <style>
      #rojo{width:50px;height:50px;background:red;border:1px solid black;}
    </style>
  </head>
  <body>
    <div id="rojo"></div>
    <script>
      // Defino condiciones de inicio
      let posx = 0;
      let posy = 0;
      document.onkeydown = function(tecla){
      	switch(tecla.key){
          case "w":
            posy -= 10;	// Restamos 10 de Y
            console.log("Movemos el personaje hacia arriba");
            break;
          case "s":
            posy += 10;	// Sumamos 10 en Y
            console.log("Movemos el personaje hacia abajo");
            break;
          case "a":
            posx -= 10; // Restamos 10 de X
            console.log("Movemos el personaje hacia la izquierda");
            break;
          case "d":
            posx += 10; // Sumamos 10 en X
            console.log("Movemos el personaje hacia la derecha");
            break;
        }
        document.querySelector("#rojo").style.transform = "translate("+posx+"px,"+posy+"px)"
      }
      document.onmousedown = function(){
      	console.log("Disparamos");
      }
    </script>
  </body>
</html>
```

### trigonometria basica
<small>Creado: 2025-12-10 09:21</small>

`010-trigonometria basica.html`

```html
<!doctype html>
<html>
  <head>	
    
  </head>
  <body>
    <script>
      let angulo = Math.PI/4;
      let coseno = Math.cos(angulo);
      let seno = Math.sin(angulo);
      console.log("El angulo es",angulo,"su coseno es",coseno,"su seno es",seno);
    </script>
  </body>
</html>
```

### dibujar con canvas
<small>Creado: 2025-12-10 09:30</small>

`011-dibujar con canvas.html`

```html
<!doctype html>
<html>
  <head>	
    
  </head>
  <body>
    <canvas></canvas>
    <script>
      let lienzo = document.querySelector("canvas");	// Atrapo el canvas
      lienzo.width = 512;															// Le pongo anchura
      lienzo.height = 512;														// Le pongo altura
      let contexto = lienzo.getContext("2d");		// Voy a dibujar en 2D
      
      // Ahora voy a dibujar un circulo
      contexto.beginPath();											// Empiezo a dibujar
      // arco: xinicial, yinicial,radio,anguloinicial,angulofinal
      contexto.arc(256,256,200,0,Math.PI*2);		// Dibujo un circulo
      contexto.stroke();												// Dibujo la linea
      
      // Ahora voy a dibujar una linea
      contexto.beginPath();											// Empiezo a dibujar
      contexto.moveTo(0,256);										// Muevo el cursor sin dibujar
      contexto.lineTo(512,256);									// Muevo el curso pero ya dibujando
      contexto.stroke()													// Realizo el trazo
      
      // Ahora voy a dibujar la linea vertical
      contexto.beginPath();											// Empiezo a dibujar
      contexto.moveTo(256,0);										// Muevo el cursor sin dibujar
      contexto.lineTo(256,512);									// Muevo el curso pero ya dibujando
      contexto.stroke()													// Realizo el trazo
      
    </script>
  </body>
</html>
```

### linea con angulo
<small>Creado: 2025-12-10 09:33</small>

`012-linea con angulo.html`

```html
<!doctype html>
<html>
  <head>	
    
  </head>
  <body>
    <canvas></canvas>
    <script>
      let lienzo = document.querySelector("canvas");	// Atrapo el canvas
      lienzo.width = 512;															// Le pongo anchura
      lienzo.height = 512;														// Le pongo altura
      let contexto = lienzo.getContext("2d");		// Voy a dibujar en 2D
      
      // Ahora voy a dibujar un circulo
      contexto.beginPath();											// Empiezo a dibujar
      // arco: xinicial, yinicial,radio,anguloinicial,angulofinal
      contexto.arc(256,256,200,0,Math.PI*2);		// Dibujo un circulo
      contexto.stroke();												// Dibujo la linea
      
      // Ahora voy a dibujar una linea
      contexto.beginPath();											// Empiezo a dibujar
      contexto.moveTo(0,256);										// Muevo el cursor sin dibujar
      contexto.lineTo(512,256);									// Muevo el curso pero ya dibujando
      contexto.stroke()													// Realizo el trazo
      
      // Ahora voy a dibujar la linea vertical
      contexto.beginPath();											// Empiezo a dibujar
      contexto.moveTo(256,0);										// Muevo el cursor sin dibujar
      contexto.lineTo(256,512);									// Muevo el curso pero ya dibujando
      contexto.stroke()													// Realizo el trazo
      
      // Ahora dibujo una linea con angulo
      let angulo = 1;														// Defino un angulo, acordaos que estamos en rad
      contexto.beginPath();											// Empiezo a dibujar
      contexto.moveTo(256,256);									// Muevo el cursor al centro
      contexto.lineTo(
        256+200*Math.cos(angulo),
        256+200*Math.sin(angulo)
      );		// Muevo el curso pero ya dibujando
      contexto.stroke()													// Realizo el trazo
      
    </script>
  </body>
</html>
```

### varias lineas
<small>Creado: 2025-12-10 09:37</small>

`013-varias lineas.html`

```html
<!doctype html>
<html>
  <head>	
    
  </head>
  <body>
    <canvas></canvas>
    <script>
      let lienzo = document.querySelector("canvas");	// Atrapo el canvas
      lienzo.width = 512;															// Le pongo anchura
      lienzo.height = 512;														// Le pongo altura
      let contexto = lienzo.getContext("2d");		// Voy a dibujar en 2D
      
      // Ahora voy a dibujar un circulo
      contexto.beginPath();											// Empiezo a dibujar
      // arco: xinicial, yinicial,radio,anguloinicial,angulofinal
      contexto.arc(256,256,200,0,Math.PI*2);		// Dibujo un circulo
      contexto.stroke();												// Dibujo la linea
      
      // Ahora voy a dibujar una linea
      contexto.beginPath();											// Empiezo a dibujar
      contexto.moveTo(0,256);										// Muevo el cursor sin dibujar
      contexto.lineTo(512,256);									// Muevo el curso pero ya dibujando
      contexto.stroke()													// Realizo el trazo
      
      // Ahora voy a dibujar la linea vertical
      contexto.beginPath();											// Empiezo a dibujar
      contexto.moveTo(256,0);										// Muevo el cursor sin dibujar
      contexto.lineTo(256,512);									// Muevo el curso pero ya dibujando
      contexto.stroke()													// Realizo el trazo
      for(let i = 0;i<Math.PI*2;i += 0.04){
        // Ahora dibujo una linea con angulo
        let angulo = i;														// Defino un angulo, acordaos que estamos en rad
        contexto.beginPath();											// Empiezo a dibujar
        contexto.moveTo(256,256);									// Muevo el cursor al centro
        contexto.lineTo(
          256+200*Math.cos(angulo),
          256+200*Math.sin(angulo)
        );		// Muevo el curso pero ya dibujando
        contexto.stroke()													// Realizo el trazo
      }
    </script>
  </body>
</html>
```

### temporizador
<small>Creado: 2025-12-10 09:40</small>

`014-temporizador.html`

```html
<!doctype html>
<html>
  <head>	
    
  </head>
  <body>
    <script>
      function saludo(){
      	document.write("yo te saludo");
      }
      setTimeout("saludo()",5000);
    </script>
  </body>
</html>
```

### bucle
<small>Creado: 2025-12-10 09:44</small>

`015-bucle.html`

```html
<!doctype html>
<html>
  <head>	
    
  </head>
  <body>
    <script>
      let temporizador = setTimeout("bucle()",1000);	// Dentro de un seg, entra en el bucle
      function bucle(){
      	console.log("Hola");
        clearTimeout(temporizador);			// Borro el temporizador anterior
        temporizador = setTimeout("bucle()",1000); // Llamada recursiva
      }
    </script>
  </body>
</html>
```

### fecha actual
<small>Creado: 2025-12-10 09:49</small>

`016-fecha actual.html`

```html
<!doctype html>
<html>
  <head>	
    
  </head>
  <body>
    <time></time>
    <script>
      let temporizador = setTimeout("bucle()",1000);	// Dentro de un seg, entra en el bucle
      function bucle(){
      	let fecha = new Date();
        let anio = fecha.getFullYear();
        let mes = fecha.getMonth()+1;
        let dia = fecha.getDate();
        let hora = fecha.getHours();
        let minuto = fecha.getMinutes();
        let segundo = fecha.getSeconds();
        document.querySelector("time").textContent = anio+"/"+mes+"/"+dia+" "+hora+":"+minuto+":"+segundo;
        clearTimeout(temporizador);			// Borro el temporizador anterior
        temporizador = setTimeout("bucle()",1000); // Llamada recursiva
      }
    </script>
  </body>
</html>
```

### reloj
<small>Creado: 2025-12-10 10:11</small>

`017-reloj.html`

```html
<!doctype html>
<html>
  <head>	
    
  </head>
  <body>
    <canvas></canvas>
    <script>
      // Condiciones iniciales
      let temporizador = setTimeout("bucle()",1000);	// Dentro de un seg, entra en el bucle
      let lienzo = document.querySelector("canvas");
      lienzo.width = 512;					// Anchura del lienzo
      lienzo.height = 512;				// Altura del lienzo
      let contexto = lienzo.getContext("2d"); // Voy a dibujar en 2d
      
      // Condicion de bucle
      function bucle(){
      	let fecha = new Date();						// Construyo una fecha

        let hora = fecha.getHours();			// Quiero saber la hora
        let minuto = fecha.getMinutes();	// Quiero saber el minuto
        let segundo = fecha.getSeconds();	// Quiero saber el segundo
        
        contexto.clearRect(0,0,512,512); 	// Borro el lienzo
        
        contexto.beginPath();				// Empiezo a dibujar
        contexto.arc(256,256,200,0,Math.PI*2) // Dibujo un circulo completo
        contexto.stroke(); 					// Y trazo linea
        
        // Ahora dibujo la manecilla de los segundos
        angulo_segundo = segundo*(Math.PI*2/60)		// Segundos convertidos a radianes
        contexto.beginPath(); 			// Empiezo a dibujar
        contexto.moveTo(256,256);		// Muevo el cursor al centro del reloj
        contexto.lineTo(
          256+Math.cos(angulo_segundo)*200,
          256+Math.sin(angulo_segundo)*200
        )
        contexto.stroke();
        
        // Ahora dibujo la manecilla de los minutos
        angulo_minuto = minuto*(Math.PI*2/60)		// Segundos convertidos a radianes
        contexto.beginPath(); 			// Empiezo a dibujar
        contexto.moveTo(256,256);		// Muevo el cursor al centro del reloj
        contexto.lineTo(
          256+Math.cos(angulo_minuto)*150,
          256+Math.sin(angulo_minuto)*150
        )
        contexto.stroke();
        
        // Ahora dibujo la manecilla de las horas
        angulo_hora = hora*(Math.PI*2/60)		// Segundos convertidos a radianes
        contexto.beginPath(); 			// Empiezo a dibujar
        contexto.moveTo(256,256);		// Muevo el cursor al centro del reloj
        contexto.lineTo(
          256+Math.cos(angulo_hora)*100,
          256+Math.sin(angulo_hora)*100
        )
        contexto.stroke();

        clearTimeout(temporizador);			// Borro el temporizador anterior
        temporizador = setTimeout("bucle()",1000); // Llamada recursiva
      }
    </script>
  </body>
</html>
```

### estilo
<small>Creado: 2025-12-10 10:19</small>

`018-estilo.html`

```html
<!doctype html>
<html>
  <head>	
    
  </head>
  <body>
    <canvas></canvas>
    <script>
      // Condiciones iniciales
      let temporizador = setTimeout("bucle()",1000);	// Dentro de un seg, entra en el bucle
      let lienzo = document.querySelector("canvas");
      lienzo.width = 512;					// Anchura del lienzo
      lienzo.height = 512;				// Altura del lienzo
      let contexto = lienzo.getContext("2d"); // Voy a dibujar en 2d
      contexto.lineCap = "round";
      // Condicion de bucle
      function bucle(){
      	let fecha = new Date();						// Construyo una fecha

        let hora = fecha.getHours();			// Quiero saber la hora
        let minuto = fecha.getMinutes();	// Quiero saber el minuto
        let segundo = fecha.getSeconds();	// Quiero saber el segundo
        
        contexto.clearRect(0,0,512,512); 	// Borro el lienzo
        
          
        // Ahora dibujo la manecilla de las horas
        contexto.lineWidth = 45;
        contexto.strokeStyle = "blue";
        angulo_hora = hora*(Math.PI*2/60)		// Segundos convertidos a radianes
        contexto.beginPath(); 			// Empiezo a dibujar
        contexto.moveTo(256,256);		// Muevo el cursor al centro del reloj
        contexto.lineTo(
          256+Math.cos(angulo_hora)*100,
          256+Math.sin(angulo_hora)*100
        )
        contexto.stroke();
        
        // Ahora dibujo la manecilla de los minutos
        contexto.lineWidth = 25;
        contexto.strokeStyle = "green";
        angulo_minuto = minuto*(Math.PI*2/60)		// Segundos convertidos a radianes
        contexto.beginPath(); 			// Empiezo a dibujar
        contexto.moveTo(256,256);		// Muevo el cursor al centro del reloj
        contexto.lineTo(
          256+Math.cos(angulo_minuto)*150,
          256+Math.sin(angulo_minuto)*150
        )
        contexto.stroke();
        
        // Ahora dibujo la manecilla de los segundos
        contexto.lineWidth = 5;
        contexto.strokeStyle = "red";
        angulo_segundo = segundo*(Math.PI*2/60)		// Segundos convertidos a radianes
        contexto.beginPath(); 			// Empiezo a dibujar
        contexto.moveTo(256,256);		// Muevo el cursor al centro del reloj
        contexto.lineTo(
          256+Math.cos(angulo_segundo)*200,
          256+Math.sin(angulo_segundo)*200
        )
        contexto.stroke();
        
        // Circulo central
        contexto.beginPath();
        contexto.arc(256,256,50,0,Math.PI*2)
        contexto.fill();
        
        contexto.lineWidth = 25;
        contexto.strokeStyle = "black";
        contexto.beginPath();				// Empiezo a dibujar
        contexto.arc(256,256,200,0,Math.PI*2) // Dibujo un circulo completo
        contexto.stroke(); 					// Y trazo linea

        clearTimeout(temporizador);			// Borro el temporizador anterior
        temporizador = setTimeout("bucle()",1000); // Llamada recursiva
      }
    </script>
  </body>
</html>
```

### desfase de 90 grados
<small>Creado: 2025-12-10 10:26</small>

`019-desfase de 90 grados.html`

```html
<!doctype html>
<html>
  <head>	
    
  </head>
  <body>
    <canvas></canvas>
    <script>
      // Condiciones iniciales
      let temporizador = setTimeout("bucle()",1000);	// Dentro de un seg, entra en el bucle
      let lienzo = document.querySelector("canvas");
      lienzo.width = 512;					// Anchura del lienzo
      lienzo.height = 512;				// Altura del lienzo
      let contexto = lienzo.getContext("2d"); // Voy a dibujar en 2d
      contexto.lineCap = "round";
      // Condicion de bucle
      function bucle(){
      	let fecha = new Date();						// Construyo una fecha

        let hora = fecha.getHours();			// Quiero saber la hora
        let minuto = fecha.getMinutes();	// Quiero saber el minuto
        let segundo = fecha.getSeconds();	// Quiero saber el segundo
        
        contexto.clearRect(0,0,512,512); 	// Borro el lienzo
        
          
        // Ahora dibujo la manecilla de las horas
        contexto.lineWidth = 45;
        contexto.strokeStyle = "blue";
        angulo_hora = hora*(Math.PI*2/12)-Math.PI/2		// Segundos convertidos a radianes
        contexto.beginPath(); 			// Empiezo a dibujar
        contexto.moveTo(256,256);		// Muevo el cursor al centro del reloj
        contexto.lineTo(
          256+Math.cos(angulo_hora)*100,
          256+Math.sin(angulo_hora)*100
        )
        contexto.stroke();
        
        // Ahora dibujo la manecilla de los minutos
        contexto.lineWidth = 25;
        contexto.strokeStyle = "green";
        angulo_minuto = minuto*(Math.PI*2/60)-Math.PI/2		// Segundos convertidos a radianes
        contexto.beginPath(); 			// Empiezo a dibujar
        contexto.moveTo(256,256);		// Muevo el cursor al centro del reloj
        contexto.lineTo(
          256+Math.cos(angulo_minuto)*150,
          256+Math.sin(angulo_minuto)*150
        )
        contexto.stroke();
        
        // Ahora dibujo la manecilla de los segundos
        contexto.lineWidth = 5;
        contexto.strokeStyle = "red";
        angulo_segundo = segundo*(Math.PI*2/60)-Math.PI/2		// Segundos convertidos a radianes
        contexto.beginPath(); 			// Empiezo a dibujar
        contexto.moveTo(256,256);		// Muevo el cursor al centro del reloj
        contexto.lineTo(
          256+Math.cos(angulo_segundo)*200,
          256+Math.sin(angulo_segundo)*200
        )
        contexto.stroke();
        
        // Circulo central
        contexto.beginPath();
        contexto.arc(256,256,50,0,Math.PI*2)
        contexto.fill();
        
        contexto.lineWidth = 25;
        contexto.strokeStyle = "black";
        contexto.beginPath();				// Empiezo a dibujar
        contexto.arc(256,256,200,0,Math.PI*2) // Dibujo un circulo completo
        contexto.stroke(); 					// Y trazo linea

        clearTimeout(temporizador);			// Borro el temporizador anterior
        temporizador = setTimeout("bucle()",1000); // Llamada recursiva
      }
    </script>
  </body>
</html>
```


<a id="interfaces"></a>
## Interfaces


<a id="sobreescritura-de-metodos"></a>
## Sobreescritura de métodos


<a id="constructores-y-herencia"></a>
## Constructores y herencia



<a id="mantenimiento-de-la-persistencia-de-los-objetos"></a>
# Mantenimiento de la persistencia de los objetos

<a id="bases-de-datos-orientadas-a-objetos"></a>
## Bases de datos orientadas a objetos


<a id="caracteristicas-de-las-bases-de-datos-orientadas-a-objetos"></a>
## Características de las bases de datos orientadas a objetos


<a id="instalacion-del-gestor-de-bases-de-datos"></a>
## Instalación del gestor de bases de datos


<a id="creacion-de-bases-de-datos"></a>
## Creación de bases de datos


<a id="mecanismos-de-consulta"></a>
## Mecanismos de consulta


<a id="el-lenguaje-de-consultas-sintaxis-expresiones-operadores"></a>
## El lenguaje de consultas sintaxis, expresiones, operadores


<a id="recuperacion-modificacion-y-borrado-de-informacion"></a>
## Recuperación, modificación y borrado de información


<a id="tipos-de-datos-objeto-atributos-y-metodos"></a>
## Tipos de datos objeto; atributos y métodos


<a id="tipos-de-datos-coleccion"></a>
## Tipos de datos colección



<a id="gestion-de-bases-de-datos"></a>
# Gestión de bases de datos

<a id="acceso-a-bases-de-datos-estandares-caracteristicas"></a>
## Acceso a bases de datos. Estándares. Características


<a id="establecimiento-de-conexiones"></a>
## Establecimiento de conexiones

### Introducción a los ejercicios

En esta sección de ejercicios, te enfocarás en el establecimiento de conexiones con bases de datos utilizando lenguajes de programación como Python o PHP. El objetivo principal es que comprendas cómo configurar y abrir una conexión a una base de datos, manejar errores relacionados con la conexión y finalmente cerrarla adecuadamente. A través de este ejercicio, mejorarás tus habilidades en la gestión de bases de datos, lo que incluye la importancia de las buenas prácticas para asegurar la seguridad y eficiencia del sistema.

### Actividades propuestas

### Actividad 1: Conexión a una Base de Datos Simulada
**Descripción:** Los estudiantes deben crear y probar una conexión con una base de datos simulada o local. Se espera que aprendan cómo establecer correctamente las credenciales, manejar excepciones y verificar la conexión.

### Actividad 2: Consulta Básica en SQL
**Descripción:** A través de un ejercicio práctico, los estudiantes realizarán consultas básicas en una base de datos existente. El objetivo es familiarizarse con el uso de comandos SELECT y entender cómo recuperar datos desde la base de datos.

### Actividad 3: Creación y Uso de Tablas
**Descripción:** Los alumnos deben crear tablas nuevas en una base de datos, definir sus columnas e insertar registros. Esta actividad busca que comprendan las estructuras de tabla y los tipos de datos en SQL.

### Actividad 4: Manejo de Excepciones durante Conexiones
**Descripción:** A partir de ejemplos proporcionados, los estudiantes tendrán que identificar y resolver problemas comunes relacionados con la conexión a una base de datos, como errores de autenticación o falta de recursos. Esto les permitirá mejorar su capacidad para depurar.

### Actividad 5: Ejecución de Consultas Parametrizadas
**Descripción:** Se les pedirá que utilicen consultas parametrizadas para prevenir la inyección SQL y manipular los datos seguramente en una base de datos. Los estudiantes aprenderán a proteger sus aplicaciones web contra ataques.

### Actividad 6: Cierre Correcto de Conexiones
**Descripción:** El objetivo es que los alumnos aprendan cómo cerrar adecuadamente las conexiones con la base de datos para liberar recursos y evitar problemas de rendimiento. Se enfatizará la importancia del manejo correcto de objetos.

### Actividad 7: Creación de Procedimientos Almacenados
**Descripción:** Los estudiantes crearán procedimientos almacenados en una base de datos, combinando múltiples sentencias SQL y operaciones CRUD (Create, Read, Update, Delete). Esto les ayudará a dominar la programación orientada a bases de datos.

### Actividad 8: Uso de Librerías de Conexión
**Descripción:** A través del uso de librerías específicas para conectarse con bases de datos SQL en un entorno de desarrollo, los estudiantes aprenderán cómo configurar y utilizar estas herramientas para facilitar el trabajo con las bases de datos.

### Actividad 9: Pruebas Unitarias para Conexiones
**Descripción:** Se pide a los alumnos que escriban pruebas unitarias básicas para asegurar la correcta conexión y operación en una base de datos. Esto les permitirá entender cómo verificar el funcionamiento de sus aplicaciones.

### Actividad 10: Documentación del Código Relacionado con Bases de Datos
**Descripción:** Los estudiantes deben documentar su código relacionado con la gestión de bases de datos, incluyendo procedimientos y consultas SQL. Esto les ayudará a mejorar sus habilidades de documentación y a mantener un código claro para otros desarrolladores.


<a id="almacenamiento-recuperacion-actualizacion-y-eliminacion-de-informacion-en-bases-de-datos"></a>
## Almacenamiento, recuperación, actualización y eliminación de información en bases de datos



<a id="programacion-en-el-lado-del-servidor"></a>
# Programación en el lado del servidor

<a id="fundamentos"></a>
## Fundamentos

### Introducción a los ejercicios

Este conjunto de ejercicios está diseñado para introducirte al mundo del lado servidor en programación, con un énfasis en PHP. Los problemas abarcan desde la creación básica de archivos PHP que contienen HTML hasta el uso de estructuras más complejas como arrays multidimensionales y clases. A través de estos ejercicios, aprenderás a manipular datos dinámicamente, utilizar operadores lógicos y condicionales, y definir funciones con parámetros. La práctica te permitirá adquirir una comprensión sólida sobre cómo interactuar entre HTML y PHP en un entorno servidor para generar contenido web interactivos.

### diagrama
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es un archivo JSON que describe gráficos y conexiones entre diferentes elementos. En el contexto de la formación profesional, este tipo de estructura suele ser utilizado para representar diagramas en aplicaciones web o para documentar relaciones en proyectos.

El archivo contiene dos tipos principales de objetos: "formas" y "flechas". Las formas son cuadrados (rectangles) y un círculo que contienen información como su posición en la pantalla, dimensiones (aunque estas están vacías), y texto que se muestra dentro del rectángulo o el círculo. Por ejemplo, hay una forma con el ID "forma-1" que es un rectángulo y contiene el texto "PHP".

Las flechas describen las conexiones entre diferentes formas. Cada flecha tiene dos propiedades principales: "desde", que indica desde qué forma parte la flecha, y "hasta", que indica hasta qué forma llega la flecha. En este caso, hay dos flechas definidas:

1. Una flecha que va de la forma con ID "forma-3" (un rectángulo con texto "PHP") al círculo con ID "forma-6" (que contiene el texto "JSON").
2. Otra flecha que va del círculo con ID "forma-6" hasta un rectángulo con ID "forma-5" (que tiene el texto "JS").

Este archivo JSON es importante porque proporciona una estructura clara y organizada para representar diagramas o relaciones en proyectos web, especialmente cuando se trabaja con tecnologías como PHP, HTML, JavaScript y JSON.

`000-diagrama.json`

```json
{
  "formas": [
    {
      "id": "forma-1",
      "tipo": "rectangle",
      "left": "366.413px",
      "top": "203.832px",
      "width": "",
      "height": "",
      "texto": "PHP"
    },
    {
      "id": "forma-2",
      "tipo": "rectangle",
      "left": "366.566px",
      "top": "162.493px",
      "width": "",
      "height": "",
      "texto": "HTML"
    },
    {
      "id": "forma-3",
      "tipo": "rectangle",
      "left": "545.524px",
      "top": "330.509px",
      "width": "",
      "height": "",
      "texto": "PHP"
    },
    {
      "id": "forma-4",
      "tipo": "rectangle",
      "left": "547.995px",
      "top": "129.995px",
      "width": "",
      "height": "",
      "texto": "HTML"
    },
    {
      "id": "forma-5",
      "tipo": "rectangle",
      "left": "548.352px",
      "top": "169.63px",
      "width": "",
      "height": "",
      "texto": "JS"
    },
    {
      "id": "forma-6",
      "tipo": "circle",
      "left": "546.189px",
      "top": "229.623px",
      "width": "",
      "height": "",
      "texto": "JSON"
    }
  ],
  "flechas": [
    {
      "desde": {
        "shapeId": "forma-3",
        "propId": null,
        "side": null
      },
      "hasta": {
        "shapeId": "forma-6",
        "propId": null,
        "side": null
      },
      "tipo": "simple",
      "estilo": "straight"
    },
    {
      "desde": {
        "shapeId": "forma-6",
        "propId": null,
        "side": null
      },
      "hasta": {
        "shapeId": "forma-5",
        "propId": null,
        "side": null
      },
      "tipo": "simple",
      "estilo": "straight"
    }
  ]
}
```

### html en php
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es un ejemplo simple que demuestra cómo puedes combinar HTML y PHP en el mismo archivo. En este caso, la mayor parte del contenido son comentarios en texto puro (no codificación PHP) que explican dónde debe ubicarse el archivo en tu sistema para que funcione correctamente cuando lo abres en un navegador web.

Lo importante de entender aquí es que un archivo con extensión `.php` puede contener tanto código PHP como HTML. En este ejemplo, los bloques de texto dentro de etiquetas `<p>` son HTML puro y se mostrarán tal cual en la página web cuando el servidor los interprete. No hay ningún código PHP activo en esta parte del archivo; simplemente se incluye contenido HTML directamente.

La última parte del comentario indica cómo debes configurar tu entorno (Linux o Windows) para que este archivo esté accesible desde un navegador web utilizando la URL proporcionada. Esto es útil para estudiantes que están aprendiendo a trabajar con servidores web locales como XAMPP o WAMP en su computadora.

`003-html en php.php`

```
Un archivo PHP puede tener HTML
<p>No, en serio, puede realmente tener HMTL</p>
<p>Un archivo PHP no te obliga a poner PHP</p>

Este archivo debe estar

Linux: /var/www/html/(carpeta que queráis)

Windows: C:/xampp/htdocs/(carpeta que queráis)

Y luego en el navegador:
http://localhost/(carpeta que queráis)

En mi caso concreto:
http://localhost/programaciondam2526/010-Programaci%c3%b3n%20en%20el%20lado%20del%20servidor/001-Fundamentos/101-Ejercicios/003-html%20en%20php.php
```

### Probamos PHP
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código está diseñado para demostrar cómo se integra el lenguaje PHP dentro de un documento HTML, aunque en este caso, el archivo podría ser simplemente una página web con instrucciones de PHP. La clave aquí son los delimitadores `<?php` y `?>`, que indican al servidor web dónde comienza y termina el código PHP.

En el código, la línea `echo "Esto si que es php";` dentro de los delimitadores PHP imprime en pantalla el texto "Esto si que es php". Esto significa que cualquier salida generada por esta línea aparecerá en la página web cuando se cargue. Las líneas anteriores y posteriores a estos delimitadores, como "Esto no es PHP" y "Esto ya no es PHP", son simplemente texto plano y serán mostradas tal cual en el navegador.

Este ejemplo es fundamental para entender cómo funciona la combinación de HTML con PHP, permitiendo que los desarrolladores mezclen código dinámico (PHP) con contenido estático (HTML) dentro del mismo archivo.

`004-Probamos PHP.php`

```
Esto no es PHP

<?php
	echo "Esto si que es php";
?>

Esto ya no es PHP
```

### comentarios en php
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es muy básico y se utiliza para mostrar cómo imprimir texto en pantalla usando PHP. La función `echo` es utilizada aquí para escribir la frase "Hola mundo en PHP" en el navegador cuando alguien accede a esta página web.

Además, el código incluye dos tipos diferentes de comentarios que son importantes entender:
1. Los comentarios de una sola línea se inician con `//`. Todo lo que está después del `//` hasta el final de la línea no será ejecutado por PHP y es únicamente para notas o explicaciones.
2. Los comentarios multilínea comienzan con `/*` y terminan con `*/`, permitiendo así escribir múltiples líneas de texto sin que sean ejecutadas como código.

Los comentarios son cruciales porque ayudan a otros desarrolladores (o a ti mismo en el futuro) a entender qué hace cada parte del código.

`006-comentarios en php.php`

```
<?php
	echo "Hola mundo en PHP"; 
  // echo en PHP es como print en Python
  // Esto es un comentario de una única línea
  
  /*
  	Esto es una linea de comentario
    Esto tambien es una linea de comentario
  */
?>
```

### operadores
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código es una introducción básica a los operadores aritméticos en PHP. Cuando se ejecuta, muestra el resultado de varias operaciones matemáticas simples: suma, resta, multiplicación, división y módulo (resto de la división). Cada línea utiliza un parámetro `echo` para imprimir en pantalla el resultado de una expresión aritmética entre los números 4 y 3. Por ejemplo, `echo 4+3;` muestra "7" porque suma 4 y 3. De manera similar, `echo 4-3;`, `echo 4*3;`, `echo 4/3;` e `echo 4%3;` muestran los resultados de restar, multiplicar, dividir y obtener el módulo respectivamente entre estos números.

Este tipo de código es fundamental para entender cómo PHP realiza cálculos matemáticos básicos, lo que es crucial en cualquier programa que requiera realizar operaciones aritméticas.

`007-operadores.php`

```
<?php
	echo 4+3;
  echo 4-3;
  echo 4*3;
  echo 4/3;
  echo 4%3;
?>
```

### romper linea
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código combina tanto HTML como PHP, lo que demuestra cómo estos dos lenguajes pueden interactuar en un archivo. La primera línea "Esto es HTML<br>" y la última línea "Esto vuelve a ser HTML<br>" son parte del marcado HTML, utilizando la etiqueta `<br>` para indicar un salto de línea.

Entre estas dos líneas está el bloque PHP que se encierra entre `<?php` y `?>`. Dentro de este bloque, el código PHP utiliza la función `echo` para imprimir "Esto es PHP<br>" en el navegador. El uso de `<br>` dentro del texto implica nuevamente un salto de línea.

La importancia de este ejemplo radica en mostrar cómo se pueden mezclar bloques de código HTML y PHP en un mismo archivo, permitiendo a los desarrolladores enviar tanto contenido estático (HTML) como dinámico generado por el servidor (PHP).

`008-romper linea.php`

```
Esto es HTML<br>
<?php
	echo "Esto es PHP<br>";
?>	
Esto vuelve a ser HTML<br>
```

### operadores de comparacion
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código PHP está utilizando operadores de comparación para evaluar diferentes condiciones entre dos números y mostrar los resultados en pantalla. Los operadores que se usan son menor que (`<`), menor o igual que (`<=`), mayor que (`>`), mayor o igual que (`>=`), igual a (`==`) y distinto de (`!=`). 

Cada línea del código compara el número 4 con el número 3 utilizando uno de estos operadores. PHP evalúa estas comparaciones y muestra en la pantalla un `1` si la condición es verdadera, o un `0` si es falsa.

Por ejemplo, cuando se ejecuta la línea `echo 4<3;`, PHP compara si 4 es menor que 3, lo cual no es cierto, por lo tanto muestra `0`. Sin embargo, en la línea `echo 4>3;`, PHP verifica si 4 es mayor que 3, lo cual es verdadero, así que muestra `1`.

Estos operadores son fundamentales en programación ya que permiten tomar decisiones basadas en condiciones específicas dentro de un programa.

`009-operadores de comparacion.php`

```
<?php
	echo 4<3;
  echo 4<=3;
  echo 4>3;
  echo 4>=3;
  echo 4==3;
  echo 4!=3;
?>
```

### operadores booleanos
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código muestra cómo funcionan los operadores booleanos en PHP, que son esenciales para la lógica de las decisiones en programación. Los operadores `&&` (AND) y `||` (OR) se usan para combinar varias condiciones.

En el primer ejemplo, se evalúan tres comparaciones con el operador `&&`. Para que toda la expresión sea verdadera (`TRUE`) cuando utiliza `&&`, todas las comparaciones deben ser verdaderas. En este caso, "4 es igual a 4", "3 es igual a 3" y "2 es igual a 2" son ciertas, por lo que el resultado es verdadero.

En la segunda línea, al cambiar una de las condiciones ("2 es igual a 1"), aunque dos son correctas, la tercera no lo está. Por tanto, como todos deben ser verdaderos para que `&&` devuelva verdadero, la salida final será falsa (`FALSE`).

Luego, se utilizan ejemplos con el operador `||`. Con este operador, solo necesita una condición verdadera en toda la expresión para que esta sea verdadera. Por ejemplo, cuando comprobamos "4 es igual a 4" o "3 es igual a 2", aunque la segunda no sea cierta, la primera lo es y por eso el resultado es verdadero.

El último ejemplo muestra que si ninguna de las condiciones es verdadera (como en "4 es igual a 3", "3 es igual a 2" y "2 es igual a 1"), entonces la expresión completa con `||` será falsa. Esto demuestra cómo estos operadores booleanos permiten crear lógicas complejas controlando el flujo del programa según las condiciones que se cumplan o no.

`010-operadores booleanos.php`

```
<?php
	echo 4 == 4 && 3 == 3 && 2 == 2; // Verdadero
  echo 4 == 4 && 3 == 3 && 2 == 1; // Falso
  
  echo 4 == 4 || 3 == 3 || 2 == 2; // Verdadero
  echo 4 == 4 || 3 == 3 || 2 == 1; // Verdadero
  echo 4 == 4 || 3 == 2 || 2 == 1; // Verdadero
  echo 4 == 3 || 3 == 2 || 2 == 1; // Falso
?>
```

### variables
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código es un ejemplo básico en PHP que muestra cómo declarar y utilizar variables. En primer lugar, se declara una variable llamada `$edad` e inicializa con el valor numérico `47`. Luego, se imprime este valor utilizando la función `echo`, seguida de un salto de línea para mejorar la legibilidad en la página web.

Después del salto de línea, el código cambia el valor de la variable `$edad` a `48` y vuelve a imprimir su nuevo valor. Este ejemplo demuestra que las variables en PHP son dinámicas, lo que significa que puedes cambiar sus valores durante la ejecución del programa según sea necesario.

Este bloque es importante porque ilustra cómo almacenar e interactuar con datos utilizando variables en PHP, una habilidad fundamental para cualquier programador web.

`011-variables.php`

```
<?php
	$edad = 47; // Las variables se declaran con dolar
  echo $edad; // Podemos hacer echo de variables
  echo "<br>"; // salto de linea
  $edad = 48; // Podemos cambiar el valor de una variable
  echo $edad;
?>
```

### estructura for y calendario
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código crea una página web que muestra los números del 1 al 30 en cuadros separados. La estructura principal es un documento HTML con CSS para estilizar los cuadros donde se muestran los días.

En el cuerpo de la página, hay un bucle `for` en PHP que itera desde `$dia = 1` hasta `$dia < 31`. En cada iteración del bucle, utiliza la función `echo` para imprimir una etiqueta `<div>` con la clase CSS 'dia'. Dentro de esta etiqueta se imprime el valor actual de `$dia`, lo que resulta en un conteo numérico desde el día 1 hasta el día 30.

El estilo aplicado a cada cuadro, definido por la clase CSS 'dia', asegura que estos números estén presentados dentro de cajas pequeñas con bordes negros y cierto relleno. Este tipo de estructura es común en calendarios simples o listas de días del mes.

`012-estructura for y calendario.php`

```
<!doctype html>
<html>
	<head>
  	<style>
    	.dia{border:1px solid black;padding:10px;width:50px;
      height:50px;display:inline-block;}
    </style>
  </head>
  <body>
    <?php
      // El signo de encadenamiento es el . (y eso es superguay)

      for($dia = 1;$dia < 31;$dia++){
        echo "<div class='dia'>".$dia."</div>";
      }
    ?>
  </body>
</html>
```

### if
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código PHP verifica si la variable `$edad` es menor que 30 y, dependiendo del resultado de esa comparación, imprime una frase en específico. En este caso, la variable `$edad` se ha inicializado con el valor 47 al inicio del script. Luego, el programa evalúa la condición dentro de la estructura `if`, es decir, comprueba si 47 (el valor de `$edad`) es menor que 30.

Dado que 47 no es menor que 30, la parte interior del bloque `if` no se ejecuta, por lo que ningún texto "Eres un joven" aparecerá en la salida. Si cambias el valor de `$edad` a cualquier número menor que 30, entonces sí se imprimiría esa frase.

Este tipo de estructura condicional es muy útil para tomar decisiones en programas basadas en diferentes condiciones y valores.

`013-if.php`

```
<?php

	$edad = 47;
  if($edad < 30){
  	echo "Eres un joven";
  }
  
?>
```

### else
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código PHP es una sencilla demostración de cómo utilizar la estructura condicional `if-else` para tomar decisiones en el programa. La variable `$edad`, que contiene el valor 47, se compara con el número 30 usando un operador menor que (`<`). Si la edad fuera menor a 30 años, el código imprimiría "Eres un joven". Sin embargo, ya que la edad es mayor o igual a 30, entra en el bloque `else` y muestra por pantalla "Ya no eres un joven".

Esta estructura de control permite al programa ejecutar diferentes bloques de código según ciertas condiciones. En este caso, la condición es una forma simple de categorizar a las personas basándose en su edad, lo que es útil para mostrar información personalizada o tomar decisiones dentro del sistema basadas en los datos del usuario.

`014-else.php`

```
<?php

	$edad = 47;
  if($edad < 30){
  	echo "Eres un joven";
  }else{
  	echo "Ya no eres un joven";
  }
  
?>
```

### else if
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código PHP es una secuencia de condiciones `if-elseif-else` que evalúa la edad de una persona y muestra diferentes mensajes dependiendo del rango en el que se encuentre dicha edad. La variable `$edad` está inicializada con un valor de 47.

El programa primero comprueba si `$edad` es menor que 10, lo que significaría que la persona es considerada un niño. Si esta condición no se cumple, entonces evalúa otras condiciones consecutivas: si la edad está entre 10 y 20 años (inclusive el 10 pero excluyendo el 20), la persona sería clasificada como adolescente; si la edad está entre 20 y 30 años (inclusive el 20 pero excluyendo el 30), se considera a la persona como joven. Si ninguna de estas condiciones es verdadera, lo que incluiría cualquier valor igual o mayor a 30, entonces se imprime "Ya no eres joven".

Este tipo de estructuras condicionales son comunes en programación para manejar diferentes casos según las características específicas del usuario o los datos ingresados.

`015-else if.php`

```
<?php

	$edad = 47;
  
  if($edad < 10){
  	echo "Eres un niño";
  }else if($edad >= 10 && $edad < 20){
  	echo "Eres un adolescente";
  }else if($edad >= 20 && $edad < 30){
  	echo "Eres un joven";
  }else{
  	echo "Ya no eres joven";
  }
  
?>
```

### switch
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

El código muestra cómo utilizar una estructura `switch` en PHP para determinar y mostrar un mensaje basado en el valor de la variable `$dia_de_la_semana`. En este caso, la variable está inicializada con el valor "martes". La estructura `switch` compara el valor de esta variable contra diferentes casos (como 'lunes', 'martes', etc.) para determinar qué bloque de código ejecutar.

Cada caso dentro del `switch` tiene una declaración `echo` que imprime un mensaje específico sobre ese día de la semana. Por ejemplo, si `$dia_de_la_semana` es "martes", el código imprimirá "hoy es el segundo peor día de la semana". Al final de cada bloque `case`, se utiliza la instrucción `break` para evitar que el programa siga ejecutando líneas adicionales después del caso correspondiente, lo cual es crucial para asegurar que solo se imprima el mensaje correcto.

Esta estructura es importante porque permite manejar múltiples condiciones de manera clara y concisa, en lugar de usar muchos `if-else` anidados. Esto mejora la legibilidad del código y facilita su mantenimiento a medida que se expande o se actualiza.

`016-switch.php`

```
<?php
	$dia_de_la_semana = "martes";
	switch($dia_de_la_semana){
  	case "lunes":
    	echo "hoy es el peor dia de la semana";
      break;
    case "martes":
    	echo "hoy es el segundo peor día de la semana";
      break;
    case "miercoles":
    	echo "hoy ya estamos a mitad de semana";
      break;
    case "jueves":
    	echo "Ya casi es viernes";
      break;
    case "viernes":
    	echo "Por fin es viernes";
      break;
    case "sábado":
    	echo "Este es el mejor dia de la semana";
      break;
    case "domingo":
    	echo "Parece mentira que mañana ya sea lunes";
      break;
  }

?>
```

### arrays
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código PHP crea un array (también conocido como lista o vector en otros lenguajes de programación) llamado `$frutas` que contiene tres elementos: 'manzana', 'pera' y 'platano'. Luego, utiliza la función `var_dump()` para imprimir información detallada sobre el array, incluyendo su tipo (en este caso, un array), sus valores y algunos detalles adicionales sobre su estructura.

La función `var_dump()` es útil cuando quieres tener una visibilidad completa de lo que contiene una variable. En este ejemplo, te mostrará exactamente qué frutas están en el array `$frutas`, junto con información sobre cómo está estructurado ese array dentro del código PHP. Esto ayuda a los programadores a depurar errores o simplemente a entender mejor las variables complejas como los arrays.

`017-arrays.php`

```
<?php
	$frutas = ['manzana','pera','platano'];
  
  var_dump($frutas);
?>
```

### arrays multidimensionales
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código en PHP crea un array multidimensional llamado `$agenda`. En este caso, el array contiene información sobre varias personas, donde cada persona es representada por una submatriz que incluye su nombre, apellido y edad. Cada subarray dentro de `$agenda` corresponde a un individuo distinto.

El código utiliza la función `var_dump()` para mostrar en pantalla toda la estructura del array `$agenda`, incluyendo el tipo de datos y los valores que contiene. Esto es útil para verificar cómo se ha construido el array y entender su contenido de manera detallada.

Es importante destacar que este ejemplo ilustra cómo organizar información compleja en arrays multidimensionales, lo cual es una habilidad clave en la programación orientada a datos en PHP.

`018-arrays multidimensionales.php`

```
<?php

	$agenda = [
  	["Jose Vicente","Carratala",47],
    ["Juan","Martinez",45],
    ["Jaime","Lopez",46]
  ];
  
  var_dump($agenda);
  
?>
```

### declarar una funcion
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es una función simple en PHP que se llama `diHola`. La función no toma ningún parámetro y cuando se ejecuta, simplemente imprime el texto "Hola como estás" en la página web o en la salida estándar del servidor. Las funciones son bloques de código reutilizables que permiten organizar mejor tu programa al agrupar instrucciones específicas para realizar tareas particulares. En este caso, cada vez que necesites saludar a alguien en una aplicación web, podrías llamar a esta función `diHola()` sin tener que escribir el mensaje de nuevo.

El uso de funciones es fundamental en la programación ya que facilita la lectura y mantenimiento del código, permitiendo también reutilizar bloques de código que realizan tareas comunes a lo largo de tu programa.

`019-declarar una funcion.php`

```
<?php
	function diHola(){
  	echo "Hola como estás";
  }
?>
```

### usar la funcion
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es un ejemplo básico en PHP que muestra cómo declarar e invocar una función simple. La función se llama `diHola` y su propósito principal es imprimir el saludo "Hola como estás" cuando se ejecuta.

La estructura de la función comienza con la palabra clave `function`, seguida del nombre de la función (`diHola`) en este caso, entre paréntesis. Dentro del bloque de código definido por las llaves `{}`, hay una instrucción `echo` que imprime el texto "Hola como estás". Esto significa que cada vez que se llama a la función `diHola`, esta mostrará ese saludo en pantalla.

Después de definir la función, el código invoca o llama a dicha función con la línea `diHola();`. Esta llamada ejecuta todo lo que está dentro de la función `diHola`, es decir, imprime "Hola como estás".

Este tipo de estructura es fundamental en programación ya que permite organizar y reutilizar bloques de código, facilitando la creación y mantenimiento de programas más grandes y complejos.

`020-usar la funcion.php`

```
<?php
	function diHola(){
  	echo "Hola como estás";
  }
  
  diHola();
?>
```

### funciones con parametros
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es un ejemplo sencillo de cómo definir y usar una función en PHP que recibe un parámetro. La función se llama `diHola` y toma un argumento que representa el nombre de una persona. Dentro de la función, utiliza la función `echo` para imprimir un saludo personalizado que incluye el nombre proporcionado.

Cuando llamas a la función `diHola("Jose Vicente")`, el código imprime en la pantalla: "Hola, Jose Vicente como estás". Esta es una forma básica pero efectiva de usar funciones con parámetros en PHP para personalizar y reutilizar bloques de código.

`021-funciones con parametros.php`

```
<?php
	function diHola($nombre){
  	echo "Hola, ".$nombre." como estás";
  }
  
  diHola("Jose Vicente");
?>
```

### varios parametros
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código en PHP es un ejemplo simple que demuestra cómo definir y utilizar una función con parámetros. La función se llama `diHola` y recibe dos argumentos: `$nombre`, que generalmente sería el nombre de una persona, y `$edad`, que indica la edad de esa persona.

Dentro de la función, el código usa la función `echo` para imprimir un saludo personalizado en pantalla. La salida del texto combina las variables pasadas como parámetros con cadenas estáticas, creando así un mensaje amigable y personalizado que dice "Hola" seguido del nombre proporcionado, su edad y una pregunta sobre cómo están.

Este tipo de código es importante porque muestra cómo encapsular funcionalidades en bloques reutilizables (en este caso, la función `diHola`) que pueden recibir datos variados para adaptar su salida. Esto facilita el mantenimiento del código y mejora la claridad al trabajar con programas más grandes.

`022-varios parametros.php`

```
<?php
	function diHola($nombre,$edad){
  	echo "Hola, ".$nombre." tienes ".$edad." años, como estás";
  }
  
  diHola("Jose Vicente",47);
?>
```

### return en la funcion
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código PHP define una función llamada `diHola` que toma dos parámetros: `$nombre` y `$edad`. La función crea un mensaje personalizado que saluda al usuario por su nombre e indica cuántos años tiene, utilizando la información proporcionada en los parámetros. Luego, el código llama a esta función pasándole los valores "Jose Vicente" para el nombre y 47 para la edad. El resultado de llamar a `diHola` es un string que dice "Hola, Jose Vicente tienes 47 años, como estás". Finalmente, este mensaje se imprime en la página web usando `echo`.

El uso del comando `return` dentro de una función es crucial porque permite que la función genere un resultado específico (en este caso, el saludo personalizado) que puede ser utilizado más adelante en el código, por ejemplo para mostrarlo en una pantalla o enviarlo a otra parte. Esto hace que las funciones sean muy útiles y flexibles en programación.

`023-return en la funcion.php`

```
<?php
	function diHola($nombre,$edad){
  	return "Hola, ".$nombre." tienes ".$edad." años, como estás";
  }
  
  echo diHola("Jose Vicente",47);
?>
```

### vamos con los gatos
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código te enseña cómo crear objetos en PHP usando clases. Una clase es como un plano para construir cosas, y en este caso, estamos creando gatos. La clase se llama `Gato` y tiene un constructor que recibe dos parámetros: el color del gato y su edad.

Cuando creamos los objetos `$gato1` y `$gato2`, le damos a cada uno un color y una edad diferentes. Por ejemplo, `$gato1` es naranja y tiene 1 año, mientras que `$gato2` es blanco y tiene 2 años.

Finalmente, el `var_dump($gato1);` muestra toda la información del objeto `$gato1`, incluyendo su color y edad. Esto te ayuda a ver cómo se ha guardado la información dentro del objeto después de crearlo con los valores específicos que le has dado.

Este código es importante porque muestra cómo definir clases, inicializar objetos con propiedades específicas usando el constructor, y cómo visualizar los detalles internos de un objeto creado en PHP.

`024-vamos con los gatos.php`

```
<?php

	class Gato{
  	function __construct($color,$edad){
    	$this->color = $color;
      $this->edad = $edad;
    }
  }
  
  $gato1 = new Gato("Naranja",1);
  $gato2 = new Gato("Blanco",2);
  
  var_dump($gato1);

?>
```

### Actividades propuestas

### Actividades Propuestas

#### **Actividad 1: Introducción a PHP**
**Descripción:** Aprender los fundamentos de PHP, incluyendo cómo se ejecuta el código y cómo intercambia información entre HTML. Los estudiantes deben crear un archivo PHP simple que imprima "¡Hola Mundo!" en la página web.

#### **Actividad 2: Uso de Comentarios**
**Descripción:** Aprender a utilizar comentarios tanto para una línea como para múltiples líneas en PHP. Los estudiantes deberán comentar su código y añadir documentación adicional para cada función o bloque de código importante.

#### **Actividad 3: Operaciones Básicas con PHP**
**Descripción:** Practicar operadores aritméticos (suma, resta, multiplicación, división, módulo) en PHP. Los estudiantes deben escribir un programa que realice cálculos básos y los imprima en la página web.

#### **Actividad 4: Condiciones y Control de Flujo**
**Descripción:** Implementar estructuras condicionales (if/else) para manejar lógica compleja. Los estudiantes deben escribir un programa que clasifique a las personas según su edad, usando if, else-if y else.

#### **Actividad 5: Estructura Switch en PHP**
**Descripción:** Utilizar la estructura switch para simplificar el código cuando se necesitan múltiples condiciones de igualdad. Los estudiantes deben crear un programa que identifique el día de la semana basado en una entrada dada.

#### **Actividad 6: Trabajo con Variables**
**Descripción:** Aprender a declarar y manipular variables en PHP. Los estudiantes deberán escribir programas que cambien los valores de las variables y luego impriman dichos cambios.

#### **Actividad 7: Creación de Arrays Simples**
**Descripción:** Introducción a arrays unidimensionales. Los estudiantes deben crear arrays para almacenar listas de elementos (como frutas) e imprimir sus contenidos.

#### **Actividad 8: Trabajo con Arrays Multidimensionales**
**Descripción:** Aprender a trabajar con arrays multidimensionales en PHP, como tablas o matrices. Los estudiantes deberán crear un array que represente una agenda y mostrar su contenido utilizando `var_dump()`.

#### **Actividad 9: Funciones Simples en PHP**
**Descripción:** Crear funciones sin parámetros en PHP para realizar tareas específicas (como imprimir un mensaje). Los estudiantes deben escribir al menos dos funciones simples y llamarlas desde el código principal.

Estas actividades están diseñadas para proporcionar una base sólida sobre los fundamentos de programación en PHP, adaptados al nivel y ritmo adecuado para estudiantes de ciclos formativos.


<a id="get-y-post"></a>
## get y post

### Introducción a los ejercicios

Este conjunto de ejercicios está diseñado para ayudarte a comprender y practicar el manejo de las solicitudes GET y POST en la programación del lado del servidor. A través de una serie de archivos HTML y PHP, aprenderás cómo enviar y recibir datos mediante parámetros en la URL (GET) y formularios (POST), así como cómo validar y procesar esa información de manera segura y eficiente. Los ejercicios también te familiarizarán con el uso de variables superglobales como $_GET y $_POST, y con técnicas básicas de depuración y manejo de errores en PHP.

### get
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es una parte fundamental de cómo los programas web reciben información enviada desde el navegador. En este caso, específicamente, el programa espera recibir un parámetro llamado "nombre" en la URL del sitio web.

La línea `echo $_GET['nombre'];` toma el valor que se ha enviado como 'nombre' en la URL (por ejemplo, si alguien visita tu página con "?nombre=Juan", esta línea imprimirá "Juan"). El símbolo `$_GET` es una variable superglobal de PHP que almacena todos los datos enviados por GET. Esta forma de enviar información es común cuando quieres que los usuarios vean en la URL qué tipo de información están proporcionando, como en las búsquedas web.

Esta técnica es importante porque permite a los sitios web interactuar con los visitantes y obtener entradas sencillas desde el navegador del usuario sin necesidad de un formulario más complejo.

`002-get.php`

```
<?php
	// Espera que en la URL haya un parametro llamado nombre
	echo $_GET['nombre'];
?>
```

### dos parametros get
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código es un fragmento de una página web en PHP que muestra los datos enviados mediante la técnica GET. Cuando se accede a esta página, se espera que en la URL haya dos parámetros: uno llamado "nombre" y otro llamado "apellidos". El programa simplemente imprime el valor del nombre y luego el valor de los apellidos separados por un salto de línea (que se ve como una nueva línea en la página web).

Por ejemplo, si accedes a `http://ejemplo.com/programaciondam2526/010-Programación en el lado del servidor/002-get y post/101-Ejercicios/004-dos parametros get.php?nombre=Juan&apellidos=Pérez García`, verás "Juan" seguido de un salto de línea, y luego "Pérez García". Este tipo de código es útil para entender cómo los formularios web envían información a través de la URL y cómo puedes capturar esos datos en PHP.

`004-dos parametros get.php`

```
<?php
	echo $_GET['nombre'];
  echo "<br>";
  echo $_GET['apellidos'];
?>
```

### formulario
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código HTML crea un formulario simple donde los usuarios pueden introducir su nombre. Cuando el usuario completa el campo del formulario y presiona el botón "Enviar", toda la información ingresada es enviada al archivo `006-post.php` usando el método HTTP POST.

El atributo `action="006-post.php"` en la etiqueta `<form>` indica que los datos recopilados por este formulario deben ser procesados por el archivo PHP llamado `006-post.php`. El atributo `method="POST"` especifica que los datos del formulario se enviarán mediante una solicitud POST, lo cual es seguro y útil para transmitir información sensible o larga.

La etiqueta `<input type="text" name="nombre">` crea un campo de entrada donde el usuario puede escribir su nombre. El atributo `name="nombre"` indica que la clave del dato enviado será "nombre", por lo que en `006-post.php`, este valor podrá ser accedido utilizando la variable `$_POST['nombre']`.

En resumen, este código HTML establece una interacción básica entre un formulario y un archivo PHP para recoger datos de los usuarios de manera segura.

`005-formulario.html`

```html
<form action="006-post.php" method="POST">
  <p>Introduce tu nombre</p>
  <input type="text" name="nombre">
  <input type="submit">
</form>

006-post.php = quien te procesa
POST = como se va a enviar y recibir la informacion
name="nombre" = la clave que se va a enviar
```

### post
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código PHP está diseñado para recuperar y mostrar un valor enviado a través del método POST en una solicitud HTTP. Cuando un usuario envía información a través de un formulario web con el método POST, esa información se almacena en el array global `$_POST` dentro del servidor web.

En este caso específico, el código imprime el valor asociado a la clave 'nombre' que fue enviado desde un formulario HTML. Esta clave ('nombre') es asignada en el atributo `name` de un elemento `<input>` en el formulario HTML cuando se envían los datos al servidor.

Es importante usar el método POST para enviar información sensible o larga, ya que no aparece visible en la URL del navegador como sucede con GET. Además, asegura que cualquier dato enviado sea correctamente almacenado y recuperado dentro de `$_POST` en lugar de otros arrays, garantizando así que los datos enviados por POST se tratan adecuadamente en el lado del servidor.

`006-post.php`

```
<?php
	echo $_POST['nombre'];
?>

$_POST porque me envían la información por POST
Y la tengo que recoger por la misma vía

'nombre' porque es la clave que se ha enviado desde HTML
```

### autoprocesamiento
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es una página PHP que se encarga de mostrar el nombre introducido por un usuario a través de un formulario. Cuando el usuario introduce su nombre en el campo del formulario y lo envía, la página PHP recoge ese dato usando `$_POST['nombre']` y lo muestra directamente en la pantalla.

El código comienza con `<?php`, que indica el inicio de una sección de código PHP, seguido por `echo $_POST['nombre'];`. Aquí, `$_POST['nombre']` es un array en PHP que almacena los datos enviados a través del método POST desde un formulario HTML. En este caso, está buscando la entrada con el nombre "nombre" que fue especificada en el atributo `name` del campo de texto en el formulario.

El formulario HTML proporciona una interfaz donde el usuario puede introducir su nombre. El atributo `method="POST"` indica que los datos enviados por el formulario deben ser tratados usando la técnica HTTP POST, lo cual es adecuado para enviar información sensible o larga sin riesgo de pérdida de datos importantes (como cuando se usa GET). La etiqueta `<form action="?">` especifica que el mismo archivo PHP debería procesar la entrada del usuario. Esto significa que el formulario vuelve a cargar la misma página después de que el usuario envíe sus datos.

Esta técnica, en la que un archivo PHP procesa y muestra información directamente en sí mismo, se conoce como autoprocesamiento, y es una herramienta útil para validar y mostrar formularios en lenguajes web como PHP.

`007-autoprocesamiento.php`

```
<?php
	echo $_POST['nombre'];
?>

<form action="?" method="POST">
  <p>Introduce tu nombre</p>
  <input type="text" name="nombre">
  <input type="submit">
</form>
```

### comprobacion
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

El fragmento de código que has proporcionado es incorrecto y generará un error al intentar ejecutarlo. En PHP, no puedes escribir texto literal como "esto da error si o si" dentro del bloque de código entre las etiquetas `<?php ?>` sin usar comillas ni definir el texto como una cadena (string). Para evitar errores, siempre es necesario rodear cualquier texto con comillas simples ('') o dobles ("") cuando se incluye en un script PHP. En este caso, si quisieras imprimir esa frase en pantalla, deberías escribir `echo 'esto da error si o si';` o `echo "esto da error si o si";`. Esto es crucial para que el código funcione correctamente y no genere errores de sintaxis.

`009-comprobacion.php`

```
<?php
	esto da error si o si
?>
```

### retomamos
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es una parte simple pero importante del aprendizaje sobre formularios y envío de datos en PHP. La página web contiene un formulario donde el usuario puede ingresar su nombre, que luego se muestra debajo del formulario después de enviarlo.

Primero, el código PHP `<?php echo $_POST['nombre']; ?>` imprime el valor que ha sido enviado al servidor a través de una solicitud POST con el nombre "nombre". Esto significa que si un usuario introduce algo en el campo de texto y luego envía el formulario, lo que haya escrito aparecerá justo donde está la línea PHP.

A continuación, hay un formulario HTML `<form action="?" method="POST">...</form>`. Este formulario permite a los usuarios ingresar su nombre en una caja de texto. La acción del formulario es `?`, lo que significa que el formulario se enviará al mismo archivo donde se encuentra (en este caso, `retomamos.php`). El método usado para enviar el formulario es POST, que oculta los datos enviados en la URL y permite manejar cantidades más grandes de información.

Este código es útil porque demuestra cómo recibir y mostrar información enviada por un usuario a través de un formulario web utilizando PHP. Es fundamental entender este concepto cuando se trabaja con formularios dinámicos en sitios web.

`010-retomamos.php`

```
<?php
	echo $_POST['nombre'];
?>

<form action="?" method="POST">
  <p>Introduce tu nombre</p>
  <input type="text" name="nombre">
  <input type="submit">
</form>
```

### comprobacion de existencia
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código PHP está diseñado para comprobar si se ha enviado un dato a través del método POST y mostrar ese dato en caso de que sea así. El bloque `if(isset($_POST['nombre']))` verifica si el formulario enviado incluye un campo llamado 'nombre'. Si existe, muestra el valor introducido por el usuario en la página.

El formulario HTML anexado permite al usuario ingresar su nombre en un campo de texto y enviarlo a través del método POST cuando hace clic en el botón "Enviar". El atributo `name="nombre"` del elemento `<input>` es clave para que PHP pueda identificar los datos enviados por el formulario.

`011-comprobacion de existencia.php`

```
<?php
	// Comprobación de existencia isset
	if(isset($_POST['nombre'])){
		echo $_POST['nombre'];
  }
?>

<form action="?" method="POST">
  <p>Introduce tu nombre</p>
  <input type="text" name="nombre">
  <input type="submit">
</form>
```

### preguntas y respuestas
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código HTML crea una página web simple que permite a los usuarios introducir preguntas y respuestas. La estructura principal de la página incluye un encabezado, un contenido principal donde se encuentra el formulario, y un pie de página.

En la parte central del documento, hay un formulario con dos campos: uno para ingresar una pregunta y otro para ingresar una respuesta. El formulario utiliza el método POST para enviar los datos al servidor cuando el usuario hace clic en el botón "Enviar". La acción del formulario es "?", lo que significa que se envían los datos a la misma página desde donde proviene la solicitud.

El estilo CSS integrado (incluido dentro de las etiquetas `<style>...</style>` en la cabecera) se encarga de dar un aspecto visual limpio y centrado al documento, asegurando que el contenido esté bien organizado y fácil de leer. El código CSS también establece márgenes y rellenos para cada elemento del formulario y estructura el diseño general de la página usando flexbox.

Esta página es importante porque enseña cómo crear un formulario en HTML y enviar datos al servidor utilizando el método POST, que es más seguro que GET para transferir información sensible o larga.

`012-preguntas y respuestas.php`

```
<!doctype html>
<html>
	<head>
  	<style>
    	body,html{width:100%;height:100%;padding:0px;margin:0px;}
      body{
      	display:flex;align-items:center;justify-content:center;
        background:lightgray;flex-direction:column;}
      header,footer,main{
      	width:400px;padding:20px;background:white;
        text-align:center;
        }
      form{display:flex;flex-direction:column;gap:10px;}
      input{padding:10px;}
    </style>
  </head>
  <body>
  	<header>
  		<h1>Preguntas y respuestas</h1>
    </header>
    <main>
    	<form action="?" method="POST">
      	<label for="pregunta">Introduce la pregunta</label>
      	<input type="text" name="pregunta" id="pregunta">
        <label for="respuesta">Introduce la respuesta</label>
      	<input type="text" name="respuesta" id="respuesta">
        <input type="submit">
      </form>
    </main>
    <footer>
    	(c) 2025 Jose Vicente Carratala
    </footer>
  </body>
</html>
```

### atrapamos la informacion
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código es una página web simple que permite a los usuarios introducir una pregunta y su respuesta mediante un formulario. Cuando se envía el formulario, los datos ingresados aparecen en la parte inferior de la misma página.

En primer lugar, observa cómo se estructura todo usando HTML y CSS para darle estilo y formato a la página. La página tiene tres partes principales: encabezado (header), contenido principal (main) y pie de página (footer). El contenido del formulario está dentro de una etiqueta `<form>` que envía los datos al servidor utilizando el método POST.

Lo más importante es lo que ocurre en la parte inferior del documento, donde se encuentra un bloque de código PHP. Este fragmento utiliza `$_POST['pregunta']` y `$_POST['respuesta']` para recuperar los valores ingresados por el usuario en el formulario y luego mostrarlos en la página web.

Este tipo de código es importante porque muestra cómo recoger datos introducidos por los usuarios a través de un formulario HTML y procesar esos datos usando PHP. Es una base fundamental para interactuar con formularios en aplicaciones web dinámicas, permitiendo al servidor responder según las acciones del usuario.

`013-atrapamos la informacion.php`

```
<!doctype html>
<html>
	<head>
  	<style>
    	body,html{width:100%;height:100%;padding:0px;margin:0px;}
      body{
      	display:flex;align-items:center;justify-content:center;
        background:lightgray;flex-direction:column;}
      header,footer,main{
      	width:400px;padding:20px;background:white;
        text-align:center;
        }
      form{display:flex;flex-direction:column;gap:10px;}
      input{padding:10px;}
    </style>
  </head>
  <body>
  	<header>
  		<h1>Preguntas y respuestas</h1>
    </header>
    <main>
    	<form action="?" method="POST">
      	<label for="pregunta">Introduce la pregunta</label>
      	<input type="text" name="pregunta" id="pregunta">
        <label for="respuesta">Introduce la respuesta</label>
      	<input type="text" name="respuesta" id="respuesta">
        <input type="submit">
      </form>
    </main>
    <footer>
    	(c) 2025 Jose Vicente Carratala
      <?php
      	echo $_POST['pregunta'];
        echo "<br>";
        echo $_POST['respuesta'];
      ?>
    </footer>
  </body>
</html>
```

### isset
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este código es una página web simple que permite a los usuarios enviar preguntas y respuestas mediante un formulario. La estructura HTML incluye estilos básicos para centrar el contenido y hacerlo más agradable visualmente.

Lo importante en este fragmento es lo que sucede cuando se envía el formulario. Cuando el usuario completa los campos de "pregunta" y "respuesta" y hace clic en enviar, los datos son enviados al servidor usando el método POST (no visible en la URL). En el pie de la página web (`<footer>`), hay un bloque de código PHP que comprueba si se han enviado tanto la pregunta como la respuesta a través del formulario.

El comando `if(isset($_POST['pregunta']) && isset($_POST['respuesta']))` verifica si los campos "pregunta" y "respuesta" han sido enviados correctamente. Si ambos están presentes, el código imprime las preguntas y respuestas directamente en la página web. Esto es útil para comprobar que los datos se envían correctamente y pueden ser utilizados por otros scripts PHP después.

Esta práctica es importante porque te permite manejar datos enviados desde un formulario de manera segura y efectiva, asegurándote de que todos los campos necesarios han sido completados antes de intentar usar esos datos.

`014-isset.php`

```
<!doctype html>
<html>
	<head>
  	<style>
    	body,html{width:100%;height:100%;padding:0px;margin:0px;}
      body{
      	display:flex;align-items:center;justify-content:center;
        background:lightgray;flex-direction:column;}
      header,footer,main{
      	width:400px;padding:20px;background:white;
        text-align:center;
        }
      form{display:flex;flex-direction:column;gap:10px;}
      input{padding:10px;}
    </style>
  </head>
  <body>
  	<header>
  		<h1>Preguntas y respuestas</h1>
    </header>
    <main>
    	<form action="?" method="POST">
      	<label for="pregunta">Introduce la pregunta</label>
      	<input type="text" name="pregunta" id="pregunta">
        <label for="respuesta">Introduce la respuesta</label>
      	<input type="text" name="respuesta" id="respuesta">
        <input type="submit">
      </form>
    </main>
    <footer>
    	(c) 2025 Jose Vicente Carratala
      <?php
      	if(isset($_POST['pregunta']) && isset($_POST['respuesta'])){
          echo $_POST['pregunta'];
          echo "<br>";
          echo $_POST['respuesta'];
        }
      ?>
    </footer>
  </body>
</html>
```

### Actividades propuestas

### Actividad 1: Manejo de Parámetros GET
**Descripción:** Los estudiantes deben crear una página PHP que reciba dos parámetros por URL y los muestre en la página. Este ejercicio les ayudará a comprender cómo manejar datos enviados mediante el método GET.

### Actividad 2: Creación de Formularios HTML con Envío POST
**Descripción:** Los estudiantes deben diseñar un formulario que recoja información del usuario y la envíe utilizando el método POST. Esto permitirá que los alumnos comprendan cómo enviar datos sensibles sin mostrarlos en la URL.

### Actividad 3: Procesamiento de Formularios Autoprocesados
**Descripción:** Los estudiantes deben crear una página PHP con un formulario autoprocesado que recoge y muestra información del usuario sin redirigirse. Esto les enseñará sobre el uso del método POST en formularios.

### Actividad 4: Validación de Datos Recibidos por POST
**Descripción:** Se requiere que los estudiantes validen la existencia de datos enviados mediante POST antes de procesarlos, utilizando la función `isset()`. Esto les ayudará a manejar errores comunes y mejorar la robustez del código.

### Actividad 5: Integración HTML y PHP para Formularios Complejos
**Descripción:** Los estudiantes deben crear una página que contenga un formulario complejo con varios campos de entrada, procesados por PHP. El objetivo es combinar HTML y PHP para manejar datos entrantes de manera efectiva.

### Actividad 6: Configuración del Ambiente de Desarrollo (php.ini)
**Descripción:** Los estudiantes deben aprender a configurar el archivo php.ini en su entorno local de desarrollo, especialmente cómo activar la visualización de errores. Esto les ayudará a depurar problemas técnicos con mayor facilidad.

### Actividad 7: Manejo de Errores y Excepciones
**Descripción:** Los estudiantes deben identificar y corregir un ejemplo dado que contiene errores lógicos en PHP. El objetivo es mejorar la capacidad para detectar y solucionar problemas comunes en el desarrollo web.

### Actividad 8: Integración de Formularios Dinámicos con Validaciones
**Descripción:** Los estudiantes deben crear formularios dinámicos utilizando HTML5 y CSS3, que validan automáticamente los datos del usuario antes de enviarlos al servidor para procesamiento. Esto les enseñará a mejorar la experiencia del usuario y reducir el trabajo en el lado del servidor.

### Actividad 9: Creación de Preguntas y Respuestas Interactivas
**Descripción:** Los estudiantes deben implementar un sistema sencillo que permita introducir preguntas y respuestas mediante formularios, mostrándolas al finalizar. Esto ayudará a comprender cómo integrar múltiples campos en un formulario.

### Actividad 10: Uso de isset para Validar Datos Complejos
**Descripción:** Los estudiantes deben crear una página que recibe varios datos por POST y utiliza `isset()` para validar cada uno de ellos antes de procesarlo. Esto les ayudará a manejar formularios complejos y evitar errores lógicos en el código.


<a id="persistencia"></a>
## Persistencia

### Introducción a los ejercicios

En esta carpeta, encontrarás una serie de ejercicios que te permitirán aprender y practicar la persistencia en el lado del servidor mediante PHP. Los ejercicios abordan temas como la manipulación de archivos y permisos en sistemas UNIX/Linux, así como la interacción con formularios HTML para guardar datos en archivos JSON o texto plano. Estos ejercicios te ayudarán a mejorar tus habilidades en la gestión de datos dinámicos, el manejo de estructuras de datos como arrays asociativos y su conversión a formatos como JSON, además de aprender cómo controlar permisos de archivos para garantizar la seguridad del sistema.

### escribir texto
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código es una pequeña secuencia que te enseña cómo escribir información en un archivo utilizando la programación en PHP. En primer lugar, el código abre o crea (si no existe) un archivo llamado "archivo.txt" en modo de anexo ("a"), lo que significa que cualquier texto nuevo se añadirá al final del contenido ya existente en el archivo, sin eliminar nada. Luego, utiliza la función `fwrite()` para agregar una línea específica de texto, que es "Nuevo texto escrito desde PHP", seguido de un salto de línea para mejorar la legibilidad si hay más entradas posteriores.

Finalmente, se cierra el archivo con `fclose($archivo)`, lo cual es importante hacer siempre después de manipular un archivo para liberar recursos del sistema. Este proceso es fundamental en programación web cuando necesitas guardar datos permanentemente en el servidor, como por ejemplo registros de actividad o información proporcionada por los usuarios a través de formularios.

`001-escribir texto.php`

```
<?php
  $archivo = fopen("archivo.txt", "a"); // "a" = append
  fwrite($archivo, "Nuevo texto escrito desde PHP\n");
  fclose($archivo);
?>
```

### leer
<small>Creado: 2025-12-03 09:54</small>

#### Explicación

Este código PHP se encarga de leer el contenido de un archivo llamado "archivo.txt" y luego mostrar ese contenido en la página web. Primero, abre el archivo para lectura usando la función `fopen()`. Luego, lee todo el contenido del archivo utilizando la función `fread()`, donde especifica que debe leer hasta el final del archivo ("filesize("archivo.txt")"). Finalmente, imprime el contenido leído con `echo` y cierra el archivo con `fclose()` para asegurarse de que los recursos sean liberados correctamente. Este tipo de código es importante cuando necesitas mostrar datos almacenados en archivos o realizar operaciones basadas en la información del mismo.

`003-leer.php`

```
<?php
  $archivo = fopen("archivo.txt", "r"); // "r" = leer/read
  
  // Parámetros 1.-Lo que lees 2.-Longitud de lo que lees
  $contenido = fread($archivo,filesize("archivo.txt"));
  
  echo $contenido;
  fclose($archivo);
?>
```

### array nombrado en php
<small>Creado: 2025-12-03 10:12</small>

#### Explicación

Este código PHP crea un array asociativo llamado `$cliente` y le asigna valores a diferentes elementos del mismo. En este caso, se crean tres claves para el array: 'nombre', 'apellidos' y 'email'. A cada una de estas claves se les asigna un valor específico:

- La clave 'nombre' contiene la cadena "Jose Vicente".
- La clave 'apellidos' tiene el valor "Carratala Sanchis".
- Y finalmente, la clave 'email' almacena el correo electrónico "info@jocarsa.com".

Después de definir estos datos en el array `$cliente`, se utiliza la función `var_dump()` para mostrar en pantalla todos los detalles del array. Esto incluye tanto las claves como los valores que contiene cada una, lo cual es útil para verificar que todo está almacenado correctamente.

Este tipo de estructura de datos es muy común en programación web cuando necesitas almacenar información relacionada de un usuario o cliente en un formato fácilmente accesible y legible por el programa.

`004-array nombrado en php.php`

```
<?php
  $cliente = [];
  $cliente['nombre'] = "Jose Vicente";
  $cliente['apellidos'] = "Carratala Sanchis";
  $cliente['email'] = "info@jocarsa.com";
  
  var_dump($cliente);
?>
```

### saco el array como json
<small>Creado: 2025-12-03 10:12</small>

#### Explicación

Este código PHP crea un array llamado `$cliente` que almacena información personal de una persona, como su nombre, apellidos y email. Primero, se inicializa el array vacío y luego se le asignan valores a cada clave del array usando nombres descriptivos como 'nombre', 'apellidos' y 'email'. Luego, utiliza la función `json_encode()` para convertir este array en un formato JSON (que es una forma de almacenar datos de manera estructurada y que puede ser fácilmente leída por diferentes lenguajes de programación). Finalmente, imprime el contenido del string JSON usando la función `echo`.

Este proceso es importante porque permite transformar los datos internos del programa en un formato estándar que otros sistemas o aplicaciones pueden entender y usar. Esto facilita la comunicación entre distintas partes de una aplicación web o incluso entre diferentes aplicaciones.

`005-saco el array como json.php`

```
<?php
  $cliente = [];
  $cliente['nombre'] = "Jose Vicente";
  $cliente['apellidos'] = "Carratala Sanchis";
  $cliente['email'] = "info@jocarsa.com";
  
  $json = json_encode($cliente);
  echo $json;  
?>
```

### recuperamos el formulario
<small>Creado: 2025-12-03 10:15</small>

#### Explicación

Este fragmento de código es una página web simple que permite a los usuarios enviar preguntas y respuestas. La estructura básica del documento es un HTML con CSS integrado para mejorar la presentación en el navegador.

Cuando un usuario completa el formulario (que tiene campos para introducir tanto una pregunta como una respuesta) y hace clic en "Enviar", los datos ingresados se envían al mismo archivo PHP que está gestionando la página utilizando el método POST. Esto significa que los detalles del formulario no aparecerán en la URL, lo cual es seguro y apropiado para información sensible.

En la parte inferior de la página HTML, hay un código PHP que convierte los datos enviados (almacenados en $_POST) a formato JSON y luego imprime este JSON en el navegador. Esto permite visualizar fácilmente los datos del formulario enviado como texto codificado en JSON, lo cual es útil para depurar o para trabajar con otros lenguajes de programación que utilizan JSON.

Este código es especialmente importante porque demuestra cómo integrar HTML y PHP (un lenguaje de lado del servidor) para manejar formularios web básicos y procesar los datos enviados por usuarios.

`006-recuperamos el formulario.php`

```
<!doctype html>
<html>
	<head>
  	<style>
    	body,html{width:100%;height:100%;padding:0px;margin:0px;}
      body{
      	display:flex;align-items:center;justify-content:center;
        background:lightgray;flex-direction:column;}
      header,footer,main{
      	width:400px;padding:20px;background:white;
        text-align:center;
        }
      form{display:flex;flex-direction:column;gap:10px;}
      input{padding:10px;}
    </style>
  </head>
  <body>
  	<header>
  		<h1>Preguntas y respuestas</h1>
    </header>
    <main>
    	<form action="?" method="POST">
      	<label for="pregunta">Introduce la pregunta</label>
      	<input type="text" name="pregunta" id="pregunta">
        <label for="respuesta">Introduce la respuesta</label>
      	<input type="text" name="respuesta" id="respuesta">
        <input type="submit">
      </form>
    </main>
    <footer>
    	(c) 2025 Jose Vicente Carratala
      <?php
      	$json = json_encode($_POST); 	// Convierte post a JSON
        echo $json;										// Y lo saca por pantalla
      ?>
    </footer>
  </body>
</html>
```

### y lo guardamos en el disco
<small>Creado: 2025-12-03 10:20</small>

#### Explicación

Este código es una página web simple que permite a los usuarios introducir una pregunta y su respuesta, almacenando esta información en un archivo JSON en el servidor. La parte visible del código está escrita principalmente en HTML y CSS para definir cómo se ve la página, mientras que PHP se utiliza en la parte inferior de la página (dentro de la etiqueta `<footer>`) para manejar las acciones cuando se envía el formulario.

Cuando un usuario completa el formulario con una pregunta y respuesta y lo envía presionando el botón "submit", los datos enviados llegan al servidor como un método POST. El código PHP verifica si ha sido enviado algo a través del método POST usando la condición `if(isset($_POST['respuesta']))`. Si se ha enviado, el código convierte los datos de entrada (que están en formato array) a una cadena JSON utilizando la función `json_encode()`.

Después, el script crea un archivo con un nombre basado en el tiempo actual (obtenido mediante la función PHP `date('U')` que devuelve el número de segundos desde el 1 de Enero de 1970), y escribe el contenido JSON dentro del archivo recién creado. Finalmente, cierra el archivo para asegurarse de que todos los datos se han guardado correctamente.

Esta página web es importante porque demuestra cómo manejar formularios en HTML con PHP, cómo guardar datos estructurados (como JSON) en archivos y cómo combinar lenguajes de marcado (HTML/CSS) y scripting (PHP) para crear una funcionalidad web completa.

`007-y lo guardamos en el disco.php`

```
<!doctype html>
<html>
	<head>
  	<style>
    	body,html{width:100%;height:100%;padding:0px;margin:0px;}
      body{
      	display:flex;align-items:center;justify-content:center;
        background:lightgray;flex-direction:column;}
      header,footer,main{
      	width:400px;padding:20px;background:white;
        text-align:center;
        }
      form{display:flex;flex-direction:column;gap:10px;}
      input{padding:10px;}
    </style>
  </head>
  <body>
  	<header>
  		<h1>Preguntas y respuestas</h1>
    </header>
    <main>
    	<form action="?" method="POST">
      	<label for="pregunta">Introduce la pregunta</label>
      	<input type="text" name="pregunta" id="pregunta">
        <label for="respuesta">Introduce la respuesta</label>
      	<input type="text" name="respuesta" id="respuesta">
        <input type="submit">
      </form>
    </main>
    <footer>
    	(c) 2025 Jose Vicente Carratala
      <?php
      	if(isset($_POST['respuesta'])){
          $json = json_encode($_POST); 	// Convierte post a JSON
          $archivo = fopen(date('U').".json",'w');	// Abre un arhivo
          fwrite($archivo,$json);										// Guarda el json
          fclose($archivo);													// Cierra el archivo
        }
      ?>
    </footer>
  </body>
</html>
```

### 1764753558
<small>Creado: 2025-12-03 10:19</small>

#### Explicación

Este fragmento de código es un array vacío en formato JSON. En términos simples, un array es una lista ordenada de elementos que pueden ser números, cadenas de texto u otros tipos de datos. Este específico está vacío, lo que significa que no contiene ningún elemento.

En el contexto del desarrollo web y la programación en general, usar un array vacío como este puede servir para inicializar una estructura de datos antes de llenarla con información relevante. Es importante porque permite preparar variables o estructuras para recibir datos sin preocuparse por inicializaciones incorrectas que podrían causar errores.

En el caso del archivo JSON que has compartido, podría ser útil en situaciones donde se desea crear un esquema de datos vacío y luego llenarlo dinámicamente con información recogida desde una base de datos o a través de formularios web.

`1764753558.json`

```json
[]
```

### 1764753566
<small>Creado: 2025-12-03 10:19</small>

#### Explicación

Este fragmento de código es un objeto JSON simple que almacena información sobre una pregunta y su respuesta. En este caso, la pregunta es "¿qué día es hoy?" y la respuesta proporcionada es "miércoles". El formato JSON (JavaScript Object Notation) se utiliza comúnmente para transmitir datos estructurados entre un servidor y una aplicación web o entre diferentes partes de una aplicación. Es importante porque permite almacenar y enviar información de manera clara y fácil de leer, facilitando la interacción entre sistemas y bases de datos. En este contexto específico, el archivo JSON podría ser utilizado en ejercicios de programación para practicar cómo manejar y procesar datos estructurados en lenguajes como PHP o JavaScript.

`1764753566.json`

```json
{"pregunta":"que dia es hoy","respuesta":"miercoles"}
```

### archivo
<small>Creado: 2025-12-03 09:51</small>

#### Explicación

Este fragmento de código parece ser simplemente un texto que ha sido escrito directamente en el cuerpo de un archivo, probablemente en PHP. Lo que está sucediendo aquí es que este texto: "Nuevo texto escrito desde PHP" se encuentra dentro de algún tipo de documento o archivo y está siendo mostrado como resultado de ejecutar un script de PHP.

En el contexto de la ruta del archivo `/var/www/html/programaciondam2526/010-Programación en el lado del servidor/003-Persistencia/101-Ejercicios/archivo.txt`, este texto podría ser parte de un ejercicio donde se está escribiendo información directamente a un archivo desde PHP. Esto es importante porque demuestra cómo PHP puede manipular archivos y guardar datos permanentemente en ellos, lo cual es una habilidad básica pero fundamental para la persistencia de datos en aplicaciones web.

Este tipo de práctica ayuda a entender cómo interactuar con el sistema de archivos del servidor web usando PHP, permitiendo almacenar y recuperar información desde archivos.

`archivo.txt`

```
Nuevo texto escrito desde PHP
```

### Actividades propuestas

### Actividades Propuestas:

1. **Escritura de Texto en Archivo**
   - **Descripción:** Los alumnos deben escribir un texto proporcionado por ellos mismos en un archivo `.txt` usando PHP y comprobar que el contenido se ha guardado correctamente. Se espera que aprendan cómo utilizar `fopen`, `fwrite` y `fclose`.

2. **Lectura de Archivo**
   - **Descripción:** Los alumnos tendrán que leer el contenido del archivo `.txt` creado en la actividad anterior utilizando PHP. La tarea consiste en mostrar el texto leído por pantalla con `echo`. Se espera que comprendan cómo usar `fread` y manejar archivos.

3. **Manejo de Permisos**
   - **Descripción:** Los estudiantes deben crear un script en línea de comandos (bash) que cambie los permisos del archivo `.txt` a 755, lo cual permite la lectura, escritura y ejecución para el propietario y sólo lectura y ejecución para otros. Se espera que aprendan sobre el sistema de permisos UNIX.

4. **Array Nombrado en PHP**
   - **Descripción:** Los alumnos deben crear un array nombrado con información personal (nombre, apellidos, email) utilizando PHP y mostrar los datos usando `var_dump`. Se espera que comprendan cómo definir e imprimir arrays asociativos en PHP.

5. **Serialización de Datos a JSON**
   - **Descripción:** Los estudiantes deben convertir el array creado en la actividad anterior a formato JSON con `json_encode` y mostrarlo por pantalla. Se espera que entiendan cómo serializar datos complejos a texto plano para almacenamiento o transmisión.

6. **Formulario Simple en PHP**
   - **Descripción:** Cada estudiante debe crear un formulario HTML básico que envíe los datos del usuario a un script PHP, el cual mostrará la información enviada en formato JSON. Se espera que aprendan cómo manejar formularios y procesar datos de entrada en PHP.

7. **Guardado de Datos en Archivo**
   - **Descripción:** Los alumnos deben modificar el formulario para guardar los datos recibidos en un archivo `.json` con nombres únicos basados en la fecha actual. Se espera que comprendan cómo escribir datos JSON directamente en archivos desde PHP.

8. **Lectura y Mostrado de Datos JSON**
   - **Descripción:** Los estudiantes deben leer el contenido del último archivo `.json` guardado por su formulario y mostrar los datos en una página web usando PHP. Se espera que aprendan a leer archivos JSON y manipular sus contenidos para presentación.

9. **Manejo de Formularios Avanzado**
   - **Descripción:** Los alumnos deben crear un sistema básico que permita agregar, listar y borrar entradas del formulario anteriormente creado en una única página PHP. Se espera que comprendan cómo gestionar múltiples operaciones CRUD (Crear, Leer, Actualizar, Borrar) con archivos.

10. **Refactorización de Códigos**
    - **Descripción:** Los estudiantes deben analizar y mejorar el código existente de varias actividades anteriores para mejor estilo y estructura, incluyendo la adición de funciones personalizadas y comentarios descriptivos. Se espera que aprendan a refactorizar código PHP existente para mejor mantenibilidad y legibilidad.

Estas actividades están diseñadas para ayudar a los estudiantes de Formación Profesional a mejorar sus habilidades en programación web, manejo de archivos, uso de JSON y desarrollo básico con PHP.


<a id="proyecto-ana"></a>
## Proyecto Ana

### Introducción a los ejercicios

En esta carpeta se encuentran una serie de ejercicios que te ayudarán a familiarizarte con la implementación y configuración de un proyecto web en el lado del servidor utilizando tecnologías como HTML, CSS, JavaScript y Python (Flask). El objetivo principal es desarrollar un entorno interactivo donde los usuarios puedan escribir código y ver los resultados en tiempo real. Estos ejercicios te permitirán aprender cómo crear interfaces de usuario simples con HTML y CSS, añadir funcionalidad interactiva mediante JavaScript, y finalmente, implementar una API backend que reciba y ejecute el código enviado por el cliente.

A través de estos problemas, practicarás competencias clave como la creación de interfaces web dinámicas, manejo del estado de sesiones en aplicaciones web, procesamiento de solicitudes HTTP POST, y ejecución segura de código Python.

### front
<small>Creado: 2025-12-04 10:50</small>

#### Explicación

Este fragmento de código HTML es la estructura básica del documento que se abrirá en un navegador web. Crea una página con tres secciones principales: encabezado (`header`), contenido principal (`main`) y pie de página (`footer`). La etiqueta `<!doctype html>` al principio indica que el documento sigue las reglas del HTML5.

En la parte central, dentro de `<body>`, hay un elemento `<header>` vacío donde normalmente se incluirían elementos como el título o el logo. En el centro de la página, encontramos una sección `<main>` que contiene un bloque de texto editable identificado con `id="terminal"`. Esto significa que en esta parte del sitio web, los usuarios podrán escribir y modificar contenido directamente desde su navegador.

La inclusión de este bloque editable puede ser útil para simular interfaces como terminales de comandos o campos interactivos donde el usuario pueda ingresar información. Es importante destacar que esta estructura básica permite una fácil extensión y personalización a medida que se añaden más características al sitio web, como estilos CSS o funcionalidades con JavaScript.

`002-front.html`

```html
<!doctype html>
<html lang="es">
  <head>
  </head>
  <body>
    	<header>
    </header>
    <main>
      <div id="terminal" contenteditable=true>
      </div>
    </main>
    <footer>
    </footer>
  </body>
</html>
```

### estilizamos un poco
<small>Creado: 2025-12-04 10:58</small>

#### Explicación

Este fragmento de código HTML crea una página web simple que simula un entorno básico para programar y ejecutar códigos. La página se compone principalmente de tres partes: un área de texto editable donde puedes escribir o copiar código (llamada "editor"), un botón verde que dice "Compilar", y otra zona debajo del editor donde podrías ver resultados, similares a una terminal en sistemas operativos Unix (llamada "terminal").

En el `<head>` del documento, se incluye CSS para estilizar estos elementos. La etiqueta `#editor` define cómo debe verse la área de texto editable: tiene un fondo gris claro, un borde con sombras y un tamaño fijo (400px de ancho por 100px de alto). El estilo para el botón incluye colores sólidos y bordes redondeados para que sea atractivo y fácil de usar. La sección `#terminal` tiene una apariencia similar, pero con un fondo negro y texto blanco, imitando la apariencia típica de una terminal en línea de comandos.

Este tipo de interfaz es útil para aprender programación porque proporciona un entorno interactivo donde puedes ver los resultados inmediatamente después de escribir o editar código.

`003-estilizamos un poco.html`

```html
<!doctype html>
<html lang="es">
  <head>
    <style>
      #editor{
      	font-family:monospace;
        background:lightgray;color:black;padding:20px;
        width:400px;
        height:100px;margin:auto;
        margin-bottom:10px;
      }
      #terminal{
      	font-family:monospace;
        background:black;color:white;padding:20px;
        width:400px;
        height:50px;margin:auto;
      }
      .ventana{
      	border:1px solid grey;
        border-top:30px solid grey;
        border-radius:5px;
        box-shadow:0px 5px 10px rgba(0,0,0,0.3);
      }
      button{
        margin:auto;background:green;
        color:white;padding:10px;border-radius:5px;border:none;
      margin:auto;margin-bottom:10px;display:block;}
    </style>
  </head>
  <body>
    	<header>
    </header>
    <main>
      <div id="editor" contenteditable=true class="ventana"></div>
      <button>Compilar</button>
      <div id="terminal" contenteditable=true class="ventana"></div>
    </main>
    <footer>
    </footer>
  </body>
</html>
```

### javascript
<small>Creado: 2025-12-04 11:01</small>

#### Explicación

Este fragmento de código HTML crea una página web sencilla que incluye un editor y un "terminal" para mostrar texto. La parte central del código se encuentra en la etiqueta `<style>`, donde se definen los estilos CSS para varios elementos como el div `#editor` y `#terminal`. Estos divs son áreas interactivas (por tener la propiedad `contenteditable=true`) que permiten a los usuarios escribir dentro de ellas.

En el cuerpo del documento (`<body>`), hay un botón con texto "Compilar". Cuando este botón es presionado, se ejecuta una función JavaScript que obtiene el contenido escrito en el div `#editor` y lo muestra en la consola del navegador (mediante `console.log`). Esta funcionalidad permite a los usuarios escribir algo en el editor y luego verlo imprimirse en la consola cuando presionan el botón.

Esta página es útil para estudiantes que están aprendiendo desarrollo web, ya que les proporciona un entorno simple donde pueden experimentar con código HTML y CSS, además de aprender cómo interactuar con JavaScript para controlar eventos como clics del mouse.

`004-javascript.html`

```html
<!doctype html>
<html lang="es">
  <head>
    <style>
      #editor{
      	font-family:monospace;
        background:lightgray;color:black;padding:20px;
        width:400px;
        height:100px;margin:auto;
        margin-bottom:10px;
      }
      #terminal{
      	font-family:monospace;
        background:black;color:white;padding:20px;
        width:400px;
        height:50px;margin:auto;
      }
      .ventana{
      	border:1px solid grey;
        border-top:30px solid grey;
        border-radius:5px;
        box-shadow:0px 5px 10px rgba(0,0,0,0.3);
      }
      button{
        margin:auto;background:green;
        color:white;padding:10px;border-radius:5px;border:none;
      margin:auto;margin-bottom:10px;display:block;}
    </style>
  </head>
  <body>
    	<header>
    </header>
    <main>
      <div id="editor" contenteditable=true class="ventana"></div>
      <button>Compilar</button>
      <div id="terminal" contenteditable=true class="ventana"></div>
    </main>
    <footer>
    </footer>
    <script>
      let boton = document.querySelector("button")
      boton.onclick = function(){
      	console.log("Vamos a enviar algo al servidor")
        let codigo = document.querySelector("#editor").textContent
        console.log(codigo)
      }
    </script>
  </body>
</html>
```

### flask
<small>Creado: 2025-12-04 11:04</small>

#### Explicación

Este fragmento de código está configurando una aplicación web simple utilizando el framework Flask en Python. La aplicación crea un servidor web básico que, cuando se accede a la dirección raíz (es decir, la URL base de tu sitio), muestra una página HTML llamada "frente.html" gracias al uso de `render_template`. Este método busca el archivo HTML en la carpeta `templates` dentro del directorio de trabajo actual.

El código primero importa las clases necesarias de Flask. Luego crea una instancia de la aplicación Flask y la asigna a la variable `app`. La línea `@app.route("/")` define que cuando un usuario acceda al sitio web a través de la URL raíz (por ejemplo, `http://localhost:5000/`), se ejecutará la función `inicio()`. Dentro de esta función, se llama a `render_template("frente.html")`, lo cual indica a Flask que debe buscar y mostrar el archivo HTML llamado "frente.html" para este endpoint.

Finalmente, el bloque `if __name__ == "__main__":` asegura que la aplicación solo se inicie si el script es ejecutado directamente (no importado como un módulo en otro script), lo cual es una buena práctica. La llamada a `app.run(debug=True)` arranca el servidor web y habilita el modo depuración, facilitando la resolución de errores durante el desarrollo.

Esta configuración básica es muy útil para desarrollar aplicaciones web con Flask en un entorno de aprendizaje o desarrollo inicial.

`005-flask.py`

```python
from flask import Flask, render_template 

app = Flask(__name__)

@app.route("/")
def inicio():
  return render_template("frente.html")

if __name__ == "__main__":
  app.run(debug=True)
```

### nuevo endpoint
<small>Creado: 2025-12-04 11:08</small>

#### Explicación

Este fragmento de código Python utiliza la biblioteca Flask para crear una aplicación web simple. La aplicación tiene dos rutas definidas: la ruta raíz ("/") y la ruta "/api". 

La función `inicio()` se encarga de mostrar un archivo HTML llamado "frente.html" cuando alguien visita la página principal del sitio web. Esta es la pantalla de inicio para los usuarios.

Por otro lado, la función `api()` está diseñada para responder a solicitudes enviadas a la ruta "/api". Cuando una solicitud llega aquí, el programa imprime en la consola "He recibido algo" y devuelve un mensaje simple que dice "ok".

Este código es importante porque permite a los desarrolladores crear endpoints (puntos de conexión) web que pueden ser consumidos por otros sistemas o aplicaciones. En este caso, `/api` puede ser útil para integrar con otras partes del sistema que necesitan interactuar con esta aplicación Flask.

La línea `if __name__ == "__main__": app.run(debug=True)` asegura que la aplicación solo se ejecute si el archivo es ejecutado directamente (no importado como módulo), y también habilita el modo de depuración, lo cual ayuda a los desarrolladores durante la fase inicial del proyecto al proporcionar información útil en caso de errores.

`006-nuevo endpoint.py`

```python
from flask import Flask, render_template 

app = Flask(__name__)

@app.route("/")
def inicio():
  return render_template("frente.html")

@app.route("/api")
def api():
  print("He recibido algo")
  return "ok"

if __name__ == "__main__":
  app.run(debug=True)
```

### estamos obligados a metodo
<small>Creado: 2025-12-04 11:17</small>

#### Explicación

Este fragmento de código es una aplicación simple en Flask que permite a los usuarios ejecutar y ver el resultado del código Python enviado a través de una solicitud HTTP POST. La aplicación está estructurada para proporcionar un servicio web básico.

En primer lugar, se importan las bibliotecas necesarias: `Flask` para crear la aplicación web, `render_template` y `request` también desde Flask para manejar el renderizado de plantillas HTML y gestionar las solicitudes entrantes respectivamente. Además, se utilizan `io.StringIO()` para manejar una salida temporal en memoria y `contextlib.redirect_stdout` para redirigir la salida estándar a este buffer.

La aplicación define dos rutas principales: `/`, que simplemente devuelve el archivo HTML llamado "frente.html", presumiblemente una página de inicio, y `/api`, donde se recibe código Python desde el cliente. Cuando se envía un POST a `/api`, el código Python viene en el cuerpo de la solicitud (`request.data`). Este código es ejecutado usando `exec()`, lo que podría ser peligroso si no se controla adecuadamente, ya que permite la ejecución de cualquier comando enviado por el usuario.

Después de intentar ejecutar el código proporcionado, cualquier salida generada (como impresiones en pantalla) se captura y devuelta al cliente. Si ocurre un error durante la ejecución del código, este se captura y se devuelve como respuesta HTTP con estado 400 Bad Request para indicar que algo ha salido mal.

Esta aplicación puede ser útil para aprender cómo interactuar con APIs en Python o para proyectos de desarrollo web donde es necesario evaluar el comportamiento de diferentes piezas de código. Sin embargo, dado que permite ejecutar cualquier código enviado por el usuario, su uso debe limitarse a entornos controlados y no se recomienda usarlo en producción sin medidas adicionales de seguridad.

`007-estamos obligados a metodo.py`

```python
from flask import Flask, render_template, request
import io
import contextlib


app = Flask(__name__)

@app.route("/")
def inicio():
  return render_template("frente.html")

@app.route("/api", methods=['POST'])
def api():
    codigo = request.data.decode("utf-8")

    buffer = io.StringIO()
    try:
        # Ejecuta el código y captura todo lo que se imprima
        with contextlib.redirect_stdout(buffer):
            exec(codigo, {})   # entorno global vacío (peligroso igualmente si no controlas el código)
    except Exception as e:
        return str(e), 400

    salida = buffer.getvalue()
    # Si no ha habido nada por pantalla, puedes devolver algo por defecto
    return salida if salida else "OK"

if __name__ == "__main__":
  app.run(debug=True)
```

### soporte multilinea
<small>Creado: 2025-12-04 11:58</small>

#### Explicación

Este fragmento de código es una aplicación web simple creada con Flask, un framework popular para Python que facilita la creación de aplicaciones web. La función principal de este script es proporcionar un endpoint ("/api") donde se puede enviar código Python y ejecutarlo dentro del servidor web. 

Cuando alguien envía una solicitud POST a "/api", el servidor recibe el código fuente enviado (en formato texto) y lo guarda en la variable `codigo`. Luego, utiliza un objeto `StringIO` para capturar cualquier salida generada cuando se ejecuta ese código. El bloque de código dentro del try-except intenta ejecutar el código proporcionado utilizando la función `exec()`, que evalúa dinámicamente las cadenas como si fueran scripts Python reales.

Si ocurre un error durante la ejecución, este es capturado y devuelto al cliente junto con un estado HTTP 400 (Bad Request) para indicar que algo ha ido mal. Si el código se ejecuta sin errores, cualquier texto impreso por `print` dentro del código enviado será recogido y devuelto como respuesta.

Este tipo de servidor puede ser útil en entornos educativos o para pruebas rápidas de pequeños bloques de código Python desde una interfaz web. Sin embargo, es importante destacar que permitir la ejecución de código arbitrario tiene implicaciones de seguridad significativas y no se recomienda su uso en entornos de producción.

`008-soporte multilinea.py`

```python
from flask import Flask, render_template, request
import io
import contextlib

app = Flask(__name__)

@app.route("/")
def inicio():
    return render_template("frente.html")

@app.route("/api", methods=['POST'])
def api():
    codigo = request.data.decode("utf-8")

    buffer = io.StringIO()
    try:
        # Ejecuta el código y captura todo lo que se imprima
        with contextlib.redirect_stdout(buffer):
            exec(codigo, {})
    except Exception as e:
        # devolvemos el error como texto y código 400
        return str(e), 400

    salida = buffer.getvalue()
    return salida if salida else "OK"

if __name__ == "__main__":
    app.run(debug=True)
```

### ampliaciones
<small>Creado: 2025-12-04 12:20</small>

#### Explicación

Este fragmento de código es una aplicación web simple creada con Flask que permite ejecutar código Python suministrado por el usuario. La idea principal es proporcionar un entorno seguro para probar y ejecutar pequeños bloques de código.

La aplicación tiene dos rutas principales: la ruta inicial ("/") que simplemente muestra una página HTML llamada "frenteampliado.html", y la ruta "/api" configurada para aceptar solicitudes POST. Esta última ruta es donde el verdadero trabajo se realiza: recibe un JSON con un código Python (`code`) y posibles entradas (`inputs`), prepara ese entorno de ejecución, y ejecuta el código enviado.

El código también incluye una función `custom_input()` para manejar cómo el programa procesa las entradas que recibió. Esto asegura que cualquier llamada a `input()` dentro del código proporcionado por el usuario use las entradas especificadas en lugar de solicitar ingresos al usuario en tiempo real.

Finalmente, la aplicación redirige tanto la salida estándar como los errores estandar (stderr) a un buffer interno para capturar toda la salida generada durante la ejecución del código. Si ocurre algún error, este se captura y devuelve al cliente con un estado de respuesta 400 (Bad Request). Si todo va bien, el contenido de ese buffer es devuelto como respuesta.

Este tipo de aplicación puede ser útil para sitios web que deseen permitir a los usuarios ejecutar código interactivo en un entorno controlado.

`009-ampliaciones.py`

```python
from flask import Flask, render_template, request
import io
import contextlib
import traceback

app = Flask(__name__)

@app.route("/")
def inicio():
    return render_template("frenteampliado.html")

@app.route("/api", methods=['POST'])
def api():
    data = request.get_json(force=True)
    codigo = data.get("code", "")
    entradas = data.get("inputs", "")

    # Preparamos las líneas de entrada para input()
    input_lines = iter(entradas.splitlines())

    buffer = io.StringIO()

    def custom_input(prompt=""):
        # Mostrar el prompt en la salida
        print(prompt, end="", file=buffer)
        try:
            linea = next(input_lines)
            # Mostrar lo que "escribe" el usuario en la misma terminal
            print(linea, file=buffer)
            return linea
        except StopIteration:
            # No quedan más líneas de entrada
            print("\n[AVISO] No quedan más líneas de entrada (stdin). Se devuelve cadena vacía.", file=buffer)
            return ""

    # Entorno de ejecución
    global_env = {
        "__name__": "__main__",
        "input": custom_input,
    }

    try:
        with contextlib.redirect_stdout(buffer):
            with contextlib.redirect_stderr(buffer):
                exec(codigo, global_env)
    except Exception:
        error_text = traceback.format_exc()
        return error_text, 400

    salida = buffer.getvalue()
    return salida if salida else "OK"

if __name__ == "__main__":
    app.run(debug=True)
```

### mejoras
<small>Creado: 2025-12-04 12:23</small>

#### Explicación

Lo siento, pero no has proporcionado ningún código dentro del archivo que debes explicar. Por favor, comparte el fragmento de código específico que deseas que explique y estaré encantado de ayudarte con una explicación clara y concisa.

`010-mejoras`

```

```

### mejoras
<small>Creado: 2025-12-04 12:27</small>

#### Explicación

Este fragmento de código es una aplicación web en Python que utiliza el framework Flask para permitir a los usuarios ejecutar y manipular sesiones de Python directamente desde un navegador. La aplicación crea una interfaz donde se puede enviar código Python, ejecutar líneas individuales del código y recibir la salida de esa ejecución.

El código define una clase `PythonSession` que maneja las interacciones con el proceso de Python en segundo plano. Esta clase guarda el código enviado por el usuario en un archivo temporal y luego ejecuta ese archivo utilizando el módulo `subprocess`. Además, implementa un hilo separado que se encarga de leer la salida estándar y los errores del proceso y almacenarlos en una cola para ser recuperados más tarde.

La aplicación Flask proporciona varios endpoints (rutas) a través de los cuales interactuar con las sesiones de Python:
- `/api/start`: Inicia una nueva sesión de Python, ejecutando el código enviado por el usuario.
- `/api/write`: Permite escribir en la entrada estándar del proceso de Python.
- `/api/read`: Lee la salida y errores generados por el proceso de Python desde la cola.

La aplicación gestiona múltiples sesiones a través de un diccionario `sessions`, donde cada sesión se identifica mediante un ID único generado por `uuid.uuid4()`.

Este código es importante porque proporciona una forma interactiva y segura para los usuarios experimentar con el lenguaje Python directamente desde su navegador, lo que puede ser muy útil tanto en entornos educativos como de desarrollo colaborativo.

**ÚLTIMO PÁRRAFO:**
En comparación con la versión anterior (supuestamente sin código), este archivo introduce una aplicación web completa con múltiples endpoints para manejar sesiones interactivas de Python, lo que permite a los usuarios enviar y recibir comandos y respuestas en tiempo real.

`010-mejoras.py`

```python
from flask import Flask, render_template, request, jsonify
import subprocess
import threading
import queue
import uuid
import os
import tempfile

app = Flask(__name__)

# Almacenar sesiones de procesos
sessions = {}

class PythonSession:
    def __init__(self, code: str):
        # Guardamos el código en un archivo temporal
        fd, path = tempfile.mkstemp(suffix=".py", prefix="compilador_")
        os.write(fd, code.encode("utf-8"))
        os.close(fd)

        self.path = path
        self.proc = subprocess.Popen(
            ["python3", self.path],
            stdin=subprocess.PIPE,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            bufsize=1,  # line-buffered
        )
        self.queue = queue.Queue()
        self.alive = True

        # Hilo que lee stdout + stderr y los mete en la cola
        self.thread = threading.Thread(target=self._reader_thread, daemon=True)
        self.thread.start()

    def _reader_thread(self):
        try:
            for line in self.proc.stdout:
                self.queue.put(line)
            # cuando stdout se cierra, leemos también stderr restante
            err = self.proc.stderr.read()
            if err:
                self.queue.put(err)
        finally:
            self.proc.wait()
            self.alive = False
            # limpiar archivo temporal
            try:
                os.remove(self.path)
            except OSError:
                pass

    def write(self, data: str):
        if not self.alive:
            return
        try:
            self.proc.stdin.write(data + "\n")
            self.proc.stdin.flush()
        except Exception:
            self.alive = False

    def read_all(self) -> str:
        chunks = []
        while not self.queue.empty():
            try:
                chunks.append(self.queue.get_nowait())
            except queue.Empty:
                break
        return "".join(chunks)

    def is_alive(self) -> bool:
        return self.alive and self.proc.poll() is None


@app.route("/")
def inicio():
    return render_template("frentemasampliado.html")


@app.route("/api/start", methods=["POST"])
def api_start():
    data = request.get_json(force=True)
    code = data.get("code", "")

    session_id = str(uuid.uuid4())
    sessions[session_id] = PythonSession(code)

    return jsonify({"session_id": session_id})


@app.route("/api/write", methods=["POST"])
def api_write():
    data = request.get_json(force=True)
    session_id = data.get("session_id")
    line = data.get("line", "")

    sess = sessions.get(session_id)
    if not sess:
        return jsonify({"error": "Sesión no encontrada"}), 404

    sess.write(line)
    return jsonify({"ok": True})


@app.route("/api/read", methods=["GET"])
def api_read():
    session_id = request.args.get("session_id")
    sess = sessions.get(session_id)
    if not sess:
        return jsonify({"error": "Sesión no encontrada"}), 404

    output = sess.read_all()
    alive = sess.is_alive()

    # Si el proceso ha terminado y no queda nada que leer, limpiar la sesión
    if not alive and not output:
        sessions.pop(session_id, None)

    return jsonify({"output": output, "alive": alive})


if __name__ == "__main__":
    app.run(debug=True)
```

### Actividades propuestas

### Actividades Propuestas para Estudiantes de Formación Profesional

#### 1. **Configuración del Entorno de Desarrollo**
- **Descripción:** Configura un entorno de desarrollo que permita ejecutar código HTML, CSS y JavaScript localmente. Además, instala y configura Flask (Python) para implementar una aplicación web básica.
- **Objetivo:** Aprender a configurar correctamente el entorno de trabajo y entender cómo funcionan los servidores locales.

#### 2. **Desarrollo Front-end Básico**
- **Descripción:** Desarrolla un front-end básico que permita al usuario escribir código en un editor y ver la salida en una consola virtual.
- **Objetivo:** Familiarizarse con HTML, CSS y JavaScript para crear interfaces web interactivas.

#### 3. **Estilización de Elementos Web**
- **Descripción:** Mejora el diseño del front-end implementado anteriormente agregando estilos adicionales utilizando CSS.
- **Objetivo:** Aprender a utilizar selectores CSS y propiedades para mejorar la presentación visual de una página web.

#### 4. **Integración de JavaScript en HTML**
- **Descripción:** Agrega funcionalidades interactivas al front-end mediante el uso de JavaScript, como enviar datos del editor a un div terminal.
- **Objetivo:** Comprender cómo interactuar con elementos HTML desde scripts JS y manipular eventos básicos.

#### 5. **Conexión Front-end y Back-end Básica**
- **Descripción:** Implementa una conexión básica entre el front-end (HTML, CSS, JavaScript) y el back-end (Flask en Python), permitiendo al usuario enviar código a través de un endpoint.
- **Objetivo:** Aprender los fundamentos de comunicación entre el servidor y el cliente utilizando métodos HTTP.

#### 6. **Manejo de Métodos HTTP**
- **Descripción:** Modifica la aplicación Flask para manejar diferentes métodos HTTP (GET, POST) en función del endpoint.
- **Objetivo:** Comprender cómo los diferentes métodos HTTP son utilizados para realizar operaciones CRUD básicas.

#### 7. **Ejecución de Código Python desde un Servidor Web**
- **Descripción:** Implementa una funcionalidad que permita ejecutar código Python enviado por el cliente a través del servidor Flask.
- **Objetivo:** Aprender a utilizar Flask para procesar y responder solicitudes POST con datos dinámicos.

#### 8. **Manejo de Entradas en Códigos Ejecutables**
- **Descripción:** Mejora la funcionalidad existente permitiendo que el código ejecutable enviado por el cliente reciba entradas especificadas.
- **Objetivo:** Aprender a gestionar las entradas y salidas del servidor cuando se ejecuta código externo.

#### 9. **Mejoras en la Interactividad**
- **Descripción:** Desarrolla una interfaz que permita al usuario interactuar en tiempo real con el código Python ejecutado en el servidor.
- **Objetivo:** Aprender a utilizar hilos y colas para manejar interacciones asíncronas entre el cliente y el servidor.

#### 10. **Implementación de Sesiones Persistentes**
- **Descripción:** Implementa una funcionalidad que permita crear sesiones persistentes en la aplicación Flask, donde cada usuario pueda interactuar con su propio código Python.
- **Objetivo:** Comprender cómo gestionar múltiples conexiones simultáneas y mantener el estado de las mismas en un entorno de desarrollo.


<a id="includes"></a>
## includes

### contacto
<small>Creado: 2025-12-05 09:27</small>

`contacto.php`

```
<?php include "bloques/cabecera.php"; ?>
<p>Aqui solo pongo el contenido de la pagina de contacto</p>
<?php include "bloques/pie.php"; ?>
```

### index
<small>Creado: 2025-12-05 09:25</small>

`index.php`

```
<?php include "bloques/cabecera.php"; ?>
<p>Aqui solo pongo el contenido de la pagina principal</p>
<?php include "bloques/pie.php"; ?>
```

### sobremi
<small>Creado: 2025-12-05 09:27</small>

`sobremi.php`

```
<?php include "bloques/cabecera.php"; ?>
<p>Aqui solo pongo el contenido de la página de sobre mi</p>
<?php include "bloques/pie.php"; ?>
```


<a id="repasito-de-cosas-de-github"></a>
## Repasito de cosas de GitHub


<a id="bloques"></a>
## Bloques

### paneldecontrol
<small>Creado: 2025-12-05 10:04</small>

`paneldecontrol.php`

```
<!doctype html>
<html>
  <head>
  </head>
  <body>
    <nav>
    	<?php include "bloques/navegacion.php" ?>
    </nav>
    <main>
    	<?php include "bloques/tabla.php" ?>
    </main>
  </body>
</html>
```


<a id="sesiones-en-php"></a>
## Sesiones en PHP

### variables en el mismo archivo
<small>Creado: 2025-12-05 10:08</small>

`001-variables en el mismo archivo.php`

```
<?php
	$nombre = "Jose Vicente";
  echo $nombre;
?>
```

### incluso en diferentes bloques
<small>Creado: 2025-12-05 10:09</small>

`002-incluso en diferentes bloques.php`

```
<?php
	$nombre = "Jose Vicente";
?>
Esto es HTML pero no pasa nada<br>
<?php
	echo $nombre;
?>
```

### origen
<small>Creado: 2025-12-05 10:10</small>

`003-origen.php`

```
<?php
	$nombre = "Jose Vicente";
?>
<a href="004-destino.php">Vamos a otra página</a>
```

### destino
<small>Creado: 2025-12-05 10:11</small>

`004-destino.php`

```
<?php
	echo $nombre;
?>
```

### origen y uso sesiones
<small>Creado: 2025-12-05 10:14</small>

`005-origen y uso sesiones.php`

```
<?php
	session_start();
	$_SESSION['nombre'] = "Jose Vicente";
?>
<a href="006-destino con sesiones.php">Vamos a otra página</a>
```

### destino con sesiones
<small>Creado: 2025-12-05 10:14</small>

`006-destino con sesiones.php`

```
<?php
	session_start();
	echo $_SESSION['nombre'];
?>
```


<a id="implantacion-crud"></a>
## Implantacion crud

### index
<small>Creado: 2025-12-11 10:38</small>

`index.php`

```
<!doctype html>
<html lang="es">
	<head>
  	<title>El jocarsa - Noticias tecnológicas</title>
    <meta charset="utf-8">
    <link rel="stylesheet" href="css/estilo.css">
  </head>
  <body>
  	<header>
    	<h1>El jocarsa</h1>
      <h2>Noticias tecnológicas</h2>
    </header>
    <main>
    	<?php include "inc/listar_articulos.php"; ?>
    </main>
    <footer>
    </footer>
  </body>
</html>
```



<a id="git"></a>
# .git

<a id="branches"></a>
## branches


<a id="hooks"></a>
## hooks


<a id="info"></a>
## info


<a id="logs"></a>
## logs


<a id="objects"></a>
## objects


<a id="refs"></a>
## refs
