# programaciondam2526

**Author:** Jose Vicente Carratala Sanchis

## Table of contents

- [Identificación de los elementos de un programa informático](#identificacion-de-los-elementos-de-un-programa-informatico)
  - [Estructura y bloques fundamentales](#estructura-y-bloques-fundamentales)
  - [Variables](#variables)
  - [Tipos de datos](#tipos-de-datos)
  - [Literales](#literales)
  - [Constantes](#constantes)
  - [Operadores y expresiones](#operadores-y-expresiones)
  - [Ejercicio de final de unidad](#ejercicio-de-final-de-unidad)
- [Utilización de objetos](#utilizacion-de-objetos)
  - [Características de los objetos](#caracteristicas-de-los-objetos)
  - [Instanciación de objetos](#instanciacion-de-objetos)
  - [Utilización de métodos. Parámetros](#utilizacion-de-metodos-parametros)
  - [Utilización de propiedades](#utilizacion-de-propiedades)
  - [Utilización de métodos estáticos](#utilizacion-de-metodos-estaticos)
  - [Constructores](#constructores)
  - [Destrucción de objetos y liberación de memoria](#destruccion-de-objetos-y-liberacion-de-memoria)
  - [Ejercicio de final de unidad](#ejercicio-de-final-de-unidad-1)
- [Uso de estructuras de control](#uso-de-estructuras-de-control)
  - [Estructuras de selección](#estructuras-de-seleccion)
  - [Estructuras de repetición](#estructuras-de-repeticion)
  - [Estructuras de salto](#estructuras-de-salto)
  - [Control de excepciones](#control-de-excepciones)
  - [Aserciones](#aserciones)
  - [Prueba, depuración y documentación de la aplicación](#prueba-depuracion-y-documentacion-de-la-aplicacion)
  - [Ejercicio](#ejercicio)
  - [Ejercicio de final de unidad](#ejercicio-de-final-de-unidad-2)
- [Desarrollo de clases](#desarrollo-de-clases)
  - [Concepto de clase](#concepto-de-clase)
  - [Estructura y miembros de una clase. Visibilidad](#estructura-y-miembros-de-una-clase-visibilidad)
  - [Creación de propiedades](#creacion-de-propiedades)
  - [Creación de métodos](#creacion-de-metodos)
  - [Creación de constructores](#creacion-de-constructores)
  - [Utilización de clases y objetos](#utilizacion-de-clases-y-objetos)
  - [Utilización de clases heredadas](#utilizacion-de-clases-heredadas)
  - [Ejercicio de final de unidad](#ejercicio-de-final-de-unidad-3)
- [Lectura y escritura de información](#lectura-y-escritura-de-informacion)
  - [Flujos. Tipos bytes y caracteres. Clases relacionadas](#flujos-tipos-bytes-y-caracteres-clases-relacionadas)
  - [Ficheros de datos. Registros](#ficheros-de-datos-registros)
  - [Apertura y cierre de ficheros. Modos de acceso. Escritura y lectura de información en ficheros](#apertura-y-cierre-de-ficheros-modos-de-acceso-escritura-y-lectura-de-informacion-en-ficheros)
  - [Utilización de los sistemas de ficheros.](#utilizacion-de-los-sistemas-de-ficheros)
  - [Creación y eliminación de ficheros y directorios](#creacion-y-eliminacion-de-ficheros-y-directorios)
  - [Entrada desde teclado. Salida a pantalla. Formatos de visualización](#entrada-desde-teclado-salida-a-pantalla-formatos-de-visualizacion)
  - [Interfaces gráficas](#interfaces-graficas)
  - [Concepto de evento](#concepto-de-evento)
  - [Creación de controladores de eventos](#creacion-de-controladores-de-eventos)
  - [- Simulacro examen miercoles](#simulacro-examen-miercoles)
  - [Ejercicio de final de unidad](#ejercicio-de-final-de-unidad-4)
  - [Examen final](#examen-final)
  - [Carpeta sin título](#carpeta-sin-titulo)
- [Aplicación de las estructuras de almacenamiento](#aplicacion-de-las-estructuras-de-almacenamiento)
  - [Estructuras estáticas y dinámicas](#estructuras-estaticas-y-dinamicas)
  - [Creación de matrices (arrays)](#creacion-de-matrices-arrays)
  - [Matrices (arrays) multidimensionales](#matrices-arrays-multidimensionales)
  - [Genericidad](#genericidad)
  - [Cadenas de caracteres. Expresiones regulares](#cadenas-de-caracteres-expresiones-regulares)
  - [Colecciones Listas, Conjuntos y Diccionarios](#colecciones-listas-conjuntos-y-diccionarios)
  - [Operaciones agregadas filtrado, reducción y recolección](#operaciones-agregadas-filtrado-reduccion-y-recoleccion)
- [Utilización avanzada de clases](#utilizacion-avanzada-de-clases)
  - [Repaso](#repaso)
  - [Composición de clases](#composicion-de-clases)
  - [Herencia y polimorfismo](#herencia-y-polimorfismo)
  - [Jerarquía de clases Superclases y subclases](#jerarquia-de-clases-superclases-y-subclases)
  - [Clases y métodos abstractos y finales](#clases-y-metodos-abstractos-y-finales)
  - [Interfaces](#interfaces)
  - [Sobreescritura de métodos](#sobreescritura-de-metodos)
  - [Constructores y herencia](#constructores-y-herencia)
- [Mantenimiento de la persistencia de los objetos](#mantenimiento-de-la-persistencia-de-los-objetos)
  - [Bases de datos orientadas a objetos](#bases-de-datos-orientadas-a-objetos)
  - [Características de las bases de datos orientadas a objetos](#caracteristicas-de-las-bases-de-datos-orientadas-a-objetos)
  - [Instalación del gestor de bases de datos](#instalacion-del-gestor-de-bases-de-datos)
  - [Creación de bases de datos](#creacion-de-bases-de-datos)
  - [Mecanismos de consulta](#mecanismos-de-consulta)
  - [El lenguaje de consultas sintaxis, expresiones, operadores](#el-lenguaje-de-consultas-sintaxis-expresiones-operadores)
  - [Recuperación, modificación y borrado de información](#recuperacion-modificacion-y-borrado-de-informacion)
  - [Tipos de datos objeto; atributos y métodos](#tipos-de-datos-objeto-atributos-y-metodos)
  - [Tipos de datos colección](#tipos-de-datos-coleccion)
- [Gestión de bases de datos](#gestion-de-bases-de-datos)
  - [Acceso a bases de datos. Estándares. Características](#acceso-a-bases-de-datos-estandares-caracteristicas)
  - [Establecimiento de conexiones](#establecimiento-de-conexiones)
  - [Almacenamiento, recuperación, actualización y eliminación de información en bases de datos](#almacenamiento-recuperacion-actualizacion-y-eliminacion-de-informacion-en-bases-de-datos)
- [Programación en el lado del servidor](#programacion-en-el-lado-del-servidor)
  - [Fundamentos](#fundamentos)
  - [get y post](#get-y-post)
  - [Persistencia](#persistencia)
  - [Proyecto Ana](#proyecto-ana)
  - [includes](#includes)
  - [Repasito de cosas de GitHub](#repasito-de-cosas-de-github)
  - [Bloques](#bloques)
- [.git](#git)
  - [branches](#branches)
  - [hooks](#hooks)
  - [info](#info)
  - [logs](#logs)
  - [objects](#objects)
  - [refs](#refs)

---

<a id="identificacion-de-los-elementos-de-un-programa-informatico"></a>
# Identificación de los elementos de un programa informático

<a id="estructura-y-bloques-fundamentales"></a>
## Estructura y bloques fundamentales

### Introducción a los ejercicios

En esta sección de ejercicios, centraremos nuestra atención en el concepto básico pero fundamental del "Hola Mundo" en Python. Este ejercicio simple te permitirá familiarizarte con la estructura básica de un programa informático y cómo imprimir texto en la consola, lo cual es uno de los primeros pasos en cualquier lenguaje de programación. A través de este ejercicio, practicarás la importancia del formato correcto del código y cómo utilizar una función integrada para mostrar mensajes en pantalla. Este tipo de ejercicios son cruciales para establecer una base sólida antes de pasar a estructuras más complejas.

### Holamundo

#### Explicación

Este fragmento de código es muy sencillo pero fundamental para entender cómo funciona el lenguaje de programación Python. La línea `print("Hola mundo desde Python")` se encarga de mostrar en la pantalla el texto "Hola mundo desde Python". La función `print()` sirve para imprimir cualquier cosa que le indiques entre paréntesis, en este caso es un mensaje simple escrito entre comillas. Este código es típicamente uno de los primeros ejemplos que se enseñan a los estudiantes de programación porque ayuda a entender cómo ejecutar y visualizar el resultado del programa en pantalla. Es importante porque establece las bases para aprender a trabajar con funciones básicas como `print()`, lo cual es crucial cuando comienzas a construir programas más complejos.

```python
print("Hola mundo desde Python")
```

### Actividades propuestas

### Actividad 1: Bienvenida al Mundo de la Programación

**Descripción:** Los estudiantes deben escribir un programa sencillo que imprima su nombre en pantalla. Este ejercicio les permitirá familiarizarse con el concepto básico de cómo ejecutar código y entender la estructura básica de los programas en Python.

### Actividad 2: Mensajes Personalizados

**Descripción:** Se solicita a los estudiantes crear un programa que reciba un mensaje personalizado por teclado (input) y lo imprima en pantalla. Esto les ayudará a comprender el uso básico de la función `input()` y cómo manipular strings.

### Actividad 3: Introducción a las Variables

**Descripción:** Los alumnos deben crear un programa que almacene su nombre en una variable y luego imprima este nombre en lugar del texto estático "Hola mundo". Esta actividad introduce el concepto de variables y almacenamiento de datos.

### Actividad 4: Suma Básica de Números

**Descripción:** Los estudiantes deben desarrollar un programa que solicite dos números por teclado, los sume y muestre el resultado. Esto ayudará a entender cómo se trabajan con operaciones matemáticas básicas en Python.

### Actividad 5: Presentación Personalizada

**Descripción:** Se les pide a los estudiantes crear un programa que imprima una presentación completa (nombre, edad) solicitando esta información al usuario. Este ejercicio reforzará el uso de variables y concatenación de strings.

### Actividad 6: Condiciones Básicas

**Descripción:** Los alumnos deben escribir un programa que pida la edad del usuario y muestre un mensaje según si es mayor o menor de 18 años. Esto introduce conceptos básicos sobre estructuras condicionales (`if`).

### Actividad 7: Estructura de Datos Básica

**Descripción:** Se les pedirá a los estudiantes crear una lista con sus nombres favoritos y luego imprimir cada nombre en una línea diferente. Esta actividad ayudará a comprender cómo se trabaja con listas.

### Actividad 8: Ciclo For Sencillo

**Descripción:** Los alumnos deben desarrollar un programa que imprima números del 1 al 10 utilizando un ciclo `for`. Esto introduce el uso de bucles para repetir tareas en Python.

### Actividad 9: Suma de Números Consecutivos

**Descripción:** Se les solicitará a los estudiantes escribir un código que sume todos los números del 1 al número especificado por el usuario. Esta actividad profundiza en la comprensión de ciclos y acumuladores.

### Actividad 10: Menú Interactivo Simple

**Descripción:** Los alumnos deben crear un programa con un menú interactivo donde el usuario puede elegir entre varias opciones (por ejemplo, ver su nombre, edad o una suma) usando `if` para las diferentes elecciones. Esto ayudará a entender cómo estructurar programas más complejos y manejar múltiples rutas de ejecución.

Estas actividades están diseñadas para cubrir los fundamentos básicos del lenguaje Python y ayudar a los estudiantes a adquirir confianza en la programación, preparándolos gradualmente para conceptos más avanzados.


<a id="variables"></a>
## Variables

### Introducción a los ejercicios

Esta carpeta contiene una serie de ejercicios básicos en Python enfocados en la comprensión y uso correcto de las variables. Los estudiantes aprenderán a declarar e inicializar variables, imprimir sus valores y cómo cambiar el contenido de una variable durante la ejecución del programa. Además, se introducirán a los diferentes tipos de identificadores válidos para nombrar variables y se explicará la importancia y uso correcto de los comentarios en el código para mejorar su legibilidad y mantenimiento.

### variables

#### Explicación

Este código Python está creando dos variables sencillas. La primera línea `nombre = "Jose Vicente"` define una variable llamada `nombre` que almacena el texto "Jose Vicente". Este es un ejemplo de una variable de tipo cadena (string), lo que significa que contiene una secuencia de caracteres entre comillas.

La segunda línea, `edad = 47`, crea otra variable denominada `edad` y le asigna el número entero 47. Esta variable es de tipo entero (int) porque almacena un valor numérico sin decimales.

Estas variables son fundamentales en la programación ya que permiten almacenar datos que se pueden usar o modificar a lo largo del programa, como el nombre y la edad de una persona en este caso. Son bloques básicos para construir programas más complejos y entender cómo los lenguajes de programación manejan diferentes tipos de información.

```python
nombre = "Jose Vicente"
edad = 47
```

### salidas

#### Explicación

Este fragmento de código Python muestra cómo guardar un texto en una variable y luego imprimir ese texto por pantalla. Primero, se crea una variable llamada `nombre` y se le asigna el valor `"Jose Vicente"`. Esto significa que la palabra `"Jose Vicente"` ahora está almacenada en la memoria del ordenador bajo el nombre de la variable `nombre`.

A continuación, se utiliza la función `print()` para mostrar por pantalla un mensaje. Dentro de esta función, primero aparece `"Mi nombre es"` y luego, gracias a la coma que separa ambos elementos, se imprime también lo que haya almacenado en la variable `nombre`. Esto significa que el programa imprimirá: "Mi nombre es Jose Vicente". Es importante porque nos permite mostrar información relevante al usuario de manera clara y sencilla.

```python
nombre = "Jose Vicente"
print("Mi nombre es",nombre)
```

### variar una variable

#### Explicación

Este fragmento de código en Python muestra cómo se pueden modificar y utilizar las variables. En primer lugar, se crea una variable llamada `nombre` a la que se le asigna el valor `"Jose Vicente"`. Luego, se imprime este valor usando la función `print()`, mostrando el mensaje "Mi nombre es Jose Vicente".

Después, en la segunda parte del código, la misma variable `nombre` se vuelve a utilizar pero esta vez se le da un nuevo valor: `"Juan"`. De nuevo, se utiliza `print()` para mostrar el contenido actual de la variable `nombre`, lo que resulta en "Mi nombre es Juan".

Este ejemplo demuestra cómo las variables pueden cambiar su valor durante la ejecución del programa. Es importante porque nos permite almacenar información que puede modificarse y ser reutilizada en diferentes partes del código, lo cual es fundamental para la programación.

```python
nombre = "Jose Vicente"
print("Mi nombre es",nombre)

nombre = "Juan"
print("Mi nombre es",nombre)
```

### identificadores permitidos

#### Explicación

Este código muestra ejemplos de cómo definir variables en Python, un lenguaje de programación que permite nombres flexibles para las variables. Las primeras líneas `nombre = "Jose"` y `nombre2 = "Vicente"` crean dos variables llamadas `nombre` y `nombre2`, almacenando cadenas de texto (nombres) dentro de ellas. La siguiente línea comentada `# 2nombre = "Jose Vicente"` demuestra que no es permitido comenzar un nombre de variable con un número, por lo que esta línea generaría un error si se descomentara.

El código también muestra ejemplos de nombres de variables no válidos: `#nombre-completo` y `#nombre completo`, indicando que los guiones medios (-) y espacios en blanco no están permitidos en los nombres de las variables, ya que pueden causar confusión con otros aspectos del código. Finalmente, la línea `nombreCompleto = "Jose Vicente"` es un ejemplo válido, aunque poco recomendado, ya que combina palabras sin separadores para formar una sola palabra (camel case), lo cual puede hacer que el nombre de la variable sea más difícil de leer y comprender en comparación con otros estilos.

```python
nombre = "Jose"
nombre2 = "Vicente"
# 2nombre = "Jose Vicente"
nombre_completo = "Jose Vicente"
#nombre-completo = "Jose Vicente"
#nombre completo = "Jose Vicente"
nombreCompleto = "Jose Vicente" # Es legal pero no se recomienda
```

### comentarios

#### Explicación

Este fragmento de código contiene dos tipos diferentes de comentarios en Python. Los comentarios son importantes porque ayudan a los programadores a entender el propósito y la lógica detrás del código sin necesidad de ejecutarlo. 

El primer comentario es una línea que comienza con el símbolo de almohadilla (#). Todo lo que está después de este símbolo en esa línea se considera un comentario y no afectará a cómo funciona el programa.

La segunda parte son comentarios multilinea, escritos entre triples comillas ("""). Puedes escribir tantas líneas como quieras dentro de estas comillas para documentar partes más complejas del código sin que esto interfiera en su ejecución. Ambos tipos de comentario son esenciales para mantener el código limpio y legible, especialmente cuando trabajan en equipos o revisan códigos después de un tiempo.

```python
# Esto es un comentario de una única línea

'''
    Esto es un comentario
    Esto sigue siendo un comentario
    Y esto también lo es
'''
```

### Explicacion del codigo

#### Explicación

Este fragmento de código en Python establece una variable llamada `edad` y le asigna el valor numérico 47. En programación, cada parte del código tiene un significado específico: `edad` es el nombre que se ha elegido para la variable (también conocida como identificador), `=` es el operador de asignación que indica que lo que está a su derecha debe ser guardado en la ubicación de memoria representada por `edad`, y finalmente, 47 es un valor literal numérico. Es importante entender este concepto porque las variables son fundamentales para almacenar datos y manipularlos durante la ejecución del programa.

```python
edad = 47
# edad es el identificador
# = es el operador de asignación
# 47 es el valor literal que se es está asignando al identificador
```

### Actividades propuestas

1. **Identificación y Uso de Variables**
   - **Descripción:** Identifica las variables en diferentes ejemplos del código proporcionado y explica qué tipo de dato contiene cada variable (cadenas, números).
   - **Objetivo:** Familiarizar a los estudiantes con la identificación y el uso correcto de variables en Python.

2. **Salidas de Texto**
   - **Descripción:** Utiliza las instrucciones `print()` para mostrar información almacenada en variables al usuario.
   - **Objetivo:** Aprender cómo imprimir datos en consola desde un programa usando variables.

3. **Modificación de Variables**
   - **Descripción:** Modifica el valor de una variable existente y muestra la nueva asignación utilizando `print()`.
   - **Objetivo:** Comprender que las variables pueden cambiar su valor durante la ejecución del código.

4. **Reglas de Identificadores de Python**
   - **Descripción:** Investiga los ejemplos válidos e inválidos de nombres para variables y proporciona una lista de reglas sobre cómo nombrar variables en Python.
   - **Objetivo:** Aprender las convenciones de nomenclatura para variables en el lenguaje Python.

5. **Uso de Comentarios**
   - **Descripción:** Identifica los comentarios existentes y agrega uno nuevo explicando una parte específica del código.
   - **Objetivo:** Conocer cómo documentar un programa con comentarios para facilitar la comprensión futura del mismo.

6. **Explicación Detallada de Código**
   - **Descripción:** Escribe una breve descripción sobre los componentes (identificadores, operaciones, valores literales) presentes en el código y su función.
   - **Objetivo:** Desarrollar habilidades para la documentación interna del código.

7. **Uso de Variables en Expresiones**
   - **Descripción:** Crea una expresión que combine dos o más variables existentes y muestre el resultado por pantalla.
   - **Objetivo:** Aprender a manipular datos usando operadores matemáticos y lógicos con variables.

8. **Análisis de Código**
   - **Descripción:** Selecciona un código dado, identifica todas las líneas que no contribuyen al flujo del programa (comentarios) y extrae su significado.
   - **Objetivo:** Mejorar la habilidad para analizar código y entender los comentarios como parte del desarrollo de software.

9. **Nombres Descriptivos**
   - **Descripción:** Reescribe variables utilizando nombres descriptivos que reflejen mejor el contenido o propósito de cada variable.
   - **Objetivo:** Mejorar la legibilidad del código a través de buenas prácticas en nomenclatura.

10. **Comparación de Codificaciones**
    - **Descripción:** Compara diferentes ejemplos de codificación y destaca las diferencias en el uso de variables, comentarios y expresiones.
    - **Objetivo:** Aprender a discernir buenas prácticas de programación frente a malas.


<a id="tipos-de-datos"></a>
## Tipos de datos

### Introducción a los ejercicios

En esta carpeta, encontrarás una serie de ejercicios diseñados para familiarizarte con los tipos de datos y la entrada de datos en Python. Los ejercicios inician explicando cómo se manejan diferentes tipos de datos como cadenas, enteros, decimales y booleanos, luego pasan a mostrar cómo obtener información del usuario mediante entradas. El objetivo es que comprendas cómo almacenar e interactuar con diversos tipos de información en programas simples, así como aprender la importancia de convertir los datos de texto ingresados por el usuario a formatos numéricos cuando sea necesario para realizar cálculos. Estos ejercicios te ayudarán a practicar tus habilidades básicas de programación y entenderás mejor cómo Python maneja diferentes tipos de datos en contextos prácticos.

### Tipos de datos

#### Explicación

Este fragmento de código está dedicado a la asignación de valores a variables, que es una operación básica en programación. En este caso, se están creando cuatro variables con diferentes tipos de datos: `nombre`, `edad`, `altura` y `vivo`. La variable `nombre` almacena el nombre de un individuo como una cadena de texto ("Jose Vicente"). La variable `edad` contiene un número entero que representa la edad del individuo (47). La variable `altura` almacena un número decimal o flotante que indica la altura en metros (1.78), y finalmente, la variable `vivo` es de tipo booleano y toma el valor True, lo cual puede interpretarse como si el individuo está vivo o no.

Este código es importante porque muestra cómo se utilizan diferentes tipos de datos para representar información variada en un programa. Entender estos conceptos básicos te permitirá gestionar adecuadamente la información que tu programa necesita procesar y almacenar, lo cual es crucial para el desarrollo de programas más complejos.

```python
nombre = "Jose Vicente" # Cadena
edad = 47 # Entero
altura = 1.78 # Decimal
vivo = True # Booleano
```

### Entradas

#### Explicación

Este código es muy sencillo y está diseñado para pedir al usuario que introduzca su nombre y luego mostrar ese nombre en pantalla. La primera línea utiliza la función `input()` para solicitar al usuario que escriba su nombre y almacenar lo que el usuario teclea en una variable llamada `nombre`. La segunda línea usa la función `print()` para mostrar un mensaje que incluye el valor de la variable `nombre`, es decir, el nombre que introdujo el usuario.

Este tipo de código es fundamental porque nos permite interactuar con los usuarios y recoger información importante para nuestro programa. Sin esta interacción básica, no podríamos hacer programas útiles que respondan a las necesidades del usuario en tiempo real.

```python
nombre = input("Dime tu nombre: ")
print("Tu nombre es: ",nombre)
```

### Entrada y problema

#### Explicación

Este código en Python solicita al usuario que ingrese su edad usando la función `input()`, y luego imprime el doble de esa edad utilizando la función `print()`. La variable `edad` guarda lo que el usuario introduce por teclado. Sin embargo, hay un error en este código: aunque se muestra "El doble de tu edad es:", realmente solo está mostrando nuevamente la edad introducida y no su doble. Para calcular el doble de la edad, necesitaríamos convertir la entrada del usuario (que llega como texto) a un número entero o decimal antes de realizar cualquier cálculo.

Es importante destacar que `input()` siempre devuelve una cadena de caracteres, por lo que si queremos hacer operaciones matemáticas con el valor ingresado, primero debemos convertirlo al tipo de dato adecuado (como int para números enteros). Esto es crucial en programación ya que combinamos diferentes tipos de datos y funciones según sea necesario.

```python
edad = input("Dime tu edad: ")
print("El doble de tu edad es: "+edad)
```

### Cambio de tipo de dato

#### Explicación

Este código pide al usuario que ingrese su edad y luego realiza algunos cálculos con ese dato. Primero, utiliza la función `input()` para obtener una entrada del usuario en texto (como "25"). Luego, convierte esa entrada de texto a un número entero usando `int()`, lo que es crucial porque las operaciones matemáticas no funcionan directamente con números escritos como cadenas de texto. Después, multiplica ese número entero por dos para calcular el doble de la edad del usuario. Finalmente, intenta mostrar el resultado en pantalla combinando una cadena de texto ("El doble de tu edad es: ") y el valor calculado, pero aquí hay un error porque no se puede sumar directamente un número con una cadena sin convertir primero el número a texto usando `str()`. Esto demuestra la importancia de entender los tipos de datos en Python y cómo transformar entre ellos para asegurar que las operaciones funcionen correctamente.

```python
# Le pregunto al usuario por su edad
edad = input("Dime tu edad: ")
# Me aseguro de convertir la edad a un número entero
entero = int(edad)
# Calculo el doble de un número entero
doble = entero*2
# Saco el resultado por pantalla
print("El doble de tu edad es: "+doble)
```

### Actividades propuestas

### Actividad 1: Identificación y Uso de Tipos de Datos Básicos

**Descripción:** Los estudiantes deben identificar los tipos de datos utilizados en un programa proporcionado (cadenas, enteros, decimales, booleanos) y explicar su uso en contextos concretos. El objetivo es que comprendan cómo se declaran e inicializan variables de diferentes tipos.

### Actividad 2: Entrada de Datos

**Descripción:** Se les pide a los estudiantes crear un programa sencillo donde el usuario pueda introducir su nombre y la consola lo muestre por pantalla. El objetivo es familiarizarles con la función `input()` en Python y cómo imprimir datos usando `print()`.

### Actividad 3: Cálculo de Edad Doblegada

**Descripción:** Los estudiantes deben completar un programa que permita al usuario ingresar su edad, calcular el doble de esta y mostrarlo por pantalla. Se enfatiza la importancia de usar operaciones aritméticas con datos numéricos.

### Actividad 4: Conversión Manual de Tipos

**Descripción:** A partir del código existente, los estudiantes deberán corregir un programa que tiene errores al intentar sumar o multiplicar cadenas sin convertirlas primero a números enteros. El objetivo es entender cómo y por qué se deben hacer conversiones explícitas entre tipos de datos.

### Actividad 5: Combinación de Entradas y Cálculos

**Descripción:** Se les solicita que diseñen un programa donde el usuario ingrese su edad y altura, luego calcula e imprime la suma de ambas. Esta actividad combina entrada de datos y operaciones matemáticas.

### Actividad 6: Condiciones Básicas con Datos

**Descripción:** Los estudiantes deben incorporar una condición simple al código que comprueba si el usuario tiene más o menos de 18 años (mediante la edad introducida) e imprime un mensaje diferente para cada caso. Esta actividad introduce conceptos básicos sobre estructuras condicionales.

### Actividad 7: Programa de Conversión de Temperaturas

**Descripción:** Los estudiantes deben crear un programa que solicite al usuario una temperatura en grados Celsius y luego la convierta a Fahrenheit, mostrando el resultado por pantalla. Esto permite trabajar con cálculos matemáticos simples.

### Actividad 8: Manipulación de Texto e Introducción de Listas

**Descripción:** En esta actividad, los estudiantes deben introducir texto (como una frase) y luego mostrar cada palabra en mayúsculas o minúsculas. También pueden experimentar con listas para almacenar múltiples entradas del usuario.

### Actividad 9: Resolución de Problemas Concretos

**Descripción:** Proporciona un problema específico (por ejemplo, calcular el promedio de tres números introducidos por el usuario) y los estudiantes deben escribir código que resuelva este problema. Esto refuerza la comprensión del manejo básico de datos y funciones matemáticas.

### Actividad 10: Introducción a Variables Booleanas

**Descripción:** Los estudiantes deben crear un programa que use una variable booleana para controlar si el usuario desea continuar introduciendo datos o no. Esto introduce conceptos sobre la lógica en programación y cómo manejar ciclos basados en condiciones boleanas.


<a id="literales"></a>
## Literales

### Introducción a los ejercicios

En esta sección de ejercicios, los estudiantes aprenderán sobre literales en Python, que son las formas directas de representar valores como números o cadenas en un programa. Los ejercicios centrarse en identificar y clasificar diferentes tipos de literales, como cadenas (strings) y enteros (integers). A través de estos ejercicios, los estudiantes practicarán la creación de variables que almacenan literales específicos y aprenderán a distinguir entre distintos tipos de datos básicos en Python.

### literales

#### Explicación

Este código muestra cómo se declaran dos variables en Python: `nombre` y `edad`. La variable `nombre` almacena la cadena "Jose Vicente", que es un grupo de caracteres entre comillas. Esta cadena es lo que llamamos un literal de texto o cadena. Por otro lado, `edad` contiene el número 47, que es un valor numérico entero sin comillas y se le conoce como literal de tipo entero. Estos literales son muy importantes porque permiten almacenar datos básicos en las variables para su uso posterior en programas más complejos.

```python
nombre = "Jose Vicente"
# Jose Vicente es el literal, y es de tipo cadena

edad = 47
# 47 es el literal, y es de tipo entero
```

### Actividades propuestas

### Actividad 1: Identificación de Literales en Python
**Descripción:** Los estudiantes deben identificar y clasificar los diferentes tipos de literales presentes en un código dado. Se espera que reconozcan las cadenas (str) y números enteros (int). **Objetivo:** Familiarizarse con la notación de literales en Python.

### Actividad 2: Crear Variables con Literales
**Descripción:** Los estudiantes deben escribir un breve código donde creen varias variables utilizando diferentes tipos de literales, incluyendo cadenas y números enteros. **Objetivo:** Practicar el uso de declaraciones para crear variables en Python.

### Actividad 3: Operaciones Básicas con Literales
**Descripción:** Los estudiantes deben realizar operaciones matemáticas básicas (suma, resta) utilizando literales numéricos. Se pide que impriman los resultados. **Objetivo:** Entender cómo funcionan las operaciones aritméticas en Python.

### Actividad 4: Formateo de Cadenas
**Descripción:** Los estudiantes deben crear una cadena que incluya variables con literales, utilizando métodos como `format()` para formatear texto. **Objetivo:** Aprender a manipular y presentar datos mediante el uso de cadenas.

### Actividad 5: Concatenación de Cadenas
**Descripción:** Los estudiantes deben concatenar diferentes cadenas que incluyen literales variables, añadiendo espacios o signos de puntuación como comillas. **Objetivo:** Practicar la operación de concatenación y manipulación de strings en Python.

### Actividad 6: Crear Funciones con Literales
**Descripción:** Los estudiantes deben crear funciones que tomen literales como argumentos y devuelvan resultados basados en ellos (por ejemplo, calcular el doble de un número entero). **Objetivo:** Aprender a definir funciones en Python utilizando parámetros y retornar valores.

### Actividad 7: Trabajar con Fechas Literales
**Descripción:** Los estudiantes deben utilizar literales de fecha para crear objetos `datetime` y realizar operaciones básicas. **Objetivo:** Familiarizarse con el manejo de fechas en Python usando literales.

### Actividad 8: Ejecución y Análisis de Código
**Descripción:** Los estudiantes recibirán un código que utiliza diversos tipos de literales y deben ejecutarlo para entender cómo funcionan. Luego, deben analizar los resultados e identificar cualquier error o problema potencial. **Objetivo:** Desarrollar habilidades de depuración básica en Python.

### Actividad 9: Uso de Literales Booleanos
**Descripción:** Los estudiantes deberán utilizar literales booleanos para controlar el flujo del programa mediante estructuras condicionales (if-else). **Objetivo:** Aprender a utilizar literales booleanos y estructuras condicionales en Python.

### Actividad 10: Documentación de Códigos con Literales
**Descripción:** Los estudiantes deben escribir comentarios explicativos para un código que utiliza diversos tipos de literales, proporcionando una guía clara sobre cada parte del código. **Objetivo:** Aprender la importancia y el uso correcto de la documentación en Python.


<a id="constantes"></a>
## Constantes

### Introducción a los ejercicios

En esta carpeta, se exploran los conceptos básicos de las constantes en programación utilizando Python. Los ejercicios te ayudarán a entender cómo declarar y utilizar constantes en tu código, así como la importancia de seguir convenciones para diferenciarlas de otras variables. Aprenderás que una constante se suele representar con letras mayúsculas y cómo su valor no debe cambiar durante la ejecución del programa, a pesar de que en Python técnicamente puedes reasignar el valor a una variable con mayúscula sin que el lenguaje te genere un error. Esto es crucial para mantener un código claro y fácil de entender.

### constantes

#### Explicación

Este fragmento de código en Python muestra cómo se puede asignar y cambiar el valor de una variable, pero también destaca un concepto importante sobre las convenciones de nomenclatura para constantes. Al principio del código, la variable `PI` recibe el valor 3.1415, que es una aproximación al número pi. Luego, se imprime en pantalla este valor usando la función `print`. Posteriormente, se cambia el valor de `PI` a 4 y se vuelve a imprimir.

Es importante notar que aunque convencionalmente las constantes en Python se escriben con letras mayúsculas para indicar que no deberían cambiarse una vez definidas (como `PI` inicialmente), este código demuestra que es posible modificarlas. Sin embargo, el comentario al final del código aconseja seguir la convención: usar mayúsculas para las constantes y minúsculas para variables regulares, lo cual ayuda a mejorar la legibilidad y comprensión del programa por parte de otros programadores.

```python
PI = 3.1415

print("PI vale",PI)

PI = 4 # Le cambio el valor a PI

print("PI vale",PI)
# Las constantes deben formularse con mayúsculas
# Las variables deben formularse con minúsculas
```

### Diferencia

#### Explicación

Este fragmento de código ilustra un concepto importante en programación, específicamente en Python: la reasignación de variables y el uso de constantes. Al principio del código, se define una variable llamada `PI` con el valor numérico 3.1416, que es una aproximación común del número matemático π (pi). Este valor debería permanecer constante en muchos cálculos matemáticos y se espera que no cambie durante la ejecución del programa.

Sin embargo, en la segunda línea, `PI` es reasignada a ser un string ("unnumero"). Esto anula el propósito de tratar `PI` como una constante, ya que ahora contiene datos completamente diferentes y de un tipo distinto (un texto en lugar de un número). En contextos profesionales o académicos más formales, este cambio sería considerado una mala práctica, ya que altera los supuestos iniciales del código sobre el propósito y la naturaleza de los valores que `PI` debería contener.

```python

# La constante es PI
# El literal es 3.1416

PI = 3.1416

PI = "unnumero"
```

### Actividades propuestas

### Actividad 1: Entendiendo la Diferencia entre Constantes y Variables
**Descripción:** Identifica las diferencias entre una constante y una variable en un código Python dado, y explica por qué se considera a PI como una constante. Esta actividad busca que los estudiantes comprendan el concepto de constantes y variables.

### Actividad 2: Creación de Constantes con Mayúsculas
**Descripción:** Escribe varios ejemplos donde declaras constantes usando solo mayúsculas para diferentes valores numéricos y textuales. La actividad pretende que los estudiantes aprendan a seguir las convenciones de nomenclatura en Python.

### Actividad 3: Modificación de Constantes
**Descripción:** Intenta modificar el valor de una constante declarada y observa el comportamiento del código. Los estudiantes deben aprender por qué es considerado un mal uso cambiar el valor de lo que se ha establecido como constante.

### Actividad 4: Uso de Literales vs Constantes
**Descripción:** Distingue entre literales numéricos, cadenas y constantes en un programa simple. Esta actividad busca que los estudiantes entiendan cuándo usar cada uno.

### Actividad 5: Comparación de Valores Constante y Literal
**Descripción:** Crea una función que compare el valor de una constante con diferentes literales numéricos. Los estudiantes deben aprender a trabajar con comparaciones y tipos de datos en Python.

### Actividad 6: Asignación Múltiple con Constantes
**Descripción:** Implementa la asignación múltiple para declarar varias constantes al mismo tiempo y observa cómo se comportan cuando intentas cambiar el valor de una. Se espera que los estudiantes comprendan las reglas de declaración y uso de constantes.

### Actividad 7: Uso de Constantes en Cálculos Matemáticos
**Descripción:** Escribe un programa donde utilices constantes matemáticas (como PI) para realizar cálculos geométricos. Se espera que los estudiantes entiendan cómo integrar las constantes en operaciones matemáticas.

### Actividad 8: Documentación de Constantes
**Descripción:** Añade comentarios a tu código explicando el propósito de cada constante y por qué es importante usar mayúsculas para declararlas. Esta actividad busca mejorar la habilidad de los estudiantes para documentar su código eficazmente.

### Actividad 9: Ejercicio Práctico con PI
**Descripción:** Crea un programa que calcule el área de un círculo utilizando PI como una constante y muestra cómo cambiar su valor afecta a la precisión del resultado. Los estudiantes deben entender la importancia de usar constantes correctas para mejorar la exactitud matemática.

### Actividad 10: Diferenciación entre Constante y Variable en Contexto
**Descripción:** Escribe un pequeño script que demuestre cómo una constante puede ser confundida con una variable por mal uso del código. Se espera que los estudiantes identifiquen el error y expliquen la importancia de mantener las convenciones al trabajar con constantes.


<a id="operadores-y-expresiones"></a>
## Operadores y expresiones

### Introducción a los ejercicios

En esta carpeta, se encuentran ejercicios que te ayudarán a familiarizarte con los operadores y expresiones en Python. Los problemas abordan diversos tipos de operaciones aritméticas, comparativas y booleanas, lo cual es fundamental para el desarrollo de programas básicos. Estos ejercicios te permitirán practicar la manipulación de datos mediante cálculos matemáticos, la realización de comparaciones lógicas entre valores y la combinación de resultados con operadores booleanos. Además, se incluye un ejercicio práctico de una calculadora de impuestos que pone en práctica lo aprendido sobre operadores aritméticos y de comparación para realizar cálculos más complejos y gestionar entradas del usuario.

### operadores aritmeticos

#### Explicación

Este código es una serie de líneas que muestran cómo se utilizan los operadores aritméticos básicos en Python. Cada línea realiza una operación matemática diferente y luego muestra el resultado en la pantalla usando la función `print()`. 

La primera línea suma dos números, 4 y 3, por lo que te mostrará un 7. La segunda resta 3 de 4, dando como resultado 1. En la tercera línea se multiplican los dos números para obtener 12. La cuarta línea divide 4 entre 3, mostrando el resultado en formato decimal (1.33333). Finalmente, la última línea usa el operador de módulo `%`, que calcula el resto de dividir 4 por 3, dando como resultado un 1.

Estos ejemplos son fundamentales porque los operadores aritméticos permiten realizar cálculos matemáticos básicos en cualquier programa, lo cual es crucial para muchas aplicaciones, desde juegos hasta procesamiento financiero.

```python
print(4+3)
print(4-3)
print(4*3)
print(4/3)
print(4%3)
```

### operadores de comparacion

#### Explicación

Este fragmento de código utiliza operadores de comparación en Python para evaluar diferentes relaciones entre los números 4 y 3. Cada línea del código genera una expresión que compara estos dos valores usando un tipo diferente de operador: menor que (`<`), menor o igual que (`<=`), mayor que (`>`), mayor o igual que (`>=`), igualdad (`==`), y desigualdad (`!=`). El resultado de cada comparación se imprime en la consola. Estos operadores son fundamentales porque nos permiten hacer juicios sobre los datos, lo cual es crucial para controlar el flujo de un programa, como decidir qué acciones tomar basadas en las condiciones dadas.

```python
print(4 < 3)
print(4 <= 3)
print(4 > 3)
print(4 >= 3)
print(4 == 3)
print(4 != 3)
```

### operadores arimeticos abreviados

#### Explicación

Este código muestra cómo se pueden modificar un valor numérico utilizando operaciones básicas de matemáticas. En este caso, el valor que está siendo modificado es la variable `edad`, inicialmente establecida en 47 años.

Primero, el programa suma dos unidades a la edad de dos maneras diferentes: primero mediante una operación normal (`edad = edad + 2`) y luego usando un operador abreviado (también conocido como operador en línea) que combina el almacenamiento del resultado directamente en la variable original (`edad += 2`). Esto último es útil porque simplifica el código al realizar y actualizar el valor de una sola vez.

Luego, se realiza lo mismo con restar dos unidades a `edad`, multiplicarla por dos y dividirla entre dos, usando tanto las operaciones tradicionales como los operadores en línea correspondientes (`-=` para resta y `/=` para división).

Este tipo de operaciones son fundamentales porque permiten manipular datos numéricos de manera eficiente y clara en la programación. Los operadores en línea no solo hacen que el código sea más conciso, sino también más legible cuando se realizan cambios simples a una variable existente.

```python
edad = 47
# Le quiero sumar dos unidades
edad = edad + 2
edad += 2
#Le quiero restar dos unidades
edad = edad - 2
edad -= 2
# Lo quiero multiplicar por dos
edad = edad * 2
edad *= 2
# Lo quiero dividir por dos
edad = edad / 2
edad /= 2
```

### operadores booleanos

#### Explicación

Este fragmento de código muestra cómo funcionan los operadores booleanos en Python, que son herramientas importantes para tomar decisiones dentro del programa. El código utiliza principalmente dos tipos de operadores booleanos: `and` y `or`. 

En las primeras líneas, el código compara si diferentes expresiones numéricas son iguales utilizando el operador de igualdad (`==`). Por ejemplo, en la primera línea se comprueba si 4 es igual a 4, 3 es igual a 3, y 2 es igual a 2. Como todas estas comparaciones son verdaderas (True), al usar `and` entre ellas, el resultado final también será True. Sin embargo, cuando una de las comparaciones cambia para ser falsa como en la segunda línea (`2 == 1` es False), entonces el resultado general con el operador `and` será False.

En las últimas líneas, se utiliza el operador `or`. Con este operador, si al menos una de las condiciones es verdadera (True), toda la expresión devolverá True. En la línea que dice "4 == 4 or 3 == 2 or 2 == 1", aunque dos de las comparaciones son falsas (`3 == 2` y `2 == 1`), una es verdadera ("4 == 4"), por lo que el resultado final será True.

Este tipo de operadores booleanos es fundamental en la programación porque te permiten combinar condiciones y tomar decisiones basadas en múltiples criterios, lo cual es crucial para desarrollar programas más complejos y dinámicos.

```python
print(4 == 4 and 3 == 3 and 2 == 2)
print(4 == 4 and 3 == 3 and 2 == 1)

print(4 == 4 or 3 == 3 or 2 == 1)
print(4 == 4 or 3 == 2 or 2 == 1)
print(4 == 3 or 3 == 2 or 2 == 1)
```

### Ejercicio1-Calculadora de impuestos

#### Explicación

Este fragmento de código es la cabecera o encabezado de un programa en Python llamado "Calculadora de Impuestos". La función principal del programa es calcular el impuesto sobre valor añadido (IVA) y el total a pagar cuando se introduce una base imponible. En otras palabras, el usuario proporciona el precio antes del IVA, y la calculadora determinará cuánto es el IVA correspondiente y cuál será el precio final incluyendo este impuesto.

Esta cabecera es importante porque proporciona información crucial sobre qué hace el programa, quién lo ha creado (en este caso, "Jose Vicente Carratalá"), y qué versión del programa se está utilizando ("v0.1"). Esta información facilita la documentación y colaboración en proyectos de programación, especialmente cuando hay múltiples personas trabajando juntas en el desarrollo del mismo software.

```python
'''
    Calculadora de Impuestos
    v0.1 por Jose Vicente Carratalá
    Funcionamiento: Introduce una base imponible y se calcula IVA y total
'''
```

### Calculadora

#### Explicación

Este fragmento de código es el comienzo del desarrollo de una pequeña aplicación en Python que sirve como una calculadora de impuestos. La idea principal es que el usuario ingrese un valor, específicamente la base imponible (el precio antes del IVA) de una factura, y el programa calculará el IVA y el total a pagar.

El código inicializa tres variables: `base_imponible`, `total_iva` e `total_factura`, todas ellas inicializadas con cero. Estas variables servirán para almacenar los valores del precio sin impuestos (base imponible), la cantidad de IVA, y el total que se debe pagar después de incluir el IVA respectivamente.

Luego, el programa solicita al usuario que introduzca la base imponible mediante una entrada de texto (`input`). Sin embargo, este código no procesa aún el cálculo del IVA ni muestra los resultados totales; ese es el siguiente paso en el desarrollo de la calculadora. Es importante notar que esta parte del código solo recoge la información necesaria para realizar las operaciones matemáticas posteriores.

La inclusión de comentarios al inicio ayuda a entender rápidamente qué hace el programa y quién lo creó, lo cual es una excelente práctica en programación ya que facilita la colaboración y mantenimiento del código.

```python
'''
    Calculadora de Impuestos
    v0.1 por Jose Vicente Carratalá
    Funcionamiento: Introduce una base imponible y se calcula IVA y total
'''

# Este programa no tiene importaciones

# Creo variables
base_imponible = 0
total_iva = 0
total_factura = 0

# Aquí pondría las funciones/clases

# Ahora calculamos
base_imponible = input("Introduce la base imponible de la factura: ")
```

### Calculadora

#### Explicación

Este fragmento de código es parte de un programa simple en Python que se utiliza para calcular impuestos. El objetivo principal del programa es permitir al usuario introducir una base imponible (el importe total antes de aplicar el IVA) y luego calcular automáticamente tanto el IVA como el total a pagar.

El código comienza creando tres variables, `base_imponible`, `total_iva` y `total_factura`, todas inicializadas en cero. Estas variables serán utilizadas para almacenar los valores que calcularemos más adelante.

Después de un bloque de texto que describe brevemente qué hace el programa, se imprime información sobre la versión del programa y su autor. Luego, solicita al usuario que introduzca la base imponible mediante la función `input()`, cuyo valor obtenido será almacenado en la variable `base_imponible`. A partir de aquí, el código no proporciona una implementación completa para calcular el IVA y el total facturado, lo cual sería el siguiente paso lógico en un programa completo.

```python
'''
    Calculadora de Impuestos
    v0.1 por Jose Vicente Carratalá
    Funcionamiento: Introduce una base imponible y se calcula IVA y total
'''

# Este programa no tiene importaciones

# Creo variables
base_imponible = 0
total_iva = 0
total_factura = 0

# Aquí pondría las funciones/clases

# Ahora calculamos
print("Programa calculadora de impuestos")
print("(c) 2025 Jose Vicente Carratalá")
print("Introduce una base y te calculo el IVA y el total")
base_imponible = input("Introduce la base imponible de la factura: ")
```

### Calculo de IVA

#### Explicación

Este programa en Python te ayuda a calcular el Impuesto sobre Valor Añadido (IVA) y el total de una factura basándose en la base imponible que introduces. En primer lugar, muestra un mensaje inicial con información del programa y solicita al usuario que ingrese la base imponible de la factura. Esta entrada se guarda en la variable `base_imponible` después de convertirla a número decimal para poder hacer cálculos matemáticos.

Luego, el programa realiza dos operaciones: calcula el IVA aplicando un 21% sobre la base imponible y añade este valor al importe original para obtener el total de la factura. Finalmente, muestra en pantalla tanto el monto del IVA como el total de la factura, proporcionando una salida clara e informativa que facilita entender cuánto se debe pagar por concepto de impuestos sobre un determinado gasto.

Este tipo de cálculo es importante porque te permite conocer exactamente cuánto debes añadir a los precios de productos o servicios para incluir el IVA, lo cual es fundamental tanto en aspectos personales como profesionales.

```python
'''
    Calculadora de Impuestos
    v0.1 por Jose Vicente Carratalá
    Funcionamiento: Introduce una base imponible y se calcula IVA y total
'''

# Este programa no tiene importaciones

# Creo variables
base_imponible = 0
total_iva = 0
total_factura = 0

# Aquí pondría las funciones/clases

# Ahora calculamos

# Primero pido una entrada
print("Programa calculadora de impuestos")
print("(c) 2025 Jose Vicente Carratalá")
print("Introduce una base y te calculo el IVA y el total")
base_imponible = float(input("Introduce la base imponible de la factura: "))

# Luego realizo cálculos
total_iva = base_imponible*0.21
total_factura = base_imponible + total_iva

# Por último expreso una salida
print("El IVA de la factura es: ",total_iva)
print("El total de la factura es: ",total_factura)
```

### Actividades propuestas

### Actividades Propuestas:

1. **Operadores Aritméticos**
   - Descripción: Los estudiantes deben escribir un programa que realice varias operaciones aritméticas (suma, resta, multiplicación y división) con dos números proporcionados por el usuario.
   - Objetivo: Familiarizar a los alumnos con la utilización de operadores aritméticos en Python.

2. **Operadores de Comparación**
   - Descripción: Los estudiantes deben crear un programa que compare dos valores ingresados por el usuario y muestre si son iguales, diferentes o cumplen otras relaciones comparativas.
   - Objetivo: Aprender a usar operadores de comparación para tomar decisiones en Python.

3. **Operadores de Asignación**
   - Descripción: Los estudiantes deben modificar un código existente que usa asignaciones simples (como `edad = edad + 2`) para utilizar los operadores abreviados (`+=`, `-=`, `*=`, `/=`).
   - Objetivo: Comprender la eficiencia y conveniencia de los operadores de asignación en Python.

4. **Operadores Lógicos**
   - Descripción: Los estudiantes deben escribir un programa que utilice operadores lógicos (`and`, `or`) para evaluar expresiones condicionales.
   - Objetivo: Aprender a combinar varias condiciones utilizando operadores lógicos.

5. **Calculadora de Impuestos Básica**
   - Descripción: Los estudiantes deben desarrollar una calculadora que pida al usuario la base imponible y calcule el IVA (21%) y el total.
   - Objetivo: Aprender a utilizar variables, operadores aritméticos y de asignación para realizar cálculos.

6. **Validación de Datos**
   - Descripción: Los estudiantes deben mejorar la calculadora de impuestos añadiendo validaciones básicas que aseguren que el usuario ingrese valores numéricos.
   - Objetivo: Aprender a manejar excepciones y validar datos en Python.

7. **Menú de Operaciones**
   - Descripción: Los estudiantes deben crear un menú interactivo donde el usuario pueda seleccionar entre diferentes operaciones (sumar, restar, multiplicar).
   - Objetivo: Practicar la estructura condicional `if-elif` y bucles en programas interactivos.

8. **Juego de Adivinanza Numérica**
   - Descripción: Los estudiantes deben desarrollar un juego donde el programa genera un número aleatorio entre 1 y 50, y el usuario debe adivinarlo.
   - Objetivo: Practicar la interacción con el usuario y la lógica condicional en programas más dinámicos.

Estas actividades están diseñadas para cubrir los aspectos fundamentales del uso de operadores y expresiones en Python, adaptándose al nivel y necesidades de los estudiantes de Formación Profesional.


<a id="ejercicio-de-final-de-unidad"></a>
## Ejercicio de final de unidad

### Introducción a los ejercicios

Esta carpeta contiene un conjunto de ejercicios diseñados para estudiantes de Formación Profesional que recién comienzan a aprender programación en Python. Los problemas abordan conceptos fundamentales como imprimir texto, declarar y manipular variables, utilizar entradas de usuario, trabajar con diferentes tipos de datos (cadenas, números enteros, decimales, booleanos), realizar operaciones aritméticas y lógicas, así como introducir comentarios en el código. A lo largo de estos ejercicios, los estudiantes aprenderán a identificar correctamente las partes constituyentes de un programa informático y a entender cómo se manipulan diferentes tipos de datos y estructuras básicas para resolver problemas simples.

### Holamundo

#### Explicación

Este código es muy sencillo y básico en la programación con Python. Lo que hace es mostrar el texto "Hola mundo desde Python" en la pantalla cuando se ejecuta. La función `print()` es una instrucción que toma lo que le pasas entre paréntesis (en este caso, el texto entre comillas) y lo muestra por la salida estándar del programa, generalmente el terminal o consola donde estás trabajando.

Este tipo de código sirve como un ejemplo introductorio en programación porque demuestra cómo interactuar con los sistemas desde Python. Es importante porque te ayuda a entender los conceptos básicos antes de pasar a cosas más complejas, como variables, estructuras de control y la manipulación de datos.

```python
print("Hola mundo desde Python")
```

### variables

#### Explicación

Este código está creando dos variables en Python. La primera variable se llama `nombre` y almacena el texto "Jose Vicente", que es una cadena de caracteres o string en programación. La segunda variable se llama `edad` y almacena el número 47, lo cual indica la edad de una persona.

Las variables son como cajas donde guardamos información para usarla más tarde en nuestro programa. En este caso, estamos almacenando el nombre y la edad de alguien llamado Jose Vicente con 47 años. Esto es importante porque nos permite trabajar fácilmente con esta información en otras partes del código, por ejemplo, si necesitamos mostrar un mensaje que incluya el nombre y la edad.

Crear variables de esta manera hace que nuestro programa sea más flexible y reusable, ya que podemos cambiar fácilmente los valores de `nombre` o `edad` sin tener que modificar todo el código.

```python
nombre = "Jose Vicente"
edad = 47
```

### salidas

#### Explicación

Este código Python muestra cómo imprimir información en la pantalla usando el comando `print`. En este caso, se está trabajando con una variable llamada `nombre` que almacena el texto `"Jose Vicente"`. Luego, utilizando la función `print`, se imprime un mensaje compuesto por dos partes: "Mi nombre es" y el valor de la variable `nombre`. Al ejecutar este código, en la pantalla aparecerá la frase completa "Mi nombre es Jose Vicente". Es importante porque ayuda a entender cómo las variables pueden ser usadas junto con texto para mostrar información personalizada.

```python
nombre = "Jose Vicente"
print("Mi nombre es",nombre)
```

### variar una variable

#### Explicación

Este código Python muestra cómo se pueden cambiar y utilizar variables en un programa. En primer lugar, la variable `nombre` se inicializa con el valor `"Jose Vicente"`, y luego este valor se imprime usando la función `print()`. A continuación, la misma variable `nombre` cambia su valor a `"Juan"` y vuelve a imprimirse utilizando de nuevo la función `print()`.

Lo importante aquí es entender que las variables en Python (y en programación en general) son como cajas donde puedes guardar información. En este caso, primero guardamos el nombre "Jose Vicente" en la caja llamada `nombre`, luego mostramos lo que hay en esa caja. Después, cambiamos el contenido de la caja por "Juan", y volvemos a mostrar el nuevo valor.

Este concepto es fundamental porque nos permite trabajar con datos dinámicos en nuestros programas, permitiéndonos actualizar información fácilmente según sea necesario durante la ejecución del programa.

```python
nombre = "Jose Vicente"
print("Mi nombre es",nombre)

nombre = "Juan"
print("Mi nombre es",nombre)
```

### identificadores permitidos

#### Explicación

Este fragmento de código muestra diferentes formas de nombrar variables en Python y cuáles son válidas según las reglas del lenguaje. Primero, vemos dos variables que guardan nombres como strings: `nombre` contiene "Jose" y `nombre2` contiene "Vicente". Luego hay varias líneas comentadas (precedidas por el símbolo #) que muestran ejemplos de cómo NO se pueden nombrar las variables en Python. Por ejemplo, no puedes usar un número al inicio del nombre (`2nombre`) ni guiones medios o espacios. Al final, hay una variable llamada `nombreCompleto` en mayúscula y sin caracteres especiales que es la forma recomendada de escribir nombres compuestos para evitar problemas. Es importante entender estas reglas porque usar nombres válidos te ayuda a mantener tu código claro y funcional.

```python
nombre = "Jose"
nombre2 = "Vicente"
# 2nombre = "Jose Vicente"
nombre_completo = "Jose Vicente"
#nombre-completo = "Jose Vicente"
#nombre completo = "Jose Vicente"
nombreCompleto = "Jose Vicente" # Es legal pero no se recomienda
```

### comentarios

#### Explicación

Este fragmento de código muestra dos formas diferentes de añadir comentarios en Python, que son esenciales para mejorar la legibilidad y el entendimiento del código. Los comentarios no afectan directamente al funcionamiento del programa, sino que sirven para explicar el código a otros programadores (incluyéndote a ti mismo en el futuro).

La primera línea comienza con un signo de almohadilla (#) seguido de texto. Este es un comentario de una sola línea que se extiende hasta el final del renglón y no tiene ningún efecto sobre la ejecución del programa.

La segunda parte utiliza tres comillas simples (‘’’) al principio y al final para encerrar comentarios multilínea, lo cual permite escribir tantas líneas como sean necesarias para explicar un bloque de código o una sección específica. Esto es útil cuando el comentario necesita extenderse más allá de una línea.

Ambos tipos de comentarios son importantes porque ayudan a documentar el código y facilitan su mantenimiento y comprensión tanto para ti como para otros programadores que puedan trabajar en tu proyecto.

```python
# Esto es un comentario de una única línea

'''
    Esto es un comentario
    Esto sigue siendo un comentario
    Y esto también lo es
'''
```

### Explicacion del codigo

#### Explicación

Este fragmento de código establece una variable llamada `edad` y le asigna un valor específico. En este caso, la línea `edad = 47` indica que la variable `edad` va a contener el número entero 47. Aquí, `edad` es el identificador (una etiqueta usada para referirse a una ubicación de memoria en tu programa), `=` es el operador de asignación (que sirve para dar un valor específico a la variable) y 47 es el valor literal (un número concreto que no cambia). Este tipo de código es fundamental porque permite almacenar datos que luego puedes usar o manipular en diferentes partes del programa. Por ejemplo, podrías utilizar esta información más adelante para hacer cálculos basados en la edad guardada.

```python
edad = 47
# edad es el identificador
# = es el operador de asignación
# 47 es el valor literal que se es está asignando al identificador
```

### Tipos de datos

#### Explicación

Este fragmento de código está mostrando ejemplos básicos de cómo se definen variables en Python utilizando diferentes tipos de datos. Comenzamos con una variable llamada `nombre`, que almacena el texto "Jose Vicente". En este caso, estamos trabajando con un tipo de dato conocido como cadena o string, que se utiliza para almacenar cualquier conjunto de caracteres encerrados entre comillas.

A continuación, definimos la variable `edad` y le asignamos el valor 47. Este es un ejemplo de un entero (int), que representa números enteros sin decimales. Luego, tenemos la variable `altura`, que almacena un número decimal como 1.78. En Python, esto se conoce como flotante o float y es útil para representar valores numéricos que tienen parte fraccionaria.

Por último, hay una variable llamada `vivo` que tiene el valor booleano True. Los booleanos son muy importantes porque solo pueden tomar dos valores: True (verdadero) o False (falso). Este tipo de dato es especialmente útil para representar condiciones verdaderas o falsas en la lógica del programa.

Entender estos tipos de datos es fundamental en programación, ya que te permitirá manejar correctamente los distintos tipos de información y realizar operaciones adecuadas con ellas.

```python
nombre = "Jose Vicente" # Cadena
edad = 47 # Entero
altura = 1.78 # Decimal
vivo = True # Booleano
```

### Entradas

#### Explicación

Este código te permite interactuar con el programa que estás ejecutando. En primer lugar, la línea `nombre = input("Dime tu nombre: ")` muestra en pantalla un mensaje pidiendo al usuario que introduzca su nombre. Cuando el usuario teclea algo y presiona Enter, lo que ha escrito se guarda en una variable llamada `nombre`.

Luego, con la línea `print("Tu nombre es: ", nombre)`, el programa imprime por pantalla el texto "Tu nombre es:" seguido del valor almacenado en la variable `nombre`. Esto nos dice al usuario que hemos capturado correctamente su entrada y podemos hacer algo con esa información.

Este código es importante porque demuestra cómo obtener datos del usuario y luego usar esos datos dentro de un programa, lo cual es fundamental para muchas aplicaciones interactivas.

```python
nombre = input("Dime tu nombre: ")
print("Tu nombre es: ",nombre)
```

### Entrada y problema

#### Explicación

Este fragmento de código en Python solicita al usuario que introduzca su edad y luego muestra por pantalla el doble de esa edad, aunque hay un pequeño error. Primero, `input()` recoge la entrada del usuario como texto (cadena de caracteres) y la guarda en la variable `edad`. Luego, `print()` muestra el mensaje "El doble de tu edad es: " seguido del valor que se ingresó por teclado, no del doble de esa edad. Para calcular realmente el doble de la edad, sería necesario convertir la entrada a un número (por ejemplo, usando `int()`) y luego realizar la multiplicación antes de imprimirlo.

Es importante destacar que este código tiene un error lógico ya que imprime simplemente lo que se ingresó en lugar del cálculo correcto. Aprender a identificar y corregir este tipo de errores es crucial para el desarrollo de programas precisos y funcionales.

```python
edad = input("Dime tu edad: ")
print("El doble de tu edad es: "+edad)
```

### Cambio de tipo de dato

#### Explicación

Este fragmento de código tiene como objetivo interactuar con el usuario para pedirle su edad y luego realizar cálculos basados en esa información. En primer lugar, el programa utiliza la función `input()` para solicitar al usuario que ingrese su edad; lo que el usuario teclea se guarda en la variable `edad`, pero inicialmente este dato es un texto (string). Luego, el código convierte ese texto a un número entero usando la función `int()`, y este nuevo valor numérico se guarda en una variable llamada `entero`. Finalmente, el programa calcula el doble del número entero obtenido e intenta imprimir este resultado utilizando la función `print()`. Sin embargo, hay un error en esta última línea porque el código está tratando de combinar (concatenar) un texto con un número sin convertir adecuadamente el número a una cadena. Para corregir esto, es necesario cambiar la forma en que se imprime el resultado para que ambos elementos sean del mismo tipo antes de ser concatenados o usar formateo de cadenas.

```python
# Le pregunto al usuario por su edad
edad = input("Dime tu edad: ")
# Me aseguro de convertir la edad a un número entero
entero = int(edad)
# Calculo el doble de un número entero
doble = entero*2
# Saco el resultado por pantalla
print("El doble de tu edad es: "+doble)
```

### literales

#### Explicación

Este fragmento de código muestra cómo se asignan valores a variables en Python. En la primera línea, se crea una variable llamada `nombre` que almacena el texto "Jose Vicente". Este texto entre comillas ("") se llama literal cadena porque es un conjunto de caracteres específicos que no cambian y representan nombres, palabras o frases.

En la segunda parte del código, vemos cómo se declara otra variable llamada `edad`, a la cual se le asigna el número 47. Este valor sin comillas (47) se denomina literal entero porque es un número que representa cantidades concretas y no contiene puntos decimales.

Estos literales son fundamentales en la programación porque permiten almacenar información básica sobre la cual las aplicaciones pueden operar para realizar funciones como mostrar datos, hacer cálculos o tomar decisiones basadas en esa información.

```python
nombre = "Jose Vicente"
# Jose Vicente es el literal, y es de tipo cadena

edad = 47
# 47 es el literal, y es de tipo entero
```

### constantes

#### Explicación

Este código muestra cómo se utilizan las constantes y variables en Python. En primer lugar, se establece una constante llamada `PI` que inicialmente tiene el valor de 3.1415. La constante es escrita completamente en mayúsculas para indicar que su valor no debería cambiar durante la ejecución del programa.

Luego, imprime en pantalla el mensaje "PI vale" seguido del valor actual de `PI`. Después, se modifica el valor de `PI` a 4 y vuelve a imprimirlo. Esto demuestra que, aunque normalmente las constantes no cambian, en Python puedes cambiar el valor de cualquier variable (incluso aquella que se supone constante) porque Python no tiene un tipo específico para las constantes.

Finalmente, se incluyen dos comentarios al final del código que recomiendan usar mayúsculas para los nombres de las constantes y minúsculas para las variables. Aunque en este caso `PI` cambió de valor, siguiendo esta convención ayudará a otros programadores entender mejor tu código, ya que esperarán que una variable escrita en mayúsculas no se modifique durante la ejecución del programa.

Es importante seguir estas pautas para mejorar la legibilidad y mantenibilidad del código.

```python
PI = 3.1415

print("PI vale",PI)

PI = 4 # Le cambio el valor a PI

print("PI vale",PI)
# Las constantes deben formularse con mayúsculas
# Las variables deben formularse con minúsculas
```

### Diferencia

#### Explicación

En este fragmento de código, primero se define una variable llamada `PI` y se le asigna el valor numérico 3.1416, que es una aproximación común del número Pi. Luego, en la segunda línea, esa misma variable `PI` se reasigna un nuevo valor: esta vez es la cadena de texto `"unnumero"`. 

Este código ilustra cómo las variables en Python pueden cambiar su tipo y contenido a lo largo del programa. En este caso específico, inicialmente `PI` era un número decimal (flotante), pero después se convierte en una cadena de caracteres, lo cual puede causar problemas si luego el programa espera que `PI` siga siendo un número.

Es importante entender estos conceptos porque manipular correctamente los tipos de datos es fundamental para evitar errores y escribir programas confiables.

```python

# La constante es PI
# El literal es 3.1416

PI = 3.1416

PI = "unnumero"
```

### operadores aritmeticos

#### Explicación

Este código es muy sencillo y te muestra cómo Python utiliza diferentes operadores aritméticos básicos. En cada línea, se realiza una operación matemática simple: suma, resta, multiplicación, división y módulo (que te da el resto de una división). 

La primera línea suma 4 y 3, dando como resultado 7. La segunda resta 3 de 4, lo que produce 1. En la tercera línea se multiplica 4 por 3 para obtener 12. La cuarta línea divide 4 entre 3, resultando en un número decimal aproximado (1.333...). Finalmente, la última línea calcula el resto de dividir 4 entre 3, que es 1.

Estas operaciones son fundamentales porque te permiten hacer cálculos matemáticos directamente en tu código, lo cual es crucial para muchas aplicaciones en programación.

```python
print(4+3)
print(4-3)
print(4*3)
print(4/3)
print(4%3)
```

### operadores de comparacion

#### Explicación

Este código muestra cómo usar diferentes operadores de comparación en Python para verificar si una afirmación es verdadera o falsa. Los operadores que se utilizan son `<` (menor que), `<=` (menor o igual que), `>` (mayor que), `>=` (mayor o igual que), `==` (igual a) y `!=` (distinto de). En cada línea del código, Python compara los números 4 y 3 usando uno de estos operadores y luego imprime el resultado. El resultado siempre será un valor booleano: `True` si la afirmación es verdadera o `False` si no lo es.

Por ejemplo, cuando se comprueba `4 < 3`, el resultado es `False` porque 4 no es menor que 3. En contraste, al evaluar `4 > 3`, el resultado será `True`. Estos operadores de comparación son fundamentales en programación ya que permiten realizar decisiones y bucles condicionales basados en la relación entre diferentes valores numéricos o variables.

```python
print(4 < 3)
print(4 <= 3)
print(4 > 3)
print(4 >= 3)
print(4 == 3)
print(4 != 3)
```

### operadores arimeticos abreviados

#### Explicación

Este fragmento de código está mostrando cómo utilizar los operadores aritméticos en Python, que son herramientas fundamentales para realizar cálculos matemáticos dentro del programa. En primer lugar, se establece una variable llamada `edad` con un valor inicial de 47 años.

El código muestra dos formas diferentes de realizar las mismas operaciones: la forma tradicional y la forma abreviada o conocida como "operador compuesto". Por ejemplo, para sumarle dos unidades a la edad se hace primero de manera clásica `edad = edad + 2` y luego usando el operador compuesto `edad += 2`, que es una forma más concisa de incrementar en 2 unidades la variable `edad`.

Estas técnicas son importantes porque permiten escribir código más limpio y fácil de leer. El uso correcto de estos operadores te ayudará a programar con mayor eficiencia, especialmente cuando necesitas realizar ajustes numéricos frecuentes.

Por tanto, este ejercicio es crucial para entender cómo manipular valores en Python utilizando operaciones básicas como suma, resta, multiplicación y división, así como su forma simplificada.

```python
edad = 47
# Le quiero sumar dos unidades
edad = edad + 2
edad += 2
#Le quiero restar dos unidades
edad = edad - 2
edad -= 2
# Lo quiero multiplicar por dos
edad = edad * 2
edad *= 2
# Lo quiero dividir por dos
edad = edad / 2
edad /= 2
```

### operadores booleanos

#### Explicación

Este código utiliza operadores booleanos en Python para comprobar y combinar diferentes condiciones. Los operadores `and` y `or` se usan para evaluar múltiples expresiones lógicas juntas.

En el primer bloque, las líneas `print(4 == 4 and 3 == 3 and 2 == 2)` y `print(4 == 4 and 3 == 3 and 2 == 1)`, se están verificando si todas las condiciones son verdaderas. En la primera línea, todas las comparaciones son correctas (4 es igual a 4, 3 es igual a 3 y 2 es igual a 2), por lo que el resultado será `True`. Sin embargo, en la segunda línea, una de las comparaciones es falsa (2 no es igual a 1), así que todo el bloque será `False`.

En el segundo bloque, se usan los operadores `or` para verificar si al menos una de las condiciones es verdadera. Por ejemplo, en `print(4 == 4 or 3 == 3 or 2 == 1)`, la primera comparación (4 es igual a 4) ya basta para que el resultado sea `True`. En cambio, en la última línea `print(4 == 3 or 3 == 2 or 2 == 1)`, ninguna de las condiciones se cumple, por lo tanto, el resultado será `False`.

Este tipo de operaciones lógicas es fundamental en programación ya que nos permite tomar decisiones basadas en múltiples condiciones.

```python
print(4 == 4 and 3 == 3 and 2 == 2)
print(4 == 4 and 3 == 3 and 2 == 1)

print(4 == 4 or 3 == 3 or 2 == 1)
print(4 == 4 or 3 == 2 or 2 == 1)
print(4 == 3 or 3 == 2 or 2 == 1)
```

### Ejercicio1-Calculadora de impuestos

#### Explicación

Este fragmento de código es la descripción del encabezado de un script Python que se llama "Calculadora de Impuestos". Su propósito principal es permitir al usuario ingresar el valor de la base imponible, que es el costo original antes de que se aplique el impuesto sobre el valor añadido (IVA). El programa entonces calcula el IVA basado en esa base imponible y muestra tanto el importe del IVA como el total que resulta de sumar la base imponible más el IVA.

Esta herramienta es útil para estudiantes, profesionales y negocios en general, ya que les ayuda a entender cómo se calculan los impuestos sobre bienes y servicios. Es importante destacar que este script proporciona una introducción básica al concepto del cálculo de impuestos en la programación, enseñando a los alumnos cómo capturar entrada del usuario y realizar operaciones matemáticas simples pero esenciales.

El comentario incluye detalles adicionales como la versión (v0.1) y el autor (Jose Vicente Carratalá), lo que ayuda a identificar fácilmente quién creó el código y qué tan reciente o maduro está en términos de desarrollo.

```python
'''
    Calculadora de Impuestos
    v0.1 por Jose Vicente Carratalá
    Funcionamiento: Introduce una base imponible y se calcula IVA y total
'''
```

### Calculadora

#### Explicación

Este fragmento de código es el comienzo de un programa sencillo en Python que sirve para calcular impuestos basado en una entrada proporcionada por el usuario. La idea principal del programa es recibir una cantidad llamada "base imponible", que es la parte de la factura antes del impuesto sobre valor añadido (IVA), y luego calcular tanto el IVA como el total a pagar.

En primer lugar, el código inicializa tres variables: `base_imponible`, `total_iva` y `total_factura`. Estas se usarán para almacenar los valores calculados durante la ejecución del programa. Luego, en la parte donde dice "Aquí pondría las funciones/clases", el autor indicó que este es el espacio reservado para definir cualquier función o clase necesaria para realizar cálculos más adelante.

El código luego pide al usuario que introduzca una base imponible a través de la función `input()`. Esta función permite que el programa espere hasta que el usuario teclee un valor y presione Enter, después lo guarda en la variable `base_imponible`.

Es importante notar que este fragmento es solo el inicio del programa; aún falta definir cómo se calculará el IVA y el total de la factura utilizando la base imponible proporcionada por el usuario.

```python
'''
    Calculadora de Impuestos
    v0.1 por Jose Vicente Carratalá
    Funcionamiento: Introduce una base imponible y se calcula IVA y total
'''

# Este programa no tiene importaciones

# Creo variables
base_imponible = 0
total_iva = 0
total_factura = 0

# Aquí pondría las funciones/clases

# Ahora calculamos
base_imponible = input("Introduce la base imponible de la factura: ")
```

### Calculadora

#### Explicación

Este código es un programa sencillo en Python que se utiliza para calcular impuestos, específicamente el IVA (Impuesto sobre Valor Añadido) basándose en una base imponible introducida por el usuario. El programa comienza mostrando información básica como el nombre del programa y los créditos al autor. Luego, pide al usuario que ingrese la base imponible de la factura a través del teclado.

El código crea tres variables para almacenar la base imponible (la cantidad antes del impuesto), el total del IVA calculado y el total final (base imponible + IVA). Sin embargo, en esta versión inicial, las funciones o clases que realizarían los cálculos aún no han sido implementadas.

El programa utiliza la función `print()` para mostrar mensajes informativos al usuario y `input()` para permitirle introducir la base imponible. El siguiente paso sería tomar esa entrada del usuario (que es un string), convertirla en un número, calcular el IVA y luego sumar ese valor a la base imponible para obtener el total de la factura.

Esta estructura básica ayuda al programador a organizar los pensamientos antes de añadir las partes que realmente hacen cálculos matemáticos. Es importante porque proporciona una base clara desde donde avanzar en el desarrollo del programa, permitiendo centrarse en cada parte del código por separado.

```python
'''
    Calculadora de Impuestos
    v0.1 por Jose Vicente Carratalá
    Funcionamiento: Introduce una base imponible y se calcula IVA y total
'''

# Este programa no tiene importaciones

# Creo variables
base_imponible = 0
total_iva = 0
total_factura = 0

# Aquí pondría las funciones/clases

# Ahora calculamos
print("Programa calculadora de impuestos")
print("(c) 2025 Jose Vicente Carratalá")
print("Introduce una base y te calculo el IVA y el total")
base_imponible = input("Introduce la base imponible de la factura: ")
```

### Calculo de IVA

#### Explicación

Este código es un programa simple que calcula el Impuesto sobre Valor Añadido (IVA) y el total de una factura basándose en la base imponible proporcionada por el usuario. El objetivo principal del programa es tomar como entrada la cantidad antes del IVA, calcular el 21% de IVA sobre esa cantidad y luego sumar el IVA a la base imponible para obtener el total de la factura.

El programa comienza solicitando al usuario que introduzca la base imponible (la cantidad antes del impuesto) usando la función `input()`, convirtiendo la entrada en un número flotante con `float()` y guardándolo en la variable `base_imponible`. Luego, el IVA se calcula multiplicando la base imponible por 0.21 (que es una tasa de IVA del 21%) y se guarda en la variable `total_iva`. Finalmente, se suma la base imponible al IVA para obtener el total de la factura, que se almacena en `total_factura`.

El resultado final se presenta al usuario a través de dos mensajes impresas por pantalla: uno muestra el monto del IVA calculado y otro muestra el total de la factura. Este tipo de programa es útil en contextos comerciales para facilitar cálculos rápidos y precisos relacionados con el IVA, lo que puede ayudar tanto a clientes como a vendedores a entender mejor las transacciones financieras.

```python
'''
    Calculadora de Impuestos
    v0.1 por Jose Vicente Carratalá
    Funcionamiento: Introduce una base imponible y se calcula IVA y total
'''

# Este programa no tiene importaciones

# Creo variables
base_imponible = 0
total_iva = 0
total_factura = 0

# Aquí pondría las funciones/clases

# Ahora calculamos

# Primero pido una entrada
print("Programa calculadora de impuestos")
print("(c) 2025 Jose Vicente Carratalá")
print("Introduce una base y te calculo el IVA y el total")
base_imponible = float(input("Introduce la base imponible de la factura: "))

# Luego realizo cálculos
total_iva = base_imponible*0.21
total_factura = base_imponible + total_iva

# Por último expreso una salida
print("El IVA de la factura es: ",total_iva)
print("El total de la factura es: ",total_factura)
```

### Actividades propuestas

### Actividad 1: Programa de Saludo Personalizado
**Descripción:** Los estudiantes deben crear un programa que imprima "¡Hola, [nombre del estudiante]!" en lugar de simplemente "Hola mundo". Se pretende que aprendan a utilizar variables y funciones básicas.

### Actividad 2: Gestión de Variables
**Descripción:** Diseñar una aplicación simple que cambie el valor de una variable y muestre su nuevo contenido. Los estudiantes aprenderán sobre la mutabilidad en Python y cómo cambiar los valores asignados a las variables durante la ejecución del programa.

### Actividad 3: Entrada/Salida Mejorada
**Descripción:** Crear un programa que pida al usuario ingresar su nombre y luego imprimirlo con una frase amigable. Este ejercicio ayuda a entender mejor el uso de funciones `input()` y `print()` en Python.

### Actividad 4: Conversión de Tipos de Datos
**Descripción:** Los estudiantes deben escribir un programa que solicite la edad del usuario (como cadena) e imprima el doble de su edad. El objetivo es aprender a convertir tipos de datos entre cadenas y números enteros para realizar operaciones aritméticas.

### Actividad 5: Operadores Aritméticos
**Descripción:** Implementar un programa que utilice diferentes operadores aritméticos (suma, resta, multiplicación, división) con dos números. Los estudiantes aprenderán a aplicar estos conceptos en situaciones prácticas.

### Actividad 6: Operadores de Comparación
**Descripción:** Desarrollar un programa que evalúe expresiones usando operadores de comparación (>, <, >=, <=, ==, !=) y muestre el resultado. Se espera que los estudiantes comprendan cómo funcionan estas operaciones en Python.

### Actividad 7: Operadores Aritméticos Abreviados
**Descripción:** Crear un programa que utiliza operadores de asignación como `+=`, `-=`, `*=`, `/=` para modificar el valor de una variable. Los estudiantes aprenderán sobre la eficiencia del código y las formas abreviadas de escribir instrucciones.

### Actividad 8: Operaciones Booleanas
**Descripción:** Implementar un programa que utilice operadores lógicos `and` y `or`. Se espera que los estudiantes comprendan cómo combinar varias condiciones en una sola expresión booleana para tomar decisiones en el código.

### Actividad 9: Calculadora de IVA Básica
**Descripción:** Crear un programa sencillo que calcule el valor del IVA y el total a partir de la base imponible introducida por el usuario. Los estudiantes aprenderán sobre entradas y cálculos en Python, así como cómo estructurar programas más complejos.

### Actividad 10: Mejora Estética e Información
**Descripción:** Añadir un encabezado con detalles del autor al programa de la calculadora del IVA (como se muestra en los ejemplos). Los estudiantes mejorarán sus habilidades de codificación y aprenderán sobre buenas prácticas en la escritura de código.



<a id="utilizacion-de-objetos"></a>
# Utilización de objetos

<a id="caracteristicas-de-los-objetos"></a>
## Características de los objetos

### Introducción a los ejercicios

En esta subunidad, nos enfocamos en comprender y utilizar objetos predefinidos en Python, específicamente centrándonos en cómo interactuar con ellos para resolver problemas comunes. Los ejercicios te ayudarán a familiarizarte con el uso del módulo `math` de Python, donde practicarás operaciones matemáticas avanzadas y manipulación de números utilizando funciones predefinidas como `sqrt`, `sin`, `cos` entre otras. Este conjunto de ejercicios te permitirá mejorar tus habilidades en la resolución de problemas que requieren cálculos matemáticos precisos, así como desarrollar una mayor confianza al utilizar bibliotecas estándar de Python.

### Nota importante

#### Explicación

Este fragmento de código es un archivo Markdown que contiene una nota importante para quienes están creando ejercicios sobre el uso de objetos en programación. La nota destaca que esta subunidad del curso no requiere que los estudiantes o los creadores de ejercicios desarrollen clases personalizadas, sino que se centran en aprender a utilizar objetos que ya existen en el lenguaje de programación elegido.

Es importante seguir estas instrucciones al crear ejercicios para asegurarse de que estos cumplan con los objetivos educativos específicos establecidos para esta subunidad. La nota también indica dónde deben buscar las actividades existentes y desarrolladas previamente, en la carpeta 101-Ejercicios, para mantener consistencia y coherencia en el contenido del curso.

En resumen, este archivo sirve como guía esencial para garantizar que todos los ejercicios creados estén alineados con las metas de aprendizaje de esta parte específica del programa.

```markdown
Nota importante para la generación de ejercicios de esta subunidad:
Esta subunidad trata, no la creación de clases personalizadas, sino la utilización de objetos predeterminados existentes en el propio lenguaje de programación.
Para crear actividades, ajustate al alcance concreto de los ejercicios desarrollados en la carpeta 101-Ejercicios.
```

### objeto math

#### Explicación

Parece que no has proporcionado el fragmento de código para analizar. Por favor, proporcione el bloque de código específico que deseas que explique en español y con los detalles pedagógicos adecuados para estudiantes de Formación Profesional.

```python

```

### Actividades propuestas

### Actividad 1: Utilización del objeto `math`
**Descripción:** Los alumnos deben usar el módulo `math` de Python para realizar cálculos matemáticos más avanzados que no pueden hacerse con operaciones básicas. Se espera que aprendan a utilizar funciones como `sqrt`, `pow`, y `sin`.

### Actividad 2: Creación de un programa de conversión
**Descripción:** Los estudiantes deben crear un programa simple que convierta unidades utilizando el módulo `math`. Por ejemplo, convertir grados centígrados a Fahrenheit. Esto les ayudará a entender cómo aplicar las funciones matemáticas en situaciones reales.

### Actividad 3: Cálculo de áreas y volúmenes
**Descripción:** Los alumnos deben diseñar un programa que calcule el área y volumen de diferentes figuras geométricas utilizando funciones del módulo `math`. Esto les permitirá familiarizarse con las operaciones matemáticas avanzadas en Python.

### Actividad 4: Resolución de ecuaciones
**Descripción:** Los estudiantes deben escribir un programa que resuelva ecuaciones cuadráticas o lineales utilizando funciones del módulo `math`. Esto les ayudará a comprender cómo aplicar fórmulas matemáticas en Python.

### Actividad 5: Generación de números aleatorios
**Descripción:** Los alumnos deben usar el objeto `random` (asociado con `math`) para generar secuencias de números aleatorios y calcular estadísticas básicas como la media o la mediana. Esto les permitirá entender cómo combinar múltiples objetos en un solo programa.

### Actividad 6: Manipulación de radianes
**Descripción:** Los estudiantes deben crear funciones que conviertan grados a radianes y viceversa, utilizando las funciones del módulo `math`. Esto les ayudará a entender la manipulación de ángulos en programas matemáticos.

### Actividad 7: Cálculo de distancia entre puntos
**Descripción:** Los alumnos deben desarrollar un programa que calcule la distancia euclidiana entre dos puntos en el espacio bidimensional o tridimensional utilizando funciones del módulo `math`. Esto les permitirá aplicar conceptos geométricos en Python.

### Actividad 8: Implementación de algoritmos numéricos
**Descripción:** Los estudiantes deben implementar un algoritmo simple que use la clase `math` para calcular números aproximados, como el valor de Pi mediante métodos de integración. Esto les permitirá entender cómo se utilizan los objetos matemáticos en algoritmos más complejos.

Estas actividades están diseñadas para ayudar a los estudiantes a dominar el uso del objeto `math` y otras funciones predeterminadas en Python, aplicándolas en contextos prácticos y resolviendo problemas comunes de programación.


<a id="instanciacion-de-objetos"></a>
## Instanciación de objetos

### Introducción a los ejercicios

En esta subcarpeta, se enfatiza el uso y manipulación de objetos predefinidos en Python, específicamente aquellos que pertenecen a módulos incorporados como `math`. Los ejercicios están diseñados para que los estudiantes practiquen la importación de módulos, el acceso a sus funciones y atributos, así como entender cómo utilizar correctamente estos objetos existentes para resolver problemas matemáticos o lógicos. Este conjunto de ejercicios es crucial para desarrollar competencias en la utilización eficiente de la biblioteca estándar de Python, permitiendo a los estudiantes aplicar conceptos matemáticos avanzados y funciones específicas del módulo `math` en el desarrollo de algoritmos y soluciones prácticas.

### Nota importante

#### Explicación

Este fragmento de texto en formato Markdown es una nota importante para quienes están creando ejercicios relacionados con la utilización de objetos en un lenguaje de programación. La nota aclara que esta subunidad no se centra en la creación de clases personalizadas, sino en cómo usar los objetos ya existentes proporcionados por el propio lenguaje de programación. Esto es crucial porque ayuda a enfocar las actividades educativas específicamente en la manipulación y comprensión de esos objetos predeterminados, lo que es fundamental para adquirir una sólida base en la programación orientada a objetos. Para generar ejercicios efectivos, se deben seguir los alcances detallados en la carpeta designada para ejercicios, asegurando así que los estudiantes practiquen exactamente las habilidades requeridas por el currículo.

```markdown
Nota importante para la generación de ejercicios de esta subunidad:
Esta subunidad trata, no la creación de clases personalizadas, sino la utilización de objetos predeterminados existentes en el propio lenguaje de programación.
Para crear actividades, ajustate al alcance concreto de los ejercicios desarrollados en la carpeta 101-Ejercicios.
```

### namespace

#### Explicación

Este fragmento de código es una declaración `import` en Python que se utiliza para incluir el módulo `math`. El módulo `math` contiene funciones matemáticas adicionales y constantes que no están disponibles por defecto en Python. Al importar este módulo, puedes usar todas las funciones y constantes que ofrece, como `sqrt()` para calcular la raíz cuadrada de un número o `pi` para obtener el valor del número π. Es importante porque facilita realizar cálculos matemáticos complejos sin tener que escribir toda la lógica desde cero.

```python
import math
```

### Actividades propuestas

### Actividad 1: Uso Básico de Nombres Espaciales (Namespaces) con Math

**Descripción:** Los estudiantes deben importar el módulo `math` en Python y utilizar algunas funciones básicas como `sqrt`, `sin`, o `cos`. Se espera que comprendan cómo se utiliza el espacio de nombres para acceder a las funciones matemáticas predefinidas.

### Actividad 2: Cálculo de Áreas con Math

**Descripción:** Los alumnos deben calcular áreas de diferentes figuras geométricas (círculos, triángulos) utilizando funciones del módulo `math`. Se busca reforzar el uso de constantes y funciones matemáticas predefinidas.

### Actividad 3: Conversión de Ángulos

**Descripción:** Los estudiantes deben escribir un programa que convierta grados a radianes y viceversa, utilizando las funciones adecuadas del módulo `math`. Se pretende que comprendan la importancia de usar unidades correctas en cálculos matemáticos.

### Actividad 4: Operaciones con Números Complejos

**Descripción:** Los alumnos deben realizar operaciones básicas (suma, resta, multiplicación) con números complejos utilizando el módulo `cmath` del espacio de nombres. Se busca que dominen la manipulación de tipos numéricos avanzados en Python.

### Actividad 5: Cálculo de Raíces y Potencias

**Descripción:** Los estudiantes deben calcular raíces cuadradas y cubicas, así como potencias elevando un número a otra. Se pretende que practiquen el uso del módulo `math` para resolver problemas matemáticos cotidianos.

### Actividad 6: Generación de Secuencias Numéricas

**Descripción:** Los alumnos deben generar secuencias numéricas utilizando la función `range()` y operaciones con arrays. Se busca que comprendan cómo crear iterables complejos para cálculos matemáticos más avanzados.

### Actividad 7: Comparación de Números Reales

**Descripción:** Los estudiantes deben escribir un programa que compare números reales utilizando el módulo `math` y operadores relacionales. Se pretende que practiquen la manipulación precisa de valores numéricos en Python.

### Actividad 8: Ejecución de Algoritmos Matemáticos Simples

**Descripción:** Los alumnos deben implementar algoritmos matemáticos simples (como el cálculo del máximo común divisor) utilizando funciones del módulo `math`. Se busca que practiquen la resolución de problemas matemáticos con funciones predefinidas en Python.

### Actividad 9: Visualización Básica de Gráficas

**Descripción:** Los estudiantes deben crear gráficas simples (como una función seno) utilizando bibliotecas como `matplotlib` que se importan a través del espacio de nombres. Se pretende que dominen la integración de herramientas visuales con cálculos matemáticos.

### Actividad 10: Resolución de Problemas Prácticos

**Descripción:** Los alumnos deben resolver problemas prácticos (como calcular áreas bajo curvas) utilizando funciones del módulo `math`. Se busca que apliquen conocimientos teóricos en contextos aplicados y realistas.


<a id="utilizacion-de-metodos-parametros"></a>
## Utilización de métodos. Parámetros

### Introducción a los ejercicios

Esta carpeta contiene ejercicios enfocados en la utilización y llamada a métodos de objetos predefinidos en Python, específicamente haciendo uso de la biblioteca `math`. Los ejercicios buscan que los estudiantes comprendan cómo importar módulos, llamar a sus métodos y utilizarlos para realizar operaciones matemáticas básicas. Se enfatiza el manejo de parámetros y el entendimiento del retorno de valores, lo cual es crucial para desarrollar habilidades en la manipulación de objetos y métodos en Python.

### Nota importante

#### Explicación

Este texto es una nota importante para quienes están creando ejercicios basados en esta subunidad del curso. Indica que el objetivo no es aprender a crear clases personalizadas desde cero, sino entender cómo utilizar los objetos ya existentes en el lenguaje de programación que se está usando. Esto significa que cuando se diseñan actividades o ejercicios para este tema, deben centrarse específicamente en la utilización y manipulación de esos objetos predefinidos, no en su creación desde principios.

Es importante seguir esta guía para asegurarse de que los ejercicios estén alineados con el objetivo educativo de la subunidad, lo cual es fundamental para que los estudiantes adquieran una comprensión sólida de cómo funcionan y se utilizan correctamente los objetos predefinidos en su lenguaje de programación.

```markdown
Nota importante para la generación de ejercicios de esta subunidad:
Esta subunidad trata, no la creación de clases personalizadas, sino la utilización de objetos predeterminados existentes en el propio lenguaje de programación.
Para crear actividades, ajustate al alcance concreto de los ejercicios desarrollados en la carpeta 101-Ejercicios.
```

### llamada a metodos

#### Explicación

Este fragmento de código utiliza la biblioteca `math` en Python, que es una colección de funciones matemáticas adicionales. En el código, se importa esta biblioteca y se le da un alias "matematicas" para facilitar su uso posterior. La función `ceil`, que significa "redondeo hacia arriba", está siendo usada sobre el número 7.2. Esta función toma un número decimal como entrada y devuelve el menor entero mayor o igual al número dado, por lo que en este caso, imprimirá el valor 8.

Este tipo de código es útil cuando necesitas realizar operaciones matemáticas más complejas que las proporcionadas por los tipos numéricos estándar en Python. La función `ceil` es especialmente relevante para situaciones donde necesitas asegurarte de trabajar con un número entero que no sea menor al decimal original, lo cual puede ser útil en diversas aplicaciones como cálculos financieros o de inventario.

```python
import math as matematicas

print(matematicas.ceil(7.2))
```

### sparse is better than dense

#### Explicación

Este fragmento de código es muy sencillo y útil para entender cómo se redondean los números en Python, específicamente hacia arriba cuando no son enteros puros. Lo que hace este código es importar un módulo llamado `math` con el alias `matematicas`, lo cual nos permite usar las funciones matemáticas incluidas en ese módulo.

Luego, se define una variable llamada `numero` y se le asigna el valor de 7.2. A continuación, se utiliza la función `ceil()` del módulo `mathematicas`, que redondea hacia arriba cualquier número decimal a su entero más cercano pero no menor al original (en este caso, 7.2 será redondeado hasta 8). 

Finalmente, el resultado de esta operación se imprime en la consola gracias a la función `print()`. En resumen, este código muestra cómo podemos manipular números con precisión y controlar su redondeo usando funciones matemáticas incorporadas en Python.

```python
import math as matematicas

numero = 7.2
redondeo = matematicas.ceil(numero)
print(redondeo)
```

### sparse

#### Explicación

Este fragmento de código utiliza la biblioteca `math` en Python, que proporciona funciones para realizar operaciones matemáticas complejas. En este caso, el código importa esta biblioteca con un alias: `import math as matematicas`. Esto significa que puedes usar el nombre "matematicas" en lugar de "math" cada vez que necesites utilizar alguna función de esta librería.

La línea `print(matematicas.ceil(7.2))` llama a la función `ceil`, que es parte de la biblioteca importada anteriormente. La función `ceil` (que significa "rebanar hacia arriba") toma un número como argumento y devuelve el menor entero mayor o igual al número dado. En este caso, cuando se pasa 7.2 a esta función, devuelve 8 porque es el siguiente número entero más cercano.

Este tipo de código es útil en situaciones donde necesitas asegurarte que los valores numéricos no sean decimales sino enteros superiores, como ajustar precios redondeados hacia arriba o calcular la cantidad mínima de recursos necesarios para un proyecto.

```python
import math as matematicas

print(matematicas.ceil(7.2))
```

### Actividades propuestas

### Actividad 1: Llamada a Métodos de Matemáticas Básicos
**Descripción:** Los estudiantes deben utilizar el módulo `math` en Python para llamar a distintos métodos, como `ceil`, `floor`, y `sqrt`. Se espera que comprendan cómo importar un módulo e invocar sus funciones.

### Actividad 2: Redondeo de Números
**Descripción:** Los estudiantes deben crear una función que redondee números hacia arriba utilizando el método `math.ceil` con diferentes valores numéricos. El objetivo es entender cómo aplicar operaciones matemáticas en Python para manipular datos.

### Actividad 3: Creación de Objetos y Acceso a Métodos
**Descripción:** Los estudiantes deben aprender a crear objetos desde módulos importados, como `math`, y acceder a métodos específicos. Se enfatiza la importancia de entender cómo trabajar con bibliotecas estándar.

### Actividad 4: Uso de Variables Intermedias en Métodos
**Descripción:** Los estudiantes deben usar una variable para almacenar el resultado de un método como `math.ceil` antes de imprimirlo. Esto ayudará a comprender la importancia del manejo adecuado de variables y cómo se integran con los métodos.

### Actividad 5: Documentación y Comentarios
**Descripción:** Los estudiantes deben añadir documentación y comentarios al código para explicar qué hace cada parte, especialmente cuando se llaman a métodos. Se pretende mejorar sus habilidades en la documentación de código.

### Actividad 6: Comparación entre Métodos Matemáticos
**Descripción:** Los estudiantes deben escribir un programa que utilice tanto `math.ceil` como `math.floor`, y luego comparar los resultados para diferentes números decimales. El objetivo es entender las diferencias en el comportamiento de distintos métodos matemáticos.

### Actividad 7: Uso de Métodos con Variables Dinámicas
**Descripción:** Los estudiantes deben crear un programa que solicite al usuario un número decimal y luego use ese valor para llamar a `math.ceil` o `math.floor`. Esto ayuda en el manejo de entrada de datos y métodos matemáticos.

### Actividad 8: Aplicación Práctica de Métodos Matemáticos
**Descripción:** Los estudiantes deben desarrollar un pequeño programa que resuelva un problema real utilizando métodos del módulo `math`, como calcular áreas, volúmenes o resolver ecuaciones. Se espera que apliquen lo aprendido en contextos prácticos.

### Actividad 9: Creación de Subrutinas con Métodos Matemáticos
**Descripción:** Los estudiantes deben crear funciones personalizadas que utilicen métodos del módulo `math`. Esto mejorará sus habilidades en la creación de subrutinas y modularización de código.

### Actividad 10: Evaluación Comparativa entre Métodos Propios y Módulos Externos
**Descripción:** Los estudiantes deben comparar el uso de métodos matemáticos directamente programados contra los proporcionados por módulos como `math`. Se espera que entiendan las ventajas y desventajas de cada enfoque.


<a id="utilizacion-de-propiedades"></a>
## Utilización de propiedades

### Introducción a los ejercicios

En esta subunidad, se enfatiza la comprensión y el uso de objetos predeterminados en Python, específicamente aquellos que ya existen en bibliotecas estándar como `math`. Los ejercicios te guiarán a través del proceso de importar módulos, acceder a constantes y métodos definidos por estos módulos, así como la manipulación de propiedades matemáticas fundamentales. El objetivo es que los estudiantes adquieran competencias en la utilización eficiente de objetos integrados para resolver problemas comunes en programación.

A través de estos ejercicios, se practicarán habilidades como el manejo de módulos de biblioteca estándar y la aplicación de propiedades y métodos existentes para realizar cálculos matemáticos o manipulaciones de datos básicas.

### Nota importante

#### Explicación

Este fragmento de código es un archivo Markdown que contiene una nota importante para quienes están generando ejercicios basados en esta subunidad. La nota aclara el propósito específico de este bloque de contenido: no se trata de crear nuevas clases personalizadas, sino de utilizar objetos predeterminados que ya existen dentro del lenguaje de programación que se está estudiando. Esto significa que los creadores de ejercicios deben enfocarse en cómo usar y manipular esos objetos existentes para resolver problemas o llevar a cabo tareas específicas. Es importante seguir esta guía al crear ejercicios para asegurarse de que los estudiantes comprendan adecuadamente el uso de las clases y objetos integrados del lenguaje.

```markdown
Nota importante para la generación de ejercicios de esta subunidad:
Esta subunidad trata, no la creación de clases personalizadas, sino la utilización de objetos predeterminados existentes en el propio lenguaje de programación.
Para crear actividades, ajustate al alcance concreto de los ejercicios desarrollados en la carpeta 101-Ejercicios.
```

### propiedades

#### Explicación

Este fragmento de código es una breve introducción al uso de módulos y propiedades en Python. En primer lugar, se importa el módulo `math` con un alias llamado `matematicas`. Esto facilita la referencia del módulo sin tener que escribir su nombre completo cada vez.

Luego, se crea una variable `PI`, que almacena el valor de la constante π (pi) que viene en el módulo `matematicas` bajo el nombre `pi`. Finalmente, se imprime este valor. El código es importante porque demuestra cómo acceder a valores predefinidos en un módulo y cómo utilizar variables para almacenar estos valores de manera que sean más fáciles de usar y entender en contextos posteriores.

```python
import math as matematicas

PI = matematicas.pi
print(PI)
```

### Actividades propuestas

### Actividad 1: Utilización de Propiedades Matemáticas Básicas
**Descripción:** Los estudiantes deberán utilizar la biblioteca `math` para imprimir varias constantes y funciones matemáticas. Esta actividad busca que los alumnos comprendan cómo acceder a propiedades predefinidas en Python.

### Actividad 2: Creación de Objetos Matemáticos Simples
**Descripción:** Se les pide a los estudiantes que creen objetos utilizando la biblioteca `math` y muestren sus propiedades, como constantes matemáticas o resultados de funciones. Esta actividad se centra en el uso práctico de las propiedades.

### Actividad 3: Operaciones Matemáticas Concretas
**Descripción:** Los alumnos deben realizar operaciones matemáticas básicas utilizando métodos y propiedades proporcionadas por la biblioteca `math`. Este ejercicio tiene como objetivo reforzar la comprensión de cómo se utilizan estas herramientas en cálculos.

### Actividad 4: Comparación de Valores Matemáticos
**Descripción:** Los estudiantes compararán valores numéricos utilizando las propiedades y métodos proporcionados por `math`. Esta actividad busca mejorar sus habilidades en la manipulación de datos matemáticos con objetos predeterminados.

### Actividad 5: Uso del Valor Pi para Cálculos Circulares
**Descripción:** Utilizando el valor pi (`PI`) desde `math`, los alumnos calcularán áreas y perímetros de círculos. Esta tarea refuerza el uso práctico de propiedades matemáticas en situaciones cotidianas.

### Actividad 6: Creación de una Clase que Utilice Propiedades Matemáticas
**Descripción:** Los estudiantes crearán una clase simple que importe y utilice propiedades del módulo `math`. Esta actividad busca que comprendan cómo integrar objetos matemáticos en estructuras más complejas.

### Actividad 7: Resolución de Problemas con Propiedades Matemáticas
**Descripción:** A los alumnos se les presentará un problema real y deben resolverlo utilizando las propiedades y métodos proporcionados por `math`. Esta actividad fomenta el pensamiento lógico y la aplicación práctica del conocimiento.

### Actividad 8: Documentación de Propiedades Matemáticas
**Descripción:** Los estudiantes revisarán documentación oficial sobre el módulo `math` y describirán las propiedades y métodos que más les hayan interesado. Esta actividad busca mejorar sus habilidades en la búsqueda de información técnica.

### Actividad 9: Ejecución de Cálculos Avanzados
**Descripción:** Los alumnos ejecutarán cálculos avanzados como factoriales, potencias, logaritmos y raíces cuadradas utilizando `math`. Este ejercicio reforzará su confianza en el manejo de propiedades matemáticas complejas.

### Actividad 10: Resolución de Ejercicios Propuestos
**Descripción:** Los estudiantes resolverán una serie de ejercicios propuestos que utilizan diferentes aspectos del módulo `math`. Esta actividad permite evaluar la comprensión global y la aplicación práctica del conocimiento adquirido.


<a id="utilizacion-de-metodos-estaticos"></a>
## Utilización de métodos estáticos

### Introducción a los ejercicios

En esta subunidad, se centran en la utilización de métodos estáticos en objetos y clases predefinidas del lenguaje Python. Los ejercicios no involucran la creación de nuevas clases desde cero sino que trabajan con las características ya establecidas dentro de los objetos matemáticos y otras estructuras existentes en el entorno de programación. Se practica cómo invocar métodos estáticos y compararlos con llamadas a métodos no estáticos, destacando la importancia del uso correcto de decoradores como `@staticmethod` para definir comportamientos que pertenecen a la clase en sí misma más que a una instancia específica.

### Nota importante

#### Explicación

Este fragmento de código es un archivo Markdown que contiene una nota importante para aquellos que están creando ejercicios relacionados con esta subunidad del curso. La nota aclara que, en lugar de enfocarse en crear nuevas clases personalizadas (objetos definidos por el programador), los ejercicios deberían centrarse en la utilización de objetos ya existentes y predeterminados proporcionados por el lenguaje de programación elegido.

Es importante destacar que este archivo sirve como guía para asegurar que las actividades creadas estén alineadas con el objetivo específico de esta subunidad, es decir, familiarizarse con la manipulación de objetos incorporados en lugar de diseñar y crear clases desde cero. Esto ayuda a mantener coherencia y relevancia en los ejercicios proporcionados, asegurando que los estudiantes se enfocan en aprender cómo utilizar efectivamente las herramientas ya disponibles en el lenguaje de programación.

```markdown
Nota importante para la generación de ejercicios de esta subunidad:
Esta subunidad trata, no la creación de clases personalizadas, sino la utilización de objetos predeterminados existentes en el propio lenguaje de programación.
Para crear actividades, ajustate al alcance concreto de los ejercicios desarrollados en la carpeta 101-Ejercicios.
```

### Gato

#### Explicación

Este código define una clase llamada `Gato` en Python, que es una plantilla para crear objetos que representan a gatos. Dentro de esta clase, se incluye un método especial llamado `__init__`, que actúa como constructor y se encarga de inicializar los atributos de la instancia (en este caso, el nombre del gato). Sin embargo, hay un detalle importante: el método `maulla()` está definido como un método estático porque no toma `self` como primer parámetro, lo que significa que no tiene acceso a las propiedades o métodos específicos de una instancia de `Gato`. Esto resulta en un error si se intenta llamar desde una instancia de la clase.

Después de definir la clase, el código crea dos instancias de `Gato`: `gato1` y `gato2`, cada una con su propio nombre. Aunque el método `maulla()` está disponible dentro de la clase, no se utiliza en este fragmento de código, lo cual puede ser confuso si esperas que los gatos maullen.

Es importante corregir cómo se define el método `maulla()`, para que pueda acceder a las características individuales del gato o simplemente devolver un sonido estándar sin depender de la instancia. De esta forma, podrías llamar a este método en cada gato y escuchar su maullido.

Este tipo de ejercicios ayuda a entender cómo se crean instancias desde una clase y cómo trabajar con atributos y métodos de esas instancias. Sin embargo, hay un error en la definición del método `maulla()`, que no debería ser estático si planea interactuar directamente con las características individuales de cada gato (como su nombre).

```python
class Gato():
  def __init__(self):
    self.nombre = ""
  def maulla():
    return "miau"
    
gato1 = Gato()
gato1.nombre = "Micifu"

gato2 = Gato()
gato2.nombre = "Belcebú"
```

### Matematicas

#### Explicación

Este código define una clase llamada `Matematicas` en Python. La clase tiene un método de inicialización (`__init__`) que establece un atributo `numero` a 0 cada vez que se crea un objeto de la clase. Además, contiene otro método llamado `suma`, que recibe dos parámetros (a y b) y devuelve su suma.

Después de definir la clase, el código crea dos objetos distintos (`operacion1` y `operacion2`) a partir de esta clase. Luego, se llama al método `suma` para cada uno de estos objetos con diferentes argumentos: en primer lugar, se suman 4 y 3, y después 6 y 7. Los resultados de estas operaciones se imprimen en la consola.

Este fragmento es importante porque demuestra cómo crear clases que encapsulan tanto datos como funcionalidades relacionadas (el número y la suma), permitiendo a los programadores crear múltiples instancias de objetos con comportamientos similares pero con sus propios estados independientes.

```python
class Matematicas():
  def __init__(self):
    self.numero = 0
  def suma(self,a,b):
    return a+b
    
operacion1 = Matematicas()
print(operacion1.suma(4,3))

operacion2 = Matematicas()
print(operacion2.suma(6,7))
```

### metodo pseudoestatico

#### Explicación

Este código define una clase en Python llamada `Matematicas` que contiene un método llamado `suma`. Sin embargo, hay un detalle importante: el método `suma` no está siendo utilizado de manera correcta dentro del contexto de la clase. En general, los métodos en clases requieren una instancia para ser llamados, pero aquí se intenta llamar a `Matematicas.suma(6,7)` como si fuera un método estático o funcional directo.

El método `suma` toma dos parámetros `a` y `b`, suma esos valores y devuelve el resultado. Sin embargo, dado que la clase tiene un constructor (`__init__`) que inicializa una variable de instancia llamada `numero`, este método debería usar esa variable o algún otro estado de la instancia para ser realmente útil dentro del contexto de la clase.

En este caso, si quisiéramos hacer uso correcto del concepto de instancias en Python, deberíamos crear un objeto de tipo `Matematicas` y luego llamar al método `suma` desde ese objeto. Sin embargo, como se está intentando llamar directamente a la clase sin crear una instancia, esto no es posible con el código tal cual está escrito.

Es importante destacar que este ejemplo ilustra cómo los métodos dentro de clases deben ser llamados en el contexto correcto y también muestra una situación donde un método podría considerarse más apropiado como función independiente o como método estático dentro de la clase, si se necesita que sea accesible sin necesidad de crear una instancia.

```python
class Matematicas():
  def __init__(self):
    self.numero = 0
  def suma(self,a,b):
    return a+b
    
print(Matematicas.suma(6,7))
```

### metodo estatico

#### Explicación

Este fragmento de código en Python está creando una clase llamada `Matematicas` que contiene un método estático. El método estático se llama `suma`, y su función es sumar dos números enteros proporcionados como argumentos. Lo especial del método `suma` es que no necesita instanciar la clase para ser utilizado, lo que significa que puedes llamar a este método directamente desde el nombre de la clase sin necesidad de crear un objeto de esa clase.

En este ejemplo, el código imprime en pantalla el resultado de la suma de los números 6 y 7 utilizando el método estático `Matematicas.suma(6,7)`. Esto es útil cuando queremos realizar una operación simple como sumar dos números sin necesidad de crear objetos adicionales que puedan complicar el manejo de memoria en programas más grandes.

El uso de métodos estáticos permite encapsular funciones útiles dentro de la estructura de clases y hacerlas accesibles a través del nombre de dicha clase, lo cual es una forma elegante de organizar el código.

```python
class Matematicas():
  def __init__(self):
    self.numero = 0
  @staticmethod
  def suma(a,b):
    return a+b
    
print(Matematicas.suma(6,7))
```

### Actividades propuestas

### Actividades Propuestas

1. **Utilización de Métodos Estáticos en Clases**
   - **Descripción:** Los estudiantes deben modificar la clase `Matematicas` para que sus métodos operativos sean estáticos y luego ejecutarlas sin necesidad de instanciar objetos.
   - **Objetivo:** Aprender a definir y utilizar métodos estáticos en una clase.

2. **Comparación entre Métodos Instancia y Estáticos**
   - **Descripción:** Los estudiantes deben comparar la implementación y uso de un método de instancia con uno estático, explicando las diferencias.
   - **Objetivo:** Comprender los beneficios y limitaciones de cada tipo de métodos en una clase.

3. **Clase Gato Mejorada**
   - **Descripción:** Los estudiantes deben modificar la clase `Gato` para que el método `maulla()` sea estático, luego instanciar dos objetos y llamar al método.
   - **Objetivo:** Aprender a utilizar métodos estáticos en clases con lógica común.

4. **Creación de Métodos Estáticos Propios**
   - **Descripción:** Los estudiantes deben crear una clase llamada `Tiempo` con un método estático que devuelva la hora actual.
   - **Objetivo:** Practicar la implementación y uso de métodos estáticos para tareas generales.

5. **Comparativa entre Métodos Instancia y Pseudoestáticos**
   - **Descripción:** Los estudiantes deben crear una clase con métodos pseudoestáticos (llamados directamente en la clase) y compararlas con métodos de instancia.
   - **Objetivo:** Comprender las ventajas y desventajas del uso de métodos pseudoestáticos frente a métodos estáticos.

6. **Documentación Metodológica**
   - **Descripción:** Los estudiantes deben documentar cada método en la clase `Matematicas` con comentarios explicando su propósito.
   - **Objetivo:** Mejorar las habilidades de documentación y creación de código legible.

7. **Uso de Métodos Estáticos en Funciones Externas**
   - **Descripción:** Los estudiantes deben crear una función externa que llame a un método estático de la clase `Matematicas` para realizar cálculos matemáticos.
   - **Objetivo:** Aprender a integrar métodos estáticos con funciones externas del programa.

8. **Aplicación en Problemas Prácticos**
   - **Descripción:** Los estudiantes deben diseñar una clase que utilice métodos estáticos para resolver un problema práctico, como calcular el IVA.
   - **Objetivo:** Aprender a aplicar la programación orientada a objetos en soluciones reales.

9. **Refactorización de Código**
   - **Descripción:** Los estudiantes deben refactorizar el código existente (clase `Gato`) para mejorar su eficiencia y claridad, utilizando métodos estáticos cuando sea apropiado.
   - **Objetivo:** Mejorar las habilidades de análisis y mejora del código existente.

10. **Implementación de Clases Complementarias**
    - **Descripción:** Los estudiantes deben diseñar una clase adicional que interactúe con la clase `Matematicas` utilizando métodos estáticos para realizar operaciones matemáticas.
    - **Objetivo:** Aprender a crear y vincular clases en un contexto más amplio.


<a id="constructores"></a>
## Constructores

### Introducción a los ejercicios

En esta carpeta, se encuentran ejercicios que te ayudarán a comprender y utilizar objetos de fechas en Python. Los problemas abordan el manejo de la clase `date` del módulo `datetime`, permitiéndote trabajar con diferentes propiedades y métodos para obtener información detallada sobre una fecha específica, como año, mes, día y día de la semana. A través de estos ejercicios, mejorarás tus habilidades en el uso de objetos predefinidos del lenguaje, lo que es fundamental para cualquier proyecto que requiera manipulación de fechas y tiempo.

### Nota importante

#### Explicación

Este fragmento de código es un archivo markdown que sirve como una nota importante para los profesores o creadores de contenido educativo. En él, se indica que esta subunidad del curso no requiere la creación de nuevas clases personalizadas en el lenguaje de programación elegido; en cambio, enfatiza la utilización y manipulación de objetos ya existentes proporcionados por el propio lenguaje. Esto es crucial para centrar los ejercicios en las habilidades específicas relacionadas con los objetos predeterminados del lenguaje, ayudando a los estudiantes a comprender mejor cómo utilizarlos correctamente antes de pasar a crear clases personalizadas más avanzadas.

La nota también sugiere que al generar actividades o ejercicios para esta subunidad, estos deben estar en línea con el contenido y la profundidad explorada en la carpeta 101-Ejercicios. Esto garantiza una coherencia en los objetivos de aprendizaje entre las lecciones teóricas y prácticas, permitiendo a los estudiantes aplicar lo que han estudiado sobre objetos predeterminados en contextos realistas y controlados.

```markdown
Nota importante para la generación de ejercicios de esta subunidad:
Esta subunidad trata, no la creación de clases personalizadas, sino la utilización de objetos predeterminados existentes en el propio lenguaje de programación.
Para crear actividades, ajustate al alcance concreto de los ejercicios desarrollados en la carpeta 101-Ejercicios.
```

### fechas en python

#### Explicación

Este código utiliza la biblioteca `datetime` de Python para trabajar con fechas. En primer lugar, importa esta biblioteca y le da el alias 'fechas', lo que hace que sea más fácil escribir y leer el código posteriormente.

El código crea un objeto `date` llamado `hoy`, que representa una fecha específica: 11 de septiembre de 2025. Para crear este objeto, se especifican tres argumentos dentro del constructor de la clase `date`: año (2025), mes (9 para septiembre) y día (11).

Finalmente, el código imprime en pantalla esta fecha utilizando la función `print()`. Esto es útil cuando necesitas mostrar fechas en formato legible por humanos o cuando deseas validar que los objetos de fecha se han creado correctamente.

Este tipo de operaciones con fechas es fundamental para muchas aplicaciones, como sistemas de gestión de eventos, bases de datos temporales y otros proyectos donde la manipulación de fechas es crucial.

```python
import datetime as fechas

hoy = fechas.date(2025, 9, 11)
print(hoy)
```

### propiedades de la fecha

#### Explicación

Este código es una introducción a cómo trabajar con fechas en Python utilizando el módulo `datetime`. Comienza importando el módulo `datetime` como `fechas`, lo que facilita su uso posterior. Luego, crea un objeto de fecha para el día 11 de septiembre del año 2025 y lo almacena en la variable `hoy`.

El código imprime la fecha completa, seguida por los componentes individuales: año, mes y día. Esto muestra cómo acceder a diferentes partes de una fecha almacenada como un objeto.

Además, el programa calcula el día de la semana correspondiente a esa fecha utilizando dos métodos del objeto `date`: `weekday()` y `isoweekday()`. Estos métodos devuelven números que representan los días de la semana (por ejemplo, 0 para lunes y 6 para domingo en `weekday()`, mientras que `isoweekday()` empieza desde el lunes con 1). Este tipo de manipulación es útil cuando necesitas realizar cálculos o consultas basadas en fechas específicas.

```python
import datetime as fechas

hoy = fechas.date(2025, 9, 11)
print(hoy)

print(hoy.year)
print(hoy.month)
print(hoy.day)

diadelasemana = hoy.weekday()
print(diadelasemana)
diadelasemana = hoy.isoweekday()
print(diadelasemana)
```

### Actividades propuestas

### Actividad 1: Manipulación de Fechas Básica
**Descripción:** Los estudiantes deben crear un programa en Python que imprima la fecha actual del año 2025. Este ejercicio ayudará a familiarizarse con el módulo `datetime` y la creación de objetos date.

### Actividad 2: Acceso a Atributos de Fecha
**Descripción:** Los estudiantes deben escribir un programa que acceda a los atributos individuales (año, mes, día) de una fecha específica y los imprima por pantalla. Esta actividad les permitirá comprender cómo obtener diferentes partes de una fecha.

### Actividad 3: Creación de Objetos Fecha
**Descripción:** Los estudiantes tendrán que crear varios objetos `date` representando distintas fechas importantes del año (por ejemplo, aniversarios o festivos). Esto los ayudará a practicar la creación y manejo de múltiples objetos.

### Actividad 4: Día de la Semana
**Descripción:** Los estudiantes deben implementar un programa que determine el día de la semana correspondiente a una fecha dada (usando tanto `weekday` como `isoweekday`). Esto les enseñará a usar métodos para determinar características del calendario.

### Actividad 5: Comparación de Fechas
**Descripción:** Los estudiantes deben escribir un código que compare dos fechas diferentes y determine cuál es la más reciente. Esta actividad ayudará a entender los operadores relacionales en Python con objetos date.

### Actividad 6: Formateo de Fechas
**Descripción:** Se requiere que los estudiantes formatee una fecha dada en un formato específico (por ejemplo, "DD/MM/YYYY"). Esto les permitirá aprender cómo manipular la representación visual de las fechas.

### Actividad 7: Cálculo de Edad
**Descripción:** Los estudiantes deben crear un programa que calcule la edad basándose en una fecha de nacimiento proporcionada. Este ejercicio facilitará el uso del módulo `datetime` para cálculos temporales.

### Actividad 8: Eventos Futuros
**Descripción:** Los estudiantes tendrán que programar una lista de eventos con sus fechas correspondientes y determinar cuáles sucederán en los próximos meses. Esto les ayudará a manejar listas, bucles y condiciones lógicas.

### Actividad 9: Días Restantes
**Descripción:** Los estudiantes deben crear un programa que calcule el número de días restantes hasta una fecha futura dada. Esta actividad refuerza los conceptos de cálculo temporal con objetos date en Python.

### Actividad 10: Resumen Semanal
**Descripción:** Se les pide a los alumnos generar un resumen semanal que muestre todas las fechas y días correspondientes para una semana específica. Esto les permitirá combinar múltiples conceptos aprendidos sobre objetos date en un solo programa más complejo.


<a id="destruccion-de-objetos-y-liberacion-de-memoria"></a>
## Destrucción de objetos y liberación de memoria

### Introducción a los ejercicios

Esta carpeta contiene una serie de ejercicios diseñados para que comprendas cómo se manejan y eliminan objetos en Python, centrando la atención en la importancia de liberar memoria. Los ejercicios trabajan con conceptos como la creación de objetos, el acceso a sus propiedades y métodos, así como la gestión adecuada de su vida útil y eliminación para evitar fugas de memoria. Aunque algunos archivos contienen código incompleto o inadecuado relacionado con un problema de caballos en cuadras, el objetivo principal sigue siendo entender cómo funcionan los objetos en Python y cómo liberar memoria una vez que ya no se necesitan estos objetos.

### Nota importante

#### Explicación

Este fragmento de texto es una nota importante que se encuentra en un archivo markdown. La nota sirve como guía para el desarrollo de ejercicios relacionados con la utilización y gestión de objetos en programación, específicamente dentro del contexto de la subunidad "Destrucción de objetos y liberación de memoria". El objetivo no es crear nuevas clases personalizadas, sino trabajar con los objetos que ya están disponibles en el lenguaje de programación utilizado. La nota sugiere que al diseñar ejercicios para esta sección, se deben seguir las directrices especificadas en la carpeta 101-Ejercicios, asegurando así que los ejercicios estén alineados con los objetivos educativos establecidos. Es importante para garantizar que los estudiantes comprendan y puedan aplicar adecuadamente el concepto de cómo manejar la memoria cuando se trabaja con objetos existentes en un lenguaje de programación.

```markdown
Nota importante para la generación de ejercicios de esta subunidad:
Esta subunidad trata, no la creación de clases personalizadas, sino la utilización de objetos predeterminados existentes en el propio lenguaje de programación.
Para crear actividades, ajustate al alcance concreto de los ejercicios desarrollados en la carpeta 101-Ejercicios.
```

### destruccion de objetos

#### Explicación

Este código utiliza la biblioteca `datetime` de Python para trabajar con fechas. Primero, importa esta biblioteca bajo el alias `fechas`. Luego crea un objeto `date` llamado `hoy`, que representa la fecha del 11 de septiembre de 2025. El programa imprime esta fecha completa y también extrae e imprime sus componentes individuales: año, mes y día.

Además, el código calcula y muestra en qué día de la semana cae esa fecha usando dos métodos diferentes del objeto `date`: `weekday()` y `isoweekday()`. El método `weekday()` devuelve un número entre 0 y 6, donde 0 es lunes y 6 es domingo; mientras que `isoweekday()` funciona similarmente pero sigue la semana ISO con valores desde 1 (lunes) hasta 7 (domingo).

Lo más importante es lo que ocurre al final del código: se utiliza la instrucción `del hoy` para eliminar el objeto `hoy`. Esto hace que cualquier intento de acceder a las propiedades o métodos de `hoy`, como en la línea siguiente donde se imprime `hoy`, genere un error, ya que el objeto ha sido eliminado. Este es un ejemplo simple pero útil del concepto de "destrucción" de objetos y liberación de memoria en Python.

```python
import datetime as fechas

hoy = fechas.date(2025, 9, 11)
print(hoy)

print(hoy.year)
print(hoy.month)
print(hoy.day)

diadelasemana = hoy.weekday()
print(diadelasemana)
diadelasemana = hoy.isoweekday()
print(diadelasemana)

del hoy
print(hoy)
```

### caballos en la cuadra

#### Explicación

Este código es la descripción o docstring de un programa en Python llamado "Calculadora de cuadras", creado por Jose Vicente Carratalá en el año 2025. La función principal del programa es calcular el número de cuadras necesarias para alojar a cierto número de caballos. La descripción proporciona información básica sobre la versión del software (v0.1) y su autor, lo que ayuda a identificar fácilmente qué se trata el código y quién lo ha desarrollado. Esta documentación es importante porque facilita la comprensión rápida del propósito del programa para cualquier persona que quiera usar o modificar el código en un futuro.

```python
''' 
    Calculadora de cuadras
    v0.1 (c) 2025 Jose Vicente Carratalá
    Programa que calcula número de cuadras a partir de los caballos
'''
```

### propiedades

#### Explicación

Este fragmento de código es el comienzo de un programa en Python llamado "Calculadora de Cuadras". El propósito del programa es calcular cuántas cuadras (cabañas o instalaciones para caballos) se necesitan basándose en el número de caballos que hay. En la parte superior, se incluye una documentación corta que describe brevemente qué hace el programa y quién lo ha creado.

Las dos líneas finales del código inicializan dos variables: `caballos` y `cuadras`. Estas variables son esenciales porque van a almacenar los datos clave que el usuario introducirá o que el programa calculará. La variable `caballos` será usada para contar cuántos caballos hay, mientras que `cuadras` se utilizará para determinar cuántas instalaciones necesitamos basándonos en la cantidad de caballos proporcionada.

Este código es importante porque establece una base clara para el resto del programa, preparando variables esenciales y dando contexto sobre lo que va a hacer.

```python
''' 
    Calculadora de cuadras
    v0.1 (c) 2025 Jose Vicente Carratalá
    Programa que calcula número de cuadras a partir de los caballos
'''

# Datos de inicio
caballos = 0
cuadras = 0
```

### entrada calculo y salida

#### Explicación

Este programa es una simple calculadora que determina el número de cuadras necesarias para alojar un cierto número de caballos. En primer lugar, se inicializan dos variables: `caballos` y `cuadras`, ambas establecidas en cero. Luego, el programa solicita al usuario que introduzca la cantidad de caballos a través del teclado.

Una vez que el usuario ha proporcionado el número de caballos, el programa realiza un cálculo sencillo dividiendo el número de caballos por tres para determinar cuántas cuadras se necesitan (se asume que cada cuadra puede albergar a tres caballos). Finalmente, muestra en pantalla un mensaje que indica cuántos caballos se tienen y cuántas cuadras son necesarias basándose en la entrada proporcionada por el usuario.

Este tipo de programa es importante para entender cómo interactuar con el usuario (mediante `input`), realizar operaciones matemáticas básicas y presentar resultados de manera clara y comprensible.

```python
''' 
    Calculadora de cuadras
    v0.1 (c) 2025 Jose Vicente Carratalá
    Programa que calcula número de cuadras a partir de los caballos
'''

# Datos de inicio
caballos = 0
cuadras = 0

# Entrada de información
caballos = int(input("Introduce el número de caballos: "))

# Realización de cálculos
cuadras = caballos / 3

# Salida de resultados
print("Si tienes",caballos,"caballos")
print("Y te caben tres caballos por cuadra")
print("En ese caso necesitas",cuadras,"cuadras")
```

### libreria matematica

#### Explicación

Este código es una simple calculadora que determina el número de cuadras necesarias para alojar un cierto número de caballos, considerando la capacidad máxima por cuadra. El programa comienza importando la biblioteca `math` y se le da el alias `matematicas`. Luego, establece tres variables iniciales: `caballos`, `cuadras` y `caballos_por_cuadra`.

El usuario es solicitado a ingresar dos datos: primero, cuántos caballos por cuadra pueden alojarse, y segundo, el número total de caballos. Con estos datos, se calcula el número de cuadras necesarias dividiendo el total de caballos entre la capacidad por cuadra.

Es importante que si el resultado no es un número entero (por ejemplo, si quedan caballos sin alojar), el programa utiliza la función `ceil` de la biblioteca matemática para redondear hacia arriba. Esto asegura que se tenga en cuenta cualquier caballo adicional que quede sin espacio y necesita una cuadra completa.

Finalmente, el resultado es mostrado al usuario con un mensaje amigable que indica cuántos caballos hay y cuántas cuadras son necesarias para alojarlos. Este tipo de cálculo es útil en situaciones prácticas donde se necesita distribuir recursos (en este caso, caballos) de manera eficiente.

```python
''' 
    Calculadora de cuadras
    v0.1 (c) 2025 Jose Vicente Carratalá
    Programa que calcula número de cuadras a partir de los caballos
'''

import math as matematicas

# Datos de inicio
caballos = 0
cuadras = 0
caballos_por_cuadra = 0

# Entrada de información
caballos_por_cuadra = int(input("Introduce el número de caballos por cuadra: "))
caballos = int(input("Introduce el número de caballos: "))

# Realización de cálculos
cuadras = caballos / caballos_por_cuadra
redondeoalza = matematicas.ceil(cuadras)

# Salida de resultados
print("Si tienes",caballos,"caballos")
print("Y te caben tres caballos por cuadra")
print("En ese caso necesitas",redondeoalza,"cuadras")
```

### Actividades propuestas

### Actividad 1: Utilización de Objetos de Fecha y Tiempo
**Descripción:** Los estudiantes deben crear un programa que utilice objetos de fecha para calcular el día del año en que se encuentran. El objetivo es aprender a manipular fechas utilizando la librería `datetime`.

---

### Actividad 2: Gestión de Recursos en Programación
**Descripción:** Esta actividad implica la creación y eliminación controlada de objetos, similares al ejemplo mostrado en el archivo "008-destruccion de objetos.py". Los estudiantes aprenderán a gestionar adecuadamente los recursos de memoria.

---

### Actividad 3: Análisis del Código Externo
**Descripción:** Los alumnos deben analizar y comprender un código dado (como el mostrado en archivos "009-caballos en la cuadra.py", "010-propiedades.py") que presenta lógicas incompletas o errores. Se espera que puedan identificar problemas de sintaxis, lógica y estructura del programa.

---

### Actividad 4: Implementación Avanzada de Cálculos
**Descripción:** Basándose en el código proporcionado para calcular cuadras necesarias para caballos ("011-entrada calculo y salida.py"), los estudiantes deben implementar una versión mejorada que incluya la entrada de más variables, como por ejemplo diferentes tipos de animales con diferente número de espacios requeridos.

---

### Actividad 5: Introducción a Librerías de Matemáticas
**Descripción:** Los estudiantes deberán utilizar librerías matemáticas en Python para realizar cálculos complejos. A partir del archivo "012-libreria matematica.py", se deben implementar funcionalidades adicionales que utilicen funciones avanzadas.

---

### Actividad 6: Pruebas Unitarias
**Descripción:** Los estudiantes aprenderán a escribir pruebas unitarias para los programas de cálculo de cuadras (como en "011-entrada calculo y salida.py" y "012-libreria matematica.py"). Se evaluará la capacidad de diseñar tests que cubran diferentes escenarios.

---

### Actividad 7: Manejo Eficiente de Excepciones
**Descripción:** Los alumnos deben mejorar el manejo de errores en los programas existentes, haciendo uso de excepciones para controlar posibles fallos en la entrada del usuario. Se basará en ejemplos como "011-entrada calculo y salida.py".

---

### Actividad 8: Documentación del Código
**Descripción:** Los estudiantes deben escribir documentación para los programas existentes (como "012-libreria matematica.py") siguiendo buenas prácticas. Esto incluirá descripciones de las funciones, parámetros y devoluciones.

---

Estas actividades están diseñadas para reforzar los conocimientos adquiridos sobre la creación y gestión de objetos en Python, así como su integración con librerías estándar del lenguaje.


<a id="ejercicio-de-final-de-unidad-1"></a>
## Ejercicio de final de unidad

### Introducción a los ejercicios

Este conjunto de ejercicios en Python está diseñado para proporcionar una introducción completa a los fundamentos del lenguaje. Los problemas abordan aspectos básicos como la impresión de texto, el uso de variables y tipos de datos, así como operaciones más avanzadas como entrada de usuario, cálculos con operadores aritméticos y comparación de valores. También se incluyen ejemplos que ilustran cómo manejar errores comunes en la programación, como malas prácticas en el uso de identificadores y problemas de tipo de dato. A través de estos ejercicios, los estudiantes practicarán sus habilidades para escribir código limpio, eficiente y libre de errores, preparándolos para proyectos más complejos.

### Holamundo

#### Explicación

Este fragmento de código es muy sencillo pero muy importante para entender cómo funciona la programación en Python. La función `print()` se utiliza aquí para mostrar un mensaje en la pantalla, que en este caso es "Hola mundo desde Python". Este programa básico te muestra cómo imprimir texto en una consola o terminal cuando ejecutas el archivo de Python. Es una excelente manera de comenzar a familiarizarte con cualquier lenguaje de programación, ya que te ayuda a entender cómo interactuar con él y ver los resultados de tu código. Es como un saludo para probar si todo está configurado correctamente en tu entorno de desarrollo antes de empezar a crear programas más complejos.

```python
print("Hola mundo desde Python")
```

### variables

#### Explicación

Este fragmento de código es muy simple pero fundamental en la programación. Estás creando dos variables, `nombre` y `edad`, e inicializándolas con valores específicos. La variable `nombre` almacena un texto que representa el nombre de una persona, "Jose Vicente", entre comillas dobles porque se trata de un dato tipo cadena (string). Por otro lado, la variable `edad` almacena un número entero 47, lo cual es apropiado ya que la edad está representada por números.

Este código es importante porque muestra cómo almacenar y etiquetar información básica en una aplicación. Es el primer paso para construir programas más complejos donde las variables pueden contener datos importantes sobre personas o cualquier entidad relevante a tu proyecto.

```python
nombre = "Jose Vicente"
edad = 47
```

### salidas

#### Explicación

Este fragmento de código en Python muestra cómo imprimir información en la pantalla del usuario. En primer lugar, se crea una variable llamada `nombre` y se le asigna el valor `"Jose Vicente"`. Esto significa que la cadena de texto "Jose Vicente" está guardada bajo el nombre de la variable `nombre`.

Después, el código utiliza la función `print()` para mostrar un mensaje en pantalla. Dentro del paréntesis de la función `print()`, se especifica lo que queremos imprimir. En este caso, `"Mi nombre es"` y la variable `nombre` son los elementos que van a ser mostrados. Al poner una coma entre el texto y la variable, Python entiende que debe combinar ambos en un solo mensaje.

Esta técnica de usar variables junto con texto estático dentro del comando `print()` es muy útil porque nos permite personalizar las salidas según lo que contengan nuestras variables. En este ejemplo, aunque el nombre sea siempre "Jose Vicente", la estructura permite cambiar fácilmente el contenido de `nombre` para mostrar diferentes nombres sin tener que modificar todo el texto del mensaje.

```python
nombre = "Jose Vicente"
print("Mi nombre es",nombre)
```

### variar una variable

#### Explicación

Este código muestra cómo se pueden cambiar y utilizar variables en Python. En este caso, la variable `nombre` almacena un texto que representa el nombre de una persona. Al principio del programa, `nombre` contiene la cadena `"Jose Vicente"`. Luego, se imprime una frase que incluye el contenido actual de `nombre`, es decir, "Mi nombre es Jose Vicente".

Después, en una segunda línea de código, cambiamos el valor de `nombre` a `"Juan"` y volvemos a imprimir la misma frase. Esta vez, como el valor de `nombre` ha cambiado, se imprime "Mi nombre es Juan". Esto demuestra que las variables pueden ser modificadas durante la ejecución del programa y que sus valores actuales son usados en las instrucciones de impresión según sean utilizadas.

Es importante entender esto porque nos permite crear programas más dinámicos y flexibles. Podemos almacenar información en variables, manipular esa información (cambiar su valor) y luego usarla nuevamente para realizar tareas como mostrar mensajes o hacer cálculos.

```python
nombre = "Jose Vicente"
print("Mi nombre es",nombre)

nombre = "Juan"
print("Mi nombre es",nombre)
```

### identificadores permitidos

#### Explicación

Este código muestra ejemplos de cómo pueden llamarse variables en Python y cuáles son los nombres válidos y recomendados para ellas. En primer lugar, vemos que `nombre` y `nombre2` son dos variables correctas ya que solo contienen letras y no incluyen caracteres especiales o espacios. Luego, se comenta varias líneas como `# 2nombre = "Jose Vicente"` y `#nombre-completo = "Jose Vicente"`, indicando que no es válido usar números al principio de un nombre de variable ni guiones medios (`-`). También se señala con comentarios inalcanzables el uso de espacios en los nombres, lo cual tampoco es permitido. Finalmente, `nombreCompleto` es una variable válida pero poco convencional, ya que utiliza mayúsculas en medio del nombre (camel case), algo que aunque está permitido no se recomienda por ser menos común y potencialmente confuso para otros programadores.

Este código ilustra las reglas sobre la nomenclatura de variables en Python y es importante conocerlas para evitar errores y mantener el código legible y fácil de entender para otros desarrolladores.

```python
nombre = "Jose"
nombre2 = "Vicente"
# 2nombre = "Jose Vicente"
nombre_completo = "Jose Vicente"
#nombre-completo = "Jose Vicente"
#nombre completo = "Jose Vicente"
nombreCompleto = "Jose Vicente" # Es legal pero no se recomienda
```

### comentarios

#### Explicación

Este fragmento de código contiene ejemplos básicos de cómo se utilizan los comentarios en Python. Los comentarios son partes del código que no afectan a su funcionamiento pero sirven para explicar y documentar el código para otros programadores o para ti mismo en un futuro, cuando puedas haber olvidado detalles sobre tu propio código.

El primer ejemplo muestra cómo escribir un comentario de una sola línea. En Python, puedes iniciar un comentario con el símbolo `#`. Todo lo que vaya después del `#` hasta el final de la línea será ignorado por el intérprete de Python y no se ejecutará como parte del código.

El segundo ejemplo muestra cómo escribir un bloque de comentarios en múltiples líneas utilizando triples comillas simples (`'''`). Este tipo de comentario también es completamente ignorado por el intérprete. Es útil para documentar bloques grandes de código o explicaciones detalladas.

Es importante incluir comentarios adecuados y claros en tu código para mejorar su mantenibilidad y legibilidad, especialmente en proyectos colaborativos o cuando trabajas con programas complejos que necesiten ser revisados por otros desarrolladores más tarde.

```python
# Esto es un comentario de una única línea

'''
    Esto es un comentario
    Esto sigue siendo un comentario
    Y esto también lo es
'''
```

### Explicacion del codigo

#### Explicación

Este fragmento de código en Python establece una variable llamada `edad` y le asigna un valor numérico específico. La línea `edad = 47` indica que la palabra clave `edad` ahora representa el número 47. Aquí, `edad` es lo que se conoce como un identificador o nombre de variable, que actúa como una etiqueta para almacenar datos. El signo igual (`=`) en programación sirve como operador de asignación, es decir, toma el valor a la derecha del signo y lo guarda bajo el nombre (identificador) a la izquierda del signo. En este caso, `47` es un número literal, que simplemente es un número escrito directamente en el código sin ser una variable o otro tipo de dato más complejo. Este tipo de declaración es fundamental para almacenar y manipular datos en programas de Python.

```python
edad = 47
# edad es el identificador
# = es el operador de asignación
# 47 es el valor literal que se es está asignando al identificador
```

### Tipos de datos

#### Explicación

Este código es una introducción básica a los tipos de datos en Python, que son fundamentales para cualquier programa. En este caso, estás viendo cuatro variables diferentes que almacenan distintos tipos de información: un nombre (que es una cadena de texto), una edad (un número entero), una altura (un número decimal) y si la persona está viva o no (un valor booleano). Estos tipos de datos (cadena, entero, decimal y booleano) son muy comunes en programación porque permiten manejar todo tipo de información que puede necesitar un programa. Es importante entenderlos bien para poder trabajar con datos más complejos en el futuro.

```python
nombre = "Jose Vicente" # Cadena
edad = 47 # Entero
altura = 1.78 # Decimal
vivo = True # Booleano
```

### Entradas

#### Explicación

Este código solicita al usuario que ingrese su nombre y luego muestra ese nombre en la pantalla. Primero, la línea `nombre = input("Dime tu nombre: ")` crea una interacción con el usuario pidiendo que introduzca su nombre cuando se ejecute este fragmento de código. Todo lo que el usuario escriba será guardado en la variable llamada `nombre`. Luego, la línea `print("Tu nombre es: ", nombre)` muestra por pantalla un mensaje seguido del valor almacenado en la variable `nombre`, lo cual confirma al usuario que su entrada ha sido recibida y procesada correctamente. Este tipo de interacción básica entre el programa y el usuario es fundamental para muchas aplicaciones, ya que permite a los programas adaptarse dinámicamente a las entradas proporcionadas por el usuario.

```python
nombre = input("Dime tu nombre: ")
print("Tu nombre es: ",nombre)
```

### Entrada y problema

#### Explicación

Este código pide al usuario que introduzca su edad a través del teclado y luego muestra en pantalla el doble de esa edad. Primero, la línea `edad = input("Dime tu edad: ")` solicita que el usuario ingrese su edad cuando se ejecute el programa; esta entrada es almacenada en la variable `edad`. Luego, con la línea `print("El doble de tu edad es: "+edad)`, el programa imprime una frase que indica cuál sería el doble de la edad introducida. Sin embargo, hay un detalle importante: aunque el usuario introduce su edad como un número, en Python la función `input()` siempre recoge esa entrada como texto (o cadena de caracteres). Por eso, el código simplemente muestra el texto ingresado dos veces sin realizar ningún cálculo matemático para duplicar realmente la edad. Para hacer el cálculo correcto, es necesario convertir el dato ingresado a un número antes de multiplicarlo por 2.

```python
edad = input("Dime tu edad: ")
print("El doble de tu edad es: "+edad)
```

### Cambio de tipo de dato

#### Explicación

Este código te pide a ti, como usuario, que ingreses tu edad y luego realiza operaciones con esa información. Primero, el programa utiliza la función `input()` para solicitarte que ingreses tu edad cuando ejecutas el script. La respuesta se almacena en la variable `edad`. Es importante notar que lo que introduces a través de `input()` siempre es un texto (una cadena de caracteres), incluso si ingresas un número.

Luego, el programa convierte esa entrada del usuario, que inicialmente es una cadena de caracteres, a un número entero utilizando la función `int()`, y almacena ese nuevo valor en la variable `entero`. Esto es crucial porque permite realizar operaciones matemáticas con los datos introducidos.

Finalmente, el programa calcula el doble del número entero que obtuvo anteriormente (multiplicándolo por 2) y guarda este resultado en la variable `doble`. Sin embargo, hay un error al intentar imprimir `doble` usando la función `print()`, ya que estás tratando de concatenar una cadena con un número sin convertir el número primero a texto. Para corregir esto, deberías usar `str(doble)` para convertir `doble` en una cadena antes de combinarla con el mensaje.

Este código es importante porque muestra cómo pedir información al usuario y luego manipular esa información para realizar cálculos simples en Python.

```python
# Le pregunto al usuario por su edad
edad = input("Dime tu edad: ")
# Me aseguro de convertir la edad a un número entero
entero = int(edad)
# Calculo el doble de un número entero
doble = entero*2
# Saco el resultado por pantalla
print("El doble de tu edad es: "+doble)
```

### literales

#### Explicación

Este código Python define dos variables: `nombre` y `edad`. La variable `nombre` se inicializa con el valor `"Jose Vicente"`, que es un texto o cadena de caracteres. En contraste, la variable `edad` se inicializa con el número `47`, que es un valor numérico entero. Estos valores iniciales son llamados "literales", ya que representan directamente los datos que almacenarán las variables sin necesidad de generarlos mediante cálculos o funciones. Es importante entender cómo funcionan estos literales porque ellos nos permiten asignar fácilmente y rápidamente información básica a nuestras variables al empezar a trabajar con ellas en un programa.

```python
nombre = "Jose Vicente"
# Jose Vicente es el literal, y es de tipo cadena

edad = 47
# 47 es el literal, y es de tipo entero
```

### constantes

#### Explicación

Este código te enseña cómo se manejan las variables en Python, centrándose específicamente en la notación para constantes. Comienza definiendo una variable llamada `PI` y le asigna el valor de 3.1415, que es un aproximado del número pi. Luego imprime este valor usando la función `print`, mostrando que `PI vale 3.1415`. Después, vuelve a asignarle a `PI` el nuevo valor 4 y vuelve a imprimirlo, esta vez con el mensaje "PI vale 4". El código incluye un comentario que señala una convención de programación: es costumbre escribir las constantes en mayúsculas (como hizo al principio con PI) y las variables en minúsculas. Sin embargo, aunque usemos mayúsculas para sugerir que no debemos cambiar el valor de `PI`, Python permite cambiar el valor de una variable sin importar su formato.

Esta práctica es importante porque ayuda a otros programadores entender rápidamente tu código, lo cual facilita la colaboración y reduce errores. Aunque en este ejemplo cambiaste el valor de PI, en la mayoría de los casos, tratarías a `PI` como un valor constante que no cambia para evitar confusiones en cálculos matemáticos o físicos.

```python
PI = 3.1415

print("PI vale",PI)

PI = 4 # Le cambio el valor a PI

print("PI vale",PI)
# Las constantes deben formularse con mayúsculas
# Las variables deben formularse con minúsculas
```

### Diferencia

#### Explicación

Este código establece una variable llamada `PI` con un valor numérico, pero luego cambia su tipo de dato y su contenido. En primer lugar, se define `PI` como el número decimal 3.1416, que es una aproximación del número matemático π (pi). Sin embargo, inmediatamente después, la variable `PI` se redefine como una cadena de texto que contiene los caracteres "unnumero". Esto significa que al final, la variable `PI` no almacena el valor numérico 3.1416 sino la cadena de texto "unnumero".

Este ejemplo ilustra cómo en Python (y otros lenguajes de programación), puedes cambiar el tipo y el contenido de una variable a lo largo del código. Es importante estar atento a estos cambios, ya que pueden causar errores si no esperas que la variable cambie de tipo o valor en diferentes partes del programa.

```python

# La constante es PI
# El literal es 3.1416

PI = 3.1416

PI = "unnumero"
```

### operadores aritmeticos

#### Explicación

Este fragmento de código muestra ejemplos básicos del uso de operadores aritméticos en Python. Cada línea realiza una operación matemática diferente entre los números 4 y 3: suma, resta, multiplicación, división y módulo (resto de la división). Al ejecutar este código, se imprimirán cinco resultados consecutivos que muestran el resultado de cada operación. Esta práctica es útil para entender cómo funcionan estas operaciones básicas en programación, lo cual es fundamental para cualquier programa que requiera cálculos matemáticos.

```python
print(4+3)
print(4-3)
print(4*3)
print(4/3)
print(4%3)
```

### operadores de comparacion

#### Explicación

Este fragmento de código en Python está utilizando operadores de comparación para evaluar diferentes condiciones entre dos números y luego imprimir los resultados en la pantalla. Los operadores que se usan aquí son `<` (menor que), `<=` (menor o igual que), `>` (mayor que), `>=` (mayor o igual que), `==` (igual a) y `!=` (distinto de). En cada línea, el código compara el número 4 con el número 3 usando uno de estos operadores y luego imprime si la condición es verdadera (`True`) o falsa (`False`). Por ejemplo, cuando se evalúa `4 < 3`, como 4 no es menor que 3, el resultado es `False`. Estos operadores son fundamentales en programación ya que nos permiten tomar decisiones basadas en comparaciones entre valores.

```python
print(4 < 3)
print(4 <= 3)
print(4 > 3)
print(4 >= 3)
print(4 == 3)
print(4 != 3)
```

### operadores arimeticos abreviados

#### Explicación

Este código está trabajando con una variable llamada `edad` que inicialmente tiene un valor de 47. El objetivo es modificar el valor de esta variable usando diferentes operaciones aritméticas y mostrar cómo se pueden simplificar estas operaciones utilizando operadores abreviados.

Primero, suma dos unidades a la edad de dos maneras: primero usando la expresión tradicional `edad = edad + 2`, luego utilizando el operador abreviado `+=`. Estos dos métodos tienen el mismo resultado y ambos incrementan la variable `edad` en 2.

Luego, resta dos unidades de la edad con los mismos métodos: primero con `edad = edad - 2` y después con el operador abreviado `-=`. Esto disminuye la edad en 2 unidades nuevamente utilizando ambas formas.

Finalmente, se multiplica y divide la edad por 2 usando tanto las expresiones tradicionales como los operadores abreviados `*=`, `/=`. Estos operadores simplifican el código haciendo que las modificaciones sean más legibles y eficientes al mismo tiempo.

Este tipo de ejercicios es importante para entender cómo se pueden hacer cálculos matemáticos en Python de manera más concisa, lo cual mejora la eficiencia del código y su legibilidad.

```python
edad = 47
# Le quiero sumar dos unidades
edad = edad + 2
edad += 2
#Le quiero restar dos unidades
edad = edad - 2
edad -= 2
# Lo quiero multiplicar por dos
edad = edad * 2
edad *= 2
# Lo quiero dividir por dos
edad = edad / 2
edad /= 2
```

### operadores booleanos

#### Explicación

Este fragmento de código en Python utiliza operadores booleanos para evaluar y mostrar resultados lógicos. Los operadores `and` y `or` se utilizan para combinar diferentes condiciones o expresiones, que son comparaciones entre números en este caso.

Primero, el código imprime la evaluación de varias expresiones usando el operador `and`, que devuelve verdadero (`True`) solo si todas las condiciones son verdaderas. Por ejemplo, cuando se evalúa `4 == 4 and 3 == 3 and 2 == 2`, cada comparación individual es verdadera, por lo que la salida será `True`. Sin embargo, en la segunda línea con `2 == 1` siendo falsa, el resultado completo será `False`.

Luego, se usa el operador `or`, que devuelve verdadero (`True`) si al menos una de las condiciones es verdadera. Por ejemplo, en la expresión `4 == 4 or 3 == 3 or 2 == 1`, aunque `2 == 1` sea falsa, el resultado total será `True` porque las otras dos comparaciones son ciertas.

Este tipo de operadores booleanos (`and`, `or`) es crucial en la programación para tomar decisiones basadas en múltiples condiciones y crear lógica compleja. Son fundamentales para controlar el flujo del programa según diferentes situaciones, lo que te permitirá hacer aplicaciones más dinámicas e interactivas.

```python
print(4 == 4 and 3 == 3 and 2 == 2)
print(4 == 4 and 3 == 3 and 2 == 1)

print(4 == 4 or 3 == 3 or 2 == 1)
print(4 == 4 or 3 == 2 or 2 == 1)
print(4 == 3 or 3 == 2 or 2 == 1)
```

### Ejercicio1-Calculadora de impuestos

#### Explicación

Este fragmento de código es la cabecera o encabezado de un archivo Python que contiene una sencilla aplicación llamada "Calculadora de Impuestos". La función principal del programa es pedir al usuario que introduzca el importe base (sin impuestos) y luego calcular tanto el IVA como el total a pagar incluyendo el impuesto. En la cabecera se proporcionan detalles importantes como la versión del código (`v0.1`), el autor (`Jose Vicente Carratalá`) y una breve descripción de cómo funciona la aplicación.

Esta práctica es fundamental para organizar bien el código, ya que facilita entender su propósito inmediatamente sin tener que revisar toda la lógica interna del programa. Además, ayuda a mantener un registro claro de las versiones y contribuidores del proyecto, lo cual es especialmente útil en proyectos colaborativos o cuando se trabaja en grandes aplicaciones.

```python
'''
    Calculadora de Impuestos
    v0.1 por Jose Vicente Carratalá
    Funcionamiento: Introduce una base imponible y se calcula IVA y total
'''
```

### Calculadora

#### Explicación

Este fragmento de código es el comienzo de un programa sencillo en Python que sirve como una calculadora para calcular impuestos. El programa permite al usuario ingresar el monto de la base imponible (el precio antes del impuesto) y luego realiza cálculos relacionados con el IVA y el total a pagar.

El código comienza creando tres variables: `base_imponible`, `total_iva` y `total_factura`. Estas variables serán usadas para almacenar los valores que se obtendrán durante la ejecución del programa. Posteriormente, utiliza una función llamada `input()` para solicitar al usuario que ingrese el valor de la base imponible a través del teclado.

Es importante notar que este fragmento es solo el inicio del programa y no incluye las partes donde se calcularían realmente el IVA y el total. Sin estas secciones, el código no realiza los cálculos necesarios para completar su propósito principal.

```python
'''
    Calculadora de Impuestos
    v0.1 por Jose Vicente Carratalá
    Funcionamiento: Introduce una base imponible y se calcula IVA y total
'''

# Este programa no tiene importaciones

# Creo variables
base_imponible = 0
total_iva = 0
total_factura = 0

# Aquí pondría las funciones/clases

# Ahora calculamos
base_imponible = input("Introduce la base imponible de la factura: ")
```

### Calculadora

#### Explicación

Este código es un programa sencillo en Python que ayuda a calcular impuestos, específicamente el IVA (Impuesto sobre Valor Añadido) basándose en una base imponible proporcionada por el usuario. El programa comienza mostrando información acerca del autor y la versión del programa. Luego, solicita al usuario que ingrese la base imponible de la factura.

El código define tres variables: `base_imponible`, `total_iva` y `total_factura`. Estas variables almacenarán los valores correspondientes a la base imponible, el IVA calculado y el total de la factura respectivamente. En este fragmento inicial del programa, solo se ha definido la variable `base_imponible` con un valor inicial de 0.

Después, el programa imprime una serie de mensajes para proporcionar contexto al usuario sobre qué hacer a continuación: introducir una base imponible. Utiliza la función `input()` para capturar la entrada del usuario y almacenarla en la variable `base_imponible`. 

Es importante notar que este bloque es solo el inicio del programa, donde se establecen las bases para realizar cálculos posteriores (como calcular el IVA y sumarlo a la base imponible para obtener el total de la factura). La lógica completa para estos cálculos aún no está implementada en esta parte del código.

```python
'''
    Calculadora de Impuestos
    v0.1 por Jose Vicente Carratalá
    Funcionamiento: Introduce una base imponible y se calcula IVA y total
'''

# Este programa no tiene importaciones

# Creo variables
base_imponible = 0
total_iva = 0
total_factura = 0

# Aquí pondría las funciones/clases

# Ahora calculamos
print("Programa calculadora de impuestos")
print("(c) 2025 Jose Vicente Carratalá")
print("Introduce una base y te calculo el IVA y el total")
base_imponible = input("Introduce la base imponible de la factura: ")
```

### Calculo de IVA

#### Explicación

Este programa en Python es una sencilla calculadora de impuestos que te ayuda a calcular el IVA y el total de una factura basada en la base imponible introducida por el usuario. Comienza solicitando al usuario que ingrese la base imponible, almacenándola en la variable `base_imponible`. Luego, realiza los cálculos necesarios: multiplica la base imponible por 0.21 para obtener el IVA (asumiendo una tasa del 21%) y suma este valor al total de la factura.

Finalmente, muestra en pantalla tanto el importe del IVA como el total de la factura. Este tipo de programa es útil porque simplifica el proceso de cálculo fiscal, permitiendo a usuarios o empresas calcular rápidamente los montos fiscales necesarios sin tener que hacer cálculos manuales, garantizando así precisión y rapidez en las operaciones financieras diarias.

```python
'''
    Calculadora de Impuestos
    v0.1 por Jose Vicente Carratalá
    Funcionamiento: Introduce una base imponible y se calcula IVA y total
'''

# Este programa no tiene importaciones

# Creo variables
base_imponible = 0
total_iva = 0
total_factura = 0

# Aquí pondría las funciones/clases

# Ahora calculamos

# Primero pido una entrada
print("Programa calculadora de impuestos")
print("(c) 2025 Jose Vicente Carratalá")
print("Introduce una base y te calculo el IVA y el total")
base_imponible = float(input("Introduce la base imponible de la factura: "))

# Luego realizo cálculos
total_iva = base_imponible*0.21
total_factura = base_imponible + total_iva

# Por último expreso una salida
print("El IVA de la factura es: ",total_iva)
print("El total de la factura es: ",total_factura)
```

### Actividades propuestas

### Actividades Propuestas para Estudiantes de Formación Profesional en Programación

1. **Introducción a Variables**
   - *Descripción:* Los estudiantes deberán crear una aplicación sencilla que solicite al usuario su nombre y edad, e imprima ambos datos por pantalla.
   - *Objetivo:* Aprender a declarar variables y utilizar funciones de entrada/salida en Python.

2. **Uso de Tipos de Datos**
   - *Descripción:* Los alumnos deben escribir un programa que pida al usuario su nombre, edad (como número entero) y altura (como número decimal), e imprima esta información.
   - *Objetivo:* Familiarizarse con diferentes tipos de datos en Python.

3. **Manejo de Entradas y Salidas**
   - *Descripción:* Se les pide que escriban un programa que solicite al usuario su edad, calcule el doble de esa edad y muestre el resultado.
   - *Objetivo:* Aprender a convertir tipos de datos (de cadena a entero) y realizar operaciones aritméticas.

4. **Operadores Lógicos**
   - *Descripción:* Crear un programa que utilice operadores lógicos (and, or) para comprobar si una edad es mayor o menor a ciertos valores.
   - *Objetivo:* Entender y aplicar operaciones booleanas en condiciones.

5. **Operadores Aritméticos**
   - *Descripción:* Diseñar un programa que permita al usuario ingresar dos números, luego realizar las cuatro operaciones básicas (+, -, *, /) e imprimir los resultados.
   - *Objetivo:* Practicar con diferentes tipos de operadores aritméticos.

6. **Cálculo de IVA**
   - *Descripción:* Elaborar una calculadora que calcule el IVA (21%) y el total de una factura basada en la base imponible ingresada por el usuario.
   - *Objetivo:* Aprender a realizar cálculos complejos e imprimir resultados formateados.

7. **Manejo de Errores**
   - *Descripción:* Crear un programa que solicite al usuario ingresar su edad como cadena, convierta esta entrada a número entero y maneje cualquier excepción que pueda surgir.
   - *Objetivo:* Aprender a trabajar con tipos de datos, conversiones y gestión de errores básicos.

8. **Entrada/Salida Mejorada**
   - *Descripción:* Diseñar un programa que presente una interfaz básica (como encabezado), solicite al usuario la base imponible e imprima el IVA y total.
   - *Objetivo:* Aprender a mejorar las salidas por pantalla para proporcionar información más estructurada.

9. **Uso de Comentarios**
   - *Descripción:* Los estudiantes deben escribir un pequeño programa que incluya múltiples comentarios explicando cada línea o bloque de código.
   - *Objetivo:* Aprender a documentar el código y añadir comentarios para mejorar la legibilidad y mantenimiento.

10. **Ejercicio Final: Calculadora Completa**
    - *Descripción:* Crear una calculadora que permita al usuario seleccionar diferentes operaciones (IVA, suma, resta, etc.), realizar cálculos según la opción elegida y mostrar resultados.
    - *Objetivo:* Integrar conocimientos de variables, entrada/salida, conversiones y operadores en un programa más complejo.



<a id="uso-de-estructuras-de-control"></a>
# Uso de estructuras de control

<a id="estructuras-de-seleccion"></a>
## Estructuras de selección

### Introducción a los ejercicios

En esta carpeta, encontrarás una serie de ejercicios que te ayudarán a comprender cómo usar estructuras de selección en Python para controlar el flujo del programa basado en condiciones. Los ejercicios abordan desde condicionales simples con `if` hasta casos más complejos que incluyen múltiples condiciones utilizando `elif` y anidación de estructuras `if`. Estos ejemplos te permitirán practicar la clasificación de datos según diferentes rangos y criterios, lo cual es fundamental en programación.

### Condicional

#### Explicación

Este fragmento de código está utilizando una estructura de control llamada condicional (o en inglés, "conditional") para determinar qué acción tomar basándose en la evaluación de una expresión lógica. En este caso, se declara una variable llamada `edad` y le asigna el valor 47. Luego, el código utiliza la estructura `if` seguida por la condición `edad < 30`, lo que significa "si la edad es menor a 30". Si esta condición es verdadera (es decir, si `edad` es efectivamente menor que 30), entonces se ejecuta el bloque de código dentro del `if`, que en este caso es imprimir la frase "Eres un joven" en pantalla. Sin embargo, dado que la edad asignada es 47, esta condición no será verdadera y por tanto, nada más se imprimirá.

Esta estructura es importante porque permite al programa tomar decisiones basadas en diferentes situaciones o condiciones. En el contexto de este ejemplo, ayuda a categorizar a las personas como "jóvenes" si su edad cumple con la condición establecida.

```python
# El código solo se ejecuta si la expresión es verdadera
edad = 47

if edad < 30:
  print("Eres un joven")
```

### else

#### Explicación

Este fragmento de código en Python está utilizando una estructura de control llamada `if-else` para tomar decisiones basadas en ciertas condiciones. En este caso, la condición es si la variable `edad`, que tiene el valor 47, es menor a 30 o no.

El programa comienza preguntándose si `edad` es menor a 30. Si la respuesta es sí (lo cual no es el caso en este ejemplo ya que `edad` es 47), entonces se imprimiría "Eres un joven". Sin embargo, dado que la condición no se cumple, el programa sigue con la parte del `else`, lo que significa que ejecuta el código dentro de ese bloque. Aquí imprime "Ya no eres un joven".

Esta estructura es muy útil en la programación porque permite a los programas tomar decisiones inteligentes basándose en diferentes situaciones o datos proporcionados, permitiendo así una interacción más dinámica y personalizada con el usuario. En este ejemplo simple, se clasifica a las personas como jóvenes o no年轻人，请问你想继续我们的对话吗？还是需要将上面的答复转换为与代码解释相关的问题的其他语言版本？如果需要翻译或其他帮助，请告诉我。

```python
# El código solo se ejecuta si la expresión es verdadera
edad = 47

if edad < 30:
  print("Eres un joven")
else:
  print("Ya no eres un joven")
```

### varios if

#### Explicación

Este fragmento de código está utilizando estructuras de control llamadas "condicionales" en Python. Específicamente, se usan dos instrucciones `if` para comprobar la edad de una persona y mostrar un mensaje diferente dependiendo del resultado de las comparaciones. En este caso, si la variable `edad`, que ha sido asignada con el valor 47, es menor que 30, entonces imprime "Eres un joven". Si la condición no se cumple (es decir, si `edad` es mayor que 30), se ejecuta otra instrucción `if` que verifica si es mayor que 30 y en ese caso muestra el mensaje "Ya no eres un joven". Este código demuestra cómo las estructuras de control permiten al programa tomar decisiones basadas en condiciones específicas, lo cual es fundamental para la lógica en la programación.

```python
# El código solo se ejecuta si la expresión es verdadera
edad = 47

if edad < 30:
  print("Eres un joven")
  
if edad > 30:
  print("Ya no eres un joven")
```

### varios if

#### Explicación

Este código en Python utiliza estructuras de control llamadas "if" para determinar a qué grupo de edad pertenece una persona basándose en su número de años. La variable `edad` se inicializa con el valor 47, lo que significa que la persona tiene 47 años. Luego, el código revisa esta variable mediante diferentes condiciones:

- Si la edad es menor que 10, imprime "Eres un niño".
- Si la edad está entre 10 y 20 (incluyendo 10 pero no incluyendo 20), imprime "Eres un adolescente".
- Si la edad está entre 20 y 30 (incluyendo 20 pero no incluyendo 30), imprime "Eres un joven".

Si ninguna de estas condiciones se cumple, es decir, si la persona tiene más de 30 años, el código ejecuta la última parte con `else` e imprime "Ya no eres un joven". Esta estructura permite categorizar a una persona en diferentes grupos de edad basándose en su año de nacimiento. Es importante porque ayuda a entender cómo se utilizan las condiciones para tomar decisiones y controlar el flujo del programa según los datos proporcionados.

```python
# El código solo se ejecuta si la expresión es verdadera
edad = 47

if edad < 10:
  print("Eres un niño")
else if edad >= 10 and edad < 20:
  print("Eres un adolescente)
else if edad >= 20 and edad < 30:
  print("Eres un joven")
else:
  print("Ya no eres un joven")
```

### particula elif

#### Explicación

Este código en Python utiliza estructuras de control para imprimir diferentes mensajes dependiendo de la edad que se le asigna a una variable llamada `edad`. En este caso, `edad` es igual a 47. El programa comienza con una estructura `if`, seguida por varias cláusulas `elif` (que significa "else if", o en español, "sino si") y finalmente un bloque `else`.

Primero, el código verifica si la edad es menor que 10 años; si esto es cierto, imprimiría "Eres un niño". Si no lo es, pasa a revisar la siguiente condición dentro del primer `elif`, que mira si la edad está entre 10 y 20 (ambos inclusive), imprimiendo en ese caso "Eres un adolescente". Luego, el segundo bloque `elif` comprueba si la edad está entre 20 y 30 años; si es así, imprime "Eres un joven".

Si ninguna de las condiciones anteriores se cumplen (es decir, si la edad es igual o mayor a 30), el programa llega al bloque `else`, que simplemente indica "Ya no eres un joven". Esta estructura permite categorizar etapas de vida según una variable numérica y es útil para realizar diferentes acciones dependiendo del valor específico de esa variable.

```python
# El código solo se ejecuta si la expresión es verdadera
edad = 47

if edad < 10:
  print("Eres un niño")
elif edad >= 10 and edad < 20:
  print("Eres un adolescente")
elif edad >= 20 and edad < 30:
  print("Eres un joven")
else:
  print("Ya no eres un joven")
```

### anidacion

#### Explicación

Este código en Python utiliza estructuras de control anidadas para imprimir mensajes diferentes basados en la variable `edad`. La función principal es clasificar a una persona según su edad, dividiendo las posibles edades en varios grupos. 

El programa comienza preguntando si `edad` es menor que 30 años. Si lo es, entra en el primer bloque de código anidado para determinar si la persona tiene menos de 20 años. En ese caso, imprime "Eres muuuuy joven". De lo contrario, si la edad está entre 20 y 29 años (inclusive), imprime "eres un joven".

Si inicialmente `edad` es 30 o más, el programa sigue con otro bloque condicional para verificar si la persona tiene menos de 40 años. Si cumple esta condición, se imprime "Eres bastante poco joven". En caso contrario, es decir, si la edad es igual o mayor a 40 años, muestra el mensaje "Ya no eres joven".

Esta estructura anidada permite clasificar con precisión a una persona en diferentes grupos de edad y es importante para entender cómo los condicionales pueden ser utilizados en cascada para manejar múltiples casos.

```python
# Esto no hay que hacerlo

edad = 47

if edad < 30:
  if edad < 20:
    print("Eres muuuuy joven")
  else:
    print("eres un joven")
else:
  if edad < 40:
    print("Eres bastante poco joven")
  else:
    print("Ya no eres joven")
```

### Ejercicio en clase

#### Explicación

Este código Python clasifica las categorías de baloncesto según la edad del jugador. La función principal comienza solicitando al usuario que introduzca su edad, almacenándola inicialmente como una cadena (texto) y luego convirtiéndola a un número entero para poder compararla con diferentes rangos.

El programa utiliza estructuras condicionales `if` y `elif` (que significa "else if") para determinar la categoría correspondiente al valor de la edad. Por ejemplo, si el jugador tiene menos de 8 años, se clasifica en la categoría "pre-mini". Cada rango de edad tiene su propia categoría asociada.

Además, después de asignar la categoría principal basada en la edad, el programa también verifica si el jugador tiene más de 40 años y, en ese caso, imprime un mensaje adicional indicando que es un veterano con experiencia. Esto añade una capa extra para reconocer a los jugadores experimentados.

Este tipo de programación es útil en entornos deportivos donde las categorías pueden variar según la edad del participante y permite automatizar el proceso de clasificación, facilitando así la gestión de competiciones o equipos.

```python
# Docstring
''' 
  Programa clasificador de baloncesto
  v0.1 Jose Vicente Carratala
  Este programa clasifica categorías por edades
'''

# Importaciones
# Este programa no requiere importaciones

# Declaración de variables globales
# Inicializamos las variables con valores vacíos

edad = 0
categoria = ""

# Funciones/clases
# En este programa no hay funciones o clases

# Función principal

edad = input("Introduce tu edad: ")
edad = int(edad) # Convierto la edad en un entero
if edad < 8:
  categoria = "pre-mini"
elif edad >= 8 and edad <= 11:
  categoria = "mini"
elif edad >= 12 and edad <=15:
  categoria = "infantil"
elif edad >= 16 and edad <=17:
  categoria = "cadete"
elif edad >= 18 and edad <=20:
  categoria = "junior"
else:
  categoria = "senior"
  
print("Tu edad es de",edad,"años y tu categoría es: ",categoria)  

if edad > 40:
  print("Veterano con experiencia en la cancha")
  
  
  
  
  
```

### Actividades propuestas

1. **Clasificación por Edad**
   - Descripción: Los estudiantes deben crear un programa que clasifique a una persona como "joven", "adulto" o "mayor" dependiendo de su edad. El objetivo es familiarizarse con el uso básico del condicional `if`.

2. **Jugando con Edades**
   - Descripción: Se pide escribir un programa que determine si una persona es menor, adulta o mayor según la edad ingresada por el usuario. Este ejercicio ayuda a entender los conceptos de lógica y comparación en Python.

3. **Clasificador de Estudiantes**
   - Descripción: Los alumnos deben desarrollar un programa que clasifique estudiantes basándose en su nivel académico (por ejemplo, primer año, segundo año, etc.). El ejercicio incluye el uso de múltiples condiciones `if`.

4. **Etapa Vital según Edad**
   - Descripción: Se requiere crear un programa que identifique la etapa vital del usuario basándose en su edad (niño, adolescente, adulto joven, adulto mayor). Esto enseña a los estudiantes a usar condicionales anidados y `elif`.

5. **Clasificador de Baloncesto**
   - Descripción: Los estudiantes deben replicar el programa proporcionado que clasifica jugadores de baloncesto según su edad en diferentes categorías (pre-mini, mini, infantil, etc.). Este ejercicio fomenta la comprensión del uso de múltiples condiciones anidadas.

6. **Determinación de Grupos**
   - Descripción: Los alumnos deben programar un sistema que clasifique a las personas en grupos según su puntaje en una prueba (por ejemplo, bajo rendimiento, rendimiento normal, alto rendimiento). Esto ayuda a entender el uso del condicional anidado y la importancia de los rangos.

7. **Controlador de Acceso**
   - Descripción: Los estudiantes deben crear un sistema simple que controle el acceso a una plataforma basándose en roles (por ejemplo, administrador, usuario normal). Este ejercicio ayuda a entender cómo las estructuras condicionales pueden ser utilizadas para controlar flujos de ejecución basados en diferentes condiciones.

8. **Recomendaciones por Edad**
   - Descripción: Los alumnos deben desarrollar un programa que recomiende actividades según la edad del usuario (por ejemplo, deportes para niños, estudios para adultos jóvenes). Este ejercicio permite a los estudiantes aplicar múltiples `if` y condiciones lógicas en sus programas.

9. **Determinación de Horario**
   - Descripción: Los estudiantes deben crear un programa que determine el horario adecuado para diferentes actividades (por ejemplo, hora de estudio, descanso). Este ejercicio ayuda a familiarizar con la anidación de condicionales y cómo se pueden usar en situaciones del mundo real.

10. **Clasificador de Riesgos**
    - Descripción: Los alumnos deben desarrollar un programa que clasifique proyectos según su nivel de riesgo (bajo, medio, alto). Esto ayuda a entender el uso de condiciones anidadas y la importancia de manejar múltiples casos con eficacia.


<a id="estructuras-de-repeticion"></a>
## Estructuras de repetición

### Introducción a los ejercicios

En esta carpeta encontrarás una serie de ejercicios que te ayudarán a comprender y practicar el uso de estructuras de repetición en Python, como los bucles `for` y `while`. Los ejercicios abordan desde la simple iteración sobre rangos numéricos hasta la anidación compleja de bucles para simular procesos más elaborados. Practicarás cómo contar días del mes utilizando diferentes métodos (eficientes e ineficientes), cómo manejar múltiples niveles de anidación en los bucles y cómo incrementar contadores dentro de un bucle `while`. También aprenderás a resolver problemas prácticos, como el conteo de patitos de goma producidos en una fábrica a lo largo del tiempo. Estos ejercicios te prepararán para la resolución de problemas que involucran secuencias temporales y conteos acumulativos en situaciones realistas.

### saltos

#### Explicación

Este código es una pequeña parte de un programa en Python que cuenta y muestra números pares desde 0 hasta menos de 100. La estructura principal utilizada aquí es el bucle `for`, que se utiliza para iterar a través de una secuencia específica. En este caso, la secuencia es generada por la función `range(0, 100, 2)`. Esta función crea una lista de números que comienza en 0 y termina antes de llegar a 100 (es decir, llegará hasta el número 98), saltando de dos en dos para solo incluir los números pares.

Dentro del bucle `for`, la sentencia `print(pares)` imprime cada número par generado por la función `range` en el terminal o consola. Esto resulta en una lista numérica de todos los números pares desde 0 hasta 98, lo cual puede ser útil para entender cómo funcionan las estructuras de control y cómo generar secuencias específicas de números en Python.

```python
# Cuento los días del mes
for pares in range(0,100,2):
  print(pares)
```

### ineficiente

#### Explicación

Este código muestra una forma muy básica de contar los días del mes, pero está escrito de manera ineficiente. Cada día se imprime en una línea diferente utilizando un comando `print`. Esto significa que si quieres cambiar algo como la frase o el número del día, tendrás que modificar muchas líneas individuales. Imagina tener que escribir esto para todo un año con 365 días; sería muy tedioso y propenso a errores.

El objetivo es simplemente imprimir una serie de frases que dicen cuál día del mes es, pero hay formas más prácticas y rápidas de hacerlo usando bucles o estructuras de repetición en lugar de escribir cada línea por separado. Esto no solo hace el código más corto y fácil de leer, sino también mucho más sencillo de mantener y modificar si fuera necesario cambiar algo en las frases o los números del día.

Es importante entender este ejemplo porque muestra claramente cómo la programación puede simplificar tareas repetitivas y cómo pensar en soluciones más eficientes es una parte crucial al aprender a codificar.

```python
# Cuento los días del mes
print("Hoy es el dia 1 del mes")
print("Hoy es el dia 2 del mes")
print("Hoy es el dia 3 del mes")
print("Hoy es el dia 4 del mes")
print("Hoy es el dia 5 del mes")
# ...
```

### estructura for

#### Explicación

Este código muestra cómo se utiliza un bucle `for` en Python para contar los días de un mes. El bucle recorre una secuencia generada por la función `range`, que va desde el día 1 hasta el día 30 (el límite superior no es inclusivo, por lo que el 31 no se incluye). En cada iteración del bucle, la variable `dia` toma el valor siguiente en esta secuencia. Luego, se imprime un mensaje indicando cuál es el número de día actual.

Este tipo de estructura es importante porque permite automatizar tareas que implican hacer algo repetidamente a lo largo de una serie numérica, como contar días, meses o años. En este caso específico, ayuda a simular la cuenta regresiva o progresiva de los días en un mes sin tener que escribir cada línea de código manualmente para cada día.

```python
# Cuento los días del mes
for dia in range(1,31):
  print("Hoy es el dia ",dia,"del mes")
```

### anidacion

#### Explicación

Este código Python muestra un ejemplo sencillo de cómo anidar estructuras de repetición para iterar sobre dos conjuntos diferentes de datos. En este caso específico, se está recorriendo cada día del año a través de los meses y días. Primero, el programa usa un bucle `for` para iterar sobre cada mes del año (del 1 al 12). Para cada uno de estos meses, hay otro bucle `for` que itera sobre los días (del 1 al 30), aunque este rango es demasiado amplio y en realidad deberías ajustarlo para meses con menos de 31 días. El programa simplemente imprime una frase indicando qué día del mes actual está considerando.

Esta técnica de anidar bucles (`for` dentro de otro `for`) es muy útil cuando necesitas trabajar con datos que tienen dos dimensiones o niveles, como los días y meses en este ejemplo. Es importante tener cuidado al usar estructuras anidadas para asegurarte de que tus rangos de iteración sean correctos para evitar errores o resultados inesperados.

Aunque el código presenta un rango de días demasiado amplio (de 1 a 30 debería ser ajustado), es una buena manera de visualizar cómo funciona la estructura anidada y cómo puedes controlar dos dimensiones con solo unas pocas líneas de código.

```python
# Cuento los días del mes
for mes in range(1,13):
  for dia in range(1,31):
    print("Hoy es el dia ",dia,"del mes",mes)
```

### mas anidacion

#### Explicación

Este código muestra cómo se utiliza un conjunto de bucles anidados para imprimir la fecha (día, mes y año) en cada iteración. Comienza con un bucle `for` que itera a través de los años desde 1978 hasta 2025 (el rango en Python no incluye el último número indicado). Dentro de este bucle anual, hay otro bucle `for` que recorre todos los meses del año, del mes 1 al mes 12. Finalmente, dentro del segundo bucle, se encuentra un tercer bucle `for` que itera a través de los días desde el día 1 hasta el día 30. Aunque este último bucle no tiene en cuenta los meses con menos de 31 días (febrero, por ejemplo), la idea es ilustrar cómo imprimir cada combinación posible de día, mes y año dentro del rango especificado.

Este tipo de estructura anidada es importante porque permite realizar tareas que requieren múltiples niveles de iteración. En este caso, el código genera todas las fechas posibles en un formato simple ("Hoy es el día X del mes Y del año Z") para cada combinación de días, meses y años dentro del rango dado. Esto puede ser útil para varias aplicaciones, como simular eventos que ocurren diariamente sobre largos períodos de tiempo o verificar algún tipo de lógica que se aplica a fechas específicas.

```python
# Cuento los días del mes
for anio in range(1978,2026):
  for mes in range(1,13):
    for dia in range(1,31):
      print("Hoy es el dia ",dia,"del mes",mes,"del año",anio)
```

### ahora los impares

#### Explicación

Este código es una pequeña secuencia de Python que utiliza un bucle `for` para imprimir todos los números impares desde 1 hasta 99. La función `range()` se usa aquí con tres argumentos: el número inicial (1), el número final no incluido (100) y la cantidad a incrementar en cada paso (2). Esto significa que comienza en 1, salta de dos en dos, imprimiendo solo los números impares. El bucle `for` recorre todos estos valores uno por uno, utilizando la variable `pares`, aunque técnicamente debería ser llamada `impares` para mejor claridad, y simplemente imprime cada número en pantalla.

Este tipo de código es importante porque te enseña a utilizar estructuras de control como el bucle `for` junto con funciones como `range()`, que son fundamentales en programación para realizar tareas repetitivas de manera eficiente.

```python
# Cuento los días del mes
for pares in range(1,100,2):
  print(pares)
```

### while

#### Explicación

Este código muestra cómo utilizar un bucle `while` en Python para realizar una acción repetidamente hasta que se cumple una condición. En este caso, la variable `dia` comienza con el valor 1 y el programa imprimirá "hoy es el dia X del mes" mientras `dia` sea menor a 31. Después de cada iteración (cada vez que imprime), el valor de `dia` no se actualiza en este código, por lo que el bucle terminará cuando la condición `dia < 31` ya no se cumpla.

Es importante notar que para que este bucle funcione correctamente y se detenga cuando debería (por ejemplo, si llega al día 31), tendría que haber una línea adicional dentro del bucle para incrementar el valor de `dia`, por ejemplo: `dia = dia + 1` o más concisamente, `dia += 1`. Sin esta línea, el bucle se convertiría en un ciclo infinito porque nunca cambia la variable `dia`.

Este tipo de estructura es útil cuando no sabes cuántas veces necesitarás repetir una acción y depende de condiciones que puedan cambiar durante la ejecución del programa. En este caso simple, ayuda a entender cómo se puede automatizar el conteo o registro diario en un mes sin tener que escribir todas las impresiones por separado para cada día.

```python
dia = 1

while dia < 31:
  print("hoy es el dia",dia,"del mes")
```

### incremento

#### Explicación

Este fragmento de código utiliza un bucle `while` para imprimir una frase que indica en qué día del mes nos encontramos, desde el primer día hasta el trigésimo. La variable `dia` comienza con el valor 1 y se incrementa en uno cada vez que se vuelve a ejecutar el bucle. Esto significa que primero imprime "hoy es el dia 1 del mes", luego "hoy es el dia 2 del mes" y así sucesivamente hasta llegar al día 30, momento en el cual la condición `dia < 31` ya no se cumple y finaliza el bucle. Este tipo de estructura es importante porque permite realizar tareas repetitivas con un número específico de iteraciones sin tener que escribir cada una manualmente.

La línea `dia += 1` es una forma abreviada de incrementar la variable `dia`. En lugar de escribir `dia = dia + 1`, simplemente se usa el operador `+=`, lo cual hace que el código sea más corto y legible.

```python
dia = 1

while dia < 31:
  print("hoy es el dia",dia,"del mes")
  dia += 1  # dia = dia + 1
```

### Ejercicio propuesto patitos

#### Explicación

Este código es una descripción detallada de un ejercicio que te pide escribir un programa en Python. El objetivo del programa es contar cuántos patitos de goma se producen cada día en una fábrica a lo largo de varios años, meses y días específicos. Para hacer esto, usarás bucles `for` para recorrer cada año desde el 2000 hasta el 2025, luego dentro de cada año, los meses van del 1 al 12, y finalmente, dentro de cada mes, los días van del 1 al 30. En cada día se supone que se fabrican exactamente 10 patitos de goma.

El programa debe mostrar un mensaje para cada día indicando cuántos patitos han sido fabricados ese día, por ejemplo: "Día 5 del mes 3 del año 2010: 10 patitos de goma fabricados". Al finalizar todos los bucles (después de contar todos los días durante el período especificado), el programa debe mostrar un mensaje con el total acumulado de patitos de goma que se han producido desde el inicio hasta el fin del periodo definido. Esto te permitirá ver cuántos patitos de goma se han fabricado en total durante ese tiempo, lo cual es útil para tener un registro preciso y hacer análisis posteriores sobre la producción.

```markdown
Ejercicio: Contando patitos de goma

Escribe un programa en Python que utilice bucles for para simular el conteo de patitos de goma en una fábrica.

El programa debe recorrer:

Los años de producción (por ejemplo, de 2000 a 2025).

Los meses del año (de 1 a 12).

Los días del mes (del 1 al 30).

Por cada día, el programa mostrará un mensaje indicando cuántos patitos de goma se han fabricado ese día.

Requisitos adicionales:

Cada día se fabrican exactamente 10 patitos de goma.

El programa debe mostrar mensajes como:

Día 5 del mes 3 del año 2010: 10 patitos de goma fabricados


Al terminar el bucle, el programa debe mostrar el total de patitos fabricados en todo el período.
```

### Actividades propuestas

### Actividad 1: Conteo de Días del Mes
**Descripción:** Los estudiantes deben crear un script que muestre los días del mes utilizando una estructura `for`. Se espera que aprendan a utilizar rangos y bucles `for` para iterar sobre un rango numérico específico.

### Actividad 2: Mejora de Códigos Ineficientes
**Descripción:** Los estudiantes deben convertir bloques de código ineficientes (que imprimen días del mes uno por uno) en una estructura de bucle `for`. Aprenderán a reemplazar la redundancia con control de flujo.

### Actividad 3: Anidación Básica
**Descripción:** Se pide a los estudiantes que realicen un ejercicio donde aniden dos ciclos `for` para recorrer días y meses. El objetivo es comprender cómo funcionan las estructuras anidadas en la programación.

### Actividad 4: Anidación Avanzada
**Descripción:** Los alumnos deben crear una estructura de bucles anidados que cubran años, meses y días. Esto ayudará a entender el uso de múltiples niveles de iteración y cómo manejar datos en tiempo largo.

### Actividad 5: Conteo Condicional (Pares/Impares)
**Descripción:** Los estudiantes deben escribir un script que cuente números pares o impares desde una lista dada, usando estructuras `for`. Aprenderán a usar condiciones dentro de los bucles para filtrar y contar elementos específicos.

### Actividad 6: Conversión de Bucle Ineficiente
**Descripción:** Los estudiantes tomarán un código que imprime días del mes sin utilizar ningún ciclo y lo convertirán en una versión eficiente usando `while`. El objetivo es mejorar su habilidad para optimizar el flujo controlado.

### Actividad 7: Incremento Manual En Ciclos
**Descripción:** Se les pide a los estudiantes que modifiquen un bucle `while` básico, añadiendo manualmente la actualización del contador. Esto fortalecerá su comprensión de cómo funcionan las variables de control en diferentes estructuras.

### Actividad 8: Simulación De Producción
**Descripción:** Los estudiantes deben desarrollar un programa que simule una fábrica produciendo patitos de goma a lo largo del tiempo. Utilizarán ciclos anidados para manejar años, meses y días y contar la producción diaria.

### Actividad 9: Resumen Mensual
**Descripción:** Los alumnos deben crear un programa que cuente los días del mes y muestre un resumen mensual al final de cada mes con el total de días contabilizados. Aprenderán a usar estructuras condicionales dentro de bucles para generar reportes.

### Actividad 10: Comparativa Bucle For vs While
**Descripción:** Los estudiantes deben escribir scripts que hagan lo mismo utilizando tanto `for` como `while`, y comparar las diferencias en términos de legibilidad y eficiencia. Esto les ayudará a decidir cuándo usar cada tipo de estructura.


<a id="estructuras-de-salto"></a>
## Estructuras de salto

### Introducción a los ejercicios

En esta carpeta, encontrarás ejercicios que te ayudarán a entender y practicar el uso de funciones en Python. Los ejercicios comienzan con la definición básica de una función y avanzan hacia la creación de funciones más complejas que incluyen parámetros, múltiples argumentos y el retorno de valores. El objetivo principal es familiarizarte con cómo declarar, llamar y utilizar funciones para realizar tareas específicas en tu código, como saludar a alguien o calcular la suma de dos números. Estos ejercicios te permitirán mejorar tus habilidades en la modularización del código, lo que es crucial para escribir programas más organizados y mantenibles.

### Funciones

#### Explicación

Este fragmento de código es una definición simple de una función en Python. La función se llama `diHola` y, como puedes ver, sigue las reglas mencionadas al principio del comentario: usa camelCase (comienza con letra minúscula y luego cada nueva palabra comienza con mayúscula), tiene un verbo (`di`) seguido de un objeto directo (`hola`), y su nombre es descriptivo ya que indica exactamente lo que hace la función.

La función `diHola()` no requiere ningún parámetro (no hay nada entre los paréntesis). Cuando se llama a esta función, simplemente imprime en pantalla el texto "Te digo hola". Las funciones son importantes porque permiten organizar el código de manera más clara y reutilizable. En este caso, cada vez que necesites saludar al usuario con un mensaje específico, puedes llamar a `diHola()` en lugar de escribir nuevamente la instrucción `print("Te digo hola")`. Esto no solo hace que tu programa sea más limpio sino también más fácil de mantener y modificar.

```python
# Deben escribirse con camelCase
# Deben tener un verbo (infinito o imperativo) y un objeto directo
# Deben tener un nombre descriptivo

def diHola():
  print("Te digo hola")
  
```

### uso de la funcion

#### Explicación

Este fragmento de código es una función básica en Python que se llama `diHola`. Una función es como una pequeña receta o tarea específica que puede hacer varias veces con diferentes datos, pero aquí no tiene parámetros y simplemente imprime el texto "Te digo hola" cuando se llama. La función sigue las reglas de nomenclatura propuestas al usar camelCase (`diHola` en lugar de `dihola`) y su nombre describe claramente lo que hace: decir hola.

Después de definir la función, el código llama a esta función con `diHola()`, lo que ejecuta todo lo contenido dentro de ella. Este es un ejemplo sencillo pero efectivo de cómo se utilizan las funciones en Python para organizar y reutilizar pedazos del programa.

```python
# Deben escribirse con camelCase
# Deben tener un verbo (infinito o imperativo) y un objeto directo
# Deben tener un nombre descriptivo

def diHola():
  print("Te digo hola")
  
diHola()
```

### parametros

#### Explicación

Este fragmento de código es una función básica en Python que ilustra cómo definir y llamar a funciones. La función se llama `diHola` y está diseñada para aceptar un parámetro, el cual generalmente sería el nombre de la persona a quien se saluda. Sin embargo, hay algo importante que notar: aunque la función está diseñada para recibir este parámetro, en la llamada a la función (`diHola()`) no se le proporciona ningún valor. Esto provocará un error al ejecutar el código porque la función espera recibir un argumento pero no lo recibe.

La función `diHola` imprime un saludo en pantalla que incluye el nombre del parámetro recibido, combinando strings y variables dentro de una llamada a `print()`. Es importante entender cómo definir funciones con parámetros y cómo proporcionar los valores correctos cuando se llama a estas funciones. Aprender esto es crucial para programar eficazmente en Python y en otros lenguajes de programación.

```python
# Deben escribirse con camelCase
# Deben tener un verbo (infinito o imperativo) y un objeto directo
# Deben tener un nombre descriptivo

def diHola(nombre):
  print("Hola,",nombre,"yo te saludo")
  
diHola()
```

### Llamada correcta

#### Explicación

Este código en Python muestra cómo crear e invocar una función sencilla. La función se llama `diHola` y está diseñada para recibir un nombre como argumento, que luego utiliza para imprimir un saludo personalizado en pantalla. Es importante notar que el nombre de la función sigue las reglas proporcionadas: usa camelCase (donde cada palabra comienza con mayúscula a partir de la segunda) y describe lo que hace la función (`diHola` podría ser "decir hola" si escribimos en español).

La parte central del código es el llamado o invocación de esta función, donde se pasa un nombre como argumento. En este caso, `diHola("Jose Vicente")` y `diHola("Jorge")` llaman a la función dos veces con diferentes nombres para saludar.

Esta estructura es fundamental en programación porque permite reutilizar código y organizarlo de manera más clara y mantenible.

```python
# Deben escribirse con camelCase
# Deben tener un verbo (infinito o imperativo) y un objeto directo
# Deben tener un nombre descriptivo

def diHola(nombre):
  print("Hola,",nombre,"yo te saludo")
  
diHola("Jose Vicente")
diHola("Jorge")
```

### varios parametros

#### Explicación

Este código es una función en Python que muestra cómo definir y utilizar funciones con parámetros. La función se llama `diHola` y tiene dos parámetros: `nombre` y `edad`. Lo primero que hace la función es imprimir un saludo personalizado usando el nombre y la edad proporcionados como argumentos.

Cuando llamas a la función `diHola("Jose Vicente", 47)`, Python entiende que "Jose Vicente" debe ser usado en lugar de `nombre` y que 47 se asigna al parámetro `edad`. Por lo tanto, el resultado es una impresión en pantalla que dice: "Hola, Jose Vicente, tienes 47 años y yo te saludo". Lo mismo ocurre con la segunda llamada a la función utilizando los valores "Jorge" y 48.

Este tipo de código es importante porque demuestra cómo crear funciones personalizables para reutilizar bloques de código que pueden adaptarse según las entradas proporcionadas, haciendo el programa más flexible y mantenible.

```python
# Deben escribirse con camelCase
# Deben tener un verbo (infinito o imperativo) y un objeto directo
# Deben tener un nombre descriptivo

def diHola(nombre,edad):
  print("Hola,",nombre,", tienes",edad," años y yo te saludo")
  
diHola("Jose Vicente",47)
diHola("Jorge",48)
```

### las funcione retornan

#### Explicación

Este fragmento de código es una parte práctica de cómo crear y usar funciones en Python. La función `diHola` está diseñada para recibir dos parámetros: un nombre (que suponemos es el nombre de una persona) y su edad. Esta función no realiza ninguna acción por sí sola, sino que genera un mensaje personalizado utilizando los datos proporcionados y lo devuelve usando la declaración `return`. 

En concreto, cuando se llama a `diHola("Jose Vicente", 47)` o `diHola("Jorge", 48)`, la función crea una cadena de texto que saluda al individuo mencionado y añade su edad. Es importante notar cómo se convierte el número (edad) a una cadena para poder concatenarlo con las palabras, usando `str(edad)`.

La estructura y nomenclatura de la función siguen un estándar recomendado en Python: el nombre es escrito en camelCase (`diHola`) e incluye acciones que serán realizadas con los parámetros proporcionados. Este tipo de prácticas ayuda a otros programadores entender rápidamente qué hace cada función sin necesidad de abrir su código interno, lo cual mejora la legibilidad y mantenimiento del programa.

```python
# Deben escribirse con camelCase
# Deben tener un verbo (infinito o imperativo) y un objeto directo
# Deben tener un nombre descriptivo
# Parámetro es el valor que entra en la función
# Return es la forma limpia de sacar información de una función

def diHola(nombre,edad):
  return "Hola,"+nombre+", tienes"+str(edad)+" años y yo te saludo"
  
diHola("Jose Vicente",47)
diHola("Jorge",48)
```

### funcion de sumar

#### Explicación

Este fragmento de código es un ejemplo simple de cómo definir y usar una función en Python. La función se llama `calculaSuma` y su objetivo es sumar dos números que le proporcionas como argumentos.

La función `calculaSuma` toma dos parámetros, llamados `operando1` y `operando2`, que representan los números que deseamos sumar. Dentro de la función, se calcula la suma de estos dos operandos utilizando el operador `+`. El resultado de esta operación se almacena en una variable llamada `resultado`.

El código importante es la línea donde se usa la palabra clave `return` para devolver el valor de `resultado`. Esto significa que cuando llamas a la función `calculaSuma(4, 3)`, no sólo realiza la suma, sino que también regresa el resultado al lugar desde donde fue llamada. En este caso, justo después de definir la función, hay una línea `print(calculaSuma(4, 3))` que imprime en pantalla el valor devuelto por la función.

Es importante destacar que esta práctica es útil porque permite reutilizar código y mantenerlo limpio: la función se encarga de realizar un cálculo específico (en este caso, sumar dos números), mientras que el resto del programa puede ocuparse de otras tareas sin preocuparse por los detalles del cálculo.

```python
'''
 Funcion correcta:
 Nombre: Verbo imperativo (o infinitivo) + objeto directo
 Usa camelCase
 Debe tener parámetros de entrada
 Debe tener una salida con return
 Debemos evitar prints u otros recursos de salida dentro de la funcion
'''

def calculaSuma(operando1,operando2):
  resultado = operando1 + operando2
  return resultado
  
print(calculaSuma(4,3))
```

### llamada a la funcion de suma

#### Explicación

Este fragmento de código es una simple llamada a una función en Python. En la primera línea, se está usando el comando `import` para traer una función específica llamada `calculaSuma` desde otro archivo llamado `funcionsuma`. Esta línea es como decir "trae la función calculaSuma que está en el archivo funcionsuma".

Luego, hay una línea donde se llama a esta función `calculaSuma`, pasándole dos números: 4 y 3. La función `calculaSuma` probablemente suma estos dos números juntos y luego devuelve el resultado. En este caso, la función está siendo llamada dentro de un comando `print`, lo que significa que después de que la función hace su cálculo, el resultado será mostrado en pantalla.

Esta práctica es importante porque permite organizar el código en diferentes archivos para mantenerlo limpio y fácil de entender, además de permitir reutilizar piezas de código como funciones sin necesidad de copiarlas manualmente.

```python
# from archivo import funcion,funcion2,funcion3

from funcionsuma import calculaSuma

print(calculaSuma(4,3))
```

### funcionsuma

#### Explicación

Este fragmento de código define una función en Python llamada `calculaSuma` que suma dos números y devuelve el resultado. La función sigue las reglas propuestas en la documentación al comienzo del bloque de código: utiliza un nombre apropiado (empleando camelCase, aunque en este caso es opcional ya que no contiene minúsculas), tiene parámetros de entrada (`operando1` y `operando2`) y retorna un valor (`resultado`). La importancia de esta estructura radica en que separa la lógica del cálculo de la suma desde el flujo principal del programa, lo cual facilita la reutilización del código en diferentes partes del programa sin necesidad de repetir el mismo bloque de operaciones.

```python
'''
 Funcion correcta:
 Nombre: Verbo imperativo (o infinitivo) + objeto directo
 Usa camelCase
 Debe tener parámetros de entrada
 Debe tener una salida con return
 Debemos evitar prints u otros recursos de salida dentro de la funcion
'''

def calculaSuma(operando1,operando2):
  resultado = operando1 + operando2
  return resultado
```

### Actividades propuestas

### Actividad 1: Crear y Llamar Funciones Simples
**Descripción:** Escribe una función llamada `saludar` que imprima un saludo simple. A continuación, llama a esta función en tu código principal para ver cómo funciona. Este ejercicio te ayudará a entender la estructura básica de las funciones en Python.

### Actividad 2: Funciones con Parámetros
**Descripción:** Modifica la función `saludar` para que tome un parámetro (por ejemplo, el nombre del usuario) y use este parámetro dentro de la función para personalizar el saludo. Aprenderás a pasar datos a una función.

### Actividad 3: Funciones con Dos Parámetros
**Descripción:** Extiende tu función `saludar` para que acepte dos parámetros, uno para el nombre y otro para un mensaje adicional. Luego llama a la función varias veces con diferentes valores de entrada para ver cómo funciona.

### Actividad 4: Retorno de Valores
**Descripción:** Modifica una función existente (como `saludar`) para que devuelva un valor en lugar de imprimirlo directamente, utilizando el comando `return`. Aprenderás a manejar los valores retornados por las funciones.

### Actividad 5: Creación y Uso de Módulos
**Descripción:** Crea una función simple (`saludar`) en un archivo separado (por ejemplo, `funcion_saludo.py`). Luego, importa esta función desde otro script principal para utilizarla. Aprenderás cómo estructurar tu código en múltiples archivos y entender el concepto de módulos.

### Actividad 6: Desarrollo de una Función Matemática
**Descripción:** Escribe una función llamada `calcular_producto` que tome dos números como parámetros, calcule su producto, y devuelva el resultado. Luego llama a esta función desde tu código principal y muestra el resultado en pantalla.

### Actividad 7: Sumar Números con Funciones
**Descripción:** Desarrolla una función llamada `sumar_numeros` que tome dos números como argumentos, sume estos valores e imprima la suma. Aprenderás cómo definir funciones para realizar cálculos matemáticos.

### Actividad 8: Invocación de Funciones desde Archivo Separado
**Descripción:** Crea una función simple (`calcular_suma`) que realice la suma de dos números y devuelva el resultado en un archivo llamado `funcion_suma.py`. Luego, importa esta función desde otro script principal para realizar cálculos y mostrar resultados.

### Actividad 9: Mejoramiento de una Función Existente
**Descripción:** Toma la función `diHola` del ejercicio proporcionado y mejórala para que acepte opcionalmente un segundo parámetro (edad), mostrando este dato en el saludo si se proporciona. Aprenderás a manejar parámetros opcionales dentro de funciones.

### Actividad 10: Crear una Función Compleja
**Descripción:** Diseña y escribe una función llamada `calcular_promedio` que tome tres números como argumentos, calcule su promedio y devuelva este valor. Luego utiliza la función desde tu código principal para mostrar el resultado.


<a id="control-de-excepciones"></a>
## Control de excepciones

### Introducción a los ejercicios

Esta carpeta contiene una serie de ejercicios en Python que te enseñan cómo manejar y controlar excepciones en tus programas. Los problemas trabajados van desde simples bloques `try-except` para capturar errores básicos, como divisiones por cero, hasta casos más complejos donde se manejan múltiples tipos específicos de excepciones para proporcionar un feedback útil al usuario del programa. A través de estos ejercicios, practicarás la estructura y el uso eficiente de las cláusulas `try`, `except`, `else` y `finally`. Esto es fundamental para crear programas más robustos que puedan manejar situaciones inesperadas sin colapsar completamente.

### tryexcept

#### Explicación

Este fragmento de código te enseña cómo manejar errores en Python utilizando la estructura `try-except`. La idea principal es ejecutar un bloque de código (en este caso, una simple operación matemática) y si ocurre algún error durante su ejecución, capturarlo para evitar que el programa se detenga bruscamente. En este ejemplo, primero intenta imprimir la suma de los números 4 y 3. Como esta operación es correcta y no genera ningún error, el código dentro del bloque `except` no se ejecuta.

Lo importante aquí es entender que aunque la operación matemática sea exitosa y no genere errores, la estructura `try-except` aún es útil para capturar situaciones en las que algo podría salir mal. En este caso específico, el mensaje "Ha ocurrido un error" solo se imprimiría si hubiera un problema dentro del bloque `try`.

Finalmente, independientemente de lo que suceda en los bloques anteriores, el programa seguirá ejecutando cualquier línea de código que esté después del bloque `try-except`. En este ejemplo, siempre se imprime la frase "Pero el programa continúa pase lo que pase", lo cual demuestra cómo Python puede continuar con su flujo normal incluso cuando hay errores en partes específicas del código.

```python
try:
  print(4+3)
except:
  print("Ha ocurrido un error")
  
print("Pero el programa continúa pase lo que pase")
```

### error

#### Explicación

Este código intenta dividir el número 4 entre 0, lo cual es matemáticamente imposible y genera un error en Python. Cuando ejecutas esta línea de código (`print(4/0)`), el programa detendrá su ejecución porque la operación no está definida. Aunque inmediatamente después se intenta imprimir "Y el programa continua", esto nunca llegará a mostrarse debido al error generado anteriormente.

Es importante entender que este tipo de errores, conocidos como excepciones, pueden interrumpir completamente el funcionamiento del código si no se manejan correctamente. En programación, es crucial aprender a anticipar estos problemas y utilizar estructuras de control llamadas bloques `try-except` para gestionarlos adecuadamente, asegurando que el programa pueda seguir ejecutándose incluso cuando ocurran errores inesperados.

```python
print(4/0)

print("Y el programa continua")
```

### error con try except

#### Explicación

Este código muestra cómo manejar errores en Python usando las estructuras `try` y `except`. La idea principal es intentar realizar una operación que podría causar un error, en este caso, dividir el número 4 entre cero, lo cual no está permitido matemáticamente. Dentro del bloque `try`, se ejecuta esta división.

Si Python detecta un error (en este caso, un `ZeroDivisionError`), salta inmediatamente al bloque `except`, donde se imprime el mensaje "No puedo ejecutar eso". Esto permite que el programa no se detenga completamente y pueda continuar su ejecución después de manejar el error. En la línea siguiente a la estructura `try-except`, se imprime un mensaje indicando que el programa sigue funcionando, lo cual demuestra cómo es posible controlar errores para mantener al software operativo incluso cuando ocurren problemas temporales o inesperados.

Este tipo de manejo de excepciones es muy importante en programación ya que permite crear programas más resistentes y capaces de recuperarse ante situaciones imprevistas, mejorando así la experiencia del usuario.

```python
try:
  print(4/0)
except:
  print("No puedo ejecutar eso")

print("Y el programa continua")
```

### pseudocodigo

#### Explicación

Este código utiliza una estructura llamada `try-except` para manejar errores que pueden ocurrir durante la ejecución del programa. En primer lugar, intenta dividir el número 4 entre 0, lo cual es imposible en matemáticas y causa un error inmediato en Python. Aunque no se llega a imprimir "Intento conectarme a la base de datos", este código simula un escenario donde podría haber problemas técnicos mientras intentas realizar una acción importante, como conectarte a una base de datos.

Si ocurre algún tipo de error dentro del bloque `try`, el programa salta al bloque `except` y ejecuta el código allí. En este caso, imprime "No puedo ejecutar eso" seguido de "Pues por lo menos guardo los datos a un archivo local temporal". Esto simula que, aunque no se pueda conectar a la base de datos debido a un error, todavía puedes tomar medidas para preservar los datos de alguna manera. 

Es importante manejar estos errores porque garantizan que tu programa siga funcionando incluso cuando algo sale mal y te permite controlar cómo reacciona el sistema ante problemas inesperados. Al final del código, se imprime "Y el programa continua", lo que indica que el error no detiene la ejecución completa del programa, sino que solo afecta a la parte específica donde ocurrió el problema.

```python
try:
  print(4/0)
  print("Intento conectarme a la base de datos")
  print("pero falla")
except:
  print("No puedo ejecutar eso")
  print("Pues por lo menos guardo los datos a un archivo local temporal")

print("Y el programa continua")
```

### Excepcion como e

#### Explicación

Este fragmento de código muestra cómo Python maneja los errores en tiempo de ejecución, específicamente cuando ocurre una división por cero. En el código, se intenta realizar la operación de división entre `dividendo` (que es 4) y `divisor` (que es 0). Como no se puede dividir un número entre cero en matemáticas, Python genera un error.

La estructura `try-except` está diseñada para capturar este tipo de errores. Cuando el código dentro del bloque `try` intenta ejecutar la división y ocurre un error (en este caso una excepción llamada `ZeroDivisionError`), el control se pasa al bloque `except`, que imprime en pantalla "Hay un error". Esto es importante porque ayuda a que nuestro programa no termine abruptamente cuando algo va mal, sino que puede gestionar los errores de manera adecuada y seguir ejecutando otras partes del código si las hay.

```python
dividendo = 4
divisor = 0

try:
  division = dividendo/divisor
except:
  print("Hay un error")
```

### capturo el error

#### Explicación

Este código muestra cómo manejar errores en Python usando bloques `try` y `except`. Aquí, se intenta realizar una operación matemática: dividir el número 4 entre cero (`dividendo/divisor`). Esto es algo que no puede hacerse porque dividir por cero no está definido en matemáticas y causa un error grave. Cuando Python detecta este problema dentro del bloque `try`, salta inmediatamente al bloque `except` más cercano, en este caso, el que está diseñado para manejar cualquier tipo de excepción.

En la sección `except Exception as mierror:`, cuando ocurre un error durante la ejecución del código dentro del bloque `try`, ese error es capturado y guardado en una variable llamada `mierror`. Luego, el programa imprime "Hay un error" y a continuación muestra información sobre qué tipo de error ocurrió (`print(mierror)`). Esto ayuda al programador a entender qué sucedió cuando se produce un fallo inesperado.

Es importante manejar los errores como este porque evita que el programa termine abruptamente o produzca resultados erróneos. Además, proporcionar mensajes claros de error puede ayudar a quienes usan tu código (o tú mismo si estás depurando) a entender rápidamente qué salió mal y cómo corregirlo.

```python
dividendo = 4
divisor = 0

try:
  division = dividendo/divisor
except Exception as mierror:
  print("Hay un error")
  print(mierror)
```

### errores personalizados

#### Explicación

Este fragmento de código muestra cómo Python maneja errores usando las estructuras `try` y `except`. En este caso, se intenta realizar una división entre el número 4 (dividendo) y 0 (divisor). Como dividir por cero no es posible matemáticamente, Python genera un error. El código está diseñado para capturar este tipo de errores específicos utilizando las sentencias `except`.

Primero, si ocurre una división entre cero, el programa imprimirá "Tienes un error de división por cero". Esto ayuda al usuario a entender claramente qué ha salido mal. Luego, en caso de que ocurra cualquier otro tipo de error inesperado dentro del bloque `try`, se capturará con la sentencia `except Exception as mierror`. Aquí, el programa informa simplemente "Hay un error" y muestra el detalle de ese error.

Este método es importante porque ayuda a hacer programas más robustos y amigables para el usuario al manejar errores de una manera predecible e informativa.

```python
dividendo = 4
divisor = 0

try:
  division = dividendo/divisor
except ZeroDivisionError:
  print("Tienes un error de division por cero")
except Exception as mierror:
  print("Hay un error")
  print(mierror)
```

### todos los posibles

#### Explicación

Este fragmento de código muestra cómo manejar diferentes tipos de errores en Python utilizando bloques `try`, `except` y otros elementos como `else` y `finally`. El objetivo principal es asegurar que el programa no se rompa abruptamente cuando ocurre un error, sino que pueda proporcionar mensajes útiles sobre qué tipo de problema ha surgido.

En este ejemplo, inicialmente se intenta realizar una operación matemática simple: dividir 4 entre 0. Esto es imposible en matemáticas y en Python genera un error llamado `ZeroDivisionError`. Sin embargo, el código está preparado para capturar este error y otros posibles errores que podrían ocurrir durante la ejecución del programa.

Los bloques `except` especifican diferentes tipos de excepciones (errores) que pueden surgir, como divisiones por cero, operaciones con tipos incompatibles, valores no válidos, entre otros. Si ocurre una de estas situaciones, el código dentro del bloque correspondiente se ejecuta para informar sobre el problema.

Después de todos los bloques `except`, si ninguna excepción ocurrió y la división fue exitosa, el programa entra en el bloque `else` que imprime un mensaje indicando que todo salió bien. Finalmente, independientemente de si hubo errores o no, el bloque `finally` se ejecuta para realizar acciones como liberar recursos o imprimir un mensaje final.

Este método de manejo de excepciones es crucial en programación porque permite a los programas lidiar con problemas inesperados sin detenerse completamente y proporciona al usuario información útil sobre qué salió mal, lo que facilita la depuración y mejora la experiencia del usuario.

```python
dividendo = 4
divisor = 0

try:
    division = dividendo / divisor

except ZeroDivisionError:
    print("❌ Error: división por cero.")

except TypeError:
    print("❌ Error: tipos de datos incompatibles para la operación.")

except ValueError:
    print("❌ Error: valor no válido.")

except NameError:
    print("❌ Error: variable no definida.")

except IndexError:
    print("❌ Error: índice fuera de rango.")

except KeyError:
    print("❌ Error: clave inexistente en un diccionario.")

except AttributeError:
    print("❌ Error: atributo no encontrado en el objeto.")

except ImportError:
    print("❌ Error: problema al importar un módulo o función.")

except FileNotFoundError:
    print("❌ Error: archivo no encontrado.")

except PermissionError:
    print("❌ Error: permiso denegado al acceder a un recurso.")

except OSError:
    print("❌ Error del sistema operativo (archivos, rutas, etc.).")

except MemoryError:
    print("❌ Error: la memoria disponible se ha agotado.")

except RecursionError:
    print("❌ Error: recursión demasiado profunda.")

except Exception as e:
    print("⚠️  Error inesperado:")
    print(type(e).__name__, "-", e)

except BaseException as e:
    print("🛑 Error crítico del sistema:")
    print(type(e).__name__, "-", e)

else:
    print("✅ La operación se realizó correctamente.")

finally:
    print("🔚 Fin del bloque try-except.")
```

### atrapar dato en consola

#### Explicación

Este código muestra cómo manejar errores cuando algo sale mal durante la ejecución, en este caso, intenta convertir una cadena de texto que no es un número entero ("hola") en un número entero usando la función `int()`. Al tratar de hacer esto, Python genera un error llamado `ValueError` porque "hola" no puede ser interpretado como un número.

El bloque `try` contiene el código que podría generar un error (`numero = int("hola")`). Si ocurre este error, el programa salta al bloque `except ValueError`, donde se imprime un mensaje amigable para informar al usuario que la entrada de texto no es válida y no puede convertirse a un número. Finalmente, independientemente de si ocurrió un error o no, el código dentro del bloque `finally` se ejecuta siempre, en este caso, imprime "🔚 Fin del bloque try-except." Este mensaje indica claramente que el programa ha terminado de manejar la posible excepción.

Este tipo de estructura es crucial para hacer programas más robustos y capaces de informar correctamente al usuario cuando algo sale mal durante su ejecución.

```python
try:
    numero = int("hola")  # Intentamos convertir texto no numérico a entero
    print("El número es:", numero)

except ValueError:
    print("❌ Error: valor no válido (no se puede convertir a número).")

finally:
    print("🔚 Fin del bloque try-except.")
```

### Actividades propuestas

### Actividad 1: Manejo Básico de Excepciones

**Descripción:** Implementa un programa que divida dos números proporcionados por el usuario. Utiliza una estructura `try-except` para manejar la excepción que ocurre cuando se intenta dividir entre cero. El objetivo es aprender a capturar y gestionar errores comunes.

### Actividad 2: Personalización de Mensajes de Error

**Descripción:** Modifica el código del ejercicio anterior para que, en lugar de un mensaje genérico, muestre un error personalizado cuando se produce una división por cero. El objetivo es aprender a mejorar la legibilidad y la amabilidad de los mensajes de error.

### Actividad 3: Gestión de Múltiples Excepciones

**Descripción:** Crea un programa que intente realizar varias operaciones (como dividir dos números, acceder a elementos inexistentes en una lista, etc.). Utiliza múltiples bloques `try-except` para manejar diferentes tipos de errores específicos. Aprenderás cómo estructurar código para manejar situaciones complejas.

### Actividad 4: Uso del Bloque `else`

**Descripción:** Desarrolla un programa que utilice una estructura `try-except-else`. El bloque `else` debe ejecutarse solo si no se produce ninguna excepción durante la división de dos números. Aprenderás a diferenciar el código que se ejecuta cuando todo sale bien del que se ejecuta en caso de errores.

### Actividad 5: Bloque `finally`

**Descripción:** Implementa un programa donde uses una estructura `try-except-finally`. El bloque `finally` debe contener acciones que deben realizarse independientemente de si ocurrió un error o no, como cerrar archivos o liberar recursos. Aprenderás a asegurar el estado final del programa.

### Actividad 6: Tratamiento de Excepciones Específicas

**Descripción:** Escribe una aplicación que capture y trate excepciones específicas (por ejemplo, `ZeroDivisionError`, `TypeError`) en un bloque `try-except`. Luego, utiliza un `except Exception` como último recurso para capturar errores no esperados. Aprenderás a ser más específico al manejar diferentes tipos de errores.

### Actividad 7: Tratamiento de Excepciones Personalizadas

**Descripción:** Diseña una aplicación que solicite al usuario ingresar dos números y realice operaciones matemáticas con ellos, utilizando excepciones personalizadas para manejar casos específicos como división por cero o entradas no numéricas. Aprenderás a crear mensajes de error más útiles y precisos.

### Actividad 8: Procesamiento de Datos Con Excepciones

**Descripción:** Crea un programa que lea datos desde una lista, intente realizar operaciones con ellos (como la división), y maneje excepciones como `IndexError` y `ZeroDivisionError`. El objetivo es aprender a gestionar errores en el contexto de manipulación de estructuras de datos.

### Actividad 9: Captura de Errores en Entrada del Usuario

**Descripción:** Desarrolla un programa que solicite al usuario ingresar una fecha en formato numérico y luego convierta esta entrada a un objeto `datetime`. Utiliza bloques `try-except` para manejar errores como `ValueError` si la entrada no es válida. Aprenderás a validar la entrada del usuario y proporcionar retroalimentación adecuada.

### Actividad 10: Integración de Excepciones en Procesos Complejos

**Descripción:** Implementa una aplicación más compleja que realice múltiples operaciones (como lectura y escritura de archivos, conexión a bases de datos) utilizando excepciones para manejar posibles errores. Aprenderás a diseñar programas robustos y resilientes frente a situaciones inesperadas.

Estas actividades están diseñadas para ayudarte a dominar el uso de estructuras de control en Python, con un enfoque especial en la gestión eficiente de excepciones.


<a id="aserciones"></a>
## Aserciones

### Introducción a los ejercicios

En esta carpeta de ejercicios, los estudiantes van a aprender y practicar el uso de aserciones en Python. Las aserciones son declaraciones que permiten verificar si una condición específica es cierta durante la ejecución del programa; sirven como un mecanismo para detectar errores lógicos en el código. A través de estos ejemplos, los estudiantes podrán entender cómo escribir y utilizar aserciones para mejorar la robustez y la legibilidad de sus programas. Además, se les enseñará cómo manejar excepciones generadas por aserciones que fallan, proporcionando una introducción a la gestión de errores en Python.

### chivato

#### Explicación

Este código utiliza una declaración `assert` en Python, que se usa para verificar si una condición es verdadera durante la ejecución del programa. En este caso, la afirmación `assert 3 == 3` comprueba si el número 3 es igual a sí mismo, lo cual obviamente es cierto. La segunda parte de la declaración, tras la coma y entre comillas, "Eso no es cierto", se muestra como un mensaje de error si la condición no se cumple. Aquí, dado que 3 siempre será igual a 3, el programa nunca lanzará este mensaje de error. El uso de `assert` ayuda a los programadores a detectar errores más fácilmente durante las pruebas y en desarrollo, asegurando que ciertas condiciones fundamentales sean verdaderas para evitar problemas posteriores en el código.

```python
assert 3 == 3 , "Eso no es cierto"
```

### el chivato salta

#### Explicación

Este fragmento de código utiliza una estructura llamada `assert`, que se traduce como "asegurar" en español. La función de `assert` es verificar si una condición determinada es verdadera durante la ejecución del programa. En este caso, el programa verifica si el número 3 es igual al número 2. Si la afirmación no es cierta (que no lo es), el programa generará un error y mostrará el mensaje "Eso no es cierto". Esta estructura de control es útil para comprobar condiciones que deberían ser verdaderas basándose en los supuestos del código, ayudando a encontrar errores durante la fase de desarrollo. En este ejemplo, `assert` actúa como una alarma que avisa cuando se viola alguna regla o asunción clave dentro del programa.

```python
assert 3 == 2 , "Eso no es cierto"
```

### ejemplo no tan traumatico

#### Explicación

Este código está utilizando una estructura llamada `assert`, que se utiliza para verificar si ciertas condiciones son verdaderas en tu programa. En este caso, el programa verifica si la variable `edad` es igual a 48. Si esto no es cierto, lo cual es el caso porque `edad` vale 47, el programa generará un error con el mensaje "no es correcto". Las aserciones son útiles para detectar errores durante la fase de desarrollo del programa y ayudan a los programadores a asegurarse de que las partes críticas de su código se están ejecutando correctamente. Sin embargo, en este ejemplo específico, la afirmación siempre fallará porque 47 no es igual a 48, lo que probablemente indica un error en el valor asignado a `edad` o una condición incorrecta en la aserción misma.

```python
edad = 47

assert edad == 48, "no es correcto"
```

### combinacion

#### Explicación

Este código comprueba si la variable `edad` tiene un valor específico y utiliza una estructura llamada aserción para hacerlo. La palabra clave `assert` se usa para verificar que cierta condición sea verdadera; en este caso, está verificando que `edad` sea igual a 48. Si esta afirmación no es correcta, el programa generará un error con el mensaje "no es correcto". El bloque `except` captura ese posible error y simplemente imprime "Error determinado" en lugar de parar abruptamente la ejecución del código.

Este tipo de comprobaciones son útiles durante la fase de desarrollo para asegurarse de que ciertas condiciones se mantengan, ayudando a identificar rápidamente errores o situaciones inesperadas en el código. En este ejemplo concreto, aunque `edad` es 47 y no 48, en lugar de hacer que el programa falle, simplemente imprime un mensaje indicando que ha habido un error en la aserción.

Es importante entender cómo funcionan las aserciones porque te permiten escribir código más seguro y fácilmente depurado.

```python
edad = 47
try:
  assert edad == 48, "no es correcto"
except:
  print("Error determinado")
```

### Actividades propuestas

### Actividad 1: Introducción a las Aserciones en Python

**Descripción:** 
Los estudiantes deben aprender cómo utilizar aserciones básicas para verificar condiciones de manera simple. Se les pedirá que añadan una serie de aserciones al código existente y observen el comportamiento del programa.

---

### Actividad 2: Creación Propia de Aserciones

**Descripción:** 
Los estudiantes deben crear un archivo Python con varias aserciones sobre diferentes tipos de datos, como números enteros, flotantes, cadenas y listas. Se les pedirá que intenten hacer fallar algunas aserciones.

---

### Actividad 3: Aserciones en Funciones

**Descripción:** 
Los estudiantes deben escribir una función simple que incluya al menos dos aserciones internamente. La función calculará un valor numérico y verificará si el resultado es correcto utilizando aserciones.

---

### Actividad 4: Manejo de Excepciones con Aserciones

**Descripción:** 
Basándose en ejemplos proporcionados, los estudiantes deben implementar una estructura `try-except` para capturar excepciones generadas por aserciones que fallan. Se espera que puedan documentar el error y continuar con la ejecución del programa.

---

### Actividad 5: Depuración de Código

**Descripción:** 
Los estudiantes recibirán un código con errores (como en el archivo "002-el chivato salta.py") y deberán encontrar, corregir y reemplazar las aserciones incorrectas por aquellas que funcionen correctamente.

---

### Actividad 6: Comparación de Aserciones

**Descripción:** 
Se les pedirá a los estudiantes que tomen un código donde se usan `if` para comprobar condiciones similares a aserciones y lo modifiquen para utilizar aserciones en su lugar. La actividad debe centrarse en entender la diferencia y el uso correcto de ambos.

---

### Actividad 7: Aserciones en Algoritmos Complejos

**Descripción:** 
Los estudiantes deben implementar un pequeño algoritmo matemático o lógico complejo que incluya varios pasos, cada uno verificado con aserciones para asegurar la correcta ejecución de las operaciones intermedias.

---

### Actividad 8: Documentación y Aserciones

**Descripción:** 
Los estudiantes deben escribir comentarios explicando por qué ciertas aserciones se han usado en el código. Se les pedirá que documenten cada línea de aserción para entender su propósito en el flujo del programa.

---

### Actividad 9: Pruebas Automáticas con Aserciones

**Descripción:** 
Basándose en un conjunto de datos proporcionados, los estudiantes deberán escribir pruebas automatizadas usando aserciones para verificar si diferentes condiciones se cumplen correctamente. El objetivo es asegurar la calidad del código a través de estas pruebas.

---

### Actividad 10: Integración de Aserciones con Funciones Existentes

**Descripción:** 
Los estudiantes deben seleccionar funciones existentes (proporcionadas o creadas por ellos mismos) y agregar aserciones al inicio y final de las funciones para verificar la entrada y salida. Esto ayudará a entender cómo integrar aserciones en el desarrollo habitual.

---

Estas actividades están diseñadas para proporcionar una base sólida en el uso y la implementación de aserciones en Python, asegurando que los estudiantes comprendan su importancia en la depuración y mantenimiento del código.


<a id="prueba-depuracion-y-documentacion-de-la-aplicacion"></a>
## Prueba, depuración y documentación de la aplicación

### Introducción a los ejercicios

Este conjunto de ejercicios está diseñado para ayudarte a comprender y practicar el uso correcto de estructuras de control en Python, así como la importancia de la prueba, depuración y documentación de aplicaciones. Los problemas que se trabajan van desde una función simple de división hasta un juego completo de tres en raya, pasando por la creación de funciones más robustas con manejo de errores y validación de tipos. A través de estos ejercicios, desarrollarás habilidades cruciales como identificar y corregir fallos en el código, mejorar la legibilidad del mismo mediante la adición de comentarios y documentación, y estructurar proyectos de manera efectiva importando y usando funciones desde diferentes módulos.

### funcion de division

#### Explicación

Este código define una función en Python llamada `hazDivision` que toma dos parámetros: `dividendo` y `divisor`. La función calcula la división entre estos dos valores y devuelve el resultado. Luego, se imprime en pantalla el resultado de llamar a esta función con los números 4 y 3.

A continuación, hay un doble bucle que itera sobre una amplia gama de posibles valores para `i` e `j`, desde -100 hasta 99. En cada iteración del bucle, se llama a la función `hazDivision` utilizando estos dos valores como argumentos.

Finalmente, independientemente de lo que pueda haber ocurrido durante la ejecución del código (incluyendo posibles errores no manejados), el programa imprime "Todo ha ido correcto". Es importante notar que este mensaje puede ser engañoso si alguna división por cero o algún otro error ha sucedido dentro de los bucles, ya que no se han implementado mecanismos para controlar y manejar tales errores.

```python
def hazDivision(dividendo,divisor):
  resultado = dividendo/divisor
  return resultado
  
print(hazDivision(4,3))

for i in range(-100,100):
  for j in range(-100,100):
    hazDivision(i,j)

print("Todo ha ido correcto")
```

### mejora

#### Explicación

Este fragmento de código es una función en Python llamada `hazDivision` que realiza una operación de división entre dos números y maneja un caso especial cuando el divisor es cero. La función toma dos argumentos: `dividendo`, que es el número que se va a dividir, y `divisor`, que es el número por el cual se divide. Si el divisor no es cero, la función calcula el resultado de la división normalmente y lo guarda en una variable llamada `resultado`. Sin embargo, si el divisor es igual a cero, la función asigna directamente 0 a `resultado` para evitar un error matemático que ocurriría al dividir por cero.

Después de definir la función, se imprime el resultado de llamar a esta función con los valores 4 y 3. Luego, mediante dos bucles anidados (uno para `i` y otro para `j`, ambos en un rango desde -100 hasta 99), se llama a la función `hazDivision` para todas las combinaciones posibles de estos números. Esto es útil para probar exhaustivamente cómo funciona la función, especialmente cuando el divisor puede ser cero o cercano a cero.

Finalmente, si todo el proceso se ejecuta sin problemas (es decir, sin errores), se imprime "Todo ha ido correcto" en pantalla. Esta línea indica que la prueba automatizada de todas las combinaciones de números para dividir funcionó bien y no hubo divisiones por cero inesperadas o otros errores durante el proceso.

```python
def hazDivision(dividendo,divisor):
  if divisor != 0:
    resultado = dividendo/divisor
  else:
    resultado = 0
  return resultado
  
print(hazDivision(4,3))

for i in range(-100,100):
  for j in range(-100,100):
    hazDivision(i,j)

print("Todo ha ido correcto")
```

### nuevo fallo

#### Explicación

Este fragmento de código define una función en Python llamada `hazDivision` que toma dos parámetros: `dividendo` y `divisor`. La función verifica si el divisor es diferente de cero. Si lo es, realiza la división del dividendo entre el divisor y guarda el resultado en la variable `resultado`. Sin embargo, si el divisor es igual a cero (lo cual no sería matemáticamente válido), asigna directamente un valor 0 a `resultado`. Finalmente, la función retorna este resultado.

Después de definir la función, se llama a ella con los argumentos `4` y `a`, donde `a` probablemente es una variable que ya ha sido declarada en otra parte del programa. El resultado de esta llamada se imprime en pantalla usando la función `print`.

Este código es importante porque muestra cómo manejar un caso especial en matemáticas, como dividir por cero, y evitar errores al ejecutar el programa.

```python
def hazDivision(dividendo,divisor):
  if divisor != 0:
    resultado = dividendo/divisor
  else:
    resultado = 0
  return resultado
  
print(hazDivision(4,a))
```

### nuevo fallo mas

#### Explicación

Este fragmento de código define una función llamada `hazDivision` que toma dos parámetros, `dividendo` y `divisor`. La función se encarga de dividir el primer número (dividendo) por el segundo número (divisor), pero antes de realizar la división, realiza varias comprobaciones importantes para evitar errores.

Primero, la función verifica si tanto el dividendo como el divisor son números válidos. Esto lo hace utilizando la función `isinstance()`, que comprueba si un valor es del tipo especificado (en este caso, puede ser un entero, flotante o número complejo).

Si ambos valores pasan esta comprobación, la función continúa verificando si el divisor no es igual a cero. Si el divisor es cero, la división no se realizaría porque matemáticamente esto está prohibido y causaría un error en el programa.

Finalmente, si todas las condiciones son correctas, se realiza la operación de división y se devuelve el resultado. En caso de que alguna de las comprobaciones falle (por ejemplo, si alguno de los valores no es numérico o el divisor es cero), la función simplemente retorna 0.

Esta práctica de comprobar entradas antes de realizar una operación es crucial en la programación para garantizar que tu programa funcione correctamente sin interrupciones y sea resistente a errores.

```python
def hazDivision(dividendo,divisor):
  # Comprobamos si son números
  if isinstance(dividendo, (int, float, complex)) and isinstance(divisor, (int, float, complex)):
    # Comprobamos que el divisor no es cero
    if divisor != 0:
      resultado = dividendo/divisor
    else:
      resultado = 0
    return resultado
  else:
    return 0
  
print(hazDivision(4,"a"))
```

### cadenas

#### Explicación

Este fragmento de código define una función llamada `hazDivision` que toma dos parámetros, `dividendo` y `divisor`. La función tiene como objetivo realizar la división entre estos dos valores pero con varios controles para asegurar que todo funcione correctamente. 

Primero, se verifica si tanto el dividendo como el divisor son números (enteros, decimales o números complejos). Si alguno de los parámetros no es un número, la función retorna 0. Luego, si el divisor no es cero, procede a realizar la división y guarda el resultado en una variable llamada `resultado`. Sin embargo, si el divisor es igual a cero (lo que matemáticamente está prohibido), la función también devuelve 0 para evitar un error.

Este tipo de validación es importante porque ayuda a prevenir errores durante la ejecución del programa, asegurando que las operaciones matemáticas se realicen solo con datos adecuados y en condiciones seguras.

```python
def hazDivision(dividendo,divisor):
  # Comprobamos si son números
  if isinstance(dividendo, (int, float, complex)) and isinstance(divisor, (int, float, complex)):
    # Comprobamos que el divisor no es cero
    if divisor != 0:
      resultado = dividendo/divisor
    else:
      resultado = 0
    return resultado
  else:
    return 0
  
print(hazDivision(4,"3"))
```

### mejoro cadenas

#### Explicación

Este fragmento de código define una función llamada `hazDivision` que toma dos parámetros: `dividendo` y `divisor`. La función tiene como objetivo realizar la división entre estos dos valores, pero antes de hacerlo, realiza varias comprobaciones para asegurarse de que el cálculo sea seguro y posible.

Primero, verifica si tanto `dividendo` como `divisor` son números (enteros, flotantes o números complejos). Si ambos son realmente números, la función se asegura de que el divisor no sea cero porque dividir por cero es matemáticamente imposible. En caso afirmativo, realiza la división y devuelve el resultado.

Si los parámetros no son números iniciales pero podrían ser convertidos a un tipo numérico (por ejemplo, una cadena que representa un número como "3"), la función intenta convertirlos usando `float()`. Si esto es exitoso, vuelve a realizar la operación de división. En caso contrario, cuando se produce algún error durante esta conversión o si el divisor sigue siendo cero después de la posible conversión, la función devuelve simplemente 0.

Esta estrategia ayuda a evitar errores inesperados y asegura que los datos ingresados sean manipulables matemáticamente antes de proceder con operaciones como la división.

```python
def hazDivision(dividendo,divisor):
  # Comprobamos si son números
  if isinstance(dividendo, (int, float, complex)) and isinstance(divisor, (int, float, complex)):
    # Comprobamos que el divisor no es cero
    if divisor != 0:
      resultado = dividendo/divisor
      return resultado
    else:
      resultado = 0
  else:
    try:
      # Vamos a intentar convertirlo a numeros
      dividendo = float(dividendo)
      divisor = float(divisor)
      resultado = dividendo/divisor
      return resultado
    except:
      return 0
  
print(hazDivision(4,"3"))
```

### depuracion

#### Explicación

Este código define una función en Python llamada `hazDivision` que toma dos parámetros: `dividendo` y `divisor`. La función tiene como objetivo realizar una división entre estos dos valores, pero antes de hacer la operación, verifica algunos aspectos clave para asegurar que los cálculos sean correctos.

Primero, el código comprueba si ambos parámetros son números (ya sea enteros, flotantes o números complejos). Si no lo son, intenta convertirlos a un tipo numérico utilizando la función `float()`. En caso de éxito, procede con la división y devuelve el resultado. Sin embargo, si los valores no pueden ser convertidos en números debido a algún error, imprime un mensaje indicando que no pudo realizar la conversión y retorna 0.

Además, verifica que el divisor no sea cero para evitar una división por cero, lo cual provocaría un error en Python. Si todo sale bien y se cumplen las condiciones necesarias, la función devuelve el resultado de dividir `dividendo` entre `divisor`.

Este tipo de comprobación previa es importante porque ayuda a prevenir errores durante la ejecución del programa y proporciona retroalimentación al usuario sobre por qué no pudo completarse una operación, lo que facilita la depuración.

```python
def hazDivision(dividendo,divisor):
  # Comprobamos si son números
  print("Entramos en la funcion")
  if isinstance(dividendo, (int, float, complex)) and isinstance(divisor, (int, float, complex)):
    print("parece que los parametros son numeros")
    # Comprobamos que el divisor no es cero
    if divisor != 0:
      print("parece que los puedo dividir")
      resultado = dividendo/divisor
      return resultado
    else:
      print("No puedo dividir porque el divisor es cero")
      resultado = 0
  else:
    print("Los parametros no son numeros, pero voy a intentar convertirlos")
    try:
      print("Intento convertir a numeros con exito")
      # Vamos a intentar convertirlo a numeros
      dividendo = float(dividendo)
      divisor = float(divisor)
      resultado = dividendo/divisor
      return resultado
    except:
      print("He intentado convertir a numeros, pero no he podido")
      return 0
  
print(hazDivision(4,"3"))
```

### documentacion de la funcion

#### Explicación

El código que has proporcionado define una función llamada `hazDivision` en Python que realiza la división de dos números y maneja posibles errores. La función toma dos parámetros: `dividendo` y `divisor`. Primero, comprueba si ambos parámetros son números (int, float o complex). Si no lo son, intenta convertirlos a un número float para realizar la división. Además, verifica que el divisor no sea cero para evitar una división por cero.

Esta función es importante porque proporciona manejo de errores robusto y permite al programa continuar su ejecución incluso si los valores ingresados no cumplen con las expectativas iniciales. Esto ayuda a mejorar la estabilidad del programa y ofrece un mejor manejo de situaciones imprevistas, como intentar dividir por cero o pasar parámetros que no son numéricos.

En resumen, `hazDivision` es una herramienta útil para realizar operaciones matemáticas de manera segura y controlada en programas más grandes.

```python
def hazDivision(dividendo,divisor):
  '''
    Función de división
    Entradas: dividendo y divisor que se espera que sean numéricos
    Salidas: resultado de la división como número (o cero si hay fallo)
    Capturas de error: 
      1.-Si es numérico
      2.-Si se puede convertir a número
      3.-Si no es división entre cero
  '''
  # Comprobamos si son números
  print("Entramos en la funcion")
  if isinstance(dividendo, (int, float, complex)) and isinstance(divisor, (int, float, complex)):
    print("parece que los parametros son numeros")
    # Comprobamos que el divisor no es cero
    if divisor != 0:
      print("parece que los puedo dividir")
      resultado = dividendo/divisor
      return resultado
    else:
      print("No puedo dividir porque el divisor es cero")
      resultado = 0
  else:
    print("Los parametros no son numeros, pero voy a intentar convertirlos")
    try:
      print("Intento convertir a numeros con exito")
      # Vamos a intentar convertirlo a numeros
      dividendo = float(dividendo)
      divisor = float(divisor)
      resultado = dividendo/divisor
      return resultado
    except:
      print("He intentado convertir a numeros, pero no he podido")
      return 0
  
print(hazDivision(4,"3"))
```

### extraccion de funcion

#### Explicación

Este fragmento de código está utilizando una función llamada `hazDivision` que se encuentra en un archivo externo denominado `funciondivision.py`. La línea `print(hazDivision(4, "3"))` llama a esta función y le pasa dos argumentos: el número 4 como entero y la cadena "3" (que representa el número tres pero es de tipo string). 

Lo que hace este código es imprimir en pantalla el resultado devuelto por la función `hazDivision`. La función debe estar diseñada para realizar alguna operación con los valores proporcionados, probablemente una división matemática, aunque aquí se le está pasando un número como cadena lo cual podría causar un error si la función no maneja adecuadamente este tipo de datos.

Es importante notar que esta línea puede generar problemas en ejecución porque está intentando dividir entre una variable que es del tipo string ("3") y no int, lo que normalmente resulta en un error de ejecución. Es crucial entender cómo se ha implementado la función `hazDivision` para saber qué efecto tendrá pasarle un argumento de este tipo.

```python
from funciondivision import hazDivision
  
print(hazDivision(4,"3"))
```

### ejercicio propuesto

#### Explicación

Este fragmento de código te pide crear una función en Python llamada `raizSegura` que calcula la raíz cuadrada de un número, pero primero realiza varias comprobaciones y manejo de errores para garantizar que el proceso sea seguro. La función debe aceptar cualquier tipo de entrada (números enteros o flotantes, cadenas) y convertir las entradas no numéricas a números si es posible.

La funcionalidad principal se implementa usando una estructura `try/except` para capturar errores durante la conversión del parámetro de entrada a un número (float) o cuando se intenta calcular la raíz cuadrada de un número negativo, ya que no está definida en el conjunto de números reales. Si todo va bien y el número es válido, la función calcula su raíz cuadrada utilizando la biblioteca `math` de Python. En caso contrario, devuelve 0.

Además, se utilizan aserciones internas para verificar que los resultados son siempre numéricos (ya sean enteros o flotantes) y que si el número de entrada es negativo, la salida debe ser exactamente cero. Esto ayuda a prevenir errores lógicos en tu programa más adelante.

Esta práctica de validación y manejo de excepciones es fundamental en programación ya que asegura que tu código responde adecuadamente a datos no esperados o condiciones inesperadas sin fallar abruptamente.

```python
Enunciado: Raíz cuadrada segura

Implementa una función raizSegura(numero) que cumpla:

Validación y manejo de errores

Si numero es un valor numérico (int o float) y es mayor o igual a 0 → devuelve su raíz cuadrada.

Si numero es una cadena, intenta convertirla a float y aplica la regla anterior.

Si la conversión falla, o si el número es negativo, la función debe devolver 0.

Usa try/except para capturar errores en la conversión o en el cálculo.

Aserciones

Usa al menos dos assert internos, por ejemplo:

que la salida siempre sea un número (int o float),

que si la entrada es negativa, la salida sea exactamente 0.

Documentación

Escribe un docstring que explique entradas, salidas y qué errores controla.

Estructura del proyecto

Guarda la función en funcionraiz.py.

Crea un archivo main.py que importe la función y realice 3 pruebas de ejemplo mostrando los resultados por pantalla.

Prueba unitaria pequeña

Crea un archivo test_raiz.py que contenga varios assert para verificar:

Caso correcto con número positivo.

Caso con cadena convertible.

Caso con número negativo.

Caso con cadena no convertible.

Caso con 0.
```

### tres en raya

#### Explicación

Este código es la parte inicial de un juego de tres en raya (también conocido como Tic-Tac-Toe) que se juega entre dos jugadores humanos. Al principio, el programa muestra un mensaje de bienvenida y se indica quién ha desarrollado el juego. Luego, define las variables necesarias para representar cada una de las casillas del tablero, inicializadas con números del 1 al 9.

El código principal utiliza un bucle `while True` que hace que el juego continúe indefinidamente hasta que se añada lógica para detenerlo (como detectar ganadores o empates). Dentro de este bucle, el programa imprime en pantalla la configuración actual del tablero. Los jugadores toman turnos introduciendo un número correspondiente a la casilla donde desean colocar su símbolo ("X" para el primer jugador y "O" para el segundo).

Después de que un jugador realiza una tirada, se comprueba qué casilla ha seleccionado (con los condicionales `if`) y se actualiza esa casilla con el símbolo correspondiente. Finalmente, cambia al siguiente turno intercambiando el valor de la variable `jugador` entre 1 y 2.

Este código es importante porque establece las bases del juego y enseña cómo gestionar turnos, entrada de usuario e impresión en pantalla para un juego interactivo simple.

```python
print("Tres en raya - 2 jugadores humanos")
print("(c) 2025 Jose Vicente Carratala")

jugador = 1
casilla1 = 1
casilla2 = 2
casilla3 = 3
casilla4 = 4
casilla5 = 5
casilla6 = 6
casilla7 = 7
casilla8 = 8
casilla9 = 9

while True:
  print(f'{casilla1}|{casilla2}|{casilla3}')
  print(f'------')
  print(f'{casilla4}|{casilla5}|{casilla6}')
  print(f'------')
  print(f'{casilla7}|{casilla8}|{casilla9}')
  tirada = input("Tirada del jugador "+str(jugador))
  if int(tirada) == 1:
    if jugador == 1:
      casilla1 = "X"
    else:
      casilla1 = "O"
  if int(tirada) == 2:
    if jugador == 1:
      casilla2 = "X"
    else:
      casilla2 = "O"
  if int(tirada) == 3:
    if jugador == 1:
      casilla3 = "X"
    else:
      casilla3 = "O"
  if int(tirada) == 4:
    if jugador == 1:
      casilla4 = "X"
    else:
      casilla4 = "O"
  if int(tirada) == 5:
    if jugador == 1:
      casilla5 = "X"
    else:
      casilla5 = "O"
  if int(tirada) == 6:
    if jugador == 1:
      casilla6 = "X"
    else:
      casilla6 = "O"
  if int(tirada) == 7:
    if jugador == 1:
      casilla7 = "X"
    else:
      casilla7 = "O"
  if int(tirada) == 8:
    if jugador == 1:
      casilla8 = "X"
    else:
      casilla8 = "O"
  if int(tirada) == 9:
    if jugador == 1:
      casilla9 = "X"
    else:
      casilla9 = "O"
  if jugador == 1:
    jugador = 2
  else:
    jugador = 1
  
```

### funciondivision

#### Explicación

Este código es una función llamada `hazDivision` que realiza la operación matemática de división entre dos números. La función recibe dos parámetros: el dividendo (el número que se divide) y el divisor (el número por el cual se divide). El objetivo principal es calcular el resultado de dividir estos dos valores, pero también incluye varias comprobaciones importantes para garantizar la correcta ejecución del código.

Primero, verifica si ambos parámetros son números (enteros, flotantes o números complejos), lo que asegura que se pueden realizar operaciones matemáticas sobre ellos. Si uno de los parámetros no es un número, el programa intentará convertirlos a tipo numérico utilizando la función `float()`. Esto permite manejar situaciones en las que se puedan pasar strings que contengan números como argumentos.

Además, la función tiene una lógica para evitar la división por cero, lo cual es matemáticamente indefinido y causaría un error si no se controla. Si el divisor es cero o si los parámetros no pueden convertirse a tipo numérico debido a un error en la conversión, la función devuelve simplemente 0 como resultado.

Este tipo de manejo cuidadoso de errores es crucial para hacer que las aplicaciones sean más robustas y capaces de lidiar con entradas inesperadas o incorrectas sin fallar abruptamente.

```python
def hazDivision(dividendo,divisor):
  '''
    Función de división
    Entradas: dividendo y divisor que se espera que sean numéricos
    Salidas: resultado de la división como número (o cero si hay fallo)
    Capturas de error: 
      1.-Si es numérico
      2.-Si se puede convertir a número
      3.-Si no es división entre cero
  '''
  # Comprobamos si son números
  print("Entramos en la funcion")
  if isinstance(dividendo, (int, float, complex)) and isinstance(divisor, (int, float, complex)):
    print("parece que los parametros son numeros")
    # Comprobamos que el divisor no es cero
    if divisor != 0:
      print("parece que los puedo dividir")
      resultado = dividendo/divisor
      return resultado
    else:
      print("No puedo dividir porque el divisor es cero")
      resultado = 0
  else:
    print("Los parametros no son numeros, pero voy a intentar convertirlos")
    try:
      print("Intento convertir a numeros con exito")
      # Vamos a intentar convertirlo a numeros
      dividendo = float(dividendo)
      divisor = float(divisor)
      resultado = dividendo/divisor
      return resultado
    except:
      print("He intentado convertir a numeros, pero no he podido")
      return 0
```

### Actividades propuestas

### Actividad 1: Mejora la Función de División
**Descripción:** 
Modifica la función `hazDivision` para que maneje correctamente los casos en que se proporcionan parámetros incorrectos (por ejemplo, cadenas no numéricas). Asegúrate de que el código maneja adecuadamente las divisiones entre cero y devuelva un mensaje significativo cuando esto ocurra.

### Actividad 2: Depuración de Código
**Descripción:** 
Identifica los errores en la función `hazDivision` cuando se pasan parámetros incorrectos. Utiliza técnicas de depuración para encontrar y corregir estos errores, luego prueba tu código con diferentes entradas.

### Actividad 3: Documentar una Función
**Descripción:** 
Añade un docstring a la función `hazDivision` que explique claramente las entradas esperadas, los posibles casos de error y el resultado devuelto. La documentación debe ser precisa y útil para otros programadores.

### Actividad 4: Prueba Unitaria
**Descripción:** 
Escribe pruebas unitarias para la función `hazDivision` utilizando el marco de pruebas PyTest o cualquier otro framework que prefieras. Asegúrate de cubrir diferentes casos, como divisiones válidas, divisiones entre cero y entradas no numéricas.

### Actividad 5: Extracción de Funciones
**Descripción:** 
Separa la función `hazDivision` en un archivo externo llamado `funciondivision.py`. Luego, importa esta función desde otro script principal y prueba su funcionamiento. Asegúrate que el módulo se puede utilizar como una biblioteca.

### Actividad 6: Implementación de Raíz Cuadrada Segura
**Descripción:** 
Implementa la función `raizSegura` según las especificaciones proporcionadas en el archivo `010-ejercicio propuesto.py`. Asegúrate de incluir validación, manejo de errores y documentación adecuada.

### Actividad 7: Juego del Tres en Raya
**Descripción:** 
Completa la implementación del juego del tres en raya para dos jugadores. Mejora el código actualizando las variables de estado para que sean más fáciles de gestionar, como matrices o listas. Asegúrate de manejar bien las entradas del usuario.

### Actividad 8: Mejorando la Interactividad
**Descripción:** 
Añade funcionalidades al juego del tres en raya (archivo `011-tres en raya.py`) para mejorar su interactividad. Esto podría incluir una mejor presentación de los mensajes y notificaciones para el usuario, así como verificar que las entradas son válidas antes de actualizarlas.

### Actividad 9: Refactorización del Código
**Descripción:** 
Refactoriza la función `hazDivision` para mejorar su claridad y eficiencia. Esto podría implicar simplificar los bloques condicionales, usar funciones auxiliares donde sea apropiado o cualquier otra mejora que puedas pensar.

### Actividad 10: Integración de Funciones
**Descripción:** 
Integra la función `hazDivision` y la función `raizSegura` en un solo archivo principal. Diseña una interfaz simple para permitir al usuario seleccionar qué operación matemática desea realizar. Asegúrate de que tu código maneje correctamente las excepciones y proporcione feedback útil al usuario.

Estas actividades se basan directamente en los ejercicios proporcionados, adaptándolos a un nivel apropiado para estudiantes de Formación Profesional, con énfasis en la práctica técnica, depuración, documentación e integración de código.


<a id="ejercicio"></a>
## Ejercicio

### Introducción a los ejercicios

Esta carpeta contiene un conjunto de ejercicios diseñados para practicar el uso de estructuras de control en Python, como bucles y condicionales. Los problemas abordan situaciones prácticas que implican la interacción con el usuario (entrada), procesamiento de datos (cálculos, clasificaciones) y manejo de errores (try-except). Entre los ejercicios se encuentran simulaciones como contar días en un mes, subir escalones, entrenar dragones y duelos mágicos, que permiten a los estudiantes aplicar sus conocimientos sobre flujo de control y estructuras de datos. Estos ejercicios ayudan a desarrollar competencias esenciales como la lógica programática, la gestión de errores y el manejo eficiente de entradas y salidas en programas simples.

### ejercicio for

#### Explicación

Este código en Python utiliza un bucle `for` para imprimir mensajes sobre los días del mes. La función `range(1,31)` crea una secuencia que comienza desde el día 1 y termina en el día 30. Dentro del bucle, se imprime la frase "Hoy es el día [día] del mes", donde `[día]` cambia para cada iteración del bucle, desde el primer hasta el trigésimo día.

Además, hay una estructura de control `if` dentro del bucle que comprueba si el valor actual de `dia` es igual a 15. Si esta condición se cumple (es decir, cuando estamos en el día 15), entonces se imprime un mensaje especial felicitando al amigo por su cumpleaños.

Este tipo de código es útil para realizar tareas repetitivas y para añadir comportamientos específicos en momentos particulares, como recordar eventos importantes durante un periodo determinado.

```python
for dia in range(1,31):
  print("Hoy es el dia",dia,"del mes")
  if dia == 15:
    print("🎉 Hoy es el cumpleaños de mi amigo")
    
```

### ejercicio escalones

#### Explicación

Este código es un ejemplo de cómo utilizar un bucle `while` en Python para imprimir una secuencia numérica. El objetivo aquí es imprimir los números del 1 al 15, representando niveles o escalones. La variable `escalon` inicialmente se establece en 1. Luego, el programa entra en un bucle que seguirá ejecutándose mientras la variable `escalon` sea menor a 16.

Dentro del bucle, la instrucción `print("Estoy en el escalon",escalón)` muestra en pantalla una frase seguida del número actual de `escalon`. Después de imprimir esta frase, el valor de `escalon` se incrementa en 1 con la línea `escalon += 1`, lo que asegura que el bucle continuará hasta que `escalon` llegue a 16. Cuando esto sucede, el programa sale del bucle y termina.

Este tipo de estructura es importante porque permite repetir acciones varias veces mientras ciertas condiciones se mantengan verdaderas, facilitando la creación de secuencias numéricas o ciclos que requieren una actualización constante en cada iteración.

```python
escalon = 1

while escalon < 16:
  print("Estoy en el escalon",escalon)
  escalon += 1
```

### subir escalones de dos en dos

#### Explicación

Este fragmento de código es un bucle `while` que te permite subir una serie de escalones, pero no de uno en uno, sino de dos en dos. La variable `escalon` se inicializa con el valor 1, lo que significa que empezamos desde el primer escalón. El bucle seguirá ejecutándose mientras la variable `escalon` sea menor a 16. En cada iteración del bucle, se imprime un mensaje indicando en qué escalón nos encontramos y luego aumenta la variable `escalon` en 2 con la operación `escalon += 2`.

Este código es importante porque muestra cómo controlar el flujo de ejecución del programa mediante condicionales y ciclos. Además, ilustra una forma práctica de realizar incrementos más grandes que uno en un bucle, lo cual puede ser útil en situaciones donde necesitas procesar o mostrar información con saltos específicos.

```python
escalon = 1

while escalon < 16:
  print("Estoy en el escalon",escalon)
  escalon += 2
```

### dragones

#### Explicación

Este código es una pequeña aplicación en Python que simula el entrenamiento de dos dragones. Comienza solicitando al usuario que ingrese el nombre y la edad para cada uno de los dos dragones (A y B). Luego, verifica si las edades ingresadas son números enteros; si no lo son, automáticamente asigna a cada dragon una edad predeterminada de 100 años.

Después de asegurarse de que las edades sean correctas, el código clasifica a los dragones en tres categorías: Joven (menos de 50 años), Adulto (entre 50 y 199 años) o Anciano (más de 200 años). Esta clasificación es importante porque determina cómo se entrenará cada dragon.

Finalmente, el código entra en un bucle que dura tres días. Cada día, según la categoría del dragón, sus estadísticas de fuerza y resistencia aumentan. Los jóvenes ganarán 2 puntos en ambas áreas por día, mientras que los adultos y ancianos solo ganarán 1 punto. Al final de cada día, se imprime el progreso del entrenamiento para ambos dragones.

Este programa ayuda a entender cómo capturar la entrada del usuario, manejar excepciones y realizar operaciones basadas en condicionales, además de bucles, lo que es fundamental para aprender programación en Python.

```python
# En este bloque tomo los datos del usuario #######################

nombre_dragon_a = input("Dime el nombre del dragón A: ")
edad_dragon_a = input("Dime la edad del dragón A: ")
clasificacion_dragon_a = ""
fuerza_dragon_a = 0
resistencia_dragon_a = 0

print("El nombre del dragon A es:",nombre_dragon_a)
print("La edad del dragon A es:",edad_dragon_a)

nombre_dragon_b = input("Dime el nombre del dragón B: ")
edad_dragon_b = input("Dime la edad del dragón B: ")
clasificacion_dragon_b = ""
fuerza_dragon_b = 0
resistencia_dragon_b = 0

print("El nombre del dragon A es:",nombre_dragon_b)
print("La edad del dragon A es:",edad_dragon_b)

# En este bloque me aseguro de que son enteros #######################

try:
  edad_dragon_a = int(edad_dragon_a)
  print("He convertido la edad A correctamente")
except:
  edad_dragon_a = 100
  print("No he convertido la edad A correctamente, asigno 100")
  
try:
  edad_dragon_b = int(edad_dragon_b)
  print("He convertido la edad B correctamente")
except:
  edad_dragon_b = 100
  print("No he convertido la edad B correctamente, asigno 100")

# En este bloque clasifico a los dragones #######################

if edad_dragon_a < 50:
  clasificacion_dragon_a = "Joven"
elif edad_dragon_a >= 50 and edad_dragon_a <= 199:
  clasificacion_dragon_a = "Adulto"
elif edad_dragon_a >= 200:
  clasificacion_dragon_a = "Anciano"
print("El dragon A es:",clasificacion_dragon_a)
  
if edad_dragon_b < 50:
  clasificacion_dragon_b = "Joven"
elif edad_dragon_b >= 50 and edad_dragon_b <= 199:
  clasificacion_dragon_b = "Adulto"
elif edad_dragon_b >= 200:
  clasificacion_dragon_b = "Anciano"
print("El dragon B es:",clasificacion_dragon_b)

# Ahora los vamos a entrenar ###################################

for dia in range (1,4):
  # Como entrenar a tu dragon A
  if clasificacion_dragon_a == "Joven":
    fuerza_dragon_a += 2
    resistencia_dragon_a += 2
  elif clasificacion_dragon_a == "Adulto":
    fuerza_dragon_a += 1
    resistencia_dragon_a += 1
  elif clasificacion_dragon_a == "Anciano":
    fuerza_dragon_a += 1
    resistencia_dragon_a += 1
  print("Final del dia",dia)
  print("El dragon A ahora tiene ",fuerza_dragon_a,"de fuerza y ",resistencia_dragon_a,"de resistencia")
  # Como entrenar a tu dragon B
  if clasificacion_dragon_b == "Joven":
    fuerza_dragon_b += 2
    resistencia_dragon_b += 2
  elif clasificacion_dragon_b == "Adulto":
    fuerza_dragon_b += 1
    resistencia_dragon_b += 1
  elif clasificacion_dragon_b == "Anciano":
    fuerza_dragon_b += 1
    resistencia_dragon_b += 1
  print("Final del dia",dia)
  print("El dragon B ahora tiene ",fuerza_dragon_b,"de fuerza y ",resistencia_dragon_b,"de resistencia")
```

### enunciado

#### Explicación

Este fragmento de código describe una simulación en la que se registran dos dragones ingresados por el usuario, Dragón A y Dragón B. El programa solicita al usuario ingresar los nombres y edades de estos dragones. Luego, utiliza condicionales para clasificar a cada dragón según su edad: si es menor de 50 años es considerado "Joven", entre 50 y 199 años es un "Adulto" y si tiene 200 o más años se lo categoriza como "Anciano". En caso de que la entrada del usuario no pueda ser convertida a entero, el programa utiliza un valor por defecto (por ejemplo, 100 años) para evitar errores.

El código también incluye una parte en la cual simula tres días de entrenamiento para cada dragón. Durante este periodo, se incrementa la fuerza y la resistencia del dragón según su categoría: los jóvenes ganan 2 puntos de fuerza por día mientras que los adultos y ancianos sólo suman un punto adicional.

Finalmente, el programa implementa una función llamada `turnoDeAtaque` para simular duelos entre los dos dragones. Los duelos se llevan a cabo en un bucle while hasta que la salud de uno de ellos llegue a cero o menos. En cada turno del duelo, los dragones intercambian ataques y su salud disminuye dependiendo del daño calculado por `turnoDeAtaque`. El código asegura que las reglas se cumplan correctamente mediante aserciones y manejo de errores para garantizar la integridad de los datos a lo largo de toda la simulación.

```markdown
Descripción

Registro de dragones (entrada del usuario)

Pide por consola nombre y edad de cada dragón: Dragón A y Dragón B.

Convierte la edad a entero con try/except. Si falla, usa un valor por defecto (p. ej., 100 años).

Clasifica cada dragón por edad con condicionales:

< 50 → “Joven”

50–199 → “Adulto”

≥ 200 → “Anciano”

Entrenamiento (bucle for)

Simula 3 días de entrenamiento por dragón con un for.

Cada día incrementa:

fuerza (p. ej., +2 por día si es Joven, +1 si es Adulto, +1 si es Anciano).

resistencia (regla similar).

Muestra por pantalla el progreso de cada día (una línea por día).

Funciones obligatorias

calculaFuerzaBase(edad) -> int
Devuelve una fuerza inicial según la categoría (elige una regla y documéntala).

turnoDeAtaque(fuerza, resistenciaEnemigo) -> int
Calcula el daño de un ataque y lo devuelve (no hagas print dentro).

Duelo (bucle while)

Inicializa salud de cada dragón (p. ej., 30–50 puntos, a tu elección).

En un while que termine cuando uno llegue a salud ≤ 0:

Turno alterno: A golpea a B y luego B a A (usa un contador de turnos).

En cada golpe, llama a turnoDeAtaque(...) y resta salud al rival.

Si la salud cae por debajo de 0, ajústala a 0 y termina el bucle.

Puedes usar un for interno para contar “subturnos” o “intentos” del ataque (por ejemplo, 2 mordiscos por turno).

Manejo de errores

Cualquier entrada (edad, confirmaciones) debe pasar por try/except.

Aserciones

Incluye al menos 2 assert:

Que la salud nunca sea negativa tras un ajuste.

Que el daño devuelto por turnoDeAtaque sea numérico y ≥ 0.

Salida final

Muestra un resumen: nombres, categorías, fuerza final, resistencia final, y ganador del duelo.
```

### magos

#### Explicación

Este código simula un duelo entre un mago y un escudo mágico con ciertas reglas basadas en la edad del mago. En primer lugar, el programa solicita al usuario que ingrese la edad del mago. Si no se puede convertir esta entrada a un número entero, se establece automáticamente la edad en 100 años. Luego, clasifica al mago en uno de tres rangos: Aprendiz (menor de 30), Hechicero (entre 30 y 99) o Archimago (mayor o igual a 100). 

El programa también tiene una función llamada `poderBase` que devuelve un valor entero basado en la categoría del mago. Aprendices tienen el menor poder, seguidos de Hechiceros y luego Archimagos con el mayor.

Después de establecer estos parámetros iniciales, se simula una batalla rápida de dos turnos donde cada turno disminuye la energía del escudo mágico en función del poder base del mago. El daño en cada turno varía: "Hechizo de Fuego" (el primer turno) causa el doble entero de la mitad del poder base, mientras que "Hechizo de Rayo" (segundo turno) es un tercio entero del poder base. La energía del escudo disminuye en cada turno y si llega a cero o menos, se detiene el duelo.

Finalmente, el programa muestra una salida con la edad del mago, su categoría, su nivel de poder base y la cantidad de energía restante en el escudo después del duelo. Dependiendo del estado final del escudo, el programa también proporciona un mensaje indicando si el mago ha roto el escudo o si este ha resistido al ataque del mago.

Este ejercicio es importante porque enseña cómo manejar entradas de usuario y excepciones, clasificar datos en categorías diferentes, usar funciones para encapsular comportamientos específicos (como calcular poder base), implementar bucles para simular procesos repetitivos y asegurar la integridad de los datos con aserciones.

```python
Descripción

Crea un programa por consola que simule un duelo relámpago entre un mago y un hechizo protector.

Entrada con validación

Pide la edad del mago. Convierte a int con try/except.

Si falla, usa edad 100 por defecto.

Clasificación y poder base (selección + función)

Clasifica al mago según su edad:

<30 → Aprendiz

30–99 → Hechicero

≥100 → Archimago

Implementa poderBase(edad) -> int que devuelva:

Aprendiz → 5

Hechicero → 8

Archimago → 10

(documenta la función con un docstring).

Rompimiento del hechizo (bucle + selección)

El escudo mágico empieza con 15 puntos de energía.

Recorre dos turnos con un for de 1 a 2:

Turno 1 → “Hechizo de Fuego” → daño = poderBase // 2

Turno 2 → “Hechizo de Rayo” → daño = poderBase // 3

Resta el daño al escudo.

Si la energía del escudo baja de 0, ajústala a 0 y sal del bucle.

Aserciones mínimas

Tras calcular cada daño: assert que el daño es numérico y ≥ 0.

Tras ajustar la energía: assert que la energía es ≥ 0.

Salida

Muestra: edad, rango del mago, poder base, energía final del escudo y resultado:

Si la energía es 0 → “¡El mago rompe el escudo mágico!”

Si no → “El escudo resiste al duelo relámpago.”


# pedir edad
edad_mago = input("Introduce la edad del mago: ")
# convertir a entero
try:
  edad_mago = int(edad_mago)
except: 
  # si falla, pon 100
  edad_mago = 100

# clasifica por edad
# menor que 30 es Aprendiz
# de 30 a 99 es Hechicero
# mas de 100 es Archimago

# funcion poderBase, recibe edad, devuelve entero
# si es aprendiz, devuelve 5
# si es hechicero, devuelve 8
# si es archimago, devuelve 10

# empezamos bucle
# escudo empieza con 15 puntos
# recorre dos turnos con for
# turno 1 fuego daño = poderBase // 2
# turno 2 hechizo rayo = daño = poderBase // 3
# resta el daño al escudo
# si energia escudo baja de cero, ajusta a cero

# tras cada daño, print de daño y mayor que cero
# tras ajuste energia, print y energia es mayor que cero

# salida: edad, rango, poder base, energia del escudo
# energia es cero, mago rompe escudo
# energia mayor que cero, escudo resiste duelo
```

### Actividades propuestas

### Actividad 1: Conteo de Días del Mes
**Descripción:**  
Los estudiantes deben escribir un programa similar al ejercicio `001-ejercicio for.py` para contar los días del mes. El objetivo es que comprendan y utilicen correctamente el bucle `for` en Python.

### Actividad 2: Escalones Incrementales
**Descripción:**  
Los alumnos deberán crear un código similar a `002-ejercicio escalones.py`, pero deben adaptarlo para mostrar los números del 1 al 15 usando un bucle `while`. Esta actividad reforzará su comprensión de la estructura `while`.

### Actividad 3: Subir Escalones Saltando
**Descripción:**  
Se les pedirá a los estudiantes que tomen el ejercicio `003-subir escalones de dos en dos.py` como base para crear un programa que recorra desde el primer peldaño hasta el décimo quinto, saltando dos escalones cada vez. Esto ayudará a consolidar su conocimiento sobre la estructura `while`.

### Actividad 4: Clasificación de Dragones
**Descripción:**  
A partir del código en `004-dragones.py`, los estudiantes tendrán que clasificar dragones basándose en su edad y luego calcular sus atributos. Esta actividad profundizará el uso de condicionales complejos y manejo de errores.

### Actividad 5: Simulación de Entrenamiento de Dragones
**Descripción:**  
Usando `004-dragones.py` como punto de partida, los estudiantes deberán desarrollar una simulación que realice un entrenamiento para los dragones durante varios días. El objetivo es familiarizarse con bucles anidados y condiciones complejas.

### Actividad 6: Registro de Magos
**Descripción:**  
Basándose en `005-magos.py`, los estudiantes deben crear un programa que clasifique a un mago según su edad y determine su poder base. Esto reforzará sus habilidades con la lógica condicional y manejo de excepciones.

### Actividad 7: Duelos Mágicos
**Descripción:**  
Se les pedirá a los estudiantes que completen el código en `005-magos.py` para simular un duelo entre un mago y su hechizo protector. La actividad incluirá la implementación de métodos como `poderBase()` y la simulación de turnos de ataque, consolidando así su entendimiento del manejo de errores y lógica condicional.

### Actividad 8: Análisis de Errores en Simulaciones
**Descripción:**  
Los estudiantes deberán revisar los ejercicios `004-dragones.py` y `005-magos.py`, identificar posibles puntos donde podrían ocurrir errores (como entradas no numéricas) e implementar soluciones utilizando `try/except`. Esta actividad ayudará a reforzar el manejo de excepciones en Python.

### Actividad 9: Mejora del Registro de Dragones
**Descripción:**  
Los alumnos deben tomar el ejercicio `004-dragones.py` y mejorar la funcionalidad añadiendo un método que calcule automáticamente la salud inicial basada en la edad del dragón. Esto reforzará su habilidad para implementar funciones y métodos.

### Actividad 10: Implementación de Bucle While en Duelos
**Descripción:**  
A partir del ejercicio `005-magos.py`, los estudiantes deben modificar el código para simular un duelo utilizando un bucle `while` en lugar de un `for`. Esto permitirá que los duelos se realicen hasta que una condición específica sea satisfecha, reforzando la estructura del bucle `while` y las condiciones de parada.


<a id="ejercicio-de-final-de-unidad-2"></a>
## Ejercicio de final de unidad

### Introducción a los ejercicios

Este conjunto de ejercicios en Python está diseñado para ayudarte a familiarizarte con los conceptos básicos de programación, como impresión de texto, manejo de variables y tipos de datos. Los ejercicios abarcan desde la creación simple de programas que imprimen mensajes hasta el desarrollo de una calculadora básica que realiza cálculos numéricos y muestra resultados en pantalla. Además, practicarás técnicas de entrada de usuario y conversión entre diferentes tipos de datos para garantizar que tus operaciones matemáticas sean precisas. Estos ejercicios te preparan para dominar la estructura y el flujo básico de un programa Python, sentando las bases para temas más avanzados en tu formación profesional.

### Holamundo

#### Explicación

Este código es muy simple y básico. La función `print()` se utiliza para mostrar información en la pantalla. En este caso, el programa está imprimiendo una frase que dice "Hola mundo desde Python". Esta expresión es tradicionalmente usada por programadores principiantes cuando aprenden un nuevo lenguaje de programación, como un saludo o prueba básica del sistema de desarrollo. Es importante porque demuestra que tu entorno de trabajo (interpretador de Python) está configurado correctamente y estás listo para comenzar a escribir programas más complejos.

```python
print("Hola mundo desde Python")
```

### variables

#### Explicación

Este código es una parte muy básica de la programación en Python. Se trata de asignar valores a variables, que son como cajas donde guardamos información para usarla después en el programa. Aquí, se crean dos variables: "nombre" y "edad". A la variable "nombre" se le da un valor que es una cadena de texto, es decir, caracteres entre comillas ("Jose Vicente"), mientras que a "edad" se le asigna un número entero (47). Estas líneas son importantes porque permiten al programa recordar información específica sobre un usuario o objeto en el contexto del software.

```python
nombre = "Jose Vicente"
edad = 47
```

### salidas

#### Explicación

Este fragmento de código sirve para mostrar cómo imprimir información en la pantalla utilizando el lenguaje Python. En primer lugar, se crea una variable llamada `nombre` y se le asigna el valor `"Jose Vicente"`. Luego, utiliza la función `print()` para mostrar un mensaje junto con el contenido de la variable `nombre`. El texto "Mi nombre es" se imprime seguido del valor almacenado en `nombre`, que en este caso es "Jose Vicente". Esto es útil cuando queremos mostrar datos o información al usuario en una interfaz simple y directa.

```python
nombre = "Jose Vicente"
print("Mi nombre es",nombre)
```

### variar una variable

#### Explicación

Este código muestra cómo se pueden cambiar y actualizar los valores de una variable en Python. En este caso, la variable llamada `nombre` cambia dos veces durante el programa. Primero, le asignamos a `nombre` el valor "Jose Vicente" y luego imprimimos ese nombre usando la función `print`. Después, actualizamos la variable `nombre`, esta vez con el valor "Juan", y volvemos a imprimirlo.

La importancia de este código reside en demostrar cómo las variables pueden ser modificadas durante la ejecución del programa. Esto es crucial en programación porque nos permite crear programas que responden dinámicamente a diferentes situaciones, almacenando datos que pueden cambiar con el tiempo o bajo ciertas condiciones. En resumen, este ejemplo ilustra la flexibilidad y la capacidad de actualización de las variables en Python.

```python
nombre = "Jose Vicente"
print("Mi nombre es",nombre)

nombre = "Juan"
print("Mi nombre es",nombre)
```

### identificadores permitidos

#### Explicación

Este fragmento de código en Python muestra cómo se definen variables con nombres válidos y cuáles son los que no lo son. En este caso, la primera línea define una variable llamada `nombre` que almacena el string "Jose". La siguiente línea crea otra variable llamada `nombre2`, también almacenando un nombre pero en esta ocasión "Vicente". 

El código incluye comentarios con ejemplos de nombres de variables que no son válidos: `"2nombre"` (no puede comenzar con un número), `"nombre-completo"` y `"nombre completo"` (no se pueden usar guiones bajos o espacios en blanco dentro del nombre). Finalmente, hay una línea donde la variable `nombreCompleto` es definida correctamente usando mayúsculas para separar las palabras, aunque el código dice que esto está permitido pero no es recomendado debido a la convención de nombres común en Python.

Este bloque te enseña sobre los criterios para nombrar variables en Python y por qué es importante seguir ciertas reglas cuando eliges un nombre para tus variables.

```python
nombre = "Jose"
nombre2 = "Vicente"
# 2nombre = "Jose Vicente"
nombre_completo = "Jose Vicente"
#nombre-completo = "Jose Vicente"
#nombre completo = "Jose Vicente"
nombreCompleto = "Jose Vicente" # Es legal pero no se recomienda
```

### comentarios

#### Explicación

Este fragmento de código está mostrando cómo se utilizan los comentarios en Python. Los comentarios son líneas que el intérprete de Python ignora y están destinados a proporcionar explicaciones o notas sobre qué hace cierto trozo del código para que otros programadores (y uno mismo, cuando revisa el código más tarde) puedan entenderlo mejor.

En el código, hay dos tipos de comentarios: 

1. El primer tipo es un comentario de una sola línea que comienza con el carácter numeral (#). Todo lo que escribas después del numeral hasta el final de la línea no será interpretado por Python como parte del programa y servirá simplemente para proporcionar información.

2. El segundo tipo son los comentarios en bloque, también conocidos como docstrings. Se crean colocando tres comillas simples (') al principio y al final del texto que deseas comentar. Esto permite escribir múltiples líneas de explicación sin necesidad de poner un numeral en cada línea.

Los comentarios son esenciales para la legibilidad y el mantenimiento del código, ya que ayudan a documentar el propósito o las especificaciones de diferentes secciones del programa.

```python
# Esto es un comentario de una única línea

'''
    Esto es un comentario
    Esto sigue siendo un comentario
    Y esto también lo es
'''
```

### Explicacion del codigo

#### Explicación

Este fragmento de código en Python establece una variable llamada `edad` y le asigna un valor numérico específico. En concreto, la línea `edad = 47` indica que la variable `edad` va a almacenar el número 47. Aquí, `edad` es el nombre (o identificador) que nosotros elegimos para referirnos a esa información en nuestro programa; `=` es el operador de asignación, que nos permite vincular un valor específico con el identificador que hemos definido. Finalmente, `47` es el valor literal, un número entero que no está entre comillas y se toma exactamente como es.

Este tipo de declaración es fundamental en programación porque nos permite almacenar datos específicos que pueden ser utilizados y manipulados a lo largo del programa. Por ejemplo, podrías usar la variable `edad` más adelante para realizar cálculos o tomar decisiones basadas en el valor de esa edad, como determinar si una persona es mayor de edad.

```python
edad = 47
# edad es el identificador
# = es el operador de asignación
# 47 es el valor literal que se es está asignando al identificador
```

### Tipos de datos

#### Explicación

Este fragmento de código está dedicado a la creación y asignación de variables en Python, que es fundamental para entender cómo almacenar diferentes tipos de datos. Aquí se definen cuatro variables: `nombre`, `edad`, `altura` y `vivo`. Cada una tiene un tipo de dato distinto. La variable `nombre` almacena una cadena de texto o "string", que en este caso es el nombre "Jose Vicente". La variable `edad` almacena un número entero, con el valor 47, lo que podría representar la edad del individuo descrito. La variable `altura` contiene un número decimal (también llamado float), que indica una altura de 1.78 metros. Finalmente, `vivo` es un booleano que solo puede tomar dos valores: verdadero o falso. En este caso se ha establecido en True, lo cual podría interpretarse como si la persona está viva.

Este código es importante porque demuestra cómo Python maneja diferentes tipos de datos básicos, permitiendo al programador almacenar y manipular información variada, desde texto hasta números enteros y decimales, y hasta estados lógicos.

```python
nombre = "Jose Vicente" # Cadena
edad = 47 # Entero
altura = 1.78 # Decimal
vivo = True # Booleano
```

### Entradas

#### Explicación

Este código en Python se utiliza para interactuar con el usuario, permitiéndole introducir información y luego mostrar un mensaje basado en esa entrada. La primera línea del código, `nombre = input("Dime tu nombre: ")`, pide al usuario que ingrese su nombre a través de la consola (también conocida como terminal o línea de comandos). Cuando el programa llega a esta línea, se detiene y espera que el usuario teclee algo seguido del botón "Enter". Todo lo que el usuario escribe en este punto se guarda en una variable llamada `nombre`.

Luego, la segunda línea, `print("Tu nombre es: ", nombre)`, muestra por pantalla un mensaje que incluye el valor almacenado en la variable `nombre`. Esto significa que después de que el usuario ingrese su nombre y presione "Enter", verá algo como "Tu nombre es: Juan" (si el usuario tecleó "Juan") en la pantalla.

Este tipo de código es importante porque permite a las aplicaciones interactuar con los usuarios, lo cual es una habilidad fundamental cuando se desarrollan programas que requieren entrada del usuario.

```python
nombre = input("Dime tu nombre: ")
print("Tu nombre es: ",nombre)
```

### Entrada y problema

#### Explicación

Este código solicita al usuario que introduzca su edad mediante el comando `input`, mostrándole un mensaje en pantalla que dice "Dime tu edad:". Cuando el usuario introduce un número y presiona Enter, lo que realmente se guarda en la variable `edad` es esa entrada como texto (o cadena de caracteres), no como un número. Luego, el código imprime en pantalla una frase que indica "El doble de tu edad es:", seguida del valor introducido por el usuario sin modificarlo ni duplicarlo matemáticamente.

Es importante entender que `input` siempre devuelve la entrada del usuario como texto (cadena), por lo que si se necesita realizar operaciones matemáticas con esa entrada, primero hay que convertirla a un tipo de dato numérico adecuado. En este caso, simplemente muestra el valor ingresado sin hacer ningún cálculo real.

```python
edad = input("Dime tu edad: ")
print("El doble de tu edad es: "+edad)
```

### Cambio de tipo de dato

#### Explicación

Este código solicita al usuario que ingrese su edad y luego realiza algunas operaciones con esa información. Primero, la función `input()` captura lo que el usuario teclea cuando se le pide "Dime tu edad:". Lo que escriba el usuario será almacenado en la variable `edad`, pero inicialmente este valor es un texto (o cadena de caracteres). Luego, el código convierte esa entrada de texto a un número entero mediante la función `int()`, y ese nuevo número entero se guarda en una variable llamada `entero`.

Después de convertir la edad a un número entero, el código calcula cuánto es el doble de esa edad multiplicando `entero` por 2. El resultado se almacena en la variable `doble`. Finalmente, intenta mostrar este resultado utilizando la función `print()`, pero hay un error: cuando concatenamos cadenas (texto) con otros tipos de datos como números enteros en Python, necesitamos asegurarnos de que todos los elementos sean del mismo tipo o convertirlos adecuadamente. En este caso, deberíamos convertir el valor de `doble` a una cadena antes de imprimirlo para evitar errores.

Esta secuencia de instrucciones es importante porque demuestra cómo obtener información del usuario y manipular diferentes tipos de datos en Python, como pasar de un texto a un número entero. También muestra la importancia de manejar correctamente los tipos de datos al momento de mostrar o procesar información.

```python
# Le pregunto al usuario por su edad
edad = input("Dime tu edad: ")
# Me aseguro de convertir la edad a un número entero
entero = int(edad)
# Calculo el doble de un número entero
doble = entero*2
# Saco el resultado por pantalla
print("El doble de tu edad es: "+doble)
```

### literales

#### Explicación

En este fragmento de código, se están asignando valores a dos variables llamadas `nombre` y `edad`. La variable `nombre` almacena la cadena `"Jose Vicente"`, que es un texto o una secuencia de caracteres entre comillas. Este tipo de valor se conoce como literal de cadena en Python. Por otro lado, la variable `edad` contiene el número 47, que es un valor entero o literal de tipo numérico. Estos literales son importantes porque permiten almacenar datos específicos para su uso posterior en operaciones y estructuras de control del programa, como comparaciones, bucles y más.

```python
nombre = "Jose Vicente"
# Jose Vicente es el literal, y es de tipo cadena

edad = 47
# 47 es el literal, y es de tipo entero
```

### constantes

#### Explicación

Este código muestra cómo funciona la asignación y reasignación de valores en Python, pero también subraya una buena práctica que los programadores suelen seguir. Al principio, se define un valor para `PI` (que es un número importante en matemáticas) como 3.1415 utilizando letras mayúsculas. Luego, se imprime el valor de `PI`. A continuación, se cambia el valor de `PI` a 4 y vuelve a imprimirlo. Esto demuestra que aunque generalmente se recomienda no cambiar el valor de constantes, en Python puedes reasignar cualquier variable. Sin embargo, es importante recordar que por convención, los nombres de las constantes (valores que no cambian) deben escribirse en mayúsculas para diferenciarlos de las variables normales, que se escriben en minúsculas. Esto ayuda a otros programadores a entender mejor el código y evitar errores.

```python
PI = 3.1415

print("PI vale",PI)

PI = 4 # Le cambio el valor a PI

print("PI vale",PI)
# Las constantes deben formularse con mayúsculas
# Las variables deben formularse con minúsculas
```

### Diferencia

#### Explicación

Este fragmento de código está trabajando con variables en Python y muestra cómo se pueden cambiar los tipos de datos asociados a una misma variable. En primer lugar, se define una constante llamada `PI` y se le asigna el valor numérico 3.1416, lo que significa que `PI` ahora es un número flotante (un número con decimales). Sin embargo, después de eso, la misma variable `PI` se reasigna para contener una cadena de texto ("unnumero"). Esto demuestra que en Python, las variables son muy flexibles y pueden cambiar su tipo de dato a lo largo del programa. Es importante tener cuidado con esto porque si un bloque de código espera que `PI` sea un número, pero luego se convierte en una cadena, podría generar errores cuando se intenta realizar operaciones matemáticas con ella.

```python

# La constante es PI
# El literal es 3.1416

PI = 3.1416

PI = "unnumero"
```

### operadores aritmeticos

#### Explicación

Este fragmento de código en Python muestra ejemplos básicos del uso de operadores aritméticos. Los operadores aritméticos son fundamentales para realizar cálculos matemáticos dentro de un programa. En este caso, el código realiza cinco impresiones en la consola:

1. La suma de 4 y 3.
2. La resta de 4 menos 3.
3. La multiplicación de 4 por 3.
4. La división de 4 entre 3.
5. El cálculo del residuo (resto) cuando se divide 4 entre 3.

Cada operación aritmética está representada por un operador específico: `+` para suma, `-` para resta, `*` para multiplicar, `/` para dividir y `%` para calcular el resto de una división. Estos operadores permiten a los programadores realizar cálculos complejos e integrar matemáticas en sus programas de manera sencilla y directa. Es importante entender estos conceptos básicos antes de avanzar hacia estructuras más complejas en la programación.

```python
print(4+3)
print(4-3)
print(4*3)
print(4/3)
print(4%3)
```

### operadores de comparacion

#### Explicación

Este código muestra ejemplos de cómo se utilizan los operadores de comparación en Python. Los operadores como `<`, `<=`, `>`, `>=`, `==` y `!=` permiten comparar dos valores numéricos (o variables que contengan esos valores) para determinar si una condición es verdadera o falsa. En cada línea del código, se compara el número 4 con el número 3 usando diferentes operadores de comparación.

El resultado de estas comparaciones es impreso en pantalla. Por ejemplo, la primera línea `print(4 < 3)` evalúa si 4 es menor que 3 y devuelve un valor booleano (`False`), ya que esta afirmación no es verdadera. De manera similar, las otras líneas de código verifican condiciones como "4 es mayor o igual a 3" y devuelven `True`, porque estas comparaciones son correctas.

Entender estos operadores es crucial en la programación porque nos permiten tomar decisiones basadas en la lógica del programa, lo que es fundamental para construir programas más complejos e interactivos.

```python
print(4 < 3)
print(4 <= 3)
print(4 > 3)
print(4 >= 3)
print(4 == 3)
print(4 != 3)
```

### operadores arimeticos abreviados

#### Explicación

Este código muestra cómo utilizar operadores aritméticos en Python para modificar el valor de una variable. La variable `edad` inicialmente contiene el número 47. El código luego realiza varias operaciones, primero sumando y restando 2 unidades a la edad utilizando tanto las expresiones tradicionales (como `edad = edad + 2`) como los operadores abreviados (como `edad += 2`). Los mismos procedimientos se aplican para multiplicar y dividir por dos. Estos operadores abreviados no solo hacen que el código sea más conciso, sino también más fácil de leer y mantener.

Es importante destacar cómo los operadores como `+=`, `-=` , `*=` y `/=` simplifican la escritura del código al combinar una operación aritmética con la asignación de un valor a una variable en una sola línea. Esto es especialmente útil cuando se necesitan realizar varias actualizaciones rápidas o repetidas sobre las mismas variables, mejorando así la legibilidad y eficiencia del código.

```python
edad = 47
# Le quiero sumar dos unidades
edad = edad + 2
edad += 2
#Le quiero restar dos unidades
edad = edad - 2
edad -= 2
# Lo quiero multiplicar por dos
edad = edad * 2
edad *= 2
# Lo quiero dividir por dos
edad = edad / 2
edad /= 2
```

### operadores booleanos

#### Explicación

Este fragmento de código utiliza operadores booleanos en Python para evaluar y mostrar resultados lógicos. Los operadores `and` y `or` son utilizados aquí para combinar varias comparaciones (como 4 es igual a 4, 3 es igual a 3) y determinar si el resultado total es verdadero (`True`) o falso (`False`). Cada línea del código compara diferentes números usando los operadores de igualdad `==` y luego usa `and` para asegurar que todas las comparaciones sean verdaderas, o `or` para verificar si al menos una de ellas es verdadera. Por ejemplo, en la primera línea se comprueba si 4 es igual a 4, 3 es igual a 3 y 2 es igual a 2, lo cual resulta en un valor `True`. Sin embargo, en la segunda línea, aunque las primeras dos comparaciones son correctas, la última (2 es igual a 1) es falsa, por lo que el resultado final con `and` es `False`.

Este tipo de ejercicios ayuda a entender cómo se combinan múltiples condiciones lógicas para tomar decisiones en programas más complejos. Es fundamental aprender esto ya que en la programación real estas operaciones son utilizadas constantemente para controlar el flujo del programa basándose en diversas condiciones.

```python
print(4 == 4 and 3 == 3 and 2 == 2)
print(4 == 4 and 3 == 3 and 2 == 1)

print(4 == 4 or 3 == 3 or 2 == 1)
print(4 == 4 or 3 == 2 or 2 == 1)
print(4 == 3 or 3 == 2 or 2 == 1)
```

### Ejercicio1-Calculadora de impuestos

#### Explicación

El fragmento de código es la descripción o el encabezado de un programa en Python llamado "Calculadora de Impuestos". Este programa tiene como objetivo principal ayudar al usuario a calcular impuestos, específicamente el IVA (Impuesto sobre Valor Añadido) y el total pagadero después del impuesto. La versión actual es la v0.1, creada por Jose Vicente Carratalá.

El funcionamiento básico del programa es que solicita al usuario que introduzca una base imponible, que es el precio original antes de aplicar el IVA. Luego, calcula automáticamente el monto correspondiente a este impuesto y proporciona el total resultante después de incluir el IVA. Este tipo de herramientas son útiles para entender mejor cómo afectan los impuestos al costo final de un producto o servicio.

Esta práctica es importante porque ayuda a comprender conceptos fundamentales de la programación, como la interacción con el usuario y la manipulación matemática en Python, además de ser relevante desde una perspectiva práctica para entender cálculos fiscales.

```python
'''
    Calculadora de Impuestos
    v0.1 por Jose Vicente Carratalá
    Funcionamiento: Introduce una base imponible y se calcula IVA y total
'''
```

### Calculadora

#### Explicación

Este código es el inicio de un programa en Python que se utiliza para calcular impuestos, específicamente el IVA y el total de una factura basándose en la base imponible introducida por el usuario. En este fragmento, primero se declaran tres variables: `base_imponible`, `total_iva` e `total_factura`. Estas variables almacenarán los valores necesarios para realizar los cálculos.

Luego, el programa solicita al usuario que introduzca la base imponible de una factura mediante la función `input()`. La entrada proporcionada por el usuario se guarda en la variable `base_imponible`.

Es importante destacar que este código solo recoge la información necesaria para comenzar con los cálculos; las partes donde se calculan el IVA y el total de la factura aún no están implementadas y probablemente vendrán después de esta parte del programa.

```python
'''
    Calculadora de Impuestos
    v0.1 por Jose Vicente Carratalá
    Funcionamiento: Introduce una base imponible y se calcula IVA y total
'''

# Este programa no tiene importaciones

# Creo variables
base_imponible = 0
total_iva = 0
total_factura = 0

# Aquí pondría las funciones/clases

# Ahora calculamos
base_imponible = input("Introduce la base imponible de la factura: ")
```

### Calculadora

#### Explicación

Este fragmento de código es parte de un programa sencillo en Python que actúa como una calculadora para calcular impuestos basados en la base imponible de una factura. El objetivo principal del programa es pedir al usuario que introduzca el monto sin IVA (base imponible) y luego realizar cálculos para determinar cuánto es el IVA aplicado a ese monto y cuál sería el total de la factura.

El código comienza estableciendo algunas variables vacías: `base_imponible`, `total_iva` y `total_factura`. Estas variables se usarán más adelante en el programa para almacenar los valores calculados. Luego, muestra mensajes al usuario en pantalla que explican brevemente lo que hace el programa y pide al usuario que introduzca la base imponible de una factura.

Es importante destacar que este código es solo el principio del programa; todavía no realiza cálculos ni presenta resultados. La entrada proporcionada por el usuario (la base imponible) se guarda en la variable `base_imponible` como un texto, aunque técnicamente debería convertirse a número antes de realizar cualquier cálculo adicional.

```python
'''
    Calculadora de Impuestos
    v0.1 por Jose Vicente Carratalá
    Funcionamiento: Introduce una base imponible y se calcula IVA y total
'''

# Este programa no tiene importaciones

# Creo variables
base_imponible = 0
total_iva = 0
total_factura = 0

# Aquí pondría las funciones/clases

# Ahora calculamos
print("Programa calculadora de impuestos")
print("(c) 2025 Jose Vicente Carratalá")
print("Introduce una base y te calculo el IVA y el total")
base_imponible = input("Introduce la base imponible de la factura: ")
```

### Calculo de IVA

#### Explicación

Este código es un programa simple en Python que calcula el Impuesto sobre Valor Añadido (IVA) y el total de una factura a partir de la base imponible introducida por el usuario. El programa comienza solicitando al usuario que ingrese el valor de la base imponible, es decir, el precio original antes del IVA. Luego, calcula el IVA aplicando un tipo del 21% (multiplicando la base imponible por 0.21) y determina el total sumando el IVA a la base imponible. Finalmente, muestra en pantalla tanto el valor del IVA como el total de la factura.

Es importante destacar que este programa utiliza funciones básicas de Python, como `input` para leer datos introducidos por teclado y operaciones matemáticas simples para realizar los cálculos necesarios. Además, se hace uso de la estructura de impresión (`print`) para mostrar el resultado del cálculo al usuario de manera clara y fácil de entender.

Este tipo de programa es útil en contextos prácticos, como en tiendas o oficinas donde se requiere calcular rápidamente el IVA y el precio final de los productos o servicios.

```python
'''
    Calculadora de Impuestos
    v0.1 por Jose Vicente Carratalá
    Funcionamiento: Introduce una base imponible y se calcula IVA y total
'''

# Este programa no tiene importaciones

# Creo variables
base_imponible = 0
total_iva = 0
total_factura = 0

# Aquí pondría las funciones/clases

# Ahora calculamos

# Primero pido una entrada
print("Programa calculadora de impuestos")
print("(c) 2025 Jose Vicente Carratalá")
print("Introduce una base y te calculo el IVA y el total")
base_imponible = float(input("Introduce la base imponible de la factura: "))

# Luego realizo cálculos
total_iva = base_imponible*0.21
total_factura = base_imponible + total_iva

# Por último expreso una salida
print("El IVA de la factura es: ",total_iva)
print("El total de la factura es: ",total_factura)
```

### Actividades propuestas

### Actividades Propuestas para Estudiantes de Formación Profesional (FP)

#### 1. **Bienvenida al Alumno**
- **Descripción**: Crea un programa en Python que salude al usuario mostrando su nombre y el día actual.
- **Objetivo**: Aprender a utilizar funciones básicas como `print` y manejar variables.

#### 2. **Edad del Usuario**
- **Descripción**: Diseña un programa que pregunte la edad del usuario e imprima una frase indicando cuántos años tiene.
- **Objetivo**: Familiarizarse con el uso de entradas y salidas en Python.

#### 3. **Calculadora Básica**
- **Descripción**: Implementa una calculadora sencilla que permita al usuario sumar o restar dos números introducidos por teclado.
- **Objetivo**: Entender la importancia de los operadores aritméticos y cómo manejar entradas numéricas.

#### 4. **Comparación de Edades**
- **Descripción**: Escribe un programa que compare las edades de dos personas y determine quién es mayor o si tienen la misma edad.
- **Objetivo**: Practicar el uso de operadores de comparación en Python.

#### 5. **Cálculo del IVA**
- **Descripción**: Desarrolla una aplicación que calcule el importe del IVA y el total a pagar a partir de un valor base imponible introducido por el usuario.
- **Objetivo**: Aprender cómo realizar cálculos matemáticos en Python, incluyendo operadores aritméticos y entradas numéricas.

#### 6. **Cambio de Tipos de Datos**
- **Descripción**: Crea un programa que convierta una entrada de texto (representando un número) a entero, y luego imprima el doble del número.
- **Objetivo**: Dominar la conversión entre tipos de datos en Python.

#### 7. **Saludo Personalizado**
- **Descripción**: Diseña un programa que reciba como entrada el nombre y la edad del usuario, y genere una salida personalizada con esta información.
- **Objetivo**: Mejorar las habilidades de manejo de variables y concatenación de cadenas.

#### 8. **Operaciones Básicas**
- **Descripción**: Implementa un programa que permita realizar operaciones básicas (suma, resta, multiplicación) entre dos números introducidos por el usuario.
- **Objetivo**: Práctica con funciones, variables y cálculos matemáticos en Python.

#### 9. **Comprobación de Identificadores**
- **Descripción**: Escribe un programa que evalúe si los identificadores utilizados cumplen las normas (uso correcto de mayúsculas/minúsculas).
- **Objetivo**: Aprender a manejar y validar nombres de variables y constantes en Python.

#### 10. **Biblioteca Personal**
- **Descripción**: Crea un programa simple que simule una pequeña biblioteca, donde el usuario pueda agregar libros (título y autor) y listarlos después.
- **Objetivo**: Introducción a la manipulación de estructuras de datos básicas como listas.

Estas actividades están diseñadas para ayudar a los estudiantes a dominar conceptos fundamentales de programación en Python, alineados con el nivel y el contenido que se observa en la carpeta proporcionada.



<a id="desarrollo-de-clases"></a>
# Desarrollo de clases

<a id="concepto-de-clase"></a>
## Concepto de clase

### Introducción a los ejercicios

Esta carpeta contiene una serie de ejercicios diseñados para introducir a los estudiantes al concepto fundamental de la programación orientada a objetos (POO) mediante el uso de clases en Python. Los problemas abordan desde la creación básica de clases hasta la implementación de propiedades y métodos dentro de ellas, enfatizando cómo encapsular datos y comportamientos para mejorar la organización del código y facilitar su mantenimiento y escalabilidad.

A través de estos ejercicios, los estudiantes practicarán habilidades clave como la definición de clases, instanciación de objetos, creación de propiedades y métodos, así como entender cómo las clases permiten una mejor estructuración del código en comparación con el paradigma estructurado tradicional. Estos ejercicios son esenciales para comprender los principios fundamentales que subyacen a la programación orientada a objetos y su importancia en el desarrollo de software más complejo.

### Introduccion

#### Explicación

Este fragmento de texto está introduciendo el concepto de clases en programación, haciendo una analogía con lo que ya conoces sobre funciones. Hasta ahora, has aprendido cómo las funciones ayudan a agrupar (encapsular) un conjunto de instrucciones para resolver tareas específicas. Al encapsular código, puedes reutilizarlo fácilmente y externalizar detalles complicados dentro del cuerpo de la función.

Las clases son una forma más avanzada de encapsulamiento que lleva este principio mucho más allá. Mientras que las funciones te permiten agrupar acciones, las clases te permiten crear plantillas para objetos complejos, definiendo tanto sus propiedades (como atributos o datos) como el comportamiento (funciones asociadas). Esto hace que sea más fácil gestionar y reutilizar código cuando estás trabajando en proyectos grandes y complicados.

```markdown
Anteriormente hemos visto como las funciones permiten encapsular código
Cuando encapsulamos podemos

- Reutilizar 
- Externalizar

Las clases llevan esta metodología mucho más alla
```

### clase gato

#### Explicación

Este fragmento de código es una definición básica de una clase en Python llamada `Gato`. Una clase en programación es como un plano o plantilla para crear objetos. En este caso, la clase `Gato` no tiene características ni métodos propios implementados (eso lo indica el uso de la palabra clave `pass`, que simplemente significa "no hacer nada" y sirve aquí como marcador temporal). Sin embargo, aunque está vacía, esta definición de clase establece las bases para crear una estructura más compleja en el futuro. Es importante porque permite a los programadores empezar a pensar en la forma en que quieren organizar su código y cómo podrían estructurar objetos en su programa, como datos y comportamientos específicos relacionados con gatos.

```python
class Gato:
  pass
  
```

### instanciamos un gato

#### Explicación

Este fragmento de código es una introducción básica al concepto de clases en Python, que es fundamental en el desarrollo orientado a objetos. Primero, se define una clase llamada `Gato`. La palabra clave `class` indica que estamos creando un nuevo tipo de objeto, y entre paréntesis no hay nada porque nuestro gato no hereda características directamente de otra clase. Dentro de la clase, el comando `pass` simplemente significa "haz nada" para evitar errores mientras creamos el resto del código.

Luego, se crea una instancia (un ejemplo específico) de esta clase llamada `gato1`. Esto es como decir que estamos creando un objeto con todas las propiedades y métodos definidos en la clase Gato. Finalmente, el programa imprime el objeto `gato1`, lo cual mostrará algo como `<__main__.Gato object at 0x7f8e5c3d4b70>`. Esto nos dice que existe un gato pero no tiene características específicas definidas aún porque la clase Gato está vacía en este momento.

Este código es importante porque muestra cómo crear y manipular objetos de una clase, aunque en esta versión inicial, la clase `Gato` no tiene atributos ni métodos definidos.

```python
class Gato:
  pass
  
gato1 = Gato()
print(gato1)
```

### ahora quiero crear otro gato

#### Explicación

Este fragmento de código está creando una clase llamada `Gato` y luego crea dos instancias de esa clase, imprimiendo cada instancia en la consola. La palabra clave `class` se usa para definir una nueva clase, en este caso `Gato`, que es un modelo o plantilla para crear objetos específicos del tipo gato. La declaración `pass` dentro de la clase indica simplemente que no hay código adicional implementado en ella por ahora.

Después, el código crea dos instancias de la clase `Gato`: `gato1` y `gato2`. Estas líneas crean objetos reales basados en el modelo `Gato`, aunque al ser tan nuevas aún no tienen características propias definidas. Al imprimir cada instancia con `print()`, se muestra información básica sobre estas instancias, como su ubicación de memoria.

Es importante entender este proceso porque la programación orientada a objetos utiliza clases para organizar y encapsular comportamientos y datos relacionados en un solo lugar, lo que facilita el desarrollo y mantenimiento del código.

```python
class Gato:
  pass
  
gato1 = Gato()
print(gato1)

gato2 = Gato()
print(gato2)
```

### Elementos principales de las clases

#### Explicación

Este fragmento de código, aunque no es realmente un código en sí mismo sino más bien una descripción en formato Markdown, explica los dos componentes fundamentales de una clase en programación orientada a objetos. En primer lugar, menciona las propiedades de la clase, que son como variables que almacenan información estática sobre el objeto. Estas propiedades no cambian con frecuencia y representan características permanentes del objeto.

En segundo lugar, se introducen los métodos, que son bloques de código similares a funciones que pueden cambiar o manipular tanto las propiedades como otros aspectos relacionados con la clase. Los métodos permiten realizar acciones específicas sobre el estado del objeto o interactuar con él.

Este tipo de explicación es crucial para estudiantes de Formación Profesional porque ayuda a comprender cómo se estructuran los objetos en programación orientada a objetos y qué roles juegan las propiedades y los métodos dentro de una clase.

```markdown
Los elementos principales de una clase son:

- Las propiedades: piezas de información estáticas (no se "mueven")

Son como variables

- Los métodos: piezas de información que "se mueven"

Son como funciones
```

### propiedades y metodos

#### Explicación

Este fragmento de código crea una clase en Python llamada `Gato` y luego instancia dos objetos a partir de esta clase. La clase `Gato` tiene un método especial denominado `__init__`, que se ejecuta automáticamente cuando creamos un nuevo objeto del tipo `Gato`. En este método, inicializamos un atributo (propiedad) llamado `color` con el valor vacío (`""`). Esto es como decir que cada vez que creamos un gato nuevo en nuestro programa, le preguntamos por su color, pero inicialmente no sabemos cuál es.

Después de definir la clase, creamos dos objetos: uno se llama `jaegger` y otro `lana`. Para cada objeto, establecemos el atributo `color`; así, `jaegger` es un gato crema y `lana`, gris. Esto muestra cómo podemos personalizar los objetos que creamos a partir de una misma clase para reflejar diferentes características en nuestro programa.

Este código es importante porque ilustra la creación de clases, la inicialización de objetos y cómo cambiar atributos de estos objetos después de su creación, permitiéndonos modelar conceptos del mundo real como gatos con distintas propiedades.

```python
class Gato:
  def __init__(self):
    self.color = ""
  
jaegger = Gato()
jaegger.color = "crema"

lana = Gato()
lana.color = "gris"
```

### propiedades

#### Explicación

Este código define una clase en Python llamada `Gato`. Una clase es como un plan o receta para crear objetos que tienen características y comportamientos específicos. En este caso, la clase `Gato` tiene dos propiedades: `color` y `edad`, las cuales se inicializan cuando creas un objeto de tipo `Gato`.

El método `__init__` es especial en Python; se utiliza para inicializar objetos recién creados. Aquí, dentro del método `__init__`, se establecen dos propiedades: `color` y `edad`, ambas inicializadas con valores vacíos (`""`) o cero (`0`). Esto significa que cuando creamos un gato nuevo, por defecto no tendrá color ni edad especificados hasta que nosotros les asignemos valores.

Después de definir la clase, el código crea dos objetos: `jaegger` y `lana`, ambos de tipo `Gato`. A continuación, se le asignan valores específicos a las propiedades de cada objeto. Por ejemplo, a `jaegger.color` se le asigna "crema" y su edad es 9 años, mientras que a `lana.color` se le asigna "gris" y su edad es 11 años.

Esta estructura permite crear objetos personalizados con características propias, lo cual es fundamental en el diseño orientado a objetos para simular entidades del mundo real de manera efectiva.

```python
class Gato:
  def __init__(self):
    self.color = ""
    self.edad = 0
  
jaegger = Gato()
jaegger.color = "crema"
jaegger.edad = 9

lana = Gato()
lana.color = "gris"
lana.edad = 11
```

### introduccion a los metodos

#### Explicación

Este código Python crea una clase llamada `Gato` que representa a un gato. Dentro de la clase, hay dos partes importantes: el método especial `__init__` y otro método llamado `maulla`. El método `__init__` se ejecuta automáticamente cuando creamos una nueva instancia (o objeto) de esta clase. En este caso, inicializa los atributos `color` y `edad`, que son características del gato como su color y cuántos años tiene.

Después, el código crea dos instancias de la clase `Gato`: `jaegger` y `lana`. Para cada uno, se establecen valores específicos para sus atributos `color` y `edad`. Finalmente, para ambos objetos, se llama al método `maulla()`, que simplemente imprime un mensaje indicando que el gato está maullando.

Esta forma de programar es importante porque permite crear objetos personalizados con características propias (como color y edad) y comportamientos específicos (como maullar), lo cual simula cómo funcionan los entornos del mundo real en código.

```python
class Gato:
  def __init__(self):
    self.color = ""
    self.edad = 0
  def maulla(self):
    print("El gato está maullando")
  
jaegger = Gato()
jaegger.color = "crema"
jaegger.edad = 9
jaegger.maulla()

lana = Gato()
lana.color = "gris"
lana.edad = 11
lana.maulla()
```

### objeto cliente

#### Explicación

Este fragmento de código es una parte inicial donde se definen variables que contienen información sobre dos clientes diferentes. Cada cliente tiene cuatro características: email, dirección, nombre y apellidos. Las variables son declaradas con nombres descriptivos como `cliente1_email`, `cliente1_direccion`, etc., lo que hace fácil entender qué dato representa cada variable.

Este tipo de estructura es común al principio del aprendizaje sobre clases en Python, ya que muestra cómo se maneja la información sin utilizar objetos. Sin embargo, cuando tienes múltiples clientes y características similares para todos ellos, usar una clase puede ser más eficiente y organizado. El objetivo de este código es familiarizarte con las estructuras básicas antes de aprender a encapsular estos datos en objetos y clases.

Es importante notar que aunque este método funciona bien para un pequeño número de clientes, se vuelve poco práctico si tienes muchos más o necesitas hacer cambios frecuentes en los datos. Este código sirve como punto de partida para entender cómo la programación orientada a objetos puede simplificar esto al agrupar datos relacionados y métodos que operan sobre ellos dentro de una clase.

```python
cliente1_email = "info@jocarsa.com"
cliente1_direccion = "La calle de Jose Vicente"
cliente1_nombre = "Jose Vicente"
cliente1_apellidos = "Carratala Sanchis"

cliente2_email = "info@cliente2.com"
cliente2_direccion = "La calle del cliente2"
cliente2_nombre = "Juan"
cliente2_apellidos = "García"
```

### clase cliente

#### Explicación

Este fragmento de código está mostrando una comparación entre dos enfoques diferentes para manejar información sobre clientes: uno que utiliza muchas variables individuales y otro que usa clases, lo cual es mucho más escalable. Al principio del código, se crean varias variables separadas como `cliente1_email`, `cliente1_dirección` y así sucesivamente para almacenar datos de dos clientes distintos. Este método puede volverse caótico y difícil de gestionar si aumenta el número de clientes.

Después, el código muestra una forma más organizada utilizando clases en Python. Se define una clase llamada `Cliente`, que es como un molde o plantilla para crear objetos (en este caso, instancias del cliente). En la definición de la clase, se incluye un método especial `__init__` que inicializa los atributos (`email`, `direccion`, `nombre`, `apellidos`) del objeto. Esto significa que cada vez que creas una nueva instancia de `Cliente`, puedes establecer estos valores automáticamente o más tarde en el código.

Finalmente, se crean dos instancias de la clase `Cliente`: `cliente1` y `cliente2`. Para cada uno de ellos, se asigna un valor a sus atributos individuales. Este enfoque es mucho mejor porque permite manejar fácilmente cualquier número de clientes sin necesidad de crear una variable por cada dato del cliente, lo que facilita la lectura y mantenimiento del código.

```python
# Poco escalable - uso de muchas variables

cliente1_email = "info@jocarsa.com"
cliente1_direccion = "La calle de Jose Vicente"
cliente1_nombre = "Jose Vicente"
cliente1_apellidos = "Carratala Sanchis"

cliente2_email = "info@cliente2.com"
cliente2_direccion = "La calle del cliente2"
cliente2_nombre = "Juan"
cliente2_apellidos = "García"

# Mucho mejor: uso de clases

class Cliente:
  def __init__(self):
    self.email = ""
    self.direccion = "" 
    self.nombre = ""
    self.apellidos = ""
    
cliente1 = Cliente()
cliente1.email = "info@jocarsa.com"
cliente1.direccion = "La calle de Jose Vicente"
cliente1.nombre = "Jose Vicente"
cliente1.apellidos = "Carratala Sanchis"

cliente2 = Cliente()
cliente2.email = "info@cliente2.com"
cliente2.direccion = "La calle del cliente2"
cliente2.nombre = "Juan"
cliente2.apellidos = "García"
  
```

### Paradigmas en programacion

#### Explicación

Este fragmento de código es en realidad una explicación escrita en Markdown sobre diferentes paradigmas de programación. Describe cómo los programas pueden ser estructurados, funcionales o orientados a objetos (POO). En el paradigma estructurado, el programa se compone principalmente de listas de instrucciones que se ejecutan secuencialmente. En contraste, en el paradigma funcional, las funciones son creadas y almacenadas para ser reutilizadas según sea necesario. Y en el paradigma orientado a objetos, además de crear funciones, también se crean objetos que encapsulan tanto datos como métodos relacionados con esos datos.

El texto proporciona una línea temporal de cómo estos paradigmas han evolucionado desde los años 60 hasta la década actual, mencionando lenguajes famosos asociados a cada uno. Por ejemplo, C++ y Scala se asocian inicialmente con el paradigma orientado a objetos en los años 80, mientras que Java y C# lo popularizaron más tarde. También señala cómo algunos lenguajes, como Python, son multiparadigma, permitiendo la adopción de múltiples estilos según sea necesario, mientras que otros, como Java, son estrictamente orientados a objetos.

Esta información es crucial para los estudiantes ya que les permite comprender las diferentes formas en que se puede estructurar un programa y qué lenguajes son adecuados para cada paradigma. Aprender estos conceptos ayuda a elegir el enfoque más efectivo para resolver problemas de programación, dependiendo del contexto y los requisitos del proyecto.

```markdown
Paradigma clásico: Estructurado

Listas de instrucciones que se ejecutan una detrás de la otra

Paradigma funcional:

Creas funciones, las almacenas en memoria y las usas cuando las necesitas

Paradigma orientado a objetos:

No solo creas funciones, sino que creas objetos, los almacenas en memoria, y luego los usas

Cada lenguaje puede adoptar uno o varios paradigmas

Los lenguajes que adoptan varios paradigmas, se llaman multiparadigma
Por ejemplo, Python es multiparadigma

Java es un lenguaje estrictamente orientado a objetos
Tienes que hacer objetos lo quieras o no

Los lenguajes estrictamente "algo" son mejores en el sentido de que "obligan" a tener buenas prácticas
Para hacer un programa sencilo es un rollo tener que hacer una clase

Años 60-70
Paradigma estructurado - Pascal - COBOL - BASIC

Años 70:
Paradigma funcional-estructurado - C

Años 80:
Aparece paradigma POO - C++ - SCALA

Años 90:
Se populariza el modelo estricto de POO - Java 1995 - C# 1998

2000's 
La época dorada de la programación orientada a objetos
La epoca dorada de Java y C#

2010's
No nos flipemos
Java, C# etc tienen su valor, y lo siguen teniendo
Pero hay un nicho para programas mas sencillos
Oracle se empieza a cargar Java
```

### Actividades propuestas

### Actividad 1: Creación Básica de Clases en Python

**Descripción:** Los estudiantes deberán crear una clase simple en Python que modele objetos relacionados con su entorno diario (por ejemplo, un vehículo, un libro o cualquier otro objeto). Se espera que comprendan cómo encapsular datos y métodos en una clase.

### Actividad 2: Instanciar Objetos desde Clases

**Descripción:** Tras crear clases básicas, los estudiantes deben instanciar varios objetos a partir de dicha clase. Esto les ayudará a entender la diferencia entre una clase y un objeto.

### Actividad 3: Propiedades en Clases

**Descripción:** Los alumnos deberán añadir propiedades (variables) a las clases que han creado para representar atributos específicos del objeto (por ejemplo, el color de un vehículo o el autor de un libro). Se evaluará su comprensión sobre cómo definir y asignar valores a estas propiedades.

### Actividad 4: Métodos en Clases

**Descripción:** Los estudiantes deben añadir métodos a las clases que han creado. Estos métodos deberán realizar acciones basadas en los atributos del objeto (por ejemplo, un método para simular la conducción de un vehículo). Esta actividad evalúa su capacidad para crear y usar funciones dentro de una clase.

### Actividad 5: Instanciación Mejorada

**Descripción:** Los alumnos deben mejorar el proceso de instanciar objetos en sus clases mediante el uso de parámetros en los métodos `__init__`. Esto les ayudará a entender cómo inicializar datos cuando se crean nuevos objetos.

### Actividad 6: Modelo Cliente-Servidor Simulado

**Descripción:** Con la ayuda de una clase "Cliente" ya proporcionada, los estudiantes deben simular interacciones simples entre clientes. El objetivo es aplicar el conocimiento adquirido sobre clases y métodos para modelar un escenario realista.

### Actividad 7: Mejora del Modelo Cliente

**Descripción:** Basándose en la clase "Cliente", los alumnos deberán mejorar su diseño añadiendo más atributos y métodos que simulen funcionalidades adicionales (como hacer una reserva o cambiar la dirección). Esto les permitirá practicar la creación de clases con mayor complejidad.

### Actividad 8: Implementación Orientada a Objetos

**Descripción:** Los estudiantes deben implementar un pequeño programa orientado a objetos basándose en las clases que han creado. Este programa debe incluir múltiples instancias de los objetos y la ejecución de métodos. Se evaluará su capacidad para aplicar el paradigma orientado a objetos en una solución práctica.

### Actividad 9: Documentación de Códigos Clase

**Descripción:** Tras crear clases y métodos, los estudiantes deberán escribir documentación adicional (document strings o docstrings) que expliquen claramente la función de cada clase y método. Esto les ayudará a mejorar sus habilidades en la documentación del código.

### Actividad 10: Comparativa Paradigmas

**Descripción:** Los estudiantes deberán investigar y comparar los paradigmas de programación (estructurado, funcional y orientado a objetos) con respecto a Python. Se les pedirá que redacten un breve resumen sobre qué tipo de problemas pueden abordarse mejor en cada paradigma utilizando ejemplos prácticos.

Estas actividades están diseñadas para incrementar gradualmente la complejidad, permitiendo a los estudiantes consolidar su comprensión y habilidades en programación orientada a objetos.


<a id="estructura-y-miembros-de-una-clase-visibilidad"></a>
## Estructura y miembros de una clase. Visibilidad

### Introducción a los ejercicios

Este conjunto de ejercicios está diseñado para ayudarte a familiarizarte con la creación y manejo de clases en Python, centrando la atención en cómo estructurar y utilizar miembros de una clase. A través de estos ejercicios, aprenderás a crear objetos desde clases simples hasta más complejas que interactúan con datos proporcionados por el usuario. Los problemas abarcan temas como la creación de instancias de clases, la entrada del usuario para definir propiedades de un objeto y operaciones básicas CRUD (Crear, Leer, Actualizar, Borrar) sobre una lista de objetos. Estos ejercicios te permiten practicar competencias esenciales en programación orientada a objetos, como encapsulamiento e interacción con datos dinámicos.

### listas

#### Explicación

Este fragmento de código es una introducción básica al manejo de listas en Python. En primer lugar, se declaran dos variables `cliente1` y `cliente2`, asignándoles respectivamente los nombres "Juan" y "Jorge". Luego, se crea una lista llamada `clientes` que contiene cuatro elementos: las cadenas "Juan", "Jorge", "Jaime" y "Jose". Finalmente, la función `print()` es utilizada para mostrar por pantalla el contenido de la lista `clientes`.

Este código ilustra cómo almacenar múltiples valores relacionados en una sola variable (la lista) lo que facilita manipularlos juntos, como imprimir todos los nombres al mismo tiempo sin tener que llamar a cada variable individualmente. Es importante destacar que este ejemplo también muestra la inclusión de los nombres definidos previamente dentro de la lista, aunque no es necesario hacerlo así; podrías directamente declarar una lista con sus elementos para empezar a trabajar con ella.

La estructura y manejo de listas en Python son fundamentales para la programación ya que permiten almacenar colecciones ordenadas de datos que pueden modificarse y manipularse fácilmente.

```python
cliente1 = "Juan"
cliente2 = "Jorge"

clientes = ["Juan","Jorge","Jaime","Jose"]

print(clientes)
```

### operaciones con listas

#### Explicación

Este código muestra cómo trabajar con listas en Python, que son una estructura de datos muy versátil para almacenar colecciones ordenadas de elementos. En primer lugar, se definen dos variables `cliente1` y `cliente2`, pero estas no tienen mucha relevancia directa en el flujo principal del código. Lo importante es la lista llamada `clientes`, que contiene los nombres "Juan", "Jorge", "Jaime" y "Jose".

El programa imprime esta lista inicialmente, lo que te permite ver cuáles son los clientes presentes al principio. Luego, se añade el nombre "Julia" a la lista utilizando el método `append()`, que agrega un elemento nuevo al final de la lista. De nuevo, se imprime la lista para mostrar cómo ha cambiado.

Por último, se utiliza el método `pop()` sin argumentos para eliminar el último elemento de la lista. Este método remueve y devuelve el último elemento por defecto si no se proporciona ningún índice específico. Finalmente, se vuelve a imprimir la lista actualizada para que puedas ver cómo ha cambiado después de agregar y quitar elementos.

Esta forma de manipular listas es fundamental en programación ya que te permite gestionar dinámicamente colecciones de datos, añadiendo o removiendo información según sea necesario.

```python
cliente1 = "Juan"
cliente2 = "Jorge"

clientes = ["Juan","Jorge","Jaime","Jose"]

print(clientes)

# Añadir un cliente

clientes.append("Julia")

print(clientes)

# Quito un elemento de la lista

clientes.pop()

print(clientes)
```

### clase cliente

#### Explicación

Este fragmento de código muestra cómo se crea y utiliza una clase llamada `Cliente` en Python. La clase `Cliente` tiene un método especial llamado `__init__`, que es como una recepción cuando un objeto nuevo de la clase `Cliente` nace. Este método inicializa las características o propiedades del cliente, que son el email, el nombre y la dirección, estableciéndolas inicialmente en `None`.

Después de definir la clase, se crea un objeto llamado `cliente1`. Es como tomar una plantilla (la clase) y hacer un ejemplar concreto a partir de ella. Luego, le damos valores específicos al email, nombre y dirección del cliente `cliente1`, por ejemplo, el email es "jose@empresa.com", su nombre es "Jose" y vive en la calle de Jose.

Este proceso es importante porque permite organizar la información relacionada con un cliente en una estructura lógica y fácil de manejar. Al encapsular esta información dentro de una clase, puedes crear múltiples objetos `Cliente` con diferentes datos sin repetir el código o complicar el programa innecesariamente.

```python
# Declaramos una clase
class Cliente():
  def __init__(self):
    self.email = None
    self.nombre = None
    self.direccion = None
    
# Usamos la clase instanciando en un objeto
cliente1 = Cliente()
cliente1.email = "jose@empresa.com"
cliente1.nombre = "Jose"
cliente1.direccion = "La calle de Jose"



    
```

### le preguntamos al usuario

#### Explicación

Este código muestra cómo crear una clase en Python y usarla para interactuar con un usuario. La clase se llama `Cliente` y tiene tres atributos: `email`, `nombre` y `direccion`. Estos atributos son inicializados como `None` cuando creamos un objeto de la clase usando el método `__init__`.

Después, en el cuerpo principal del programa (fuera de la clase), creamos una instancia de la clase llamada `cliente1`. Luego, pedimos al usuario que introduzca el email, nombre y dirección del cliente utilizando las funciones `input()`, y guardamos estos valores en los atributos correspondientes del objeto `cliente1`.

Finalmente, se imprime el objeto `cliente1` usando `print(cliente1)`, lo cual mostrará información sobre el objeto en la pantalla. Este código es útil para entender cómo definir clases con atributos específicos y cómo interactuar con ellas para recoger datos del usuario.

```python
# Declaramos una clase
class Cliente():
  def __init__(self):
    self.email = None
    self.nombre = None
    self.direccion = None
    
# Usamos la clase instanciando en un objeto
cliente1 = Cliente()
cliente1.email = input("Introduce el email del cliente: ")
cliente1.nombre = input("Introduce el nombre del cliente: ")
cliente1.direccion = input("Introduce la direccion del cliente: ")

print(cliente1)



    
```

### leemos los datos del cliente

#### Explicación

Este código muestra cómo se crean y utilizan objetos en Python a través de una clase llamada `Cliente`. En primer lugar, definimos la clase `Cliente`, que es como un molde para crear diferentes clientes con sus propios datos. Dentro de esta clase, hay un método especial llamado `__init__` que se encarga de inicializar los atributos del objeto (en este caso, el email, nombre y dirección) cuando creamos una nueva instancia de la clase.

Después, creamos un objeto específico llamado `cliente1` basándonos en esta clase. Luego pedimos al usuario que introduzca el email, nombre y dirección del cliente a través de la función `input()`. Estos datos se asignan a los atributos correspondientes del objeto `cliente1`.

Finalmente, imprimimos el objeto completo (`print(cliente1)`), aunque esto por defecto no mostrará información muy útil para el usuario sin personalizar cómo debe imprimirse un objeto `Cliente`, y luego mostramos cada uno de los atributos individuales del cliente (email, nombre y dirección). Esto es importante porque nos permite organizar la información del cliente en una estructura que podemos modificar o ampliar fácilmente en el futuro.

```python
# Declaramos una clase
class Cliente():
  def __init__(self):
    self.email = None
    self.nombre = None
    self.direccion = None
    
# Usamos la clase instanciando en un objeto
cliente1 = Cliente()
cliente1.email = input("Introduce el email del cliente: ")
cliente1.nombre = input("Introduce el nombre del cliente: ")
cliente1.direccion = input("Introduce la direccion del cliente: ")

print(cliente1)
print(cliente1.email)
print(cliente1.nombre)
print(cliente1.direccion)



    
```

### crud

#### Explicación

Este fragmento de código es una pequeña aplicación en Python que permite gestionar clientes mediante operaciones básicas como insertar, listar, actualizar y eliminar. En términos sencillos, se presenta al usuario con un menú interactivo donde puede seleccionar diferentes acciones para manejar una lista de clientes.

El programa muestra opciones en el menú y pide al usuario que introduzca su elección mediante la función `input()`. Luego, convierte esa entrada a un número entero para poder compararla fácilmente con los números de las opciones. La variable `clientes` se inicializa como una lista vacía, lo que servirá como contenedor para almacenar información sobre los clientes en futuras versiones del programa.

El bucle `while True` es crucial porque permite al programa seguir corriendo y presentando el menú hasta que el usuario decide salir. Si la opción elegida por el usuario coincide con uno de los números (1, 2, 3 o 4), se imprime un mensaje correspondiente a la acción seleccionada. Si el usuario introduce una opción no válida, el programa simplemente sale del bucle y termina.

Esta estructura es importante porque proporciona al usuario control sobre qué operaciones desea realizar en cada momento, y prepara el escenario para futuras mejoras donde podrías añadir las funciones reales de inserción, lectura, actualización y eliminación de clientes.

```python
# CRUD
# Create 
# Read
# Update
# Delete

print("Programa de gestión de clientes v0.1 Jose Vicente Carratala")

# Muestro opciones en el menú para el usuario
print("Selecciona una opción: ")
print("1.-Insertar un cliente")
print("2.-Listar clientes")
print("3.-Actualizar clientes")
print("4.-Eliminar clientes")

# Le permito escoger una opción
opcion = input("Escoge una opción: ")
opcion = int(opcion)   # Convierto a entero

clientes = []   # Creo una lista VACIA

while True: # Esto desata un bucle infinito pero controlado
  if opcion == 1:
    print("Vamos a insertar un cliente")
  elif opcion == 2:
    print("Vamos a ver los clientes")
  elif opcion == 3:
    print("Vamos a actualizar un cliente")
  elif opcion == 4:
    print("Vamos a eliminar un cliente")
  else:
    break
    
```

### crud insertar y listar

#### Explicación

Este código es una pequeña aplicación en Python que permite gestionar clientes a través de una interfaz simple basada en texto. La aplicación sigue el patrón CRUD (Create, Read, Update, Delete), aunque sólo implementa parcialmente las operaciones "Crear" y "Leer". 

El programa comienza mostrando un menú interactivo al usuario donde puede seleccionar entre diferentes opciones como insertar un nuevo cliente en la lista de clientes, listar todos los clientes existentes o salir del programa. La lista de clientes se maneja mediante una estructura de datos llamada 'lista' que es inicialmente vacía.

Cuando el usuario selecciona "Insertar un cliente", se le pide su nombre y este se añade a la lista de clientes. Si elige "Listar clientes", simplemente se imprime en pantalla toda la lista actualizada con los nombres de los clientes agregados anteriormente. Las opciones para actualizar o eliminar clientes están incluidas pero no implementadas completamente, lo que significa que el programa mostrará un mensaje si el usuario selecciona estas opciones pero no realizará ninguna acción adicional.

Esta es una buena introducción a la gestión de datos en Python y al manejo básico de interfaces de menú. Es importante notar cómo se utiliza la estructura de control `while True` para mantener al usuario dentro del programa hasta que decida salir eligiendo una opción específica para finalizar la ejecución.

```python
# CRUD
# Create 
# Read
# Update
# Delete

print("Programa de gestión de clientes v0.1 Jose Vicente Carratala")

# Muestro opciones en el menú para el usuario
print("Selecciona una opción: ")
print("1.-Insertar un cliente")
print("2.-Listar clientes")
print("3.-Actualizar clientes")
print("4.-Eliminar clientes")

clientes = []   # Creo una lista VACIA

while True: # Esto desata un bucle infinito pero controlado

  # Le permito escoger una opción
  opcion = input("Escoge una opción: ")
  opcion = int(opcion)   # Convierto a entero
  
  if opcion == 1:
    print("Vamos a insertar un cliente")
    nuevocliente = input("Introduce el nombre del cliente: ")
    clientes.append(nuevocliente)
  elif opcion == 2:
    print("Vamos a ver los clientes")
    print(clientes)
  elif opcion == 3:
    print("Vamos a actualizar un cliente")
  elif opcion == 4:
    print("Vamos a eliminar un cliente")
  else:
    break
    
```

### clase cliente

#### Explicación

Este fragmento de código es una aplicación básica en Python que gestiona clientes utilizando una estructura de datos simple. La aplicación sigue los principios CRUD (Crear, Leer, Actualizar y Borrar), que son operaciones fundamentales para manejar información en sistemas de gestión de bases de datos o listas.

La clase `Cliente` se define con un método especial llamado `__init__`, que es el constructor de la clase. Este método inicializa los atributos del cliente (email, nombre y dirección) a None, lo cual significa que al crear una nueva instancia de Cliente, estos campos estarán vacíos hasta que se les asigne un valor.

El programa principal comienza mostrando un menú interactivo en el que el usuario puede elegir entre varias opciones: insertar un nuevo cliente, listar todos los clientes existentes, actualizar la información de un cliente o eliminar un cliente. La elección del usuario determina qué acción realizará el programa. 

Al seleccionar "Insertar un cliente", se crea una nueva instancia de `Cliente`, se le solicita al usuario que introduzca los detalles del nuevo cliente y luego este cliente se añade a la lista `clientes`. Si el usuario elige ver todos los clientes, simplemente imprime en pantalla la lista completa actualizada.

Esta estructura es importante porque proporciona una forma simple pero efectiva de gestionar datos de clientes y permite extender fácilmente las funcionalidades para incluir más operaciones CRUD.

```python
# CRUD
# Create 
# Read
# Update
# Delete

class Cliente():
  def __init__(self):
    self.email = None
    self.nombre = None
    self.direccion = None

print("Programa de gestión de clientes v0.1 Jose Vicente Carratala")

# Muestro opciones en el menú para el usuario
print("Selecciona una opción: ")
print("1.-Insertar un cliente")
print("2.-Listar clientes")
print("3.-Actualizar clientes")
print("4.-Eliminar clientes")

clientes = []   # Creo una lista VACIA

while True: # Esto desata un bucle infinito pero controlado

  # Le permito escoger una opción
  opcion = input("Escoge una opción: ")
  opcion = int(opcion)   # Convierto a entero
  
  if opcion == 1:
    print("Vamos a insertar un cliente")
    # Primero creamos un nuevo cliente
    nuevocliente = Cliente()
    # Ahora le ponemos propiedades
    nuevocliente.nombre = input("Introduce el nombre del cliente: ")
    nuevocliente.email = input("Introduce el email del cliente: ")
    nuevocliente.direccion = input("Introduce la direccion del cliente: ")
    # A la lista de clientes añadimos nuestro cliente
    clientes.append(nuevocliente)
  elif opcion == 2:
    print("Vamos a ver los clientes")
    print(clientes)
  elif opcion == 3:
    print("Vamos a actualizar un cliente")
  elif opcion == 4:
    print("Vamos a eliminar un cliente")
  else:
    break
    
    
    
    
    
    
    
    
    
    
    
```

### Actividades propuestas

### Actividad 1: Crear una clase básica de usuario

**Descripción:** Diseña e implementa una clase `Usuario` que tenga atributos como nombre, email y dirección. Los estudiantes deben instanciar esta clase con datos proporcionados por el usuario a través del teclado.

**Objetivo:** Aprender la estructura básica de una clase en Python y cómo utilizar métodos `__init__`.

### Actividad 2: Modificar atributos de una instancia

**Descripción:** Los estudiantes deben modificar los valores iniciales de las propiedades (atributos) de un objeto instanciado a partir de la clase `Usuario` que crearon en la actividad anterior.

**Objetivo:** Entender cómo acceder y cambiar el estado de un objeto desde fuera de su definición.

### Actividad 3: Clase con métodos

**Descripción:** Añadir a la clase `Usuario` creada antes, varios métodos que permitan obtener y establecer los valores de los atributos. Los estudiantes deben probar estos métodos en sus respectivos objetos.

**Objetivo:** Familiarizarse con el concepto de métodos dentro de una clase y cómo facilitan la interacción con las propiedades del objeto.

### Actividad 4: Interfaz simple de usuario

**Descripción:** Crear un programa que permita al usuario interactuar con instancias de `Usuario`, pidiéndole que introduzca valores para los atributos a través de entradas de texto. El programa debe mostrar estos datos después.

**Objetivo:** Practicar la integración entre clases y entrada/salida del usuario en Python, además de entender cómo usar métodos definidos previamente.

### Actividad 5: Lista de usuarios

**Descripción:** Los estudiantes deben crear una lista para almacenar instancias múltiples de `Usuario`. Deben implementar funcionalidades básicas como agregar y listar los usuarios registrados.

**Objetivo:** Aprender a trabajar con listas que contienen objetos, así como entender cómo realizar operaciones CRUD (Crear, Leer, Actualizar, Borrar) en un contexto orientado a objetos.

### Actividad 6: Gestión de usuarios avanzada

**Descripción:** Extender la funcionalidad del programa anterior para permitir a los usuarios actualizar y eliminar información de una instancia `Usuario`. 

**Objetivo:** Mejorar las habilidades de manejo de listas con objetos, aprender sobre actualización y eliminación de datos en contextos orientados a objetos.

### Actividad 7: Manejar excepciones

**Descripción:** Los estudiantes deben incorporar control de errores básicos (manejo de excepciones) en su programa CRUD para tratar situaciones como inserción de valores no válidos o acceso a elementos que no existen en la lista.

**Objetivo:** Introducir conceptos básicos sobre el manejo de errores y excepciones en programas orientados a objetos, aprendiendo a hacer los programas más robustos.

### Actividad 8: Mejorar la interfaz del usuario

**Descripción:** Los estudiantes deben mejorar la interacción con el programa CRUD, proporcionando instrucciones claras para cada opción del menú y formatando mejor la salida de datos.

**Objetivo:** Refinar las habilidades en diseño de interfaces simples y eficaces, así como aprender a formatear y presentar información de manera legible.


<a id="creacion-de-propiedades"></a>
## Creación de propiedades

### Introducción a los ejercicios

En esta carpeta de ejercicios, se profundiza en el uso y manipulación de propiedades dentro de clases utilizando Python. Los ejercicios comienzan con una introducción básica sobre cómo declarar e inicializar propiedades en una clase, pasando luego a operaciones más avanzadas como la creación de listas de propiedades y lectura/escritura de estas propiedades en objetos instanciados. A medida que avanza el conjunto de ejercicios, se integra la gestión de datos mediante clases para desarrollar una aplicación sencilla de gestión de productos. Esta aplicación permite al usuario crear, listar, actualizar y eliminar productos, practicando así la creación de estructuras de datos complejas y la interacción con objetos de clase en un contexto aplicado.

Estos ejercicios son ideales para estudiantes que buscan refinar sus habilidades en el manejo de clases y objetos en Python, enfocándose tanto en la sintaxis como en la aplicación práctica del paradigma orientado a objetos.

### Repaso de propiedades

#### Explicación

Este fragmento de código muestra cómo se define una clase en Python, específicamente la clase `Cliente`. En programación orientada a objetos, las clases son plantillas que describen el comportamiento y características de un objeto. Aquí, la clase `Cliente` contiene dos propiedades: `nombre` e `edad`, ambas inicializadas dentro del método especial `__init__`. Este método se llama automáticamente cuando se crea una nueva instancia (o objeto) de esta clase. En este caso, `nombre` es inicializado como una cadena vacía (`""`) y `edad` es inicializada con el valor 0. Esto asegura que cada cliente creado a partir de esta clase tenga un nombre y edad predeterminados hasta que se les asigne valores específicos.

```python
# Las propiedades son como las variables PERO dentro de una clase

class Cliente():
  def __init__(self):
    self.nombre = ""
    self.edad = 0
    
```

### las propiedades pueden ser arrays

#### Explicación

Este fragmento de código está creando una clase llamada `Cliente` en Python. Una clase es como un modelo o plantilla que define las características y comportamientos que tendrán los objetos creados a partir de ella. En este caso, la clase tiene tres propiedades (que son similares a variables pero pertenecientes específicamente a cada objeto de la clase): `nombre`, `edad` e `telefonos`.

Cuando se crea un nuevo objeto del tipo `Cliente`, automáticamente se inicializan estas propiedades con valores predeterminados: el nombre está vacío (`""`), la edad es cero (`0`), y los teléfonos son una lista que contiene dos números telefónicos: `'543534'` y `'5345345'`. Es importante tener en cuenta que cada objeto de esta clase tendrá su propia copia de estas propiedades, lo que significa que puedes crear múltiples clientes con diferentes nombres, edades y teléfonos sin interferir entre sí.

La parte clave del código es el método `__init__()`, también conocido como constructor. Este método se ejecuta automáticamente cada vez que creas un nuevo objeto de la clase, permitiendo inicializar las propiedades del objeto en el momento de su creación. La inclusión de los teléfonos como una lista dentro de esta propiedad (`telefonos`) muestra cómo puedes almacenar múltiples valores relacionados en una sola propiedad, lo que es muy útil para manejar datos complejos.

```python
# Las propiedades son como las variables PERO dentro de una clase

class Cliente():
  def __init__(self):
    self.nombre = ""
    self.edad = 0
    self.telefonos = ['543534','5345345']
    
```

### escribir las propiedades de una clase

#### Explicación

Este código crea una clase llamada `Cliente` en Python. Dentro de esta clase, se define el método especial `__init__`, que es lo que se llama cuando creamos un nuevo objeto basado en esa clase. En este caso, dentro del método `__init__`, se inicializan tres propiedades: `nombre`, `edad` y `telefonos`. 

La propiedad `nombre` comienza como una cadena vacía (`""`), la propiedad `edad` empieza con el valor 0 (cero) y la lista de `telefonos` tiene dos números de teléfono almacenados por defecto. Estas propiedades son características que cada objeto del tipo `Cliente` tendrá.

Después, se crea un nuevo objeto llamado `cliente1` basándose en la clase `Cliente`. A continuación, a este objeto específico le asignamos un valor al atributo `nombre`, cambiándolo de su valor inicial vacío a "Jose Vicente". Esto muestra cómo podemos modificar las propiedades de un objeto después de haberlo creado para adaptarlas a nuestras necesidades específicas.

```python
# Las propiedades son como las variables PERO dentro de una clase

class Cliente():
  def __init__(self):
    self.nombre = ""
    self.edad = 0
    self.telefonos = ['543534','5345345']
    
# Ahora instancio un nuevo objeto
cliente1 = Cliente()

# Ahora le escribo una propiedad

cliente1.nombre = "Jose Vicente"

    
```

### leemos propiedad

#### Explicación

Este fragmento de código muestra cómo crear y utilizar propiedades dentro de una clase en Python. La clase `Cliente` se define con tres atributos: `nombre`, que almacena el nombre del cliente, `edad`, que almacena la edad del cliente (inicializada como 0), y `telefonos`, que es una lista inicializada con dos números telefónicos de ejemplo. Al instanciar un nuevo objeto `cliente1` de la clase `Cliente`, los atributos se inicializan según lo definido en el constructor (`__init__`). Luego, cambiamos el valor del atributo `nombre` de `cliente1` a "Jose Vicente". Finalmente, imprimimos el nombre actualizado del cliente. Este ejemplo ilustra cómo las propiedades dentro de una clase permiten almacenar y manipular datos específicos para cada instancia (objetos) creados a partir de esa clase, lo que es fundamental en la programación orientada a objetos para mantener información organizada y encapsulada.

```python
# Las propiedades son como las variables PERO dentro de una clase

class Cliente():
  def __init__(self):
    self.nombre = ""
    self.edad = 0
    self.telefonos = ['543534','5345345']
    
# Ahora instancio un nuevo objeto
cliente1 = Cliente()

# Ahora le escribo una propiedad

cliente1.nombre = "Jose Vicente"

print("El nombre del cliente es:",cliente1.nombre)
    
```

### los telefonos deben ser una lista

#### Explicación

Este fragmento de código muestra cómo se crea y utiliza una clase en Python para representar un objeto "Cliente". La clase `Cliente` tiene tres propiedades: `nombre`, que almacena el nombre del cliente; `edad`, que indica la edad del cliente, pero inicialmente está vacía (establecida como 0); y `telefonos`, que es una lista donde se pueden almacenar varios números telefónicos del cliente.

Después de definir la clase, creamos un objeto específico llamado `cliente1` a partir de esta clase. Luego, asignamos el nombre "Jose Vicente" al atributo `nombre` del objeto `cliente1`. También añadimos dos números telefónicos diferentes a la lista `telefonos`.

El código final imprime en pantalla el nombre del cliente y luego muestra todos los números almacenados en su lista de teléfonos. Esto es importante porque nos permite entender cómo las propiedades dentro de una clase pueden ser utilizadas para guardar información variada, incluyendo datos simples como un string (nombre) o colecciones más complejas como listas (telefonos), lo que hace a las clases muy flexibles y útiles en la programación orientada a objetos.

```python
# Las propiedades son como las variables PERO dentro de una clase

class Cliente():
  def __init__(self):
    self.nombre = ""
    self.edad = 0
    self.telefonos = []
    
# Ahora instancio un nuevo objeto
cliente1 = Cliente()

# Ahora le escribo una propiedad

cliente1.nombre = "Jose Vicente"

print("El nombre del cliente es:",cliente1.nombre)

cliente1.telefonos.append("63354333")
cliente1.telefonos.append("65436456")

print(cliente1.telefonos)
    
```

### aplicacion de productos

#### Explicación

Este fragmento de código es la parte superior de un archivo Python que sirve como una aplicación para gestionar productos. Comienza con un comentario multilínea que proporciona información sobre el propósito del programa y los detalles del autor. En este caso, se indica que la aplicación está diseñada para gestionar productos y que fue creada por Jose Vicente Carratala en 2025.

A continuación, hay una línea vacía seguida de un comentario que indica que no es necesario importar ninguna librería adicional para esta aplicación. Esto puede ser importante si el programa utiliza características básicas de Python sin necesidad de bibliotecas externas o específicas.

Es relevante entender este preámbulo ya que proporciona contexto sobre qué esperar del código restante y cómo se estructura la aplicación en términos de dependencias externas.

```python
'''
  Aplicación de gestión de productos
  (c) 2025 Jose Vicente Carratala
  Esta aplicación gestiona productos
'''

# En esta aplicación no aplica importar librerías
    
```

### funciones y clases

#### Explicación

Este fragmento de código es el comienzo del desarrollo de una aplicación en Python para gestionar productos. La parte principal aquí es la definición de una clase llamada `Producto`. Esta clase tiene un método especial llamado `__init__`, que se ejecuta automáticamente cada vez que se crea un nuevo objeto `Producto`.

En este método, inicializamos dos propiedades del objeto: `nombre` y `precio`. Ambas son variables que pertenecen a cualquier instancia de la clase `Producto` y en este caso, al crear el objeto por primera vez, establecemos valores predeterminados. `nombre` se inicia como una cadena vacía (`""`) y `precio` como un número entero 0 (`0`). Estas propiedades permitirán almacenar información específica para cada producto que gestione la aplicación.

Esta estructura de clases es importante en Python porque nos permite organizar el código de manera más clara y crear objetos con características y comportamientos definidos, facilitando así la gestión de los productos en este caso.

```python
'''
  Aplicación de gestión de productos
  (c) 2025 Jose Vicente Carratala
  Esta aplicación gestiona productos
'''

# En esta aplicación no aplica importar librerías

# Definimos clases y funciones

class Producto():
  def __init__(self):
    self.nombre = ""
    self.precio = 0
    

    
```

### creamos las variables globales

#### Explicación

Este fragmento de código es el inicio de una aplicación en Python diseñada para gestionar productos. En la parte superior, se incluye un comentario que describe brevemente qué hace la aplicación y quién es el autor.

Dentro del código, hay una clase llamada `Producto` que contiene dos propiedades: `nombre`, un string vacío por defecto, y `precio`, un número entero con valor 0 por defecto. Estas propiedades se inicializan en el método `__init__()` cuando se crea un objeto de la clase `Producto`.

Además, fuera de cualquier clase o función, existe una lista llamada `productos` que está vacía (`[]`). Esta lista es global y servirá para almacenar objetos de tipo `Producto`. La idea es que esta lista permita a la aplicación gestionar múltiples productos, añadiéndolos y accediendo a ellos fácilmente durante el funcionamiento del programa.

```python
'''
  Aplicación de gestión de productos
  (c) 2025 Jose Vicente Carratala
  Esta aplicación gestiona productos
'''

# En esta aplicación no aplica importar librerías

# Definimos clases y funciones

class Producto():
  def __init__(self):
    self.nombre = ""
    self.precio = 0
    
# Creamos las variables globales

productos = []


    
```

### pseudocodigo

#### Explicación

Este código es una estructura básica para una aplicación en Python que gestiona productos, como podrían ser artículos de tienda. La idea principal es crear y manipular objetos `Producto` mediante diferentes opciones que ofrece el programa al usuario.

En la parte superior del código, se incluye un comentario que describe brevemente qué hace la aplicación y quién es su creador. Luego, se define una clase llamada `Producto`, que contiene dos propiedades: `nombre` (un string vacío) y `precio` (un número entero inicializado en 0). Estas propiedades representan los atributos principales de cada producto.

Además, el código declara una lista vacía llamada `productos`, que será utilizada para almacenar instancias de la clase `Producto`. Finalmente, se menciona un menú interactivo donde el usuario puede elegir entre varias opciones: crear un nuevo producto, listar los productos existentes, actualizar información sobre un producto o eliminar un producto. Este enfoque facilita la gestión y manipulación de productos a través de interacciones sencillas con el usuario.

Este tipo de estructura es importante para entender cómo organizar una aplicación Python que maneja datos complejos como listas de productos, ya que permite encapsular información y operaciones relacionadas dentro de clases y funciones.

```python
'''
  Aplicación de gestión de productos
  (c) 2025 Jose Vicente Carratala
  Esta aplicación gestiona productos
'''

# En esta aplicación no aplica importar librerías

# Definimos clases y funciones

class Producto():
  def __init__(self):
    self.nombre = ""
    self.precio = 0
    
# Creamos las variables globales

productos = []

# Primero lanzamos un mensaje de bienvenida
# Le mostramos al usuario las opciones que tiene
# En función de la opción que coja el usuario
  # O bien creamos un nuevo producto
  # O bien listamos los productos
  # O bien actualizamos los productos
  # O bien eliminamos los productos
    
```

### voy creando el codigo

#### Explicación

Este código es una aplicación básica de gestión de productos que utiliza la estructura de clases en Python. La clase `Producto` se define con dos propiedades: `nombre`, que almacena el nombre del producto, y `precio`, que almacena su valor monetario. Al crear un objeto de esta clase (`Producto()`), estas propiedades se inicializan vacías.

El código también declara una lista llamada `productos` donde se almacenarán los objetos `Producto`. Esta estructura es importante porque permite gestionar múltiples productos fácilmente, añadiéndolos a la lista o accediendo a ellos para modificar sus propiedades como el nombre y precio. 

El programa comienza mostrando un mensaje de bienvenida al usuario y luego le ofrece varias opciones: crear un nuevo producto, listar los existentes, actualizar información o eliminar productos. Esta interacción continua hasta que se decide finalizar la aplicación, permitiendo así una gestión sencilla pero efectiva del inventario de productos en tiempo real.

```python
'''
  Aplicación de gestión de productos
  (c) 2025 Jose Vicente Carratala
  Esta aplicación gestiona productos
'''

# En esta aplicación no aplica importar librerías

# Definimos clases y funciones

class Producto():
  def __init__(self):
    self.nombre = ""
    self.precio = 0
    
# Creamos las variables globales

productos = []

# Primero lanzamos un mensaje de bienvenida
print("Gestor de productos v0.1 Jose Vicente Carratala")
# Le mostramos al usuario las opciones que tiene
# En función de la opción que coja el usuario
  # O bien creamos un nuevo producto
  # O bien listamos los productos
  # O bien actualizamos los productos
  # O bien eliminamos los productos
# Y volvemos a repetir
    
```

### le mostramos al usuario las opciones que tiene

#### Explicación

Este fragmento de código es una aplicación sencilla para gestionar productos, diseñada para mostrar cómo se puede interactuar con el usuario y manejar diferentes opciones utilizando clases en Python. La aplicación comienza mostrando un mensaje de bienvenida y luego presenta al usuario varias opciones: crear un nuevo producto, listar los productos existentes, actualizar información sobre un producto o eliminar un producto. Estas opciones son imprescindibles porque permiten que el usuario interactúe con la base de datos de productos según sus necesidades.

El código crea una clase llamada `Producto`, que inicializa dos atributos: `nombre` y `precio`. Luego, se define una lista vacía llamada `productos` para almacenar objetos de tipo `Producto`.

Lo más importante es que después de mostrar las opciones al usuario, el programa debería permitirle seleccionar una opción e implementar la funcionalidad correspondiente. Sin embargo, en este fragmento sólo están descriptas las opciones y no se incluye el código necesario para ejecutarlas (como capturar la entrada del usuario o llamar a funciones específicas). Esta estructura es fundamental porque establece el flujo básico de cualquier aplicación interactiva: mostrar al usuario lo que puede hacer, recibir su elección y actuar en consecuencia.

```python
'''
  Aplicación de gestión de productos
  (c) 2025 Jose Vicente Carratala
  Esta aplicación gestiona productos
'''

# En esta aplicación no aplica importar librerías

# Definimos clases y funciones

class Producto():
  def __init__(self):
    self.nombre = ""
    self.precio = 0
    
# Creamos las variables globales

productos = []

# Primero lanzamos un mensaje de bienvenida
print("Gestor de productos v0.1 Jose Vicente Carratala")
# Le mostramos al usuario las opciones que tiene
print("Selecciona una opción:")
print("1.-Crear un nuevo producto")
print("2.-Listar productos")
print("3.-Actualizar productos")
print("4.-Eliminar productos")
# En función de la opción que coja el usuario
  # O bien creamos un nuevo producto
  # O bien listamos los productos
  # O bien actualizamos los productos
  # O bien eliminamos los productos
# Y volvemos a repetir
    
```

### tomamos la entrada de usuario

#### Explicación

Este código es una aplicación simple que gestiona productos y se basa en la estructura básica de un programa interactivo. Primero, define una clase llamada `Producto` con dos propiedades: `nombre` (un string vacío) y `precio` (un entero inicializado en 0). Luego, crea una lista vacía llamada `productos`, que servirá para almacenar los productos creados.

El código principal muestra un menú al usuario con cuatro opciones: crear un nuevo producto, listar todos los productos existentes, actualizar la información de un producto y eliminar un producto. El usuario debe seleccionar una opción introduciendo un número del 1 al 4. Dependiendo de lo que elija, la aplicación realizará diferentes acciones relacionadas con esos productos.

Esta estructura es importante porque permite a los usuarios interactuar fácilmente con la lista de productos mediante opciones claras y sencillas. Permite organizar las operaciones en un flujo lógico y repetitivo, mejorando así la experiencia del usuario al gestionar sus productos.

```python
'''
  Aplicación de gestión de productos
  (c) 2025 Jose Vicente Carratala
  Esta aplicación gestiona productos
'''

# En esta aplicación no aplica importar librerías

# Definimos clases y funciones

class Producto():
  def __init__(self):
    self.nombre = ""
    self.precio = 0
    
# Creamos las variables globales

productos = []

# Primero lanzamos un mensaje de bienvenida
print("Gestor de productos v0.1 Jose Vicente Carratala")
# Le mostramos al usuario las opciones que tiene
print("Selecciona una opción:")
print("1.-Crear un nuevo producto")
print("2.-Listar productos")
print("3.-Actualizar productos")
print("4.-Eliminar productos")
opcion = int(input("Escoge tu opción: "))
# En función de la opción que coja el usuario
  # O bien creamos un nuevo producto
  # O bien listamos los productos
  # O bien actualizamos los productos
  # O bien eliminamos los productos
# Y volvemos a repetir
    
```

### estructura if

#### Explicación

Este fragmento de código es una simple aplicación en Python que gestiona un inventario básico de productos. La aplicación muestra al usuario cuatro opciones: crear un nuevo producto, listar todos los productos existentes, actualizar información sobre los productos y eliminar productos. 

El corazón del programa está en el bloque `if-elif-else`, donde se evalúa la opción seleccionada por el usuario a través de una entrada numérica (1, 2, 3 o 4). Dependiendo del número ingresado, la aplicación imprime un mensaje específico que indica qué acción va a realizar. Por ejemplo, si el usuario ingresa "1", la aplicación responde diciendo que se creará un nuevo producto.

Esta estructura de código es importante porque permite al usuario interactuar con la aplicación en función de sus necesidades, proporcionando una experiencia personalizada y funcional para manejar el inventario de productos.

```python
'''
  Aplicación de gestión de productos
  (c) 2025 Jose Vicente Carratala
  Esta aplicación gestiona productos
'''

# En esta aplicación no aplica importar librerías

# Definimos clases y funciones

class Producto():
  def __init__(self):
    self.nombre = ""
    self.precio = 0
    
# Creamos las variables globales

productos = []

# Primero lanzamos un mensaje de bienvenida
print("Gestor de productos v0.1 Jose Vicente Carratala")
# Le mostramos al usuario las opciones que tiene
print("Selecciona una opción:")
print("1.-Crear un nuevo producto")
print("2.-Listar productos")
print("3.-Actualizar productos")
print("4.-Eliminar productos")
opcion = int(input("Escoge tu opción: "))
# En función de la opción que coja el usuario
if opcion == 1:
  # O bien creamos un nuevo producto
  print("Creamos un nuevo producto")
elif opcion == 2:
  # O bien listamos los productos
  print("Vamos a listar los productos")
elif opcion == 3:
  # O bien actualizamos los productos
  print("Vamos a actualizar productos")
elif opcion == 4:
  # O bien eliminamos los productos
  print("Vamos a eliminar productos")
# Y volvemos a repetir
    
```

### bucle infinito

#### Explicación

Este fragmento de código es el inicio de una aplicación sencilla para gestionar productos en un inventario. La estructura principal del programa está basada en la definición de una clase llamada `Producto`, que contiene propiedades básicas como nombre y precio. A continuación, se crean algunas variables globales, principalmente una lista vacía llamada `productos` donde se almacenará cada objeto de tipo Producto.

El núcleo del código es un bucle infinito (`while True:`), que mantiene la aplicación en ejecución hasta que el usuario decida cerrarla manualmente. En cada iteración del bucle, el programa muestra un menú con opciones para interactuar: crear, listar, actualizar o eliminar productos. Dependiendo de la opción elegida por el usuario a través del input, se imprime un mensaje correspondiente. Sin embargo, es importante notar que esta versión del código solo muestra mensajes informativos y no realiza las acciones propiamente dichas.

Este enfoque utilizando un bucle infinito asegura que el programa esté siempre listo para recibir nuevas instrucciones hasta que sea cerrado de manera explícita. Es una técnica comúnmente usada en aplicaciones interactivas donde la finalización del programa depende directamente de la acción del usuario, como cerrar una sesión o seleccionar una opción de "salir".

```python
'''
  Aplicación de gestión de productos
  (c) 2025 Jose Vicente Carratala
  Esta aplicación gestiona productos
'''

# En esta aplicación no aplica importar librerías

# Definimos clases y funciones

class Producto():
  def __init__(self):
    self.nombre = ""
    self.precio = 0
    
# Creamos las variables globales

productos = []

# Primero lanzamos un mensaje de bienvenida
print("Gestor de productos v0.1 Jose Vicente Carratala")
# Metemos al usuario en un bucle infinito
while True:
  # Le mostramos al usuario las opciones que tiene
  print("Selecciona una opción:")
  print("1.-Crear un nuevo producto")
  print("2.-Listar productos")
  print("3.-Actualizar productos")
  print("4.-Eliminar productos")
  opcion = int(input("Escoge tu opción: "))
  # En función de la opción que coja el usuario
  if opcion == 1:
    # O bien creamos un nuevo producto
    print("Creamos un nuevo producto")
  elif opcion == 2:
    # O bien listamos los productos
    print("Vamos a listar los productos")
  elif opcion == 3:
    # O bien actualizamos los productos
    print("Vamos a actualizar productos")
  elif opcion == 4:
    # O bien eliminamos los productos
    print("Vamos a eliminar productos")
  # Y volvemos a repetir
    
```

### desarrollo la insercion de producto

#### Explicación

Este código es una aplicación sencilla para gestionar productos, desarrollada en Python. La idea principal es permitir al usuario realizar operaciones básicas como crear, listar, actualizar y eliminar productos.

En el corazón del programa se encuentra la clase `Producto`, que define un objeto básico con dos propiedades: `nombre` y `precio`. Cuando creamos una instancia de esta clase (por ejemplo, cuando el usuario selecciona "Crear un nuevo producto"), inicializamos estas propiedades con valores vacíos o cero. Luego, pedimos al usuario que introduzca los detalles del producto, y estos se asignan a las propiedades correspondientes.

La aplicación utiliza una lista llamada `productos` para almacenar todos los productos creados. Cuando un nuevo producto es creado, simplemente añadimos la instancia de `Producto` recién creada a esta lista.

El bucle infinito (`while True`) presenta al usuario un menú con opciones para interactuar con los productos. Dependiendo de lo que elija el usuario (1 para crear, 2 para listar, etc.), el programa realiza diferentes acciones y vuelve a mostrar el menú hasta que se decide terminar la aplicación.

Esta estructura es fundamental en aplicaciones interactivas ya que permite al usuario navegar por las distintas funcionalidades sin tener que cerrar y abrir de nuevo el programa cada vez.

```python
'''
  Aplicación de gestión de productos
  (c) 2025 Jose Vicente Carratala
  Esta aplicación gestiona productos
'''

# En esta aplicación no aplica importar librerías

# Definimos clases y funciones

class Producto():
  def __init__(self):
    self.nombre = ""
    self.precio = 0
    
# Creamos las variables globales

productos = []

# Primero lanzamos un mensaje de bienvenida
print("Gestor de productos v0.1 Jose Vicente Carratala")
# Metemos al usuario en un bucle infinito
while True:
  # Le mostramos al usuario las opciones que tiene
  print("Selecciona una opción:")
  print("1.-Crear un nuevo producto")
  print("2.-Listar productos")
  print("3.-Actualizar productos")
  print("4.-Eliminar productos")
  opcion = int(input("Escoge tu opción: "))
  # En función de la opción que coja el usuario
  if opcion == 1:
    # O bien creamos un nuevo producto
    print("Creamos un nuevo producto")
    producto1 = Producto()           # Creo una nueva instancia de la clase
    producto1.nombre = input("Introduce el nombre del producto: ")   # Escribo la propiedad
    producto1.precio = input("Introduce el precio del producto: ")   # Escribo la propiedad
    productos.append(producto1)      # Y a la la lista de productos le añado el producto
  elif opcion == 2:
    # O bien listamos los productos
    print("Vamos a listar los productos")
  elif opcion == 3:
    # O bien actualizamos los productos
    print("Vamos a actualizar productos")
  elif opcion == 4:
    # O bien eliminamos los productos
    print("Vamos a eliminar productos")
  # Y volvemos a repetir
    
```

### Actividades propuestas

1. **Clase Cliente: Propiedades y Métodos Básicos**
   - **Descripción:** Crea una clase `Cliente` con propiedades como nombre, edad y telefonos (una lista). Implementa métodos para agregar y eliminar números telefónicos.

2. **Gestor de Clientes**
   - **Descripción:** Diseña un programa que gestione clientes a través de diferentes operaciones: agregar cliente, listar clientes, actualizar datos del cliente, eliminar cliente.

3. **Aplicación de Gestión de Productos (Parte 1)**
   - **Descripción:** Crea una clase `Producto` con atributos nombre y precio. Implementa la creación de un producto nuevo y muestra cómo almacenarlo en una lista global.

4. **Interfaz del Usuario para Gestión de Productos**
   - **Descripción:** Desarrolla el menú principal que permita al usuario seleccionar entre opciones como crear, listar, actualizar o eliminar productos.

5. **Validación de Entradas de Usuarios**
   - **Descripción:** Asegura la validación de las entradas del usuario en las operaciones CRUD (Crear, Leer, Actualizar y Eliminar) para evitar errores en tiempo de ejecución.

6. **Aplicación de Gestión de Productos (Parte 2)**
   - **Descripción:** Amplía el menú principal añadiendo la lógica necesaria para cada opción seleccionada por el usuario, incluyendo la manipulación de datos y almacenamiento en una lista.

7. **Bucle Infinito con Gestión de Productos**
   - **Descripción:** Desarrolla un bucle infinito que permita al usuario interactuar repetidamente con las opciones del menú hasta que decida salir voluntariamente.

8. **Ejercicio Práctico: Implementación Final del Proyecto**
   - **Descripción:** Combina todos los componentes anteriores para crear una aplicación funcional de gestión de productos con interacción completa del usuario, incluyendo la implementación de operaciones CRUD y manejo de excepciones.


<a id="creacion-de-metodos"></a>
## Creación de métodos

### Introducción a los ejercicios

Esta carpeta contiene una serie de ejercicios que te ayudarán a entender y practicar el uso de métodos en la programación orientada a objetos con Python. Los ejercicios van desde conceptos básicos como definir propiedades y métodos, hasta prácticas más avanzadas como encapsulamiento (usando setters y getters) y manejo de listas de objetos. A través de estos ejercicios, aprenderás cómo proteger la integridad de tus datos utilizando variables privadas y validaciones en los métodos setter, así como cómo interactuar con colecciones de objetos para realizar operaciones CRUD (Crear, Leer, Actualizar, Eliminar).

### repaso de los metodos

#### Explicación

Este código es una introducción básica al concepto de clases y objetos en Python, que son fundamentales para la programación orientada a objetos. En este ejemplo, se crea una clase llamada `Gato` que representa las características y comportamientos típicos de un gato. Dentro de esta clase, hay dos componentes principales: una propiedad (variable) llamada `color`, que almacena el color del gato; y un método (función dentro de la clase) llamado `maulla()`, que devuelve el sonido "miau" cuando se llama.

Luego, se crea un objeto específico de esta clase, denominado `gato1`. A través de este objeto, puedes modificar las propiedades del gato, como establecer su color en `"naranja"` usando la línea `gato1.color = "naranja"`, y también llamar a sus métodos para simular acciones que un gato puede realizar. En el caso de este código, se imprime en pantalla el sonido que hace el gato cuando llamamos al método `maulla()`. Este ejemplo demuestra cómo las clases permiten encapsular tanto datos (propiedades) como funcionalidades (métodos) relacionados con un concepto específico (en este caso, un gato), facilitando la organización y reutilización del código.

```python
class Gato():
  def __init__(self):
    self.color = ""     # Esto es una propiedad
  
  def maulla(self):     # Esto es un método (es una acción)
    return "miau"
    
    
gato1 = Gato()
gato1.color = "naranja"   # Aquí seteamos una propiedad
print(gato1.maulla())     # Aquí llamamos a un método
```

### metodo set

#### Explicación

Este código define una clase llamada `Gato` en Python. La clase tiene algunas características importantes:

- El método `__init__()` inicializa un objeto de la clase, estableciendo una propiedad llamada `color`, que por defecto es una cadena vacía.

- Hay un método llamado `maulla()` que siempre devuelve el sonido "miau" cuando se llama a él. Este método simula cómo un gato maulla.

- El método `setColor(nuevocolor)` permite cambiar la propiedad `color` del objeto gato, tomando como argumento una nueva cadena que representa el nuevo color del gato. Esto es útil porque nos permite actualizar el color de nuestro gato a través de este método en lugar de acceder directamente a la propiedad.

En la parte final del código, se crea un objeto `gato1` usando la clase `Gato`. Luego, se muestra cómo inicializar el color del gato directamente (lo cual no es recomendado) y luego cómo hacerlo utilizando el método `setColor()`, que es una práctica mucho más apropiada porque permite controlar mejor cómo se actualiza esta propiedad.

```python
class Gato():
  def __init__(self):
    self.color = ""     # Esto es una propiedad
  
  def maulla(self):     # Esto es un método (es una acción)
    return "miau"
    
  def setColor(self,nuevocolor):   # Defino un setter - el método es el responsable de cambiar la
    # Por ejemplo aquí podría validar si el color es un color válido para un gato
    self.color = nuevocolor         # Y cambio la propiedad
    
    
gato1 = Gato()
gato1.color = "naranja"   # Aquí seteamos una propiedad directamente (no es buena práctica)

gato1.setColor("naranja") # Esto es una práctica mucho mejor
```

### metodo getter

#### Explicación

Este código Python muestra cómo crear y utilizar métodos getter y setter en una clase llamada `Gato`. La clase tiene varias partes importantes: un constructor (`__init__`), que inicializa la propiedad `color`, un método llamado `maulla` que simplemente devuelve el sonido "miau", y dos métodos específicos para gestionar la propiedad `color`: `setColor` (setter) y `getColor` (getter).

El setter, `setColor`, toma un argumento `nuevocolor` y lo asigna a la propiedad `self.color`. Este método puede incluir validaciones adicionales para asegurarse de que el color ingresado sea válido. Por otro lado, el getter, `getColor`, simplemente devuelve el valor actual de la propiedad `color`.

El uso de getters y setters es importante porque proporcionan control sobre cómo se accede a las propiedades del objeto. En lugar de modificar directamente una propiedad como en `gato1.color = "naranja"`, que aunque funcional no es recomendado, se prefiere usar el método `setColor("naranja")`. Esto permite encapsular y proteger la información interna del objeto, manteniendo la integridad de los datos.

```python
class Gato():
  def __init__(self):
    self.color = ""     # Esto es una propiedad
  
  def maulla(self):     # Esto es un método (es una acción)
    return "miau"
    
  def setColor(self,nuevocolor):   # Defino un setter - el método es el responsable de cambiar la
    # Por ejemplo aquí podría validar si el color es un color válido para un gato
    self.color = nuevocolor         # Y cambio la propiedad
  
  def getColor(self):
    # Una vez más, aquí podría poner validaciones si lo quisiera
    return self.color
    
    
gato1 = Gato()
gato1.color = "naranja"   # Aquí seteamos una propiedad directamente (no es buena práctica)

gato1.setColor("naranja") # Esto es una práctica mucho mejor

print(gato1.color)      # Acceso directo, se puede pero no se recomienda

print(gato1.getColor()) # Acceso mediante método, se recomienda
```

### defino propiedad privada

#### Explicación

Este fragmento de código muestra cómo definir y usar una propiedad privada en una clase en Python. La clase se llama `Gato` y tiene un método especial llamado `__init__`, que es como un constructor en otros lenguajes de programación. Dentro del método `__init__`, hay una línea que establece la variable de instancia `self.__color` con el valor "naranja". El doble subrayado antes de `color` indica que esta propiedad es privada, lo que significa que no debería ser accedida desde fuera de la clase.

Después de definir la clase, se crea una instancia del objeto `Gato` llamada `gato1`. Luego, el código intenta imprimir el valor de la propiedad privada `__color` utilizando `print(gato1.__color)`, pero esto no funcionará como está esperado porque `__color` es privado y no puede ser accedido desde fuera de la clase. Esto ilustra una importante característica de las propiedades privadas en Python: limitan el acceso a ciertos atributos para proteger su integridad y prevenir modificaciones accidentales o malintencionadas desde código externo.

Es fundamental entender esta diferencia entre propiedades públicas y privadas para mantener la estructura y seguridad del código.

```python
class Gato():
  def __init__(self):
    self.__color = "naranja"     # Esto es una propiedad privada (contrapuesta a pública)
    
gato1 = Gato()

print(gato1.__color)
  
```

### Clase cuenta bancaria

#### Explicación

Este fragmento de código define una clase en Python llamada `CuentaBancaria`. Una clase es como un plan o plantilla para crear objetos, que son entidades con propiedades y comportamientos específicos. En este caso, el objeto representará una cuenta bancaria.

Dentro de la clase, se encuentra un método especial denominado `__init__`, también conocido como constructor. Este método se ejecuta automáticamente cuando se crea una nueva instancia de la clase (es decir, cuando se crea un nuevo objeto). El propósito del constructor es inicializar los atributos o propiedades del objeto.

En este caso, el constructor establece dos variables de instancia: `saldo` y `cliente`. La variable `saldo` se inicializa con el valor 0, lo que significa que al crear una nueva cuenta bancaria, siempre comenzará sin fondos. Por otro lado, la variable `cliente` está vacía, representada por las comillas "", indicando que no hay un cliente asociado a la cuenta hasta que se especifique uno.

Esta inicialización es importante porque establece los valores iniciales para cualquier objeto de tipo `CuentaBancaria`, asegurando que cada nueva cuenta tenga una estructura y estado definidos desde el inicio.

```python
class CuentaBancaria():
  def __init__(self):
    self.saldo = 0
    self.cliente = ""
    
```

### convertir en privadas

#### Explicación

Este código define una clase llamada `CuentaBancaria` en Python, que es un modelo básico para representar una cuenta bancaria. La clase tiene dos atributos privados: `_saldo` y `_cliente`, lo que significa que estos valores no pueden ser accedidos directamente desde fuera de la clase; esto ayuda a proteger los datos de la clase y evitar modificaciones no controladas.

Además, se define un método llamado `setSaldo()` dentro de la clase para establecer el valor del saldo. Este método toma como parámetro un nuevo saldo que será asignado al atributo privado `_saldo` de la instancia de la clase.

Finalmente, se crea una instancia de la clase `CuentaBancaria` llamada `cuentecliente1`, y luego se usa el método `setSaldo()` para establecer el saldo en 10.000.000.000 (diez mil millones). El uso de setters como este es importante porque permite controlar cómo se modifican los atributos privados de una clase, lo que ayuda a mantener la integridad y coherencia de los datos dentro del objeto.

Es importante notar que hay un pequeño error tipográfico en el nombre `cuentecliente1`, pero esto no afecta la explicación del funcionamiento del código.

```python
class CuentaBancaria():
  def __init__(self):
    self.__saldo = 0
    self.__cliente = ""
    
  # Defino setters y getters para el saldo
  def setSaldo(self,nuevosaldo):
    self.__saldo = nuevosaldo
    
cuentecliente1 = CuentaBancaria()
cuentecliente1.setSaldo(10000000000)


    
```

### get saldo

#### Explicación

Este código es una parte de un programa en Python que representa una cuenta bancaria y permite obtener y establecer el saldo de esa cuenta. La clase `CuentaBancaria` tiene dos métodos importantes: uno para establecer (`setSaldo`) y otro para obtener (`getSaldo`) el saldo de la cuenta, aunque inicialmente también se define un método `__init__` que es un constructor que inicializa una nueva cuenta bancaria con un saldo inicial de 0. 

El saldo en la clase está encapsulado (es decir, es privado), lo que significa que no puede ser modificado directamente desde fuera de la clase; sólo puede ser establecido a través del método `setSaldo` y obtenido mediante el método `getSaldo`. Esto ayuda a mantener la seguridad y integridad de los datos.

En el fragmento final, se crea una instancia de la clase `CuentaBancaria`, llamada `cuentecliente1`, se establece su saldo en 10 mil millones usando el método `setSaldo` y luego se imprime el saldo actual utilizando `getSaldo`. Este código es útil para enseñar cómo trabajar con encapsulamiento y métodos getter/setter en la programación orientada a objetos.

```python
class CuentaBancaria():
  def __init__(self):
    self.__saldo = 0
    self.__cliente = ""
    
  # Defino setters y getters para el saldo
  def setSaldo(self,nuevosaldo):
    self.__saldo = nuevosaldo
  def getSaldo(self):
    return self.__saldo
    
cuentecliente1 = CuentaBancaria()
cuentecliente1.setSaldo(10000000000)
print(cuentecliente1.getSaldo())


    
```

### validacion

#### Explicación

Este código Python se centra en la creación de una clase llamada `CuentaBancaria` que simula el funcionamiento básico de una cuenta bancaria, con un énfasis especial en la validación del saldo. La clase contiene dos métodos importantes: `setSaldo`, que permite establecer el saldo de la cuenta, y `getSaldo`, que devuelve el saldo actual.

El método `__init__` es el constructor de la clase; inicializa las variables privadas `saldo` a 0 y `cliente` a una cadena vacía. Estas variables están protegidas por dos guiones bajos (`__`) al inicio, lo que indica que no deben ser accedidas directamente desde fuera de la clase.

El método `setSaldo` establece un límite para el cambio en el saldo: si se intenta depositar una cantidad que aumente el saldo más allá de 1000 euros sobre el saldo actual, el programa imprime un mensaje indicando que se va a notificar a la entidad bancaria y no realiza el cambio. Si la operación es válida (es decir, el nuevo saldo no supera este límite), entonces el saldo se actualiza correctamente.

Finalmente, en el bloque principal del script, se crea una instancia de `CuentaBancaria` llamada `cuentacliente1`. Se intenta establecer un saldo muy alto (10000000000 euros) y luego se imprime el saldo actual para verificar que no ha cambiado debido a la validación.

Esta práctica es importante en programación orientada a objetos porque muestra cómo proteger los datos de una clase de modificaciones no deseadas y cómo implementar controles específicos antes de permitir cambios en esos datos.

```python
limitediferenciasaldo = 1000

class CuentaBancaria():
  def __init__(self):
    self.__saldo = 0
    self.__cliente = ""
    
  # Defino setters y getters para el saldo
  def setSaldo(self,nuevosaldo):
    # Establezco una condicion de que valida si el saldo nuevo es mayor de 1000 euros
    if nuevosaldo > self.__saldo + 1000:
      # Si salta la alarma, avisa y NO cambia el saldo
      print("Voy a avisar a la entidad de un ingreso muy grande")
    else
      # Si pasa el filtro, solo entonces se cambia el saldo
      self.__saldo = nuevosaldo
      
  def getSaldo(self):
    return self.__saldo
    
cuentacliente1 = CuentaBancaria()
cuentacliente1.setSaldo(10000000000)
print(cuentacliente1.getSaldo())


    
```

### variable global

#### Explicación

Este código Python define una clase llamada `CuentaBancaria` que representa una cuenta bancaria y permite gestionar el saldo de esta cuenta. La variable global `limitediferenciasaldo` establece un límite para las diferencias permitidas en el saldo, en este caso, 1000 euros.

La clase tiene dos métodos principales: `setSaldo()` y `getSaldo()`. El método `setSaldo(nuevosaldo)` es responsable de cambiar el saldo de la cuenta. Sin embargo, antes de hacerlo, verifica si la nueva cantidad que se intenta establecer supera en más de 1000 euros al saldo actual (es decir, si está tratando de ingresar una gran cantidad). Si esto ocurre, imprime un aviso indicando que el banco debe ser informado y no cambia realmente el saldo. Si la nueva cantidad es aceptable según esta regla, entonces se establece como nuevo saldo.

Este tipo de control sobre cambios en los saldos ayuda a prevenir posibles errores o fraudes al mantener un nivel razonable de seguridad en las transacciones bancarias. Es importante destacar que este código usa variables encapsuladas (comenzando con `__`), lo cual significa que el saldo (`self.__saldo`) no se puede acceder directamente desde fuera de la clase, sino a través de los métodos proporcionados como `setSaldo()` y `getSaldo()`. Esto asegura una gestión más segura y controlada del estado interno de la instancia de la clase.

```python
limitediferenciasaldo = 1000

class CuentaBancaria():
  def __init__(self):
    self.__saldo = 0
    self.__cliente = ""
    
  # Defino setters y getters para el saldo
  def setSaldo(self,nuevosaldo):
    # Establezco una condicion de que valida si el saldo nuevo es mayor de 1000 euros
    if nuevosaldo > self.__saldo + limitediferenciasaldo:
      # Si salta la alarma, avisa y NO cambia el saldo
      print("Voy a avisar a la entidad de un ingreso muy grande")
    else
      # Si pasa el filtro, solo entonces se cambia el saldo
      self.__saldo = nuevosaldo
      
  def getSaldo(self):
    return self.__saldo
    
cuentacliente1 = CuentaBancaria()
cuentacliente1.setSaldo(10000000000)
print(cuentacliente1.getSaldo())


    
```

### creo setters y getters

#### Explicación

El fragmento de código que se muestra es el inicio de la definición de una clase en Python llamada `Cliente`. Esta clase está diseñada para representar a un cliente, almacenando información básica como su nombre completo y correo electrónico. Sin embargo, hay un problema crucial: la función `__init__` no tiene parámetros ni código dentro que permita inicializar realmente los atributos de la clase.

El método `__init__` es especial en Python ya que se llama automáticamente cuando creamos una nueva instancia (o objeto) a partir de esta clase. Este método debería tomar al menos un parámetro, además de `self`, para recibir datos con los cuales inicializar los atributos del cliente. En el código proporcionado, la función `__init__` no está completa ni funcional ya que falta especificar cómo se reciben y asignan los valores a los atributos `nombrecompleto` y `email`. Para corregir esto, necesitaríamos añadir parámetros al método `__init__`, como por ejemplo `nombrecompleto` e `email`, para que puedas establecer estos valores cuando crees un nuevo objeto de la clase Cliente. Esto es fundamental porque sin una inicialización correcta, no podremos almacenar ni recuperar información sobre los clientes utilizando objetos de esta clase.

```python
class Cliente():
  def __init__():
    self.nombrecompleto = ""
    self.email = ""
  
    


    
```

### ejemplo practico

#### Explicación

El código que has proporcionado es el inicio de la definición de una clase llamada `Cliente` en Python. La clase tiene un método especial denominado `__init__`, que se ejecuta automáticamente cada vez que se crea una nueva instancia (o objeto) de esta clase. Sin embargo, hay un detalle importante: la implementación del método `__init__()` está incompleta ya que falta el parámetro `self` en su definición.

En Python, todos los métodos dentro de una clase deben tener como primer parámetro a `self`, que se refiere al propio objeto. Este parámetro es crucial porque permite acceder y modificar las propiedades (atributos) de la instancia. En tu código, debes incluir el parámetro `self` para que la definición del método sea correcta:

```python
def __init__(self):
    self.nombrecompleto = ""
    self.email = ""
```

Este método inicializa dos atributos: `nombrecompleto` y `email`, ambos establecidos en una cadena vacía al principio. Esto significa que cada vez que se cree un nuevo objeto de la clase `Cliente`, estos atributos comenzarán con valores vacíos, listos para ser rellenados con información específica sobre el cliente.

Es importante tener este método porque permite configurar las características básicas de los objetos cuando son creados, lo cual es una práctica común y recomendada en programación orientada a objetos.

```python
class Cliente():
  def __init__():
    self.nombrecompleto = ""
    self.email = ""
  
    


    
```

### creo setters y getters

#### Explicación

Este código define una clase llamada `Cliente` en Python, que es útil para manejar información sobre clientes. La clase tiene un método especial denominado `__init__`, que se llama automáticamente cuando creamos un nuevo objeto de tipo `Cliente`. En este método inicializador, establecemos dos atributos de la clase: `nombrecompleto` y `email`, ambos con valores vacíos al principio.

Además del constructor, la clase incluye cuatro métodos adicionales conocidos como setters y getters. Los setters (`setNombreCompleto` y `setEmail`) permiten establecer o actualizar el nombre completo y el email de un cliente respectivamente. Por otro lado, los getters (`getNombreCompleto` y `getEmail`) nos devuelven los valores actuales del nombre completo y del email.

Estos métodos son importantes porque proporcionan una forma controlada de acceder a las propiedades privadas de la clase (en este caso, `nombrecompleto` y `email`). Esto ayuda a mantener la integridad de los datos, ya que permitimos cambiar o leer estos atributos solo mediante funciones específicas. Es una buena práctica en el desarrollo orientado a objetos para encapsular las variables y protegerlas de manipulaciones no autorizadas desde fuera de la clase.

```python
class Cliente():
  # Este es el método constructor
  def __init__(self):
    self.nombrecompleto = ""
    self.email = ""
  # Estos son los setters y los getters
  def setNombreCompleto(self,nuevonombre):
    self.nombrecompleto = nuevonombre
  def setEmail(self,nuevoemail):
    self.email = nuevoemail
  def getNombreCompleto(self):
    return self.nombrecompleto
  def getEmail(self):
    return self.email
    
# CRUD - Create, Read, Update, Delete
# CRUD SQL - INSERT, SELECT, UPDATE, DELETE


    

    


    
```

### pequeño programa

#### Explicación

Este código es una parte del diseño de una clase llamada `Cliente` en Python y muestra cómo interactuar con ella a través de opciones simples. La clase `Cliente` contiene un método constructor (`__init__`) que inicializa dos atributos: `nombrecompleto` y `email`, ambos como cadenas vacías al principio. Además, se definen cuatro métodos adicionales llamados setters y getters, es decir, métodos para establecer (`setNombreCompleto`, `setEmail`) y obtener (`getNombreCompleto`, `getEmail`) valores de los atributos del objeto.

Después de la definición de la clase, el código muestra un ejemplo básico de cómo podrías interactuar con objetos de esta clase a través de una interfaz simple en consola. Se le pide al usuario que seleccione entre dos opciones: insertar un nuevo cliente o obtener un listado de clientes (aunque el segundo no está implementado en este fragmento). Dependiendo de la opción seleccionada, se imprime un mensaje correspondiente para indicar qué acción tomaría en una aplicación real.

Este tipo de estructura es útil porque permite aislar la lógica del negocio (en este caso, el manejo de clientes) en clases y objetos, mientras que la interacción con estos puede mantenerse simple y clara en la parte principal del programa.

```python
class Cliente():
  # Este es el método constructor
  def __init__(self):
    self.nombrecompleto = ""
    self.email = ""
  # Estos son los setters y los getters
  def setNombreCompleto(self,nuevonombre):
    self.nombrecompleto = nuevonombre
  def setEmail(self,nuevoemail):
    self.email = nuevoemail
  def getNombreCompleto(self):
    return self.nombrecompleto
  def getEmail(self):
    return self.email
    
# CRUD - Create, Read, Update, Delete
# CRUD SQL - INSERT, SELECT, UPDATE, DELETE

print("Gestor de clientes v0.1 Jose Vicente Carratala")
print("Selecciona una opción:")
print("1.-Insertar un nuevo cliente")
print("2.-Obtener listado de clientes")
opcion = int(input("Indica tu opción (1,2): "))

if opcion == 1:
  print("Voy a insertar un cliente")
elif opcion == 2:
  print("Saco el listado de clientes")
  
  

    

    


    
```

### creo una lista de clientes

#### Explicación

Este código es una parte básica de un programa que gestiona una lista de clientes utilizando la programación orientada a objetos en Python. El programa define una clase llamada `Cliente`, la cual incluye métodos para establecer y obtener el nombre completo y el email del cliente (conocidos como setters y getters). Estos métodos permiten manipular los datos internos de un objeto `Cliente` de manera segura y controlada.

El código también muestra cómo crear una lista vacía llamada `clientes`, donde se almacenarán los objetos de la clase `Cliente`. Luego, el programa presenta al usuario un menú con dos opciones: insertar un nuevo cliente o obtener un listado de clientes. Si el usuario selecciona la opción 1 (insertar un nuevo cliente), el programa crea una nueva instancia de la clase `Cliente`, solicita al usuario que introduzca el nombre y el email del nuevo cliente, y utiliza los métodos set para asignar estos valores al objeto recién creado. Finalmente, este objeto se podría añadir a la lista `clientes` (aunque esta parte no está implementada en el código proporcionado).

Este tipo de estructura es fundamental en aplicaciones que manejan datos de usuarios o clientes, ya que permite encapsular y gestionar eficazmente los datos relacionados con cada cliente.

```python
class Cliente():
  # Este es el método constructor
  def __init__(self):
    self.nombrecompleto = ""
    self.email = ""
  # Estos son los setters y los getters
  def setNombreCompleto(self,nuevonombre):
    self.nombrecompleto = nuevonombre
  def setEmail(self,nuevoemail):
    self.email = nuevoemail
  def getNombreCompleto(self):
    return self.nombrecompleto
  def getEmail(self):
    return self.email
    
# CRUD - Create, Read, Update, Delete
# CRUD SQL - INSERT, SELECT, UPDATE, DELETE

clientes = []             ############## Meto una lista de clientes vacia

print("Gestor de clientes v0.1 Jose Vicente Carratala")
print("Selecciona una opción:")
print("1.-Insertar un nuevo cliente")
print("2.-Obtener listado de clientes")
opcion = int(input("Indica tu opción (1,2): "))

if opcion == 1:     # Los SETTERS se usan en las operaciones de creación de nuevos elementos
  print("Voy a insertar un cliente")
  nuevocliente = Cliente()
  nombrecliente = input("Introduce el nombre del cliente: ")  # Tomo el dato
  nuevocliente.setNombreCompleto(nombrecliente) # Uso el metodo set para meter el dato en el objeto
  emailcliente = input("Introduce el email del cliente: ")  # Tomo el dato
  nuevocliente.setEmail(emailcliente) # Uso el metodo set para meter el dato en el objeto
elif opcion == 2:
  print("Saco el listado de clientes")
  

  
  

    

    


    
```

### getters

#### Explicación

Este código es una pequeña aplicación en Python que gestiona un listado de clientes, mostrando cómo crear y manipular objetos. Se define una clase llamada `Cliente` con métodos para establecer (`set`) y obtener (`get`) información sobre los clientes como su nombre completo y correo electrónico. Estos métodos permiten encapsular la lógica de acceso a las propiedades del objeto, asegurando que el estado del objeto se mantenga consistente.

La aplicación también incluye un bucle principal donde el usuario puede elegir entre dos opciones: insertar un nuevo cliente o obtener una lista de todos los clientes existentes. Cuando se crea un nuevo cliente, primero se instancia un objeto `Cliente`, luego se utiliza el método `setNombreCompleto` para asignarle un nombre y `setEmail` para asignarle un correo electrónico. Este cliente recién creado es añadido a una lista global llamada `clientes`. Si el usuario decide obtener la lista de clientes, la aplicación itera sobre cada objeto en la lista y usa los métodos `getNombreCompleto` y `getEmail` para imprimir la información del cliente.

Este tipo de diseño, que separa claramente la responsabilidad entre la lógica de negocio (clase `Cliente`) y la interfaz con el usuario (bucle principal), es fundamental en programación orientada a objetos ya que facilita la mantenibilidad y extensibilidad del código.

```python
class Cliente():
  # Este es el método constructor
  def __init__(self):
    self.nombrecompleto = ""
    self.email = ""
  # Estos son los setters y los getters
  def setNombreCompleto(self,nuevonombre):
    self.nombrecompleto = nuevonombre
  def setEmail(self,nuevoemail):
    self.email = nuevoemail
  def getNombreCompleto(self):
    return self.nombrecompleto
  def getEmail(self):
    return self.email
    
# CRUD - Create, Read, Update, Delete
# CRUD SQL - INSERT, SELECT, UPDATE, DELETE

clientes = []             ############## Meto una lista de clientes vacia

print("Gestor de clientes v0.1 Jose Vicente Carratala")
while True:
  print("Selecciona una opción:")
  print("1.-Insertar un nuevo cliente")
  print("2.-Obtener listado de clientes")
  opcion = int(input("Indica tu opción (1,2): "))

  if opcion == 1:     # Los SETTERS se usan en las operaciones de creación de nuevos elementos
    print("Voy a insertar un cliente")
    nuevocliente = Cliente()
    nombrecliente = input("Introduce el nombre del cliente: ")  # Tomo el dato
    nuevocliente.setNombreCompleto(nombrecliente) # Uso el metodo set para meter el dato en el objeto
    emailcliente = input("Introduce el email del cliente: ")  # Tomo el dato
    nuevocliente.setEmail(emailcliente) # Uso el metodo set para meter el dato en el objeto
    clientes.append(nuevocliente) # Y por ultimo añado el cliente a la lista de clientes
  elif opcion == 2:   # Los GETTERS se usan en las operaciones de listado
    print("Saco el listado de clientes")
    for cliente in clientes:
      print("-------------------------")
      print("Nombre: ",cliente.getNombreCompleto())
      print("email: ",cliente.getEmail())
      print("-------------------------")


  
  

  
  

    

    


    
```

### Actividades propuestas

### Actividad 1: Creación y Acceso a Propiedades de Objetos

**Descripción:** Crea una clase `Perro` con atributos como nombre, raza y edad. Luego, crea un objeto de esta clase e imprime la información del perro utilizando métodos getters. Este ejercicio permite entender cómo encapsular y acceder a propiedades.

### Actividad 2: Métodos Setters

**Descripción:** Añade métodos setters a tu clase `Perro` para cambiar los valores de sus atributos. Prueba estos setters en un objeto de la clase e imprime el resultado para verificar que los cambios se han aplicado correctamente.

### Actividad 3: Uso de Propiedades Privadas

**Descripción:** Modifica la clase `Perro` para hacer algunas de las propiedades privadas (prefijos con "__"). Luego, crea métodos getters y setters para acceder a estas propiedades. Prueba el funcionamiento.

### Actividad 4: Clase Cuenta Bancaria Básica

**Descripción:** Crea una clase `CuentaBancaria` que tenga un atributo de saldo inicial en cero. Implementa los métodos necesarios para depositar y retirar dinero, con validaciones básicas para evitar saldos negativos.

### Actividad 5: Validación de Operaciones Bancarias

**Descripción:** Añade una nueva clase `CuentaBancaria` que incluya un límite en las transacciones. Implementa métodos que permitan depositar y retirar dinero, pero alerten al usuario si la operación supera este límite.

### Actividad 6: Cliente con Setters y Getters

**Descripción:** Crea una clase `Cliente` similar a la vista en el código proporcionado. Incluye métodos para establecer y obtener datos como nombre completo y email, y luego prueba estos métodos insertando y mostrando información de clientes.

### Actividad 7: Gestión Básica de Clientes

**Descripción:** Desarrolla un programa sencillo que permita al usuario elegir entre agregar un nuevo cliente o mostrar la lista de todos los clientes. Utiliza la clase `Cliente` y sus métodos setters y getters para manipular datos.

### Actividad 8: Manejo de Listas de Clientes

**Descripción:** Añade funcionalidades al programa anterior para permitir que el usuario inserte varios clientes en una lista y luego los muestre. Implementa también la opción para mostrar un cliente específico por su nombre.

### Actividad 9: Práctica con Clases y Métodos

**Descripción:** Utilizando las clases `Cliente` y `CuentaBancaria`, crea una aplicación que permita gestionar cuentas bancarias de clientes, incluyendo operaciones como depósito, retiro e impresión del saldo actual.

### Actividad 10: Integración y Pruebas

**Descripción:** Combina todas las clases y métodos desarrollados en actividades anteriores para crear una aplicación integral que permita gestionar tanto a los clientes como sus cuentas bancarias. Implementa validaciones adicionales para mejorar la robustez del sistema.

Estas actividades están diseñadas para ir incrementando gradualmente el nivel de complejidad, desde conceptos básicos hasta implementación de funcionalidades más avanzadas con clases y métodos en Python.


<a id="creacion-de-constructores"></a>
## Creación de constructores

### Introducción a los ejercicios

Esta carpeta contiene una serie de ejercicios que te ayudarán a entender y practicar cómo crear constructores en Python. Los ejercicios van desde un repaso básico sobre la creación de una clase simple con un constructor sin parámetros, hasta ejemplos más complejos donde se pasan múltiples argumentos al construir instancias de una clase como gatos o clientes. A través de estos ejercicios, aprenderás a inicializar atributos en los objetos al momento de su creación y cómo gestionar diferentes tipos de datos (números, cadenas) como parámetros del constructor. Estas actividades son fundamentales para dominar la creación de clases y objetos personalizados en Python.

### repaso gato

#### Explicación

Este código define una clase llamada `Gato` en Python, que es como un modelo o plantilla para crear objetos que representen a gatos. La clase tiene dos partes importantes: el constructor y un método.

El constructor se llama `__init__`, y su función principal es inicializar los atributos (características) del objeto cuando este se crea. En este caso, el constructor establece la edad del gato a 0 utilizando el comando `self.edad = 0`. El uso de `self` en Python indica que esta variable pertenece al objeto mismo.

Además, hay un método llamado `maulla`, que simplemente retorna una cadena de texto diciendo "El gato está maullando". Este método no se ejecuta automáticamente cuando creas el objeto, sino que debes invocarlo explícitamente como hicimos en la última línea del código.

Es importante entender estos conceptos porque te permiten crear objetos personalizados con comportamientos y características específicas. En este ejemplo, puedes ver cómo crear un gato con una edad inicial (aunque sea 0) y hacer que el gato "maulle" cuando quieras representar ese comportamiento en tu programa.

```python
class Gato():
  def __init__(self):    # El constructor se ejecuta sí o sí
    self.edad = 0
    
  def maulla(self):     # El resto de métodos sólo se ejecutan si los llamas
    return "El gato está maullando"
    
    
gato1 = Gato()
print(gato1.edad)

print(gato1.maulla())
    
```

### a un construtor se le pueden pasar parametros

#### Explicación

Este código crea una clase llamada `Gato` en Python, que es como un modelo para crear objetos que representen gatos. La clase tiene dos partes principales: el constructor y un método.

El constructor es la función especial `__init__(self)`, que se ejecuta automáticamente cuando creamos un nuevo objeto de tipo `Gato`. En este caso, le asigna a cada gato una edad inicial de 0 (`self.edad = 0`). La palabra clave `self` se usa para referirse al propio objeto recién creado.

Además del constructor, la clase tiene un método llamado `maulla`, que retorna un string diciendo que el gato está maullando. Este método solo se ejecuta cuando lo llamamos explícitamente en nuestro código.

Después de definir la clase, creamos una instancia de ella llamada `gato1`. Imprimimos su edad inicial (0), cambiamos su edad a 5 y volvemos a imprimir para ver el cambio. Finalmente, llamamos al método `maulla` y lo imprimimos.

Este código es importante porque demuestra cómo definir y usar una clase con un constructor que establece propiedades iniciales y métodos que definen comportamientos específicos del objeto.

```python
class Gato():
  def __init__(self):    # El constructor se ejecuta sí o sí
    self.edad = 0
    
  def maulla(self):     # El resto de métodos sólo se ejecutan si los llamas
    return "El gato está maullando"
    
    
gato1 = Gato()
print(gato1.edad)
gato1.edad = 5
print(gato1.edad)

print(gato1.maulla())
    
```

### constructor con parametros

#### Explicación

Este fragmento de código Python muestra cómo crear una clase en programación orientada a objetos. La clase se llama `Gato` y tiene un atributo llamado `edad`. El constructor, que es la función especial `__init__()`, recibe un parámetro llamado `edad` cuando se crea un nuevo objeto de tipo `Gato`. Este constructor inicializa el atributo `self.edad` del gato con el valor proporcionado. Es importante porque asegura que cada gato tenga su propia edad asignada al momento de ser creado.

Además, la clase tiene otro método llamado `maulla()`, que simplemente devuelve un mensaje indicando que "El gato está maullando". Este método no necesita parámetros adicionales y se puede llamar en cualquier momento después de haber creado el objeto `gato1` usando el constructor.

En resumen, este código te permite crear objetos de la clase `Gato`, cada uno con su propia edad establecida desde el principio. El método `maulla()` es una acción que puedes realizar con estos gatos creados una vez que los tienes en tu programa.

```python
class Gato():
  def __init__(self,edad):    # El constructor se ejecuta sí o sí
    self.edad = edad
    
  def maulla(self):     # El resto de métodos sólo se ejecutan si los llamas
    return "El gato está maullando"
    
    
gato1 = Gato(5)

    
```

### mas parametros

#### Explicación

Este código crea una clase llamada `Gato` en Python. La clase es como un molde para crear objetos, que en este caso son representaciones de gatos virtuales. Dentro de la clase, hay dos partes importantes: el constructor y un método.

1. **Constructor (`__init__`):** Este es el primer bloque de código que se ejecuta cuando creamos una nueva instancia (un nuevo objeto) del tipo `Gato`. En este caso, el constructor recibe dos parámetros: `edad` y `nombre`, que son características específicas para cada gato. Cuando un gato nuevo es creado a partir de esta clase, debes proporcionar estos detalles. El código dentro del constructor guarda la edad y el nombre en atributos llamados `self.edad` y `self.nombre`. Estos atributos pertenecen al objeto que se está creando.

2. **Método (`maulla`):** Este método es una función dentro de la clase que describe un comportamiento del gato, en este caso, maullar. No se ejecuta automáticamente cuando creamos un objeto `Gato`, sino que debe ser llamado explícitamente para que el objeto haga algo.

Al final, el código crea una instancia específica de la clase `Gato` y le da los valores de 5 años de edad y "micifu" como nombre. Esto significa que se ha creado un gato concretamente identificado en nuestro programa.

Este tipo de diseño es importante porque permite crear objetos personalizados dentro del mismo modelo, permitiendo representar diferentes entidades (en este caso, diferentes gatos) con características únicas pero bajo la misma estructura general.

```python
class Gato():
  def __init__(self,edad,nombre):    # El constructor se ejecuta sí o sí
    self.edad = edad
    self.nombre = nombre
    
  def maulla(self):     # El resto de métodos sólo se ejecutan si los llamas
    return "El gato está maullando"
    
    
gato1 = Gato(5,"micifu")

    
```

### tercera propiedad

#### Explicación

Este fragmento de código Python crea una clase llamada `Gato` que permite representar y manipular información sobre un gato. La parte más importante es el método especial `__init__`, conocido como constructor, que se encarga de inicializar cada instancia (objeto) de la clase con valores específicos. En este caso, al crear un nuevo objeto `Gato`, necesitas proporcionar tres piezas de información: la edad del gato, su nombre y su raza.

Además del constructor, la clase tiene otro método llamado `maulla` que, cuando se llama, simplemente devuelve el mensaje "El gato está maullando". Este tipo de estructura es importante porque permite encapsular en un solo lugar todas las características y comportamientos relacionados con los gatos, haciendo más fácil trabajar con objetos del tipo `Gato`.

En la última línea, creamos una instancia específica de `Gato` llamada `gato1`, dando como argumentos 5 (edad), "micifu" (nombre) y "mainecoon" (raza). Esto significa que ahora tenemos un objeto en nuestra memoria con estos detalles específicos.

```python
class Gato():
  def __init__(self,edad,nombre,raza):    # El constructor se ejecuta sí o sí
    self.edad = edad
    self.nombre = nombre
    self.raza = raza
    
  def maulla(self):     # El resto de métodos sólo se ejecutan si los llamas
    return "El gato está maullando"
    
    
gato1 = Gato(5,"micifu","mainecoon")

    
```

### ejemplo con cliente

#### Explicación

Este código crea una clase llamada `Cliente` en Python, que es como un modelo o plantilla para crear objetos que representen a los clientes. Dentro de esta clase, se define un método especial llamado `__init__`, que sirve para inicializar cada nuevo objeto de la clase `Cliente`. Este método toma cinco parámetros: nombre, apellidos, email y dirección del cliente. Estos parámetros son usados para asignar valores a las propiedades del objeto (`self.nombre`, `self.apellidos`, etc.).

A continuación, el código solicita al usuario que ingrese información sobre un nuevo cliente a través de la consola: nombre, apellidos, email y dirección. Esta información se utiliza para crear una nueva instancia de la clase `Cliente`. Finalmente, se imprime el objeto recién creado en pantalla.

Este tipo de estructura es importante porque permite organizar y encapsular datos y comportamientos relacionados con un cliente en una sola entidad, facilitando así el manejo de información compleja y permitiendo expandir fácilmente las funcionalidades del programa más adelante.

```python
class Cliente():
  def __init__(self,nombre,apellidos,email,direccion):
    self.nombre = nombre
    self.apellidos = apellidos
    self.email = email
    self.direccion = direccion
    
nombre = input("Introduce el nombre del cliente: ")
apellidos = input("Introduce los apellidos del cliente: ")
email = input("Introduce el email del cliente: ")
direccion = input("Introduce la dirección del cliente: ")

cliente1 = Cliente(nombre,apellidos,email,direccion)
print(cliente1)




    
```

### listado de clientes

#### Explicación

Este código es una parte de un programa en Python que ayuda a gestionar una lista de clientes. La clase `Cliente` se define para crear objetos que representan información sobre cada cliente, como su nombre, apellidos, email y dirección. Cuando creas un objeto de tipo `Cliente`, debes proporcionar esos cuatro detalles al momento de la creación del objeto, gracias al método `__init__`.

Luego, el programa entra en un bucle infinito (`while True:`) que solicita repetidamente al usuario que introduzca información para cada nuevo cliente. Con los datos ingresados por el usuario, se crea una instancia (ejemplar) de la clase `Cliente` y se añade a la lista `clientes`. Esto permite almacenar múltiples clientes en un contenedor fácil de manejar.

Este código es importante porque muestra cómo se pueden utilizar clases para organizar y encapsular información de manera estructurada, facilitando así el manejo y uso de datos relacionados con diferentes objetos en programas más grandes.

```python
class Cliente():
  def __init__(self,nombre,apellidos,email,direccion):
    self.nombre = nombre
    self.apellidos = apellidos
    self.email = email
    self.direccion = direccion
 
clientes = []
while True:  
 
  nombre = input("Introduce el nombre del cliente: ")
  apellidos = input("Introduce los apellidos del cliente: ")
  email = input("Introduce el email del cliente: ")
  direccion = input("Introduce la dirección del cliente: ")

  clientes.append(Cliente(nombre,apellidos,email,direccion))





    
```

### Actividades propuestas

### Actividades Propuestas

1. **Constructor Básico de Gato**
   - Descripción: Diseña una clase `Gato` con un constructor que inicialice el atributo `edad`. Este ejercicio ayuda a entender cómo definir y utilizar constructores en Python.
   
2. **Modificar Atributos del Gato**
   - Descripción: Crea un método dentro de la clase `Gato` para modificar su edad después de crear una instancia. Los alumnos aprenderán a interactuar con los atributos de una instancia.

3. **Constructor con Parámetros**
   - Descripción: Mejora el constructor del gato para que acepte parámetros al instanciar un objeto, inicializando la edad y nombre en función de estos valores.
   
4. **Añadir Múltiples Propiedades**
   - Descripción: Añade más propiedades a tu clase `Gato`, como el nombre y la raza, para practicar con múltiples parámetros en un constructor.

5. **Método de Acción del Gato**
   - Descripción: Implementa un método llamado `maulla` dentro de la clase que devuelva una cadena indicando que el gato está maullando, para entender cómo trabajar con métodos de instancia.
   
6. **Instanciar Clientes**
   - Descripción: Crea instancias de la clase `Cliente`, recogiendo datos del usuario como nombre y dirección. Los estudiantes aprenderán a manipular clases más complejas.

7. **Listado de Clientes**
   - Descripción: Elabora un programa que permita almacenar múltiples clientes en una lista, solicitando información al usuario para cada uno.
   
8. **Personalización del Cliente**
   - Descripción: Añade propiedades adicionales a la clase `Cliente`, como número de teléfono o preferencias de contacto, y modifica el constructor y los métodos necesarios.

Estas actividades están diseñadas para ayudar a los estudiantes a comprender y aplicar conceptos fundamentales de programación orientada a objetos en Python, adaptándose al nivel intermedio esperado en Formación Profesional.


<a id="utilizacion-de-clases-y-objetos"></a>
## Utilización de clases y objetos

### Introducción a los ejercicios

En esta carpeta de ejercicios, te encuentras con tres archivos que exploran el uso y la creación de clases en Python para realizar operaciones matemáticas básicas como redondeo hacia arriba y hacia abajo. Estos ejemplos comienzan por crear una clase personalizada llamada `Matematicas` donde se implementa un método para redondear números, y luego expanden esta clase añadiendo métodos para obtener el techo (redondeo al alza) y suelo (redondeo a la baja). El último ejercicio muestra cómo utilizar funciones equivalentes desde la librería estándar de Python (`math`). A través de estos ejercicios, aprenderás a encapsular funcionalidades en clases propias y a utilizar eficientemente las herramientas que ofrece el lenguaje para resolver problemas matemáticos.

### Mi propia clase

#### Explicación

Este fragmento de código Python crea una clase llamada `Matematicas` que nos permite realizar ciertas operaciones matemáticas. La clase tiene un método especial llamado `__init__`, que se ejecuta automáticamente cuando creamos un objeto de esta clase. En este caso, el método inicializa una propiedad de la clase llamada `PI`, que es un valor constante de pi (π) con muchos decimales.

Además, la clase tiene otro método llamado `redondeo` que toma como entrada un número real y devuelve su redondeo al entero más cercano. Este método funciona dividiendo el número en parte entera y decimal, luego decide si redondear hacia arriba o hacia abajo dependiendo del valor de la parte decimal.

Finalmente, se crea una instancia de la clase `Matematicas` llamada `Mate`, y se llama al método `redondeo` dos veces con diferentes números (4.7 y 4.2) para mostrar cómo funciona el redondeo. Esto es importante porque permite encapsular comportamientos matemáticos en un objeto, haciéndolo más fácil de usar y mantener en programas más grandes.

```python
class Matematicas():
  def __init__(self):
    self.PI = 3.14159265359
    
  def redondeo(self,numero):
    entero = int(numero)
    decimal = numero - entero
    if decimal < 0.5:
      redondeo = 0
    else:
      redondeo = 1
    return entero + redondeo
    
Mate = Matematicas()
print(Mate.redondeo(4.7))
print(Mate.redondeo(4.2))
```

### redondeos alza y baja

#### Explicación

Este código Python crea una clase llamada `Matematicas` que ayuda a realizar operaciones matemáticas básicas como redondear números, calcular el "techo" (redondear hacia arriba) y el "suelo" (redondear hacia abajo). Cuando se crea un objeto de la clase `Matematicas`, este inicializa una constante `PI` con un valor aproximado del número Pi.

El método `redondeo()` toma un número como entrada, separa la parte entera y decimal del número, y decide si redondear hacia arriba o hacia abajo basándose en el valor de la parte decimal. Si la parte decimal es menor que 0.5, el número se redondea hacia abajo (hacia cero), y si es mayor o igual a 0.5, se redondea hacia arriba.

Los métodos `techo()` y `suelo()` son más sencillos: simplemente toman un número, eliminan la parte decimal con la función `int()`, y el método `techo()` suma uno para siempre redondear al siguiente entero. Esto es útil cuando necesitas asegurarte de que un número siempre se ajuste hacia arriba o hacia abajo dependiendo de las circunstancias.

Este tipo de operaciones son fundamentales en programación ya que a menudo trabajamos con números y debemos manejarlos de manera precisa según nuestras necesidades.

```python
class Matematicas():
  def __init__(self):
    self.PI = 3.14159265359
    
  def redondeo(self,numero):
    entero = int(numero)
    decimal = numero - entero
    if decimal < 0.5:
      redondeo = 0
    else:
      redondeo = 1
    return entero + redondeo
    
  def techo(self,numero):
    return int(numero)+1
  def suelo(self,numero):
    return int(numero)
    
Mate = Matematicas()
print(Mate.redondeo(4.7))
print(Mate.redondeo(4.2))
print(Mate.techo(4.7))
print(Mate.suelo(4.7))
```

### ahora uso la libreria estandar

#### Explicación

Este fragmento de código está utilizando algunas funciones matemáticas básicas en Python para redondear y manipular números. Primero, se importa el módulo `math`, que es una biblioteca estándar en Python que proporciona acceso a funciones matemáticas adicionales más allá de las que ofrece la sintaxis básica del lenguaje.

El código imprime en pantalla cuatro resultados diferentes:

1. La función `round()` se utiliza dos veces para redondear los números 4.7 y 4.2 al número entero más cercano. Para el caso de 4.7, el resultado será 5 porque está más cerca a 5 que a 4; mientras que para 4.2, la función devolverá 4 ya que es más cercano a este.

2. La función `math.ceil()` se utiliza para redondear hacia arriba cualquier número decimal al entero inmediatamente superior. Así, cuando se aplica a 4.7, el resultado será 5.

3. Por último, `math.floor()` redondea hacia abajo cualquier número decimal al entero más cercano pero menor que el original. En este caso, aplicado a 4.7, devolverá 4.

Estas funciones son esenciales en la programación para manipular números según sea necesario y realizar cálculos precisos dependiendo del contexto de tu programa.

```python
import math
    
print(round(4.7))
print(round(4.2))
print(math.ceil(4.7))
print(math.floor(4.7))
```

### Actividades propuestas

### Actividades Propuestas

1. **Clase `Matematicas`: Creación y Uso Básico**
   - Desarrolla una clase llamada `Calculadora` que incluya un método para redondear números, similar a la implementación en el archivo `001-Mi propia clase.py`. El objetivo es familiarizarse con la creación de clases y métodos en Python.

2. **Expansión de Funcionalidades**
   - Añade dos nuevos métodos a la clase `Matematicas` del ejercicio anterior: uno que redondee hacia arriba (techo) y otro que redondee hacia abajo (suelo), como se muestra en el archivo `002-redondeos alza y baja.py`. Esto permitirá entender mejor cómo extender las funcionalidades de una clase existente.

3. **Comparación con Librerías Estandar**
   - Utiliza la librería estándar `math` para implementar funciones similares a los métodos creados en `002-redondeos alza y baja.py`. Comparar ambas implementaciones ayudará a entender las ventajas de usar bibliotecas existentes.

4. **Documentación de Métodos**
   - Añade docstrings (documentación) a cada método dentro de la clase `Matematicas` para describir brevemente su función. Esto es fundamental para mejorar la calidad del código y facilitar el mantenimiento.

5. **Uso de Atributos Estáticos**
   - Modifica la clase `Calculadora` para que tenga un atributo estático llamado `PI`. Este valor debe ser accesible desde cualquier instancia de la clase sin necesidad de crear una nueva instancia cada vez que se quiera usar.

6. **Encapsulamiento y Atributos Privados**
   - Introduce el concepto de encapsulamiento cambiando los atributos de la clase a privados (`_PI`, `_numero`). Crea métodos getter para acceder a estos atributos desde fuera de la clase, lo que ayudará a entender cómo proteger ciertos datos.

7. **Herencia Simple**
   - Diseña una nueva clase llamada `CalculadoraCientifica` que herede de `Matematicas`. Añade un nuevo método en esta clase para calcular el seno de un número, demostrando cómo se puede utilizar la herencia para ampliar funcionalidades.

8. **Testeo y Pruebas Unitarias**
   - Escribe pruebas unitarias utilizando una biblioteca como `unittest` para verificar que los métodos `redondeo`, `techo`, y `suelo` de tu clase `Matematicas` funcionan correctamente. Esto es crucial para garantizar la robustez del código.

Estas actividades están diseñadas para permitir a los estudiantes de Formación Profesional adquirir experiencia práctica en la creación y uso de clases en Python, desde conceptos básicos hasta temas más avanzados como herencia e implementación de pruebas unitarias.


<a id="utilizacion-de-clases-heredadas"></a>
## Utilización de clases heredadas

### Introducción a los ejercicios

En esta carpeta de ejercicios, se exploran conceptos fundamentales sobre la herencia en programación orientada a objetos utilizando Python. Los ejercicios comienzan con clases independientes para gatos y perros (archivo 001), luego introducen una clase madre llamada "Animal" que es utilizada por las subclases Gato y Perro, mostrando cómo compartir atributos entre ellas mediante la herencia (archivo 002). En el archivo 003, se introduce una nueva clase "Roca", para ilustrar situaciones en las que no es apropiado utilizar herencia. Finalmente, en el ejercicio 004, se amplía la profundidad de la herencia mostrando cómo las clases pueden formar cadenas jerárquicas más complejas con múltiples niveles de herencia.

Estos ejercicios buscan desarrollar tus habilidades para diseñar estructuras de datos y objetos que reflejen relaciones reales en el mundo, ayudándote a comprender mejor cuándo es apropiado utilizar la herencia y cómo manejar distintas configuraciones de clases.

### gatos y perros

#### Explicación

Este código define dos clases separadas, `Gato` y `Perro`, cada una con un método especial llamado `__init__`. Este método se utiliza para inicializar objetos cuando se crean instancias de la clase. En este caso, tanto para los gatos como para los perros, el método `__init__` establece tres atributos: `edad`, `nombre` e `raza`. Estos atributos son vacíos al principio (con valores 0 y cadena vacía), lo que significa que cuando se crea un objeto de estas clases, estos campos deben ser especificados posteriormente para tener información útil sobre el gato o perro.

Es importante destacar que este código es una buena introducción a la creación de clases en Python, ya que muestra cómo definir atributos comunes a las mascotas y cómo inicializarlos cuando se crea un objeto. Sin embargo, podríamos notar que los atributos `edad`, `nombre` e `raza` son compartidos por ambos animales, lo que podría sugerir la posibilidad de crear una clase base común para evitar duplicar el código en ambas clases. Esto es un concepto avanzado llamado herencia, que permitirá reutilizar y organizar mejor nuestro código cuando trabajemos con varios tipos de mascotas o incluso otros animales.

```python
class Gato():
  def __init__(self):
    self.edad = 0
    self.nombre = ""
    self.raza = ""
    
class Perro():
  def __init__(self):
    self.edad = 0
    self.nombre = ""
    self.raza = ""
```

### clase madre animal

#### Explicación

Este código enseña cómo las clases pueden heredar propiedades y métodos de otras clases en Python, lo que es una parte fundamental del concepto de herencia en programación orientada a objetos. La clase base se llama `Animal` y tiene tres atributos: `edad`, `nombre` y `raza`. Posteriormente, definimos dos nuevas clases, `Gato` y `Perro`, que heredan de la clase `Animal`. Esto significa que tanto `Gato` como `Perro` tienen automáticamente los mismos atributos (`edad`, `nombre`, `raza`) que la clase `Animal`.

En el código, al crear un objeto `gato1` de tipo `Gato` y uno `perro1` de tipo `Perro`, ambos objetos pueden acceder a su atributo `edad` porque heredan este atributo de la clase base `Animal`. Al imprimir la edad de cada animal, obtenemos 0 para ambos, ya que es el valor por defecto establecido en la inicialización (`__init__`) de la clase `Animal`.

Esta práctica de herencia permite reutilizar código y estructurar programas más organizados al compartir características comunes entre clases relacionadas.

```python
class Animal():
  def __init__(self):
    self.edad = 0
    self.nombre = ""
    self.raza = ""

class Gato(Animal):
  def __init__(self):
    super().__init__()    # Me traigo todo lo que tenga la clase superior
    
class Perro(Animal):      # Me traigo todo lo que tenga la clase superior
  def __init__(self):
    super().__init__()

gato1 = Gato()
print(gato1.edad)

perro1 = Perro()
print(perro1.edad)
    
```

### clase Roca

#### Explicación

Este código muestra cómo se crean y utilizan clases en Python para representar animales con características comunes y específicas. Primero, se define una clase base llamada `Animal` que contiene atributos como la edad del animal, su nombre y raza. Luego, dos clases derivadas (`Gato` y `Perro`) heredan de `Animal`. Esto significa que los gatos y perros pueden usar todos los atributos y métodos de la clase `Animal`, pero también tienen sus propios atributos adicionales como coordenadas en 3D (x, y, z).

La clase `Roca` no hereda de ninguna otra clase porque las rocas no son animales. Tiene atributos similares a los gatos y perros para ilustrar que estos atributos son específicos de cada tipo de entidad.

El código crea una instancia (`gato1`) del objeto `Gato` y muestra su edad, demostrando cómo heredar características de la clase base. Lo mismo se hace con el perro (`perro1`). Este enfoque es importante porque permite reutilizar código (en este caso, los atributos comunes a todos los animales) mientras añade funcionalidades específicas para cada subclase.

Este tipo de herencia y composición de clases es fundamental en la programación orientada a objetos ya que ayuda a organizar el código y hacerlo más mantenible.

```python
class Animal():
  def __init__(self):
    self.edad = 0
    self.nombre = ""
    self.raza = ""

class Gato(Animal):
  def __init__(self):
    super().__init__()    # Me traigo todo lo que tenga la clase superior
    self.x = 0
    self.y = 0
    self.z = 0
    
class Perro(Animal):      
  def __init__(self):
    super().__init__()  # Me traigo todo lo que tenga la clase superior
    self.x = 0
    self.y = 0
    self.z = 0

class Roca():
  def __init__(self):
    self.x = 0
    self.y = 0
    self.z = 0

gato1 = Gato()
print(gato1.edad)

perro1 = Perro()
print(perro1.edad)
    
```

### herencia o multinivel

#### Explicación

Este código enseña cómo se utilizan las clases heredadas en Python, un concepto clave para el desarrollo orientado a objetos. Primero, define una clase base llamada `Entidad` que contiene atributos como coordenadas (x, y, z), los cuales pueden ser relevantes para representar entidades en un espacio tridimensional. A partir de esta clase se crea otra llamada `Animal`, la cual hereda todos los atributos de `Entidad` pero también añade sus propios atributos específicos como edad, nombre y raza.

Luego, dos subclases más, `Gato` y `Perro`, son definidas a partir de la clase `Animal`. Ambas clases simplemente llaman al constructor de su superclase (`Animal`) para heredar todos sus atributos sin agregar nada nuevo. Finalmente, se crea una instancia de `Gato` llamada `gato1` e imprime su edad (que es 0 ya que no se ha especificado ningún valor en la definición del objeto). Se hace lo mismo con una instancia de `Perro`.

Este ejemplo demuestra cómo puedes reutilizar código y estructurar tus clases para crear jerarquías más complejas, lo cual es importante cuando trabajas en proyectos grandes donde necesitas objetos relacionados pero no idénticos.

```python
class Entidad():
  def __init__(self):
    self.x = 0
    self.y = 0
    self.z = 0

class Animal(Entidad):
  def __init__(self):
    super().__init__()
    self.edad = 0
    self.nombre = ""
    self.raza = ""

class Gato(Animal):
  def __init__(self):
    super().__init__()    # Me traigo todo lo que tenga la clase superior

    
class Perro(Animal):      
  def __init__(self):
    super().__init__()  # Me traigo todo lo que tenga la clase superior
    

class Roca(Entidad):
  def __init__(self):
    super().__init__()


gato1 = Gato()
print(gato1.edad)

perro1 = Perro()
print(perro1.edad)
    
```

### Actividades propuestas

### Actividades Propuestas

#### 1. Creación de Clases con Herencia Simples
**Descripción:** Los estudiantes deben crear una clase abstracta `Vehiculo` que incluya atributos comunes a todos los vehículos (como marca y modelo). A continuación, deben crear dos clases derivadas: `Coche` e `Moto`, incorporando características específicas de cada tipo. La actividad busca reforzar el concepto de herencia y polimorfismo.

#### 2. Clase Madre con Herencia Múltiple
**Descripción:** Los estudiantes deben implementar una clase base llamada `Persona` que tenga atributos como nombre, edad y dirección. A partir de esta clase, deben crear dos clases derivadas: `Estudiante` e `Empleado`, añadiendo propiedades adicionales relevantes para cada rol.

#### 3. Creación de Clases con Herencia Multinivel
**Descripción:** Se pide a los estudiantes que diseñen una jerarquía de clases basada en la creación de plantas, donde una clase `Planta` actúa como clase base y tiene dos subclases: `Hierba` e `Árbol`. Cada una debe tener características propias adicionales al modelo básico.

#### 4. Herencia vs Composición
**Descripción:** Los estudiantes deben discutir y demostrar cómo usar la herencia o la composición para modelar una relación de contención entre clases, como por ejemplo entre `Escuela` (contiene `Profesor`) y `Alumno`. La actividad busca entender cuándo es apropiado usar cada técnica.

#### 5. Sobrescribir Métodos en Herencia
**Descripción:** Se pide a los estudiantes que escriban una clase base con un método genérico, luego crear varias clases derivadas que sobreescriben este método para comportarse de manera diferente según su tipo específico (por ejemplo, `Aves` y `Peces`). La actividad pretende reforzar el concepto de polimorfismo.

#### 6. Ejercicio Práctico: Creación de un Sistema de Personajes
**Descripción:** Los estudiantes deben crear una jerarquía de clases que represente a diferentes personajes en un juego, como `Jugador` y `Enemigo`. Cada clase debe tener características específicas e implementar métodos comunes pero con comportamientos únicos.

#### 7. Uso de Superclases
**Descripción:** Se pide diseñar una estructura basada en la herencia donde una superclase abstracta tenga métodos y atributos que deben ser utilizados por sus subclases, mostrando cómo se utiliza `super()` para inicializar las partes comunes.

#### 8. Ejercicio de Refactorización
**Descripción:** Los estudiantes reciben un código con múltiples clases y les piden refactorizarlo para mejorar la estructura herárquica y el uso eficiente de la herencia, buscando eliminar redundancias y aumentar la cohesión del código.

#### 9. Herencia Profunda
**Descripción:** Los estudiantes deben diseñar una jerarquía compleja basada en una clase base `Objeto` que se ramifica para crear objetos más específicos como `Artefacto`, `Mueble`, y `Utensilio`. Cada nivel de la jerarquía debe agregar detalles específicos.

#### 10. Ejercicio de Polimorfismo Complejo
**Descripción:** Los estudiantes deben implementar un sistema donde varias clases (por ejemplo, diferentes tipos de vehículos) heredan de una clase base y se comportan en función del contexto actual, mostrando el uso avanzado de polimorfismo en situaciones prácticas.


<a id="ejercicio-de-final-de-unidad-3"></a>
## Ejercicio de final de unidad

### Introducción a los ejercicios

Este conjunto de ejercicios en Python está diseñado para cubrir los fundamentos básicos del lenguaje, desde la impresión simple hasta el manejo de datos y operaciones aritméticas. Los estudiantes aprenderán a trabajar con variables, tipos de datos, entradas y salidas, así como a realizar cálculos simples y comprender conceptos como literales y constantes. A medida que avanzan, se les introduce la creación de programas más complejos, como una calculadora básica para calcular impuestos, lo cual les ayuda a aplicar en práctica los conocimientos adquiridos sobre variables, tipos de datos y operaciones matemáticas.

La secuencia gradual del contenido permite a los estudiantes familiarizarse con la sintaxis y las estructuras básicas de Python antes de abordar problemas más complejos que requieren el uso combinado de varios conceptos. Esto incluye la conversión entre tipos de datos, uso eficaz de operadores aritméticos y de comparación, así como manipulación básica de entradas y salidas del usuario.

### Holamundo

#### Explicación

Este código es muy sencillo y está diseñado para mostrar cómo imprimir texto en la pantalla cuando se ejecuta un programa en Python. La función `print()` se utiliza para mostrar el texto entre paréntesis, que en este caso es "Hola mundo desde Python". Al ejecutar el programa, simplemente verás ese mensaje aparecer en la consola o terminal donde estés trabajando con tu código.

Este fragmento de código es especialmente importante porque suele ser uno de los primeros ejemplos que se enseñan a principiantes cuando están aprendiendo un nuevo lenguaje de programación. Ayuda a familiarizarse con el entorno de desarrollo y confirma que todo está configurado correctamente para poder ejecutar scripts Python.

```python
print("Hola mundo desde Python")
```

### variables

#### Explicación

Este código es muy sencillo pero fundamental para entender cómo trabajamos con datos en Python. Se crean dos variables, `nombre` y `edad`. La variable `nombre` almacena el texto `"Jose Vicente"`, que es una cadena de caracteres o string en programación. Por otro lado, la variable `edad` guarda el número entero `47`. Estas líneas son importantes porque nos permiten referirnos a información específica utilizando nombres significativos y no solo números o caracteres aleatorios, lo cual facilita mucho la lectura y comprensión del código para otros programadores.

```python
nombre = "Jose Vicente"
edad = 47
```

### salidas

#### Explicación

Este código Python muestra cómo imprimir un texto en la pantalla junto con una variable. En primer lugar, se define una variable llamada `nombre` y se le asigna el valor de la cadena `"Jose Vicente"`. Luego, utilizando la función `print()`, el programa imprime la frase `"Mi nombre es"` seguida del contenido de la variable `nombre`.

Lo que hace este código es combinar texto estático con datos almacenados en variables para formar un mensaje coherente. Es importante porque permite personalizar los mensajes que se muestran a los usuarios, haciendo el programa más interactivo y relevante.

Este tipo de técnica es fundamental en la programación ya que nos permite mostrar información al usuario de manera clara y estructurada, lo cual es crucial para aplicaciones web, consolas de comandos y cualquier otro medio donde se necesita presentar datos de forma legible.

```python
nombre = "Jose Vicente"
print("Mi nombre es",nombre)
```

### variar una variable

#### Explicación

Este fragmento de código en Python muestra cómo se pueden cambiar el valor de una variable durante la ejecución del programa. En este caso, la variable llamada `nombre` almacena inicialmente el texto "Jose Vicente". Luego, el programa imprime un mensaje que incluye este nombre. Después, el valor de la variable `nombre` cambia a "Juan" y se vuelve a imprimir otro mensaje utilizando el nuevo valor de la variable.

La importancia de esto radica en la capacidad del código para ser dinámico; es decir, puede modificar los datos utilizados durante su ejecución. Esto es fundamental cuando se trabaja con programas que necesitan actualizar información basada en diferentes entradas o condiciones cambiantes.

```python
nombre = "Jose Vicente"
print("Mi nombre es",nombre)

nombre = "Juan"
print("Mi nombre es",nombre)
```

### identificadores permitidos

#### Explicación

Este fragmento de código muestra ejemplos válidos e inválidos para nombrar variables en Python. En la primera línea, `nombre` es un nombre de variable válido que contiene el valor `"Jose"`. Luego, `nombre2` también es una variable válida con el valor `"Vicente"`. Se muestran algunos ejemplos de nombres no permitidos: comienzos de nombres con números (`2nombre`) y uso de caracteres especiales como guiones (`-`), ya que estos generarían un error en Python. Finalmente, `nombreCompleto` es un nombre válido pero poco recomendado porque combina palabras sin guion bajo para mejorar la legibilidad (es preferible usar `_` entre palabras). Los buenos nombres de variables ayudan a entender el propósito del dato y facilitan la lectura del código.

```python
nombre = "Jose"
nombre2 = "Vicente"
# 2nombre = "Jose Vicente"
nombre_completo = "Jose Vicente"
#nombre-completo = "Jose Vicente"
#nombre completo = "Jose Vicente"
nombreCompleto = "Jose Vicente" # Es legal pero no se recomienda
```

### comentarios

#### Explicación

Este código muestra dos formas diferentes de escribir comentarios en Python. Los comentarios son importantes porque ayudan a explicar el propósito del código o proporcionar información adicional que puede ser útil para otros programadores o para ti mismo en el futuro.

La primera línea, que empieza con `#`, es un comentario de una sola línea. Todo lo que se escriba después de este símbolo y antes de que finalice la línea no será ejecutado por Python; simplemente sirve para documentar el código.

El segundo bloque, encerrado entre triples comillas (""" o '''), es un comentario de múltiples líneas. Este tipo de comentarios se usa comúnmente para proporcionar explicaciones más detalladas sobre cómo funciona una parte específica del código o para escribir documentación en la misma fuente del programa.

Ambos tipos de comentarios son herramientas valiosas para mejorar la legibilidad y mantenimiento del código, ayudando a otros a entender rápidamente qué hace cada parte del programa.

```python
# Esto es un comentario de una única línea

'''
    Esto es un comentario
    Esto sigue siendo un comentario
    Y esto también lo es
'''
```

### Explicacion del codigo

#### Explicación

Este código en Python establece la variable `edad` y le asigna un valor específico. En este caso, estás creando una variable llamada `edad` y usando el operador de asignación (`=`) para darle el valor numérico 47. La variable es como una caja donde guardas información que puedes usar más adelante en tu programa. El número 47 se conoce como un "valor literal" porque está escrito directamente en el código y no es calculado o obtenido de otra fuente.

Es importante entender esto porque las variables son fundamentales en la programación: te permiten almacenar datos que pueden cambiar durante la ejecución del programa, como edades, nombres, precios, etc. Aprender a declarar e inicializar variables correctamente es crucial para empezar a construir programas más complejos y útiles.

```python
edad = 47
# edad es el identificador
# = es el operador de asignación
# 47 es el valor literal que se es está asignando al identificador
```

### Tipos de datos

#### Explicación

Este fragmento de código está inicializando cuatro variables con diferentes tipos de datos, que son fundamentales en la programación con Python. La primera variable se llama `nombre` y le asigna el valor `"Jose Vicente"`, lo que significa que este es un dato del tipo cadena (string) que almacena texto. Luego, tenemos la variable `edad` que contiene el número entero `47`. Este tipo de datos, conocido como int en Python, se utiliza para almacenar números enteros sin decimales. La tercera variable llamada `altura` tiene asignado el valor decimal `1.78`, lo que indica que es un dato del tipo float, usado para representar números con decimales, perfecto para medidas como altura o peso. Finalmente, la variable `vivo` es un booleano y su valor es `True`. Los datos booleanos pueden tener solo dos valores: `True` (verdadero) o `False` (falso), y son muy útiles en comparaciones y condiciones lógicas.

Este código es importante porque demuestra cómo declarar variables con diferentes tipos de datos, lo cual es crucial para el manejo correcto de la información dentro del programa.

```python
nombre = "Jose Vicente" # Cadena
edad = 47 # Entero
altura = 1.78 # Decimal
vivo = True # Booleano
```

### Entradas

#### Explicación

Este código pide al usuario que introduzca su nombre y luego muestra ese nombre en pantalla. La primera línea utiliza la función `input()` para mostrar el mensaje "Dime tu nombre:" y esperar a que el usuario escriba algo y presione enter. Lo que el usuario escribe se guarda en la variable llamada `nombre`. Luego, con la segunda línea, se imprime en pantalla un mensaje que indica "Tu nombre es: " seguido del valor almacenado en `nombre`. Este tipo de código es importante porque ayuda a interactuar directamente con los usuarios, permitiéndoles proporcionar información personalizada que luego puedes usar en tu programa.

```python
nombre = input("Dime tu nombre: ")
print("Tu nombre es: ",nombre)
```

### Entrada y problema

#### Explicación

Este código te pide que ingreses tu edad a través del teclado y luego muestra el doble de esa edad. Primero, la línea `edad = input("Dime tu edad: ")` solicita al usuario que ingrese su edad y guarda esta entrada como una cadena de texto en la variable `edad`. Aunque se pide calcular el doble de la edad, aquí sólo concatenamos (unimos) el valor ingresado con un mensaje. Para obtener realmente el doble de la edad, tendríamos que convertir la edad a un número entero primero y luego multiplicarla por dos antes de imprimir el resultado.

Esta práctica es importante porque muestra cómo interactuar con el usuario para recoger información, pero también ilustra que debes ser cuidadoso al manejar los tipos de datos: en este caso, necesitaríamos convertir la entrada del usuario (que siempre es una cadena) a un número antes de hacer cualquier cálculo numérico.

```python
edad = input("Dime tu edad: ")
print("El doble de tu edad es: "+edad)
```

### Cambio de tipo de dato

#### Explicación

Este código solicita al usuario que ingrese su edad y luego realiza algunas operaciones básicas con ese dato. En primer lugar, el programa pide al usuario que introduzca un número representando su edad. Lo importante aquí es que esta entrada siempre se recibe como texto, incluso si introduces números. Luego, para poder hacer cálculos matemáticos con la edad, convierte esa cadena de texto en un número entero usando `int(edad)`. Finalmente, el programa calcula el doble de ese número entero y trata de mostrarlo por pantalla. Sin embargo, aquí hay un error: al intentar combinar una cadena de texto (la parte "El doble de tu edad es: ") con un número entero (`doble`), debe convertir `doble` a texto antes de imprimirlo para que ambos tipos sean compatibles en la concatenación.

```python
# Le pregunto al usuario por su edad
edad = input("Dime tu edad: ")
# Me aseguro de convertir la edad a un número entero
entero = int(edad)
# Calculo el doble de un número entero
doble = entero*2
# Saco el resultado por pantalla
print("El doble de tu edad es: "+doble)
```

### literales

#### Explicación

Este código está asignando valores a variables en Python. La primera línea crea una variable llamada `nombre` e inicializa esta con la frase "Jose Vicente". Esta frase entre comillas ("") se considera un **literal de cadena**, porque contiene texto y caracteres, no números.

La segunda parte del código declara otra variable llamada `edad`, a la que se le asigna el número 47. Este es un **literal de entero** ya que representa un valor numérico sin decimales. En resumen, este fragmento muestra cómo Python maneja diferentes tipos de datos: cadenas para texto y enteros para números sin punto decimal. Es importante conocer estos conceptos porque te permiten almacenar e interactuar con distintas clases de información en tus programas.

```python
nombre = "Jose Vicente"
# Jose Vicente es el literal, y es de tipo cadena

edad = 47
# 47 es el literal, y es de tipo entero
```

### constantes

#### Explicación

Este código te muestra cómo funciona la asignación de valores a una variable en Python. Primero, se define un valor para la variable `PI`, que es un número constante aproximado del número π (pi). Inicialmente, `PI` tiene el valor 3.1415 y luego se imprime este valor usando la función `print`. A continuación, cambiamos el valor de `PI` a 4 y volvemos a imprimirlo para mostrar que las variables en Python pueden cambiar su valor durante la ejecución del programa.

Es importante recordar que aunque `PI` fue inicialmente pensado como una constante (un número fijo), Python no tiene un tipo de dato específico para constantes. Por lo tanto, puedes modificar el valor de `PI` sin que el lenguaje te impida hacerlo. Sin embargo, es una convención en la programación usar mayúsculas para nombres que se supone que no cambian (como las constantes matemáticas), y minúsculas para variables cuyo valor puede cambiar durante la ejecución del programa.

```python
PI = 3.1415

print("PI vale",PI)

PI = 4 # Le cambio el valor a PI

print("PI vale",PI)
# Las constantes deben formularse con mayúsculas
# Las variables deben formularse con minúsculas
```

### Diferencia

#### Explicación

Este fragmento de código muestra una forma inadecuada y potencialmente problemática de trabajar con constantes en Python. Al principio, se define la variable `PI` como un número decimal que representa aproximadamente el valor matemático π (pi), que es 3.1416. Sin embargo, después de esta definición, el código redefine `PI` como una cadena de texto ("unnumero"). Esto anula completamente su significado inicial y puede llevar a errores si se utiliza más adelante en un programa que espera que `PI` sea un número.

Es importante entender que al redefinir `PI` como una cadena, la variable ya no representa el valor numérico 3.1416 ni tiene ninguna relación con el número pi. Esta práctica no es recomendada porque las constantes en programación suelen ser valores que no cambian durante la ejecución del programa y redefinirlas puede confundir al lector del código o causar errores funcionales si se espera que `PI` sea un valor numérico para realizar cálculos matemáticos.

```python

# La constante es PI
# El literal es 3.1416

PI = 3.1416

PI = "unnumero"
```

### operadores aritmeticos

#### Explicación

Este fragmento de código en Python muestra ejemplos sencillos del uso de operadores aritméticos básicos. Los operadores que se utilizan aquí son la suma (+), resta (-), multiplicación (*), división (/) y el módulo (%). Cada línea del código realiza una operación matemática simple entre los números 4 y 3, y luego imprime el resultado en pantalla.

- La primera línea suma 4 y 3, dando como resultado 7.
- La segunda resta 3 de 4, obteniendo 1.
- La tercera multiplica 4 por 3 para dar un total de 12.
- En la cuarta línea se divide 4 entre 3, lo que da aproximadamente 1.333 cuando redondeamos a tres decimales.
- Finalmente, el operador módulo (%) calcula el resto de la división entera de 4 por 3, resultando en 1.

Este código es útil para comprender cómo funcionan estos operadores aritméticos y cómo manipular datos numéricos en Python. Es fundamental para cualquier programa que requiera cálculos matemáticos básicos.

```python
print(4+3)
print(4-3)
print(4*3)
print(4/3)
print(4%3)
```

### operadores de comparacion

#### Explicación

Este fragmento de código muestra cómo se utilizan los operadores de comparación en Python. Estos operadores nos permiten comparar dos valores y obtener un resultado que es `True` (verdadero) o `False` (falso). En el ejemplo, estamos comparando siempre el número 4 con el número 3 usando diferentes operadores: menor que (`<`), menor o igual que (`<=`), mayor que (`>`), mayor o igual que (`>=`), igual a (`==`) y diferente de (`!=`). 

El código imprime en la consola el resultado de cada comparación. Por ejemplo, `4 < 3` evalúa si 4 es menor que 3, lo cual no es cierto, así que imprime `False`. En cambio, `4 > 3` comprueba si 4 es mayor que 3, y como esto es verdadero, imprime `True`.

Estos operadores son fundamentales en la programación ya que nos permiten tomar decisiones basadas en condiciones específicas. Son útiles para crear programas que puedan adaptarse a diferentes situaciones según los datos proporcionados.

```python
print(4 < 3)
print(4 <= 3)
print(4 > 3)
print(4 >= 3)
print(4 == 3)
print(4 != 3)
```

### operadores arimeticos abreviados

#### Explicación

Este fragmento de código muestra cómo usar operadores aritméticos en Python para realizar diferentes tipos de cálculos con una variable llamada `edad`. La idea principal es modificar el valor de la variable `edad` usando distintos métodos. Comienza estableciendo `edad` a 47 y luego realiza operaciones como sumar, restar, multiplicar y dividir este número por dos.

Lo importante aquí son las líneas que usan los operadores abreviados, también conocidos como operadores de asignación compuesta: `+=`, `-=` , `*=` y `/= `. Estos permiten realizar una operación aritmética y reasignar el resultado a la misma variable en una sola línea. Por ejemplo, `edad += 2` es equivalente a escribir `edad = edad + 2`, pero de manera más concisa.

Este tipo de sintaxis es útil porque hace que el código sea más corto y fácil de leer cuando se necesitan realizar operaciones repetidas con la misma variable.

```python
edad = 47
# Le quiero sumar dos unidades
edad = edad + 2
edad += 2
#Le quiero restar dos unidades
edad = edad - 2
edad -= 2
# Lo quiero multiplicar por dos
edad = edad * 2
edad *= 2
# Lo quiero dividir por dos
edad = edad / 2
edad /= 2
```

### operadores booleanos

#### Explicación

Este código muestra cómo funcionan los operadores booleanos en Python, que son herramientas fundamentales para tomar decisiones en la programación. Los operadores `and` y `or` se usan para combinar varias condiciones lógicas.

En las primeras dos líneas del código, el programa evalúa tres comparaciones con `and`. Para que una expresión usando `and` sea verdadera (`True`), todas las partes de la expresión deben ser verdaderas. Por ejemplo, en la primera línea, todas las comparaciones (4 es igual a 4, 3 es igual a 3 y 2 es igual a 2) son ciertas, así que el resultado será `True`. Sin embargo, en la segunda línea, aunque las dos primeras comparaciones son correctas, la última dice que 2 es igual a 1, lo cual es falso. Por eso, toda la expresión con `and` resulta falsa (`False`).

Después, el código utiliza el operador `or`. Con este operador, si al menos una de las comparaciones es verdadera, entonces todo el resultado será `True`. En las líneas siguientes, puedes ver que cuando todas las comparaciones son falsas (como en la última línea del código), el resultado final también será falso (`False`).

Entender estos operadores te ayudará a escribir programas más complejos y poderosos, ya que permiten controlar el flujo de tu programa basado en diferentes condiciones.

```python
print(4 == 4 and 3 == 3 and 2 == 2)
print(4 == 4 and 3 == 3 and 2 == 1)

print(4 == 4 or 3 == 3 or 2 == 1)
print(4 == 4 or 3 == 2 or 2 == 1)
print(4 == 3 or 3 == 2 or 2 == 1)
```

### Ejercicio1-Calculadora de impuestos

#### Explicación

Este fragmento de código es la documentación inicial o el bloque de comentarios de un programa en Python llamado "Calculadora de Impuestos". Este programa está diseñado para calcular el IVA (Impuesto sobre Valor Añadido) y el total después del impuesto a partir de una base imponible que introduce el usuario. La versión actual es la v0.1, creada por Jose Vicente Carratalá.

El bloque de comentarios al principio de un script en Python, conocido como docstring, es crucial porque proporciona información importante sobre la función o el propósito del programa. En este caso, indica claramente qué hace el programa y cómo funciona, lo que ayuda a otros programadores (o incluso a uno mismo después de tiempo) a entender rápidamente su propósito sin necesidad de desglosar todo el código.

Este tipo de documentación es importante en proyectos más grandes para mantener la claridad y facilitar la colaboración entre diferentes desarrolladores.

```python
'''
    Calculadora de Impuestos
    v0.1 por Jose Vicente Carratalá
    Funcionamiento: Introduce una base imponible y se calcula IVA y total
'''
```

### Calculadora

#### Explicación

Este fragmento de código es el inicio de un programa en Python que sirve como una sencilla calculadora para calcular impuestos. El programa pide al usuario que introduzca la base imponible, que es el precio original antes del impuesto sobre valor añadido (IVA). En este punto, el código ha creado tres variables: `base_imponible`, `total_iva` y `total_factura`. Todas estas variables están inicializadas en 0. Luego, se utiliza la función `input()` para pedir al usuario que introduzca la base imponible de una factura. Esta entrada será almacenada en la variable `base_imponible`.

Es importante destacar que este código es solo el comienzo del programa; aún falta implementar funciones o métodos para calcular el IVA y el total de la factura basándose en la base imponible proporcionada por el usuario.

```python
'''
    Calculadora de Impuestos
    v0.1 por Jose Vicente Carratalá
    Funcionamiento: Introduce una base imponible y se calcula IVA y total
'''

# Este programa no tiene importaciones

# Creo variables
base_imponible = 0
total_iva = 0
total_factura = 0

# Aquí pondría las funciones/clases

# Ahora calculamos
base_imponible = input("Introduce la base imponible de la factura: ")
```

### Calculadora

#### Explicación

Este fragmento de código es el inicio de un programa en Python que sirve como una simple calculadora de impuestos. El propósito principal del programa es recibir de entrada la cantidad de la base imponible de una factura y luego calcular el IVA (Impuesto al Valor Agregado) y el total a pagar, aunque esta parte del cálculo no se implementa en este trozo de código.

El código comienza por definir tres variables: `base_imponible`, que almacenará el importe sobre el cual se calcula el IVA; `total_iva`, que contendrá el valor del impuesto una vez sea calculado; y `total_factura`, que guardará la suma total de la base imponible más el IVA.

A continuación, muestra información básica al usuario acerca del programa y su autor. Luego, mediante un mensaje en pantalla, guía al usuario para que introduzca la base imponible correspondiente a una factura. La entrada proporcionada por el usuario es almacenada en la variable `base_imponible` como texto (string), pero aún no se realiza ningún cálculo sobre ella.

Es importante notar que este código está incompleto ya que falta implementar las funciones para calcular el IVA y sumarlo a la base imponible, así como también la parte donde mostraría los resultados al usuario.

```python
'''
    Calculadora de Impuestos
    v0.1 por Jose Vicente Carratalá
    Funcionamiento: Introduce una base imponible y se calcula IVA y total
'''

# Este programa no tiene importaciones

# Creo variables
base_imponible = 0
total_iva = 0
total_factura = 0

# Aquí pondría las funciones/clases

# Ahora calculamos
print("Programa calculadora de impuestos")
print("(c) 2025 Jose Vicente Carratalá")
print("Introduce una base y te calculo el IVA y el total")
base_imponible = input("Introduce la base imponible de la factura: ")
```

### Calculo de IVA

#### Explicación

Este código Python crea un programa sencillo que calcula el Impuesto sobre Valor Añadido (IVA) y el total de una factura basándose en la base imponible proporcionada por el usuario. Al ejecutar el programa, primero muestra algunos datos iniciales como el título del programa y el autor, luego solicita al usuario que introduzca el valor de la base imponible de la factura.

Una vez obtenida esta información a través de un input, el código realiza dos cálculos: el IVA se calcula multiplicando la base imponible por 0.21 (que es el tipo de IVA general en España), y el total de la factura se obtiene sumando la base imponible con el IVA calculado.

Finalmente, muestra al usuario tanto el valor del IVA como el total de la factura. Este programa es útil para estudiantes que están aprendiendo a manipular entradas y salidas en Python, así como para entender cómo realizar operaciones básicas de cálculo utilizando variables.

```python
'''
    Calculadora de Impuestos
    v0.1 por Jose Vicente Carratalá
    Funcionamiento: Introduce una base imponible y se calcula IVA y total
'''

# Este programa no tiene importaciones

# Creo variables
base_imponible = 0
total_iva = 0
total_factura = 0

# Aquí pondría las funciones/clases

# Ahora calculamos

# Primero pido una entrada
print("Programa calculadora de impuestos")
print("(c) 2025 Jose Vicente Carratalá")
print("Introduce una base y te calculo el IVA y el total")
base_imponible = float(input("Introduce la base imponible de la factura: "))

# Luego realizo cálculos
total_iva = base_imponible*0.21
total_factura = base_imponible + total_iva

# Por último expreso una salida
print("El IVA de la factura es: ",total_iva)
print("El total de la factura es: ",total_factura)
```

### Actividades propuestas

### Actividades Propuestas para los Estudiantes

#### 1. **Imprimir Datos Básicos**
**Descripción:** Los estudiantes deben crear un programa que imprima su nombre completo y edad en pantalla. Se espera que aprendan a utilizar las declaraciones de variables y la función `print()`.

#### 2. **Manejo de Entradas y Salidas**
**Descripción:** El alumnado debe realizar un programa que pida el nombre del usuario por consola y lo imprima con una frase amigable. Se espera que aprendan a utilizar la función `input()` junto con las declaraciones de variables.

#### 3. **Cambio en Variables**
**Descripción:** Los estudiantes deben escribir un código que cambie el valor de una variable ya existente y muestre los cambios por pantalla. Aprenderán cómo actualizar valores de variables existentes y usar múltiples impresiones para verificar las modificaciones.

#### 4. **Uso de Tipos de Datos**
**Descripción:** Se les solicita a los estudiantes que creen un programa que declare variables con distintos tipos de datos (cadenas, enteros, decimales y booleanos) e imprima sus valores en pantalla. Aprenderán sobre las diferencias entre tipos de datos y cómo declararlos.

#### 5. **Operaciones Matemáticas Básicas**
**Descripción:** Los alumnos deben crear un programa que realice operaciones matemáticas básicas como suma, resta, multiplicación y división utilizando dos números enteros dados por el usuario. Se espera que aprendan a usar los operadores aritméticos en Python.

#### 6. **Operadores de Comparación**
**Descripción:** Los estudiantes deben escribir un código que compare dos variables numéricas con diferentes operadores (menor, mayor, igual) y muestre el resultado por pantalla. Se espera que comprendan los operadores de comparación y cómo utilizarlos en expresiones condicionales.

#### 7. **Operaciones Aritméticas Avanzadas**
**Descripción:** Los estudiantes deben modificar un programa dado para que use operadores aritméticos abreviados (+=, -=, *=, /=) en lugar de las operaciones tradicionales. Se espera que aprendan a utilizar estos operadores eficientemente.

#### 8. **Operaciones Booleanas**
**Descripción:** Los alumnos deben crear un programa que combine varios operadores lógicos (and, or) para realizar comparaciones entre variables y mostrar el resultado por pantalla. Aprenderán sobre los operadores booleanos en Python y cómo utilizarlos en expresiones complejas.

#### 9. **Cálculo de Impuestos**
**Descripción:** Se les pide a los estudiantes que completen un programa para calcular IVA y total de una factura basándose en la base imponible ingresada por el usuario. Se espera que aprendan a realizar cálculos matemáticos con datos ingresados por consola.

#### 10. **Constantes vs Variables**
**Descripción:** Los estudiantes deben escribir un código que demuestre la diferencia entre una variable y una constante en Python, asignando valores y cambiándolos según corresponda. Aprenderán sobre el uso correcto de constantes y variables.

Estas actividades están diseñadas para ayudar a los estudiantes a adquirir habilidades fundamentales en programación con Python, adaptándose al nivel intermedio previsto para la Formación Profesional DAM (Desarrollo de Aplicaciones Multiplataforma).



<a id="lectura-y-escritura-de-informacion"></a>
# Lectura y escritura de información

<a id="flujos-tipos-bytes-y-caracteres-clases-relacionadas"></a>
## Flujos. Tipos bytes y caracteres. Clases relacionadas

### Introducción a los ejercicios

En esta carpeta de ejercicios, se exploran conceptos fundamentales relacionados con la manipulación de archivos en Python. Los estudiantes aprenderán cómo crear y escribir información en un archivo utilizando la función `open()` con el modo 'w' (write) para sobrescribir o crear nuevos archivos. También se enseñará cómo leer contenido desde un archivo existente usando el modo 'r' (read). Además, se incluye una práctica más avanzada donde los estudiantes crean una pequeña aplicación de agenda que permite añadir y listar contactos en un archivo, utilizando la opción 'a' (append) para agregar información sin borrar lo ya existente. Estos ejercicios ayudarán a fortalecer las habilidades de manejo básico de archivos y flujo de entrada/salida en Python.

### escribir texto a archivo

#### Explicación

Este fragmento de código muestra cómo crear y escribir en un archivo llamado "clientes.txt". El programa comienza abriendo el archivo con la instrucción `open`, especificando `'w'` como modo, lo que significa "write" (escribir). Al abrir el archivo en modo escritura, si el archivo ya existe, se borrará su contenido. Si no existe, se creará uno nuevo.

Luego, el programa utiliza el método `.write()` para escribir la frase "Esto es una prueba" dentro del archivo recién abierto. Finalmente, el archivo se cierra con `archivo.close()`, lo cual es importante para liberar los recursos utilizados por el sistema operativo y asegurar que toda la información escrita sea guardada correctamente.

Es fundamental cerrar un archivo después de haber terminado de trabajar con él para evitar posibles errores o pérdida de datos.

```python
archivo = open("clientes.txt",'w') # W = Write

archivo.write("Esto es una prueba")

archivo.close()
```

### ahora leemos

#### Explicación

Este código Python se utiliza para leer el contenido de un archivo llamado "clientes.txt". Primero, la línea `archivo = open("clientes.txt", 'r')` abre el archivo en modo lectura. La letra 'r' indica que solo queremos leer lo que hay en ese archivo.

Luego, con la línea `contenido = archivo.readline()`, se lee la primera línea del archivo y se guarda en una variable llamada `contenido`. Hay otra función similar llamada `archivo.readlines()` que puedes usar para leer todas las líneas de un archivo a la vez, pero aquí solo estamos leyendo la primera línea.

Finalmente, con `print(contenido)`, el programa imprime en pantalla lo que ha leído del archivo. Es importante cerrar el archivo después de terminar de trabajar con él usando `archivo.close()`. Esto asegura que los recursos del sistema estén disponibles para otros procesos y que no haya errores relacionados con la gestión de archivos abiertos.

```python
archivo = open("clientes.txt",'r') # R = Read

contenido = archivo.readline()
# También existe archivo.readlines()

print(contenido)

archivo.close()
```

### creador agenda

#### Explicación

Este código es una pequeña aplicación en Python que permite gestionar un simple registro de contactos. Primero, muestra al usuario una lista de opciones para interactuar con el registro de contactos almacenado en un archivo llamado "agenda.txt". El programa entra en un bucle infinito (`while True`) que presenta siempre la misma lista de opciones hasta que se interrumpe manualmente.

Cuando el usuario selecciona la opción 1, el programa pide al usuario que introduzca el nombre y el email de una nueva persona. Luego, abre el archivo "agenda.txt" en modo añadir (`'a'`), lo que significa que los nuevos datos se agregan al final del archivo sin borrar nada existente, y escribe el nombre y el email separados por una coma. Después de guardar la información, cierra el archivo para asegurar que todo lo escrito ha sido guardado correctamente.

Si el usuario selecciona la opción 2, el programa abre "agenda.txt" en modo lectura (`'r'`), lee todas las líneas del archivo y muestra cada línea por separado. Esto permite ver todos los contactos almacenados hasta ese momento, mostrándolos tal como fueron escritos.

Este código es importante porque enseña conceptos básicos de programación orientada a la interacción con el usuario, manejo de archivos y bucles infinitos en Python, proporcionando una forma sencilla pero funcional para gestionar datos persistentes en un archivo.

```python
while True:
  print("Dime lo que quieres hacer: ")
  print("1.-Introduce un nuevo contacto")
  print("2.-Leer todos los contactos")
  opcion = int(input("Escoge tu opción: "))
  if opcion == 1:
    nombre = input("Introduce el nombre de la persona: ")
    email = input("Introduce el email de la persona: ")
    archivo = open("agenda.txt",'a') # A = añadir
    archivo.write(nombre+","+email+"\n")
    archivo.close()
  elif opcion == 2:
    archivo = open("agenda.txt",'r')
    lineas = archivo.readlines()
    for linea in lineas:
      print(linea)
    archivo.close()
```

### agenda

#### Explicación

El fragmento de código que has proporcionado no es realmente un código, sino más bien una línea que parece ser contenido dentro de un archivo de texto. Este tipo de estructura comúnmente se utiliza en archivos como listas o registros sencillos.

En este caso, la línea "Jorge,jorge@jocarsa.com" representa probablemente información sobre una persona, donde "Jorge" es el nombre y "jorge@jocarsa.com" es su dirección de correo electrónico. Este formato es útil para almacenar datos de forma simple y legible.

Esta estructura de datos puede ser utilizada en programas que necesitan leer archivos de texto para obtener información como contactos o registros. En contextos de programación, sería importante saber cómo abrir el archivo, leer cada línea, dividir la línea por la coma (",") para separar nombre y correo electrónico, e interpretar estos datos según sea necesario.

Es fundamental entender este tipo de estructuras cuando trabajamos con archivos de texto en proyectos que requieren manejar listas o bases de datos sencillas.

```
Jorge,jorge@jocarsa.com
```

### clientes

#### Explicación

Lo siento, pero el fragmento de código que proporcionaste no es un código real para ninguna lengua de programación conocida. El texto "Esto es una prueba" parece ser simplemente un comentario o una nota escrita en español, y no realiza ninguna acción en un programa. Si estás buscando explicar un bloque de código específico relacionado con la lectura y escritura de información en archivos, necesitaría el código real para poder ayudarte a entenderlo correctamente.

```
Esto es una prueba
```

### Actividades propuestas

1. **Lectura y escritura básica de archivos**
   - **Descripción:** Los estudiantes deben abrir un archivo existente, leer su contenido e imprimirlo en la consola. A continuación, deberán escribir una nueva línea al mismo archivo sin borrar el contenido previo. Este ejercicio ayuda a entender las diferencias entre los modos 'r' y 'a'.

2. **Manejo de excepciones en archivos**
   - **Descripción:** Los estudiantes deben crear un programa que abra un archivo, pero si no existe, deberá mostrar un mensaje indicando que el archivo está faltante sin producir un error crítico. Este ejercicio enseña sobre manejo de errores y la importancia del control excepcional.

3. **Crear una agenda personal**
   - **Descripción:** A partir del código proporcionado, los estudiantes deben desarrollar un programa que permita a los usuarios agregar múltiples contactos (nombre y email) en una agenda digital y posteriormente leer todos los contactos existentes. Esto refuerza la comprensión de bucles, condicionales y archivos.

4. **Modificando datos en el archivo**
   - **Descripción:** Los estudiantes deben escribir un programa que permita a los usuarios buscar y editar un contacto específico dentro del archivo 'agenda.txt'. Este ejercicio mejora las habilidades para manipular archivos existentes y trabajar con estructuras de control más complejas.

5. **Flujos de bytes vs flujos de caracteres**
   - **Descripción:** Los estudiantes deben investigar e implementar el manejo de ambos tipos de flujo (bytes y caracteres) al leer y escribir en un archivo binario. Este ejercicio ayuda a entender las diferencias fundamentales entre los dos y cuándo usar cada uno.

6. **Validación de datos antes del guardado**
   - **Descripción:** Los estudiantes deben añadir validaciones para asegurarse de que el nombre y email introducidos en la agenda sean correctos (por ejemplo, verificar que el correo electrónico tenga un @) antes de guardarlos en el archivo. Este ejercicio enseña sobre la importancia de la validación de datos.

7. **Programa de gestión de clientes**
   - **Descripción:** Los estudiantes deben crear un programa similar al proporcionado pero orientado a gestionar una lista de clientes (nombre, email y teléfono). Este ejercicio implica trabajar con archivos más complejos que incluyen múltiples campos para cada registro.

8. **Búsqueda y eliminación de registros**
   - **Descripción:** Los estudiantes deben implementar la funcionalidad en su agenda o programa de gestión de clientes para buscar un contacto específico y permitir su eliminación del archivo. Esto refuerza las habilidades de lectura/escritura selectiva en archivos.

9. **Integrando funciones**
   - **Descripción:** Los estudiantes deben dividir el código proporcionado en varias funciones (una para leer, otra para escribir, etc.) y luego usarlas en un menú principal. Este ejercicio ayuda a entender la modularización del código.

10. **Backup de archivos**
    - **Descripción:** Los estudiantes deben crear una función que genere automáticamente un archivo de respaldo cada vez que se realizan cambios importantes (como añadir o eliminar registros). Esto enseña sobre buenas prácticas en el manejo y seguridad de datos.


<a id="ficheros-de-datos-registros"></a>
## Ficheros de datos. Registros

### Introducción a los ejercicios

En esta carpeta de ejercicios, trabajaremos principalmente con la lectura y manipulación de archivos en diferentes formatos como HTML, JSON y texto plano. Los ejercicios te guiarán a través del proceso de leer datos desde estos archivos y luego acceder y mostrar dicha información en Python. Asimismo, explorarás cómo integrar esta lógica con un servidor web básico usando Flask para generar páginas HTML dinámicamente a partir de los datos leídos. Este conjunto de ejercicios fortalecerá tus habilidades en el manejo de archivos y estructuras de datos en Python, además de introducirte al desarrollo web mediante la creación de sitios simples que muestran información almacenada en archivos externos.

### leer archivo

#### Explicación

Este fragmento de código en Python te muestra cómo leer un archivo de texto y mostrar su contenido línea por línea. Primero, se abre el archivo llamado "blog.txt" en modo lectura ('r'). Luego, todas las líneas del archivo son leídas y almacenadas en una lista llamada `lineas`. Finalmente, mediante un bucle for, cada línea de la lista es recorrida e impresa por pantalla. Esta técnica es importante porque permite procesar fácilmente el contenido de archivos grandes, permitiéndote manipular o analizar su información línea a línea.

```python
archivo = open("blog.txt",'r')

lineas = archivo.readlines()

for linea in lineas:
  print(linea)
```

### leer json

#### Explicación

Este código en Python es utilizado para leer un archivo JSON y mostrar su contenido por pantalla. Primero, importamos el módulo `json`, que proporciona funciones específicas para trabajar con archivos de formato JSON.

Luego, abrimos el archivo llamado "blog.json" en modo lectura (`'r'`). Esto nos permite acceder al contenido del archivo. El archivo se guarda en la variable `archivo`.

Con la función `json.load(archivo)`, leemos todo el contenido del archivo JSON y lo convierte directamente a un objeto de Python (generalmente es un diccionario o una lista, dependiendo de cómo esté estructurado el JSON). Este contenido se almacena en la variable `contenido`.

Finalmente, imprimimos el contenido del archivo JSON utilizando la función `print(contenido)`. Esto muestra por pantalla toda la información que contiene el archivo "blog.json" en un formato fácil de leer para los programadores.

Este código es importante porque nos permite interactuar con datos estructurados y manipularlos dentro de nuestro programa, lo cual es fundamental en muchos proyectos relacionados con bases de datos o aplicaciones web.

```python
import json

archivo = open("blog.json",'r')

contenido = json.load(archivo)

print(contenido)
```

### leemos linea a linea

#### Explicación

Este código es una parte de un programa en Python que te enseña cómo leer y procesar información desde un archivo llamado "blog.json". Primero, el programa importa la biblioteca `json`, lo cual es necesario para manejar archivos JSON correctamente. Luego, abre el archivo "blog.json" en modo lectura (`'r'`). A continuación, carga todo el contenido del archivo JSON en una variable llamada `contenido`. Finalmente, utiliza un bucle `for` para iterar a través de cada elemento dentro del archivo y lo imprime línea por línea. Esto es importante porque te permite acceder fácilmente a la información estructurada que se almacena en formato JSON y trabajar con ella paso a paso en tu programa.

```python
import json

archivo = open("blog.json",'r')

contenido = json.load(archivo)

for linea in contenido:
  print(linea)
```

### ahora accedemos a las parejas

#### Explicación

Este fragmento de código en Python se utiliza para leer y procesar un archivo JSON que contiene información sobre entradas de blog. El archivo "blog.json" está abierto en modo lectura ('r'), lo que significa que el programa va a leer los datos contenidos en él sin modificarlos.

La función `json.load(archivo)` lee todo el contenido del archivo y lo convierte en un objeto Python, generalmente un diccionario o una lista de diccionarios. En este caso, cada entrada de blog se almacena como un diccionario dentro de una lista que es asignada a la variable `contenido`.

Luego, se itera sobre cada elemento (que es un diccionario individual) en `contenido` usando un bucle for. Para cada entrada del blog, el código imprime los campos 'titulo', 'fecha', 'autor' y 'contenido'. Esto ayuda a visualizar o analizar la información almacenada en el archivo JSON de manera estructurada.

Este tipo de código es crucial para trabajar con datos que están almacenados de forma estructurada en archivos externos, permitiendo a las aplicaciones acceder y manipular esa información de acuerdo a necesidades específicas.

```python
import json

archivo = open("blog.json",'r')

contenido = json.load(archivo)

for linea in contenido:
  print(linea['titulo'])
  print(linea['fecha'])
  print(linea['autor'])
  print(linea['contenido'])
```

### una pequeña decoracion

#### Explicación

Este código en Python está diseñado para leer y mostrar el contenido de un archivo JSON llamado "blog.json". Primero, importamos el módulo `json`, que nos ayuda a manejar datos en formato JSON. Luego, abrimos el archivo "blog.json" en modo lectura (`'r'`). El contenido del archivo se carga en una variable llamada `contenido` usando la función `json.load()`. Este contenido es un conjunto de registros o artículos del blog que están estructurados como diccionarios.

El código entonces itera sobre cada artículo en el contenido utilizando un bucle `for`, y para cada uno, imprime información clave: título, fecha, autor y contenido. Entre cada artículo, se muestra una línea divisoria con asteriscos para mejorar la legibilidad del output. Este tipo de programa es útil cuando necesitas visualizar los datos almacenados en archivos JSON de manera estructurada y fácilmente legible.

```python
import json

archivo = open("blog.json",'r')

contenido = json.load(archivo)

for linea in contenido:
  print("####### ARTICULO ########")
  print(linea['titulo'])
  print(linea['fecha'])
  print(linea['autor'])
  print(linea['contenido'])
  print("#########################")
  print("")
```

### blog

#### Explicación

Este fragmento de código es una plantilla básica en HTML que se utiliza para estructurar una página web. La parte inicial, `<html lang="es">`, indica que este documento está escrito en español y será interpretado por navegadores como una página web. Dentro del bloque `<head>`, encontramos información importante sobre la página pero no visible directamente para el usuario: un título que aparecerá en la pestaña del navegador (`<title>JOCARSAblog</title>`), y una declaración de caracteres (`<meta charset="utf-8">`) que asegura que todos los símbolos y caracteres especiales se muestren correctamente. La etiqueta `<style>` es donde normalmente irían las instrucciones CSS para estilizar la página, aunque en este caso está vacía.

El bloque `<body>` es donde se colocarán todo el contenido visible de la página web, como texto, imágenes o videos. Este archivo HTML parece ser el punto de partida para una página que podría formar parte de un blog llamado "JOCARSAblog", y aunque por ahora no contiene mucha información dentro del `<body>` ni estilos en CSS, proporciona una estructura sólida sobre la cual construir funcionalidades más avanzadas.

```html
<!doctype html>
<html lang="es">
  <head>
    <title>JOCARSAblog</title>
    <meta charset="utf-8">
    <style>
      
    </style>
  </head>
  <body>
    
  </body>
</html>
```

### secciones

#### Explicación

Este fragmento de código es un archivo HTML básico que representa la estructura de una página web. En esta página, el título es "JOCARSAblog", y está configurado para usar caracteres en español con la declaración `meta charset="utf-8"`. El contenido principal se encuentra dentro del elemento `<main>`, aunque en este caso está vacío, lo que significa que aún no ha sido llenado con información específica.

Los elementos `<header>` e `<footer>` son utilizados para contener información sobre la página: el encabezado muestra un título `<h1>` que dice "JOCARSAblog", y el pie de página incluye un mensaje de derechos de autor. Este tipo de estructura es importante porque ayuda a los navegadores y motores de búsqueda a entender mejor cómo está organizada la información en una página web, lo cual puede mejorar su visibilidad online.

Esta organización del código HTML es fundamental para crear páginas web que sean claras y fácilmente interpretadas tanto por usuarios como por sistemas automatizados.

```html
<!doctype html>
<html lang="es">
  <head>
    <title>JOCARSAblog</title>
    <meta charset="utf-8">
    <style>
      
    </style>
  </head>
  <body>
    <header><h1>JOCARSAblog</h1></header>
    <main>
    
    </main>
    <footer>(c)2025 Jose Vicente Carratalá</footer>
  </body>
</html>
```

### articulo

#### Explicación

Este código HTML crea una página web simple que contiene información sobre un artículo específico en un blog llamado "JOCARSAblog". En la parte superior, hay un encabezado donde se muestra el título del blog. Bajo este encabezado, encontramos la estructura principal de la página con una sección dedicada al contenido del artículo.

Dentro de esta sección, puedes ver detalles como el título del artículo, la fecha en que fue publicado y los datos sobre el autor. También hay un párrafo que muestra el contenido ficticio del artículo. Al final de la página, hay un pie de página con información sobre derechos de autor.

Este tipo de estructura HTML es importante porque ayuda a organizar claramente la información en una página web, haciendo más fácil para los visitantes entender qué sección está viendo y qué contenido es relevante para cada área. Además, esta organización facilita el trabajo para otros desarrolladores o diseñadores que puedan necesitar trabajar con este código en un futuro.

```html
<!doctype html>
<html lang="es">
  <head>
    <title>JOCARSAblog</title>
    <meta charset="utf-8">
    <style>
      
    </style>
  </head>
  <body>
    <header><h1>JOCARSAblog</h1></header>
    <main>
      <article>
        <h3>Titulo del articulo</h3>
        <time>2025-10-16</time>
        <p>Jose Vicente Carratala</p>
        <p>Este es el contenido de un artículo ficticio</p>
      </article>
    </main>
    <footer>(c)2025 Jose Vicente Carratalá</footer>
  </body>
</html>
```

### estilos minimos

#### Explicación

Este fragmento de código HTML crea una página web simple y minimalista con estilo básico integrado. La estructura principal incluye las secciones `header`, `main` y `footer`. En el encabezado, se muestra un título "JOCARSAblog" centrado en un fondo blanco. El cuerpo principal contiene un artículo que presenta información sobre el autor y una fecha ficticia, todo ello con un estilo de letra negra sobre fondo blanco para mejorar la legibilidad. El pie de página también está centrado y proporciona información de derechos de autor.

El bloque `<style>` dentro del encabezado define cómo se debe visualizar cada sección de la página. Por ejemplo, establece que el cuerpo de toda la página tiene un color de fondo azul acero y una fuente sans-serif para dar al sitio un aspecto moderno y limpio. Las áreas `header`, `main` y `footer` tienen un diseño similar en cuanto a las dimensiones y los colores utilizados.

Este tipo de estructura es importante porque ayuda a organizar el contenido web de manera clara y coherente, facilitando la navegación para los usuarios y permitiendo al desarrollador controlar visualmente cada parte del sitio.

```html
<!doctype html>
<html lang="es">
  <head>
    <title>JOCARSAblog</title>
    <meta charset="utf-8">
    <style>
      body{background:steelblue;color:steelblue;font-family:sans-serif;}
      header,main,footer{background:white;padding:20px;margin:auto;width:600px;}
      header,footer{text-align:center;}
      main{color:black;}
    </style>
  </head>
  <body>
    <header><h1>JOCARSAblog</h1></header>
    <main>
      <article>
        <h3>Titulo del articulo</h3>
        <time>2025-10-16</time>
        <p>Jose Vicente Carratala</p>
        <p>Este es el contenido de un artículo ficticio</p>
      </article>
    </main>
    <footer>(c)2025 Jose Vicente Carratalá</footer>
  </body>
</html>
```

### Instalar servidor

#### Explicación

Este fragmento de texto proporciona instrucciones sobre cómo configurar un servidor web en tu propio ordenador para fines de desarrollo y práctica. En resumen, te guía a través del proceso de instalación dependiendo del sistema operativo que estés utilizando.

Para usuarios de Windows, se recomienda descargar e instalar XAMPP, una suite de software que incluye Apache (el servidor web), MySQL (base de datos), PHP y Perl en un solo paquete. Una vez instalado, la carpeta donde podrás alojar tus archivos HTML para el servidor es "c:/xampp/htdocs". Este directorio actúa como la raíz del sitio web local que estás configurando.

Para usuarios de Linux, puedes instalar Apache utilizando el gestor de paquetes predeterminado. El comando mostrado en el texto te permitirá instalar Apache fácilmente en sistemas basados en Debian o Ubuntu. Al igual que en Windows con XAMPP, una vez que Apache está instalado en tu sistema Linux, los archivos HTML y otros documentos web se colocarán dentro del directorio "/var/www/html", que es la ubicación predeterminada para el contenido web servido.

La importancia de este proceso radica en permitirte desarrollar y probar sitios web o aplicaciones sin necesidad de subirlas a un servidor real, lo cual no sólo facilita el desarrollo y depuración sino también garantiza que tus proyectos estén seguros durante las etapas iniciales.

```markdown
-Instalar un servidor web en entorno de desarrollo
(se entiende vuestro propio ordenador)

-Windows:
Se recomienda instalar el paquete XAMPP
https://www.apachefriends.org/es/index.html

Una vez instalado, la carpeta de publicación es c:/xampp/htdocs

-Linux:
Se instala Apache con el comando
sudo apt install apache2

Una vez instalado, la carpeta de publicación es: /var/www/html
```

### arranco flask

#### Explicación

Este código te enseña cómo configurar y ejecutar una aplicación web básica utilizando Flask, que es una biblioteca muy popular para Python. Primero, importas la clase `Flask` desde el módulo flask. Luego creas una instancia de esta clase llamada `aplicacion`, que se encargará de gestionar tu servidor web.

El decorador `@aplicacion.route("/")` define qué función (en este caso, `raiz()`) debe ejecutarse cuando alguien accede a la página principal del sitio web (URL base). La función `raiz()` simplemente retorna una cadena que representa un texto en HTML, mostrando "Esto es HTML desde Flask" en el navegador.

Finalmente, el bloque `if __name__ == "__main__":` asegura que solo se ejecute la línea `aplicacion.run(debug=True)` si estás ejecutando este archivo directamente (no cuando lo importas como un módulo en otro script). Esta línea inicia el servidor Flask y habilita el modo de depuración, útil para detectar errores mientras desarrollas.

```python
# Abre una terminal e instala flask:
# pip install flask
# Flask es un microservidorweb que nos permite generar HTML desde Python

from flask import Flask

aplicacion = Flask(__name__)

@aplicacion.route("/")
def raiz():
  return "Esto es HTML desde Flask"
  
# Ahora arranco el servidor
if __name__ == "__main__":
  aplicacion.run(debug=True)
```

### frankenstein

#### Explicación

Este fragmento de código es un ejemplo básico de una aplicación web utilizando Flask, que es un framework en Python. La función principal del código es crear una página web simple con la información básica sobre un blog llamado "JOCARSAblog". Cuando se ejecuta este programa, Flask establece un servidor local para mostrar esta página.

En primer lugar, el código importa la clase `Flask` desde el módulo flask. Luego, crea una instancia de esta aplicación web y la guarda en la variable `aplicacion`. La función `@aplicacion.route("/")` indica que cuando se accede a la ruta principal del servidor (es decir, al entrar en la dirección base de la página), la función `raiz()` es llamada. Esta función retorna el código HTML necesario para dibujar una estructura básica de un sitio web con encabezado, contenido principal y pie de página.

El bloque HTML incluye estilos básicos que definen cómo se verá el sitio (por ejemplo, color de fondo, fuente). En la parte central del HTML, hay información ficticia sobre un artículo: título, fecha, autor y texto. Finalmente, si este archivo es ejecutado directamente, en lugar de importarse como módulo, la línea `aplicacion.run(debug=True)` inicia el servidor Flask para que puedas ver tu sitio web.

Este tipo de código es fundamental para aprender a crear páginas web interactivas y dinámicas utilizando Python.

```python
from flask import Flask

aplicacion = Flask(__name__)

@aplicacion.route("/")
def raiz():
  return '''
    <!doctype html>
<html lang="es">
  <head>
    <title>JOCARSAblog</title>
    <meta charset="utf-8">
    <style>
      body{background:steelblue;color:steelblue;font-family:sans-serif;}
      header,main,footer{background:white;padding:20px;margin:auto;width:600px;}
      header,footer{text-align:center;}
      main{color:black;}
    </style>
  </head>
  <body>
    <header><h1>JOCARSAblog</h1></header>
    <main>
      <article>
        <h3>Titulo del articulo</h3>
        <time>2025-10-16</time>
        <p>Jose Vicente Carratala</p>
        <p>Este es el contenido de un artículo ficticio</p>
      </article>
    </main>
    <footer>(c)2025 Jose Vicente Carratalá</footer>
  </body>
</html>
  '''
  
if __name__ == "__main__":
  aplicacion.run(debug=True)
```

### blog

#### Explicación

El fragmento de código que has proporcionado es un archivo JSON (JavaScript Object Notation) que contiene una lista de artículos. Cada artículo está estructurado como un objeto con varias propiedades: `titulo`, `fecha`, `autor` y `contenido`. Este formato de datos permite almacenar información sobre múltiples artículos de manera organizada y legible.

En este caso, el archivo JSON almacena cuatro artículos diferentes. Cada artículo tiene sus propias características, como su título, la fecha en que fue publicado y quién lo escribió. La propiedad `contenido` contiene un breve texto para cada artículo. Este tipo de estructura es muy común cuando se trabaja con bases de datos o archivos de configuración en aplicaciones web, ya que permite almacenar fácilmente información compleja y relacionada.

La importancia de este formato radica en su capacidad para ser fácilmente leído por humanos pero también procesado eficientemente por programas. Esto facilita la interacción entre diferentes componentes de una aplicación o incluso entre sistemas distintos, permitiendo compartir datos de manera sencilla y estandarizada.

```json
[
  {
    "titulo":"Primer artículo",
    "fecha":"2025-10-16",
    "autor":"Jose Vicente Carratala",
    "contenido":"Este es el contenido del primer artículo"
  },
  {
    "titulo":"Segundo artículo",
    "fecha":"2025-10-17",
    "autor":"Jose Vicente Carratala",
    "contenido":"Este es el contenido del segundo artículo"
  },
  {
    "titulo":"Tercer artículo",
    "fecha":"2025-10-16",
    "autor":"Jose Vicente Carratala",
    "contenido":"Este es el contenido del tercer artículo"
  },
  {
    "titulo":"Cuarto artículo",
    "fecha":"2025-10-16",
    "autor":"Jose Vicente Carratala",
    "contenido":"Este es el contenido del cuarto artículo"
  }
]
```

### blog

#### Explicación

El fragmento que has proporcionado parece ser contenido textual almacenado en un archivo llamado `blog.txt`. Este tipo de estructura se utiliza comúnmente para guardar artículos o entradas de blog. Cada línea representa una entrada diferente: la primera es el primer artículo, la segunda línea contiene el segundo artículo y así sucesivamente. En este caso, cada artículo está separado por líneas distintas, lo que facilita su lectura y procesamiento individual cuando se programa para acceder a este archivo.

Es importante destacar que en entornos de programación, leer archivos como este nos permite tomar el contenido textual y manipularlo según nuestras necesidades. Por ejemplo, podríamos querer contar cuántas entradas hay en total, extraer información específica de cada entrada o incluso generar un índice automático para estos artículos.

```
Este es un primer articulo de blog
Este es un segundo artículo de blog
Y este es el tercero
Y por qué no, podemos tener un cuarto artículo
```

### Actividades propuestas

### Actividad 1: Leer y Mostrar Contenido de Ficheros de Texto
**Descripción:** Los estudiantes deben crear un programa en Python que lea un archivo de texto (blog.txt) y muestre su contenido por pantalla línea a línea. Se espera que aprendan cómo abrir archivos, leer sus líneas y manipular el flujo de datos.

### Actividad 2: Leer JSON e Imprimir Datos
**Descripción:** Los estudiantes deben escribir un programa Python para leer un archivo JSON (blog.json) y mostrar en la consola los datos del primer artículo. A través de esta actividad, aprenderán a trabajar con estructuras de datos más complejas usando el módulo `json`.

### Actividad 3: Manipulación Avanzada de JSON
**Descripción:** Los estudiantes deben crear un programa Python que recorra cada uno de los artículos en blog.json y imprima solo el título, fecha y contenido del autor. Esta actividad les ayudará a entender la manipulación de datos en estructuras JSON más complejas.

### Actividad 4: Personalizar Salida con Formato
**Descripción:** Los estudiantes deben modificar un programa existente para que, al leer blog.json, imprima cada artículo con una línea de separación decorativa antes y después. Esta actividad permitirá a los alumnos practicar el uso de bucles y cadenas formateadas.

### Actividad 5: Crear un Servidor Web Básico
**Descripción:** Los estudiantes deben configurar Flask para servir contenido HTML básico (como visto en 012-frankenstein.py), mostrando una página estática en lugar del texto plano. Esta actividad les ayudará a entender cómo crear y ejecutar aplicaciones web simples.

### Actividad 6: Creación de Páginas HTML desde Python
**Descripción:** A partir de los archivos HTML existentes, los estudiantes deben modificar el código en Python para generar dinámicamente un archivo HTML que incluya múltiples artículos del blog.json. Esto permitirá a los alumnos combinar conocimientos de HTML y programación.

### Actividad 7: Implementar Estilos Básicos en HTML
**Descripción:** Los estudiantes deben tomar el código HTML básico (008-articulo.html) y agregar estilos mínimos para mejorar la presentación visual, similar al ejemplo en 009-estilos minimos.html. Esta actividad les ayudará a entender cómo aplicar CSS simple para mejorar la apariencia de sitios web.

### Actividad 8: Desarrollar una Página HTML Dinámica
**Descripción:** Los estudiantes deben crear un script Flask que lea blog.json y genere dinámicamente una página HTML con múltiples artículos. Esta actividad les ayudará a combinar conceptos de programación, manejo de archivos JSON, generación de HTML y servidor web.

### Actividad 9: Integrar HTML Dinámico en Servidor Flask
**Descripción:** Los estudiantes deben modificar el código existente (012-frankenstein.py) para que genere dinámicamente un HTML basado en datos del blog.json. Esto les permitirá entender cómo integrar la generación de contenido web con servidores web Flask.

### Actividad 10: Crear y Configurar Servidor Local
**Descripción:** Los estudiantes deben instalar un servidor local (XAMPP o Apache) según las instrucciones en 010-Instalar servidor.md, configurarlo para que se pueda acceder a los archivos HTML generados en el servidor. Esta actividad les permitirá entender la infraestructura necesaria para servir contenido web y manejar solicitudes HTTP desde un entorno de desarrollo local.


<a id="apertura-y-cierre-de-ficheros-modos-de-acceso-escritura-y-lectura-de-informacion-en-ficheros"></a>
## Apertura y cierre de ficheros. Modos de acceso. Escritura y lectura de información en ficheros

### Introducción a los ejercicios

En esta carpeta, trabajaremos con ejercicios que te ayudarán a entender cómo manejar archivos en Python. Los problemas abordan la creación, escritura y lectura de archivos tanto en formato texto como binario. Aprenderás a abrir archivos con diferentes modos (lectura, escritura, apendizaje) y a gestionar correctamente su cierre para evitar errores y garantizar la integridad de los datos.

Además, practicarás técnicas avanzadas como el uso del módulo `pickle` para serializar objetos complejos en archivos binarios y luego recuperarlos. Esto es especialmente útil cuando necesitas almacenar estructuras de datos más elaboradas que simples cadenas de texto.

### escribir

#### Explicación

Este código Python muestra cómo abrir, escribir en y luego cerrar un archivo de texto llamado "basededatos.txt". Primero, la función `open()` se utiliza para crear o abrir el archivo "basededatos.txt" con modo de escritura ("w"). En este modo, si el archivo no existe, será creado; si ya existe, su contenido previo será borrado. Luego, utilizamos el método `.write()` en el objeto del archivo recién abierto para añadir la frase "esto es otro contenido". Finalmente, cerramos el archivo con `archivo.close()`, lo cual es crucial porque nos asegura que todos los cambios se han guardado y liberamos los recursos del sistema.

Es importante cerrar un archivo después de trabajar con él para evitar problemas relacionados con la seguridad o el manejo ineficiente de los recursos.

```python
archivo = open("basededatos.txt","w")
archivo.write("esto es otro contenido")
archivo.close()
```

### apendizar

#### Explicación

Este fragmento de código en Python se encarga de abrir y escribir información en un archivo llamado "basededatos.txt". La función `open()` se utiliza para abrir el archivo, pero con un detalle importante: el segundo argumento "a" indica que queremos añadir contenido al final del archivo sin eliminar lo que ya está escrito (esto se llama modo de apertura 'append'). Luego, la línea `archivo.write("esto es un contenido")` inserta el texto especificado en el archivo. Finalmente, `archivo.close()` cierra el archivo para asegurarse de que toda la información escrita sea guardada correctamente y los recursos sean liberados. Este código es fundamental cuando necesitas actualizar o ampliar archivos sin perder la información existente.

```python
archivo = open("basededatos.txt","a")
archivo.write("esto es un contenido")
archivo.close()
```

### añadir salto de linea

#### Explicación

Este código está diseñado para añadir texto a un archivo existente llamado "basededatos.txt". Primero, el programa abre el archivo en modo de "append" ("a"), lo que significa que cualquier texto nuevo se agregará al final del archivo sin sobrescribir nada. Luego, utiliza la función `write()` para agregar una nueva línea que dice "esto es un contenido", seguida de un salto de línea "\n". Esto permite que el siguiente texto escrito aparezca en una nueva línea en el archivo. Finalmente, cierra el archivo con la función `close()`. Es importante cerrar el archivo después de usarlo para asegurar que todos los cambios se guarden correctamente y liberar recursos del sistema.

```python
archivo = open("basededatos.txt","a")
archivo.write("esto es un contenido\n")
archivo.close()
```

### leer una linea

#### Explicación

Este fragmento de código en Python muestra cómo abrir un archivo existente y leer una línea específica de él. Primero, el programa abre el archivo llamado "basededatos.txt" en modo lectura (`"r"`), lo que significa que solo puede leer información del archivo pero no escribir en él. Luego, utiliza la función `readline()` para leer la primera línea del archivo y guarda esa línea en una variable llamada `linea`. Finalmente, imprime la línea leída con el comando `print(linea)` antes de cerrar el archivo con `archivo.close()`, lo cual es importante hacer para liberar los recursos del sistema.

```python
archivo = open("basededatos.txt","r")
linea = archivo.readline()
print(linea)
archivo.close()
```

### leer varias lineas

#### Explicación

Este fragmento de código en Python se utiliza para abrir un archivo llamado "basededatos.txt" y leer todas sus líneas. Primero, el programa abre el archivo en modo lectura ("r"), lo que significa que solo puede leer su contenido sin modificarlo. Luego, la función `readlines()` lee todo el contenido del archivo línea por línea y almacena cada línea como un elemento de una lista llamada `lineas`. Finalmente, imprime esta lista para mostrar todas las líneas del archivo en la consola y cierra el archivo para asegurar que todos los cambios realizados durante la lectura (como el puntero de lectura) se guardan correctamente y liberar recursos.

Esta técnica es importante porque permite trabajar fácilmente con cada línea del archivo como un elemento individual en una lista, lo que facilita procesar o manipular cada línea por separado si fuera necesario.

```python
archivo = open("basededatos.txt","r")
lineas = archivo.readlines()
print(lineas)
archivo.close()
```

### recorrer la lista

#### Explicación

Este código Python se utiliza para leer el contenido de un archivo llamado "basededatos.txt" y luego imprimir cada línea del archivo en la consola. Primero, el programa abre el archivo en modo lectura ("r") usando la función `open()`. Luego, lee todas las líneas del archivo utilizando el método `readlines()` y almacena estas líneas en una lista llamada `lineas`. Finalmente, recorre cada elemento de esta lista (cada línea del archivo) con un bucle `for` e imprime cada línea. Es importante cerrar el archivo después de terminar de leerlo para liberar los recursos del sistema operativo, lo cual se hace con la función `close()`. Este tipo de código es útil cuando necesitas procesar información almacenada en archivos de texto, como bases de datos simples o registros de eventos.

```python
archivo = open("basededatos.txt","r")
lineas = archivo.readlines()
for linea in lineas:
  print(linea)
archivo.close()
```

### pickle escribir

#### Explicación

Este código utiliza la biblioteca `pickle` en Python para guardar datos en un archivo binario. Lo primero que hace es abrir un archivo llamado "datos.bin" en modo de escritura binaria ("wb"). Luego, toma una cadena de texto que dice "Jose Vicente" y la guarda en el archivo usando la función `pickle.dump()`. Finalmente, cierra el archivo para asegurarse de que todos los datos se han guardado correctamente. Este proceso es importante porque permite almacenar información compleja en un formato binario que puede ser leído fácilmente por Python más tarde, lo que facilita la persistencia y recuperación de datos en programas más grandes.

```python
#pip3 install pickle | pip install pickle
import pickle

archivo = open("datos.bin","wb")
cadena = "Jose Vicente"

pickle.dump(cadena,archivo)

archivo.close()
```

### leer pickle

#### Explicación

Este fragmento de código muestra cómo se utiliza la biblioteca `pickle` en Python para leer datos binarios desde un archivo. En primer lugar, el programa abre un archivo llamado "datos.bin" en modo lectura binaria ("rb"). Luego, usa la función `pickle.load()` para cargar los datos del archivo y convertirlos en una estructura de datos legible por Python (como una lista, tupla, diccionario, etc.). Estos datos cargados se almacenan en la variable `cadena`, que después se imprime en pantalla. Finalmente, el programa cierra el archivo para liberar los recursos del sistema.

La función `pickle.load()` es crucial porque permite recuperar objetos complejos desde un archivo binario, lo cual es útil cuando necesitas almacenar estructuras de datos no simples y luego leerlas nuevamente en tu programa. Esto facilita mucho la manipulación de datos persistentes entre sesiones del programa o entre diferentes partes de una misma aplicación.

```python
#pip3 install pickle | pip install pickle
import pickle

archivo = open("datos.bin","rb")

cadena = pickle.load(archivo)
print(cadena)

archivo.close()
```

### crear cliente

#### Explicación

Este código crea una clase llamada `Cliente` que sirve para representar información sobre clientes, como su nombre y correo electrónico. En el constructor de la clase (el método `__init__`), se inicializan los atributos del objeto con los valores proporcionados por parámetros (`nuevonombre` y `nuevoemail`). Luego, creamos una lista vacía llamada `clientes`. A continuación, añadimos dos objetos de la clase `Cliente` a esta lista usando el método `append`, pasando como argumentos los detalles del cliente para cada uno. Finalmente, se imprime la lista completa de clientes.

Esta forma de estructurar la información es importante porque permite manejar datos complejos y relacionados en una manera clara y organizada, facilitando su uso en aplicaciones más grandes que pueden necesitar almacenar o procesar datos de múltiples clientes.

```python
class Cliente():
  def __init__(self,nuevonombre,nuevoemail):
    self.nombre = nuevonombre
    self.email = nuevoemail

clientes = []

clientes.append(Cliente("Jose Vicente","info@jocarsa.com"))
clientes.append(Cliente("Juan","juan@jocarsa.com"))

print(clientes)
```

### guardo con pickle a binario

#### Explicación

Este código es una pequeña parte de un programa que muestra cómo guardar datos en formato binario utilizando el módulo `pickle` de Python. En primer lugar, se define una clase llamada `Cliente`, la cual tiene dos atributos: `nombre` y `email`. Estos atributos son inicializados mediante el método `__init__`, que recibe como parámetros los valores del nombre y email del cliente.

Luego, creamos una lista vacía llamada `clientes` donde almacenaremos instancias de la clase `Cliente`. En este ejemplo, añadimos dos clientes a esta lista: uno con el nombre "Jose Vicente" y otro con el nombre "Juan", ambos asociados al mismo dominio de correo electrónico.

Finalmente, se abre un archivo en modo escritura binaria (esto significa que los datos serán guardados de manera no legible directamente por humanos) con el nombre `"clientes.bin"` utilizando la función `open`. Luego, usamos la función `pickle.dump` para guardar toda la lista `clientes` dentro del archivo recién abierto. Una vez finalizado este proceso de escritura, cerramos el archivo con `archivo.close()` para asegurarnos de que todos los cambios se hayan guardado correctamente.

Este tipo de operaciones es muy útil en programación ya que permite almacenar objetos complejos como listas de instancias de clases directamente en un archivo binario, facilitando así su posterior lectura y uso sin necesidad de volver a crearlos desde cero.

```python
import pickle

class Cliente():
  def __init__(self,nuevonombre,nuevoemail):
    self.nombre = nuevonombre
    self.email = nuevoemail

clientes = []

clientes.append(Cliente("Jose Vicente","info@jocarsa.com"))
clientes.append(Cliente("Juan","juan@jocarsa.com"))

archivo = open("clientes.bin","wb")
pickle.dump(clientes,archivo)
archivo.close()
```

### recupero los datos

#### Explicación

Este código está diseñado para leer información almacenada en un archivo binario utilizando el módulo `pickle` de Python. En primer lugar, se importa el módulo `pickle`, que es una herramienta útil para guardar y cargar objetos complejos en archivos.

El código define una clase llamada `Cliente`, la cual tiene dos atributos: `nombre` y `email`. Estos atributos se inicializan a través del método `__init__`, que recibe el nombre y el correo electrónico del cliente como parámetros cuando se crea un nuevo objeto de tipo `Cliente`.

Luego, el programa abre el archivo binario llamado "clientes.bin" en modo lectura binaria ("rb"). A continuación, utiliza la función `pickle.load()` para cargar los datos almacenados en este archivo en una variable llamada `clientes`. Esta operación convierte la representación de bytes en un objeto Python que se puede manipular.

Finalmente, el programa cierra el archivo y muestra por pantalla lo que ha cargado utilizando la función `print()`. Esto es útil para verificar que los datos del archivo han sido correctamente recuperados y convertidos en objetos Python.

```python
import pickle

class Cliente():
  def __init__(self,nuevonombre,nuevoemail):
    self.nombre = nuevonombre
    self.email = nuevoemail

archivo = open("clientes.bin","rb")
clientes = pickle.load(archivo)
archivo.close()

print(clientes)
```

### basededatos

#### Explicación

El fragmento que has proporcionado no parece ser código, sino simplemente texto. Sin embargo, en el contexto del archivo de ruta que mencionas (`basededatos.txt`), este podría representar una base de datos simple o un archivo de texto donde se almacenan datos. En un ejercicio de programación, podrías usar este contenido para aprender a leer y escribir información en archivos.

El propósito de tener tal contenido en un archivo es permitirte practicar operaciones como abrir el archivo, leer su contenido línea por línea, contar cuántas líneas hay, buscar ciertas palabras o incluso modificar el texto que contiene. Estos ejercicios son fundamentales para entender cómo interactuar con archivos en la programación.

Es importante aprender a manejar estos archivos porque te permiten almacenar y recuperar información de forma persistente fuera del programa, lo cual es crucial en muchos proyectos de desarrollo web o software más grandes donde se necesita guardar datos de los usuarios o estados del sistema.

```
esto es un contenido
esto es un contenido
esto es un contenido
```

### Actividades propuestas

1. **Escribir en Ficheros**
   - Descripción: Los estudiantes deben escribir una cadena de texto en un fichero y luego cerrarlo correctamente.
   - Objetivo: Aprender a abrir, escribir y cerrar archivos en modo "w".

2. **Añadir Contenido al Final del Fichero**
   - Descripción: Los alumnos añaden contenido nuevo al final del archivo existente sin sobrescribirlo.
   - Objetivo: Comprender la apertura de archivos en modo "a" y el uso adecuado del método `write()`.

3. **Incluir Saltos de Línea**
   - Descripción: Los estudiantes deben añadir un salto de línea después de escribir cada frase en un archivo.
   - Objetivo: Aprender a usar `\n` para insertar saltos de línea en los archivos escritos.

4. **Leer Contenido de un Fichero**
   - Descripción: Los estudiantes deben leer y mostrar una línea específica de un fichero existente.
   - Objetivo: Entender cómo abrir y cerrar archivos en modo "r" y usar `readline()`.

5. **Recorrer y Mostrar Todas las Líneas**
   - Descripción: Los alumnos deben recoger todas las líneas del archivo y mostrarlas por pantalla.
   - Objetivo: Aprender a utilizar `readlines()` para leer múltiples líneas de un fichero.

6. **Manejo de Listas con Archivos**
   - Descripción: Los estudiantes crearán una lista de clientes (objetos) y la almacenarán en un archivo binario.
   - Objetivo: Aprender a usar `pickle` para guardar objetos complejos en archivos binarios.

7. **Serialización y Deserialización con Pickle**
   - Descripción: Los estudiantes serializan un objeto simple (cadena) usando pickle y luego lo recuperan del archivo.
   - Objetivo: Familiarizar al estudiante con la importancia de `pickle` para almacenar datos estructurados.

8. **Manipulación Compleja de Datos**
   - Descripción: Los alumnos crean un conjunto de objetos cliente, los serializan y luego los recuperan del archivo binario.
   - Objetivo: Aprender a manejar conjuntos complejos de datos (listas de objetos) utilizando `pickle`.

Estas actividades proporcionarán a los estudiantes una base sólida en la manipulación de archivos y el uso de serialización para guardar y recuperar datos estructurados, aspectos clave en el desarrollo de aplicaciones orientadas a la persistencia de datos.


<a id="utilizacion-de-los-sistemas-de-ficheros"></a>
## Utilización de los sistemas de ficheros.

### Introducción a los ejercicios

It looks like you've shared a list of file paths from what appears to be a course directory for a programming or database management course. Each path points to a specific topic within the curriculum, covering various aspects related to object-oriented programming and databases.

Here's a brief summary of the main topics based on the filenames:

1. **Concepts of Classes**: Introduction to classes, objects, properties, methods, and basic OOP principles.
2. **Structure and Members of Classes**: Detailed explanation about class structures including attributes (properties), constructors, destructors, static members, visibility modifiers (public, private).
3. **Development of Class Methods**: Focuses on the creation and implementation of methods within classes, their functionalities, and best practices for method design.
4. **Inheritance and Polymorphism**: Covers how to create hierarchical class relationships using inheritance, understanding base and derived classes, overriding methods, etc.
5. **Persistence Management of Objects**: Techniques and tools used in saving object state to a database or file system so that it can be restored later when needed.
6. **Query Language Syntax & Expressions**: Introduces OQL (Object Query Language) syntax for querying objects stored within an object-oriented database management system.
7. **Database Creation**: Steps and commands for creating new databases, tables, indexes etc., using a specific DBMS like db4o or similar systems.
8. **Retrieval, Modification & Deletion of Information**: How to retrieve data from the database, update existing records, delete unwanted entries efficiently.
9. **Collection Data Types**: Explains different types of collections (like Sets, Lists) available in object-oriented programming and their use cases.

The course structure seems well-organized with detailed explanations followed by evaluation criteria for each topic. If you need help understanding any particular aspect or want to dive deeper into one of these topics based on the provided file paths, feel free to ask!

### listar contenido de carpeta

#### Explicación

Este fragmento de código en Python sirve para listar los archivos y directorios que hay dentro de una carpeta específica. Primero, el programa importa el módulo `os`, que es una colección de funciones útiles relacionadas con el sistema operativo donde se ejecuta tu script.

Luego, le pide al usuario que ingrese la ruta de una carpeta a través del comando `input()`. La entrada proporcionada por el usuario se guarda en la variable `carpeta`.

Finalmente, el código utiliza la función `os.listdir()` para obtener una lista de todos los nombres de archivos y directorios dentro de la carpeta especificada. Esta lista se almacena en la variable `elementos`. Después, usando un bucle `for`, el programa itera a través de cada elemento en esa lista e imprime su nombre en pantalla.

Este código es importante porque permite interactuar con el sistema de archivos del ordenador y entender qué archivos o carpetas existen en una ubicación dada, lo cual puede ser útil para muchas tareas de automatización y gestión de archivos.

```python
import os

carpeta = input("Indica una carpeta: ")

elementos = os.listdir(carpeta)

for elemento in elementos:
  print(elemento)
```

### atributos

#### Explicación

Este fragmento de código en Python te permite explorar los archivos y directorios dentro de una carpeta específica del sistema de ficheros. Empezamos importando el módulo `os`, que proporciona funciones para interactuar con el sistema operativo.

El programa solicita al usuario que introduzca la ruta de un directorio o carpeta a través de la función `input()`. Luego, usa `os.listdir()` para obtener una lista de todos los elementos (archivos y subdirectorios) que contiene esa carpeta. A continuación, utiliza un bucle `for` para recorrer cada uno de estos elementos.

Para cada elemento en la carpeta, el código construye la ruta completa a través de `os.path.join()`, que asegura que la sintaxis de los directorios sea correcta tanto en sistemas Unix como Windows. Luego, muestra esta ruta y utiliza dos funciones más del módulo `os.path`: `getsize()` para imprimir el tamaño del archivo o subdirectorio en bytes, y `getmtime()` para imprimir la hora de última modificación del elemento en formato de tiempo Unix (segundos desde 1970).

Este código es útil para comprender qué archivos contiene un directorio específico, cuánto ocupa cada uno y cuándo se modificó por última vez. Es una herramienta básica para el manejo de archivos y directorios en Python, muy práctica para tareas como la limpieza de discos o la monitorización del uso del espacio en disco.

```python
import os

carpeta = input("Indica una carpeta: ")

elementos = os.listdir(carpeta)

for elemento in elementos:
  ruta = os.path.join(carpeta, elemento)
  print(ruta)
  print(os.path.getsize(ruta))
  print(os.path.getmtime(ruta))
```

### formateo el resultado

#### Explicación

Este fragmento de código en Python tiene como objetivo recopilar información sobre los archivos y directorios que se encuentran dentro de una carpeta específica. Primero, el programa solicita al usuario que introduzca la ruta de una carpeta utilizando `input("Indica una carpeta: ")`. Luego, utiliza la función `os.listdir(carpeta)` para obtener una lista de todos los elementos (archivos y directorios) dentro de esa carpeta.

Para cada elemento en esta lista, el código crea la ruta completa del archivo o directorio usando `os.path.join(carpeta, elemento)`, lo que garantiza que la ruta sea correcta independientemente del sistema operativo. Después, imprime esta ruta completa y también muestra el tamaño de los archivos (no de los directorios, ya que estos no tienen tamaño) en megabytes (MB), utilizando `os.path.getsize(ruta)/(1024*1024)`.

Además, el código imprime la fecha y hora modificada más reciente del archivo o directorio con `os.path.getmtime(ruta)`, proporcionando información útil sobre cuándo se accedió por última vez a cada elemento. Este tipo de operaciones es importante para administrar archivos y entender su contenido y estado, especialmente cuando trabajamos en sistemas que manejan muchos archivos, como servidores web o bases de datos.

```python
import os

carpeta = input("Indica una carpeta: ")

elementos = os.listdir(carpeta)

for elemento in elementos:
  ruta = os.path.join(carpeta, elemento)
  print(ruta)
  print(os.path.getsize(ruta)/(1024*1024),"MB")
  print(os.path.getmtime(ruta))
```

### suma del tamaño

#### Explicación

Este código te ayuda a entender cuánto espacio en disco ocupa una carpeta específica. Primero, el programa pide que introduzcas la ruta de una carpeta. Luego, utiliza la función `os.listdir()` para obtener una lista con todos los archivos y subdirectorios que contiene esa carpeta. 

A continuación, el código itera a través de cada elemento en esta lista. Para cada uno, construye su ruta completa (por ejemplo, si introduces '/home/usuario/documentos' y dentro hay un archivo llamado 'archivo.txt', la función `os.path.join()` crea la ruta '/home/usuario/documentos/archivo.txt'). Luego, utiliza la función `os.path.getsize()`, que devuelve el tamaño en bytes de ese elemento (ya sea archivo o directorio). Suma estos tamaños para obtener el total.

Finalmente, muestra cuánto espacio ocupa todo juntos, pero convierte los bytes a megabytes para hacerlo más manejable y comprensible. Esto es útil para saber qué tan grande es tu carpeta en términos humanamente significativos como MB.

```python
import os

carpeta = input("Indica una carpeta: ")

elementos = os.listdir(carpeta)

suma = 0

for elemento in elementos:
  ruta = os.path.join(carpeta, elemento)
  suma += os.path.getsize(ruta)

print("La carpeta ocupa:")
print(suma/(1024*1024),"MB")
```

### recorrer

#### Explicación

Este código es un ejemplo sencillo de cómo recorrer y examinar el contenido de una carpeta específica en Python. Primero, importa la librería `os`, que proporciona funciones para interactuar con el sistema operativo.

Luego, se pide al usuario que introduzca el nombre de una carpeta mediante el método `input()`. La función `os.walk()` es utilizada a continuación para recorrer recursivamente todos los directorios y subdirectorios dentro de la carpeta dada por el usuario. En cada paso del bucle, `os.walk()` proporciona tres variables: `directorio`, que contiene el nombre completo del directorio actual; `carpetas`, una lista con los nombres de todas las carpetas contenidas en ese directorio; y `archivo`, otra lista pero esta vez con los nombres de todos los archivos presentes.

El código simplemente imprime estas tres variables para cada nivel en la jerarquía de carpetas que se analiza. Esto puede ser útil para entender la estructura completa de un conjunto de carpetas, ver qué archivos y subcarpetas contiene cada directorio a medida que recorre el árbol de carpetas.

Esta técnica es importante porque permite automatizar tareas como buscar archivos específicos, listar todo el contenido de una carpeta o incluso realizar operaciones en todos los archivos y carpetas dentro de un conjunto dado.

```python
import os

carpeta = input("Indica una carpeta: ")

for directorio,carpetas,archivo in os.walk(carpeta):
  print(directorio)
  print(carpetas)
  print(archivo)
```

### tamaño recursivo

#### Explicación

Este código Python ayuda a calcular el tamaño total de una carpeta específica, incluyendo todos los archivos y subcarpetas dentro de ella. En primer lugar, solicita al usuario que ingrese la ruta de la carpeta que desea analizar. Luego, utiliza un bucle `for` junto con la función `os.walk()`, que recorre todo el contenido de la carpeta proporcionada, incluyendo subdirectorios y archivos individuales.

Dentro del bucle, para cada archivo encontrado se calcula su tamaño real en bytes utilizando `os.path.getsize()` y se suma al total acumulado. Si durante este proceso ocurre algún error (por ejemplo, si no se puede leer un archivo), el código simplemente pasa a la siguiente iteración gracias al bloque `except: pass`, lo que significa que el programa sigue funcionando sin interrupciones.

Finalmente, después de recorrer toda la carpeta y sumar los tamaños de todos los archivos accesibles, el código muestra en pantalla cuánto ocupa la carpeta en total, expresado en megabytes. Esto es útil para conocer rápidamente cuánto espacio ocupa una carpeta completa en el sistema de archivos, lo cual puede ser importante cuando gestionas el almacenamiento en un dispositivo limitado o buscas optimizar tu uso del espacio en disco.

```python
import os

carpeta = input("Indica una carpeta: ")

suma = 0

for directorio, carpetas, archivos in os.walk(carpeta):
    for archivo in archivos:
        ruta = os.path.join(directorio, archivo)
        try:
            suma += os.path.getsize(ruta)
        except:
            pass  # Evita errores si un archivo no se puede leer
  
print("La carpeta ocupa:")
print(suma/(1024*1024),"MB")
```

### condicion

#### Explicación

Este fragmento de código Python está diseñado para ayudar a los usuarios a identificar archivos grandes en una carpeta específica. El programa comienza importando el módulo `os`, que proporciona funciones para interactuar con el sistema operativo.

El usuario es solicitado a ingresar la ruta de una carpeta, y se define un tamaño grande (1 gigabyte) como límite. Luego, utilizando `os.walk()`, el código recorre todos los archivos en esa carpeta y sus subcarpetas. Para cada archivo encontrado, el programa construye su ruta completa y luego intenta obtener su tamaño usando `os.path.getsize()`. Si el tamaño del archivo supera el límite de 1 gigabyte definido al principio, se imprime la ruta del archivo junto con su tamaño en megabytes.

Este tipo de script es útil para administrar espacio en disco, ya que ayuda a identificar rápidamente archivos grandes que podrían estar ocupando demasiado espacio y necesitan revisarse o eliminarse.

```python
import os

carpeta = input("Indica una carpeta: ")
grande = 1024*1024*1024 # 1 giga

for directorio, carpetas, archivos in os.walk(carpeta):
    for archivo in archivos:
        ruta = os.path.join(directorio, archivo)
        try:
            if os.path.getsize(ruta) > grande:
              print(ruta,os.path.getsize(ruta)/(1024*1024),"MB")
        except:
            pass  
    
```

### escribir en archivo el contenido de la carpeta

#### Explicación

Este código Python es una herramienta útil para estudiantes de Formación Profesional que trabajan con sistemas operativos y gestión de archivos. El objetivo principal del código es recorrer una carpeta específica dada por el usuario, listar todos los archivos dentro de esa carpeta y sus subcarpetas, y escribir la ruta completa de cada archivo en un archivo llamado `mapa.txt`. 

Al ejecutar el programa, primero pedimos al usuario que introduzca la ruta de la carpeta que quiere analizar. Luego, creamos o abrimos el archivo `mapa.txt` para añadir información al final del documento (esto se hace con el modo 'a' en la función `open`). A continuación, usamos una estructura de bucle `for` junto a la función `os.walk()` que recorre recursivamente todas las subcarpetas y archivos dentro de la carpeta especificada. Para cada archivo encontrado, creamos su ruta completa con `os.path.join()` y la escribimos en el archivo `mapa.txt`.

Esta herramienta es especialmente útil para tener un registro detallado de todos los archivos que existen en una estructura de carpetas compleja, lo cual puede ser muy valioso para tareas como respaldos, auditoría o gestión de proyectos.

```python
import os

carpeta = input("Indica una carpeta: ")
grande = 1024*1024*1024 # 1 giga

mapa = open("mapa.txt",'a') # Vaciamos los contenidos anteriores

for directorio, carpetas, archivos in os.walk(carpeta):
    for archivo in archivos:
        ruta = os.path.join(directorio, archivo)
        mapa.write(ruta+"\n")
        
mapa.close()
         
    
```

### sobreescribir cada vez

#### Explicación

Este código es un fragmento de un programa en Python que recorre una carpeta dada y registra la ruta completa de cada archivo que contiene. Primero, importamos el módulo `os`, que nos permite trabajar con el sistema operativo para tareas como navegar por directorios o archivos.

El programa comienza pidiendo al usuario que ingrese una carpeta específica a examinar. Luego establece un tamaño grande (1 gigabyte) que no se utiliza en este contexto particular, pero sirve para definir un espacio grande en bytes. 

Después, el código crea y abre un archivo llamado "mapa.txt" en modo de escritura (`'w'`), lo cual significa que si ya existe un archivo con ese nombre, su contenido anterior será borrado.

El programa luego itera sobre todos los directorios y archivos dentro de la carpeta especificada utilizando `os.walk()`. Para cada archivo encontrado, construye una ruta completa desde el directorio actual hasta el archivo específico y la escribe en "mapa.txt", seguida de un salto de línea para separar las rutas.

Finalmente, cierra el archivo "mapa.txt" con `mapa.close()` para asegurarse de que todos los cambios se guarden correctamente y los recursos sean liberados. Este código es útil cuando necesitas mapear o documentar la estructura de archivos en una carpeta específica en tu sistema.

```python
import os

carpeta = input("Indica una carpeta: ")
grande = 1024*1024*1024 # 1 giga

mapa = open("mapa.txt",'w') # Vaciamos los contenidos anteriores

for directorio, carpetas, archivos in os.walk(carpeta):
    for archivo in archivos:
        ruta = os.path.join(directorio, archivo)
        mapa.write(ruta+"\n")
        
mapa.close()
         
    
```

### minibuscador

#### Explicación

Este código Python busca determinar si una palabra específica, en este caso "manzana", aparece dentro de otra cadena más larga llamada "cadena". El programa utiliza la estructura `if` para comprobar si "objetivo" (que es "manzana") está presente en "cadena" (que contiene el texto "Esto es una cadena de prueba"). Si se encuentra la palabra, imprime "Efectivamente está", pero si no la encuentra, imprime "No está". Este tipo de comprobación es muy útil cuando necesitas buscar información específica dentro de un texto más grande, como por ejemplo en búsquedas de palabras clave o en el procesamiento de datos textuales.

```python
cadena = "Esto es una cadena de prueba"
objetivo = "manzana"

if objetivo in cadena:
  print("Efectivamente está")
else:
  print("No está")
  
```

### busca en mapa

#### Explicación

Este código python es muy sencillo pero útil para entender cómo trabajar con archivos de texto. Lo que hace este fragmento es abrir un archivo llamado "mapa.txt", leer todas sus líneas y luego buscar dentro de cada línea si contiene la palabra "json". Si encuentra esa palabra, imprime en pantalla una línea de separación y después muestra la línea completa donde encontró "json".

Este tipo de código es importante porque te permite analizar archivos grandes buscando información específica, lo que puede ser muy útil para tareas como el análisis de datos o la búsqueda de errores en un archivo de configuración.

```python
archivo = open("mapa.txt",'r') # READ

lineas = archivo.readlines()

for linea in lineas:
  if "json" in linea:
    print("###########################")
    print("Encontrado!: ",linea)   
     
```

### usuario busca

#### Explicación

Este código es una pequeña parte de un programa que busca información específica dentro de un archivo llamado "mapa.txt". En primer lugar, el programa abre el archivo en modo lectura ('r'). Luego, le pide al usuario que introduzca un término que quiere buscar dentro del archivo. Después, lee todas las líneas del archivo y guarda cada línea como elementos individuales en una lista llamada 'lineas'.

El bucle for itera sobre cada línea de la lista y comprueba si el término que se buscaba está presente en esa línea. Si lo encuentra, imprime un aviso con varios trazos para resaltar la salida y luego muestra la línea completa donde aparece el término.

Este tipo de código es muy útil cuando necesitas buscar información específica dentro de grandes archivos de texto sin tener que leerlos manualmente, ya que puede automatizar el proceso de búsqueda y facilitar mucho las tareas de análisis o recuperación de datos.

```python
archivo = open("mapa.txt",'r') # READ
busca = input("Introduce el término a buscar: ")

lineas = archivo.readlines()

for linea in lineas:
  if busca in linea:
    print("###########################")
    print("Encontrado!: ",linea)   
     
```

### mapa

#### Explicación

It looks like you have a well-organized structure for learning about object-oriented programming and database management. Here are some key areas based on the files provided:

### Object-Oriented Programming (OOP)
1. **Concept of Class**
   - Introduction to classes, objects, properties, and methods.
   - Example: Creating a `Gato` (Cat) class in Python.

2. **Structure and Members of Classes**
   - Understanding attributes and methods within classes.
   - Operations with list-based structures.

3. **Development of Methods**
   - Writing functions inside the class that operate on the object's data.

4. **Properties and Development of Class Properties**
   - Defining and managing properties in a more sophisticated manner.
   
5. **Inheritance and Polymorphism**
   - Creating subclasses from existing classes and using polymorphism to make code flexible.

6. **Abstract Classes and Interfaces**
   - Using abstract base classes and interfaces for better design patterns.

7. **Development of Methods with Advanced Features**
   - Implementing methods that utilize inheritance, encapsulation, etc.

8. **Advanced Concepts (Design Patterns)**
   - Understanding and applying design patterns such as Singleton, Factory, Observer, etc.

### Persistence of Objects
1. **Object-Oriented Databases**
   - Introduction to object-oriented databases compared to relational ones.
   
2. **Characteristics of Object-Oriented Databases**
   - Features like polymorphism, inheritance, encapsulation in DB context.

3. **Installation and Setup**
   - Setting up an OODBMS (e.g., db4o).

4. **Creating Databases**
   - Basic operations to create and manage databases.
   
5. **Query Language Syntax**
   - Understanding the syntax for querying object-oriented databases.
   
6. **Query Mechanisms**
   - Various mechanisms used to retrieve data from an OODBMS.

7. **Updating, Retrieving, Deleting Information**
   - CRUD (Create, Read, Update, Delete) operations in context of OODBMS.

8. **Collection Types and Data Structures**
   - Different collection types and how they are stored/retrieved.

### Example File Structure:
Here's an example file structure based on your provided list:

```
/programaciondam2526
├── 004-Desarrollo de clases
│   ├── 001-Concepto de clase
│   │   ├── 101-Ejercicios
│   │   │   ├── 001-introduccion.md
│   │   │   └── ...
│   │   └── 201-Criterios de evaluacion
│   │       └── Criterios_de_evaluacion.md
│   └── 008-Mantenimiento de la persistencia de los objetos
│       ├── 001-Bases de datos orientadas a objetos
│       │   ├── 101-Ejercicios
│       │   │   ├── 001-introduccion.md
│       │   └── 201-Criterios de evaluacion
│       │       └── Criterios_de_evaluacion.md
├── ...
└── 008-Mantenimiento de la persistencia de los objetos
    ├── 009-Tipos de datos colección
    │   ├── 201-Criterios de evaluación
    │   └── 001-Contenidos básicos
    │       └── Contenidos_básicos.md
```

Each of these sections typically includes:
- **Introduction** (Introducción): Overview and basic concepts.
- **Exercises** (Ejercicios): Practical applications with code examples.
- **Evaluation Criteria**: Guidelines for grading assignments.

This structure helps in systematically learning OOP principles and applying them to database management, specifically focusing on object-oriented databases.

```
/var/www/html/programaciondam2526/001-Resumen.md
/var/www/html/programaciondam2526/README.md
/var/www/html/programaciondam2526/000-Resumen.md
/var/www/html/programaciondam2526/peticiones.py
/var/www/html/programaciondam2526/006-Aplicación de las estructuras de almacenamiento/000-Resumen.md
/var/www/html/programaciondam2526/006-Aplicación de las estructuras de almacenamiento/Criterios de evaluacion.md
/var/www/html/programaciondam2526/006-Aplicación de las estructuras de almacenamiento/001-Estructuras estáticas y dinámicas/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/006-Aplicación de las estructuras de almacenamiento/001-Estructuras estáticas y dinámicas/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/006-Aplicación de las estructuras de almacenamiento/004-Genericidad/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/006-Aplicación de las estructuras de almacenamiento/004-Genericidad/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/006-Aplicación de las estructuras de almacenamiento/003-Matrices (arrays) multidimensionales/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/006-Aplicación de las estructuras de almacenamiento/003-Matrices (arrays) multidimensionales/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/006-Aplicación de las estructuras de almacenamiento/005-Cadenas de caracteres. Expresiones regulares/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/006-Aplicación de las estructuras de almacenamiento/005-Cadenas de caracteres. Expresiones regulares/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/006-Aplicación de las estructuras de almacenamiento/002-Creación de matrices (arrays)/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/006-Aplicación de las estructuras de almacenamiento/002-Creación de matrices (arrays)/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/006-Aplicación de las estructuras de almacenamiento/006-Colecciones Listas, Conjuntos y Diccionarios/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/006-Aplicación de las estructuras de almacenamiento/006-Colecciones Listas, Conjuntos y Diccionarios/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/006-Aplicación de las estructuras de almacenamiento/007-Operaciones agregadas filtrado, reducción y recolección/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/006-Aplicación de las estructuras de almacenamiento/007-Operaciones agregadas filtrado, reducción y recolección/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/001-Introduccion.md
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/000-Resumen.md
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/Criterios de evaluacion.md
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/101-Ejercicio de final de unidad/101-Ejercicios/013-constantes.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/101-Ejercicio de final de unidad/101-Ejercicios/014-Diferencia.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/101-Ejercicio de final de unidad/101-Ejercicios/009-Entradas.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/101-Ejercicio de final de unidad/101-Ejercicios/014-operadores aritmeticos.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/101-Ejercicio de final de unidad/101-Ejercicios/019-Calculadora.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/101-Ejercicio de final de unidad/101-Ejercicios/003-salidas.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/101-Ejercicio de final de unidad/101-Ejercicios/011-Cambio de tipo de dato.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/101-Ejercicio de final de unidad/101-Ejercicios/010-Entrada y problema.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/101-Ejercicio de final de unidad/101-Ejercicios/021-Calculo de IVA.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/101-Ejercicio de final de unidad/101-Ejercicios/017-operadores booleanos.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/101-Ejercicio de final de unidad/101-Ejercicios/004-variar una variable.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/101-Ejercicio de final de unidad/101-Ejercicios/001-Holamundo.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/101-Ejercicio de final de unidad/101-Ejercicios/012-literales.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/101-Ejercicio de final de unidad/101-Ejercicios/020-Calculadora.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/101-Ejercicio de final de unidad/101-Ejercicios/005-identificadores permitidos.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/101-Ejercicio de final de unidad/101-Ejercicios/007-Explicacion del codigo.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/101-Ejercicio de final de unidad/101-Ejercicios/008-Tipos de datos.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/101-Ejercicio de final de unidad/101-Ejercicios/018-Ejercicio1-Calculadora de impuestos.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/101-Ejercicio de final de unidad/101-Ejercicios/002-variables.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/101-Ejercicio de final de unidad/101-Ejercicios/006-comentarios.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/101-Ejercicio de final de unidad/101-Ejercicios/016-operadores arimeticos abreviados.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/101-Ejercicio de final de unidad/101-Ejercicios/015-operadores de comparacion.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/101-Ejercicio de final de unidad/201-Criterios de evaluación/001-actividad.md
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/001-Estructura y bloques fundamentales/101-Ejercicios/001-Holamundo.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/001-Estructura y bloques fundamentales/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/001-Estructura y bloques fundamentales/001-Contenidos básicos/Introduccion.md
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/001-Estructura y bloques fundamentales/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/002-Variables/101-Ejercicios/003-salidas.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/002-Variables/101-Ejercicios/004-variar una variable.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/002-Variables/101-Ejercicios/005-identificadores permitidos.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/002-Variables/101-Ejercicios/007-Explicacion del codigo.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/002-Variables/101-Ejercicios/002-variables.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/002-Variables/101-Ejercicios/006-comentarios.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/002-Variables/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/002-Variables/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/005-Constantes/101-Ejercicios/013-constantes.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/005-Constantes/101-Ejercicios/014-Diferencia.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/005-Constantes/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/005-Constantes/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/004-Literales/101-Ejercicios/012-literales.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/004-Literales/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/004-Literales/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/006-Operadores y expresiones/101-Ejercicios/014-operadores aritmeticos.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/006-Operadores y expresiones/101-Ejercicios/019-Calculadora.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/006-Operadores y expresiones/101-Ejercicios/021-Calculo de IVA.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/006-Operadores y expresiones/101-Ejercicios/017-operadores booleanos.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/006-Operadores y expresiones/101-Ejercicios/020-Calculadora.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/006-Operadores y expresiones/101-Ejercicios/018-Ejercicio1-Calculadora de impuestos.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/006-Operadores y expresiones/101-Ejercicios/016-operadores arimeticos abreviados.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/006-Operadores y expresiones/101-Ejercicios/015-operadores de comparacion.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/006-Operadores y expresiones/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/006-Operadores y expresiones/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/003-Tipos de datos/101-Ejercicios/009-Entradas.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/003-Tipos de datos/101-Ejercicios/011-Cambio de tipo de dato.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/003-Tipos de datos/101-Ejercicios/010-Entrada y problema.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/003-Tipos de datos/101-Ejercicios/008-Tipos de datos.py
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/003-Tipos de datos/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/001-Identificación de los elementos de un programa informático/003-Tipos de datos/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/009-Gestión de bases de datos/000-Resumen.md
/var/www/html/programaciondam2526/009-Gestión de bases de datos/Criterios de evaluacion.md
/var/www/html/programaciondam2526/009-Gestión de bases de datos/002-Establecimiento de conexiones/101-Ejercicios/001-ejercicio.md
/var/www/html/programaciondam2526/009-Gestión de bases de datos/002-Establecimiento de conexiones/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/009-Gestión de bases de datos/002-Establecimiento de conexiones/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/009-Gestión de bases de datos/003-Almacenamiento, recuperación, actualización y eliminación de información en bases de datos/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/009-Gestión de bases de datos/003-Almacenamiento, recuperación, actualización y eliminación de información en bases de datos/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/009-Gestión de bases de datos/001-Acceso a bases de datos. Estándares. Características/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/009-Gestión de bases de datos/001-Acceso a bases de datos. Estándares. Características/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/007-Utilización avanzada de clases/000-Resumen.md
/var/www/html/programaciondam2526/007-Utilización avanzada de clases/Criterios de evaluacion.md
/var/www/html/programaciondam2526/007-Utilización avanzada de clases/006-Sobreescritura de métodos/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/007-Utilización avanzada de clases/006-Sobreescritura de métodos/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/007-Utilización avanzada de clases/005-Interfaces/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/007-Utilización avanzada de clases/005-Interfaces/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/007-Utilización avanzada de clases/001-Composición de clases/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/007-Utilización avanzada de clases/001-Composición de clases/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/007-Utilización avanzada de clases/007-Constructores y herencia/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/007-Utilización avanzada de clases/007-Constructores y herencia/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/007-Utilización avanzada de clases/003-Jerarquía de clases Superclases y subclases/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/007-Utilización avanzada de clases/003-Jerarquía de clases Superclases y subclases/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/007-Utilización avanzada de clases/004-Clases y métodos abstractos y finales/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/007-Utilización avanzada de clases/004-Clases y métodos abstractos y finales/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/007-Utilización avanzada de clases/002-Herencia y polimorfismo/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/007-Utilización avanzada de clases/002-Herencia y polimorfismo/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/003-Uso de estructuras de control/000-Resumen.md
/var/www/html/programaciondam2526/003-Uso de estructuras de control/Criterios de evaluacion.md
/var/www/html/programaciondam2526/003-Uso de estructuras de control/002-Estructuras de repetición/101-Ejercicios/006-ahora los impares.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/002-Estructuras de repetición/101-Ejercicios/004-mas anidacion.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/002-Estructuras de repetición/101-Ejercicios/002-estructura for.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/002-Estructuras de repetición/101-Ejercicios/001-ineficiente.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/002-Estructuras de repetición/101-Ejercicios/007-while.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/002-Estructuras de repetición/101-Ejercicios/0005-saltos.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/002-Estructuras de repetición/101-Ejercicios/009-Ejercicio propuesto patitos.md
/var/www/html/programaciondam2526/003-Uso de estructuras de control/002-Estructuras de repetición/101-Ejercicios/008-incremento.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/002-Estructuras de repetición/101-Ejercicios/003-anidacion.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/002-Estructuras de repetición/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/003-Uso de estructuras de control/002-Estructuras de repetición/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/003-Uso de estructuras de control/001-Estructuras de selección/101-Ejercicios/003-varios if.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/001-Estructuras de selección/101-Ejercicios/004-varios if.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/001-Estructuras de selección/101-Ejercicios/006-anidacion.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/001-Estructuras de selección/101-Ejercicios/002-else.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/001-Estructuras de selección/101-Ejercicios/001-Condicional.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/001-Estructuras de selección/101-Ejercicios/007-Ejercicio en clase.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/001-Estructuras de selección/101-Ejercicios/005-particula elif.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/001-Estructuras de selección/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/003-Uso de estructuras de control/001-Estructuras de selección/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/003-Uso de estructuras de control/005-Aserciones/101-Ejercicios/004-combinacion.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/005-Aserciones/101-Ejercicios/002-el chivato salta.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/005-Aserciones/101-Ejercicios/001-chivato.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/005-Aserciones/101-Ejercicios/003-ejemplo no tan traumatico.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/005-Aserciones/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/003-Uso de estructuras de control/005-Aserciones/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/003-Uso de estructuras de control/003-Estructuras de salto/101-Ejercicios/funcionsuma.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/003-Estructuras de salto/101-Ejercicios/008-llamada a la funcion de suma.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/003-Estructuras de salto/101-Ejercicios/002-uso de la funcion.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/003-Estructuras de salto/101-Ejercicios/006-las funcione retornan.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/003-Estructuras de salto/101-Ejercicios/005-varios parametros.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/003-Estructuras de salto/101-Ejercicios/004-Llamada correcta.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/003-Estructuras de salto/101-Ejercicios/007-funcion de sumar.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/003-Estructuras de salto/101-Ejercicios/003-parametros.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/003-Estructuras de salto/101-Ejercicios/001-Funciones.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/003-Estructuras de salto/101-Ejercicios/__pycache__/funcionsuma.cpython-312.pyc
/var/www/html/programaciondam2526/003-Uso de estructuras de control/003-Estructuras de salto/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/003-Uso de estructuras de control/003-Estructuras de salto/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/003-Uso de estructuras de control/006-Prueba, depuración y documentación de la aplicación/101-Ejercicios/010-ejercicio propuesto.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/006-Prueba, depuración y documentación de la aplicación/101-Ejercicios/005-cadenas.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/006-Prueba, depuración y documentación de la aplicación/101-Ejercicios/008-documentacion de la funcion.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/006-Prueba, depuración y documentación de la aplicación/101-Ejercicios/003-nuevo fallo.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/006-Prueba, depuración y documentación de la aplicación/101-Ejercicios/002-mejora.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/006-Prueba, depuración y documentación de la aplicación/101-Ejercicios/006-mejoro cadenas.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/006-Prueba, depuración y documentación de la aplicación/101-Ejercicios/009-extraccion de funcion.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/006-Prueba, depuración y documentación de la aplicación/101-Ejercicios/004-nuevo fallo mas.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/006-Prueba, depuración y documentación de la aplicación/101-Ejercicios/001-funcion de division.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/006-Prueba, depuración y documentación de la aplicación/101-Ejercicios/011-tres en raya.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/006-Prueba, depuración y documentación de la aplicación/101-Ejercicios/funciondivision.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/006-Prueba, depuración y documentación de la aplicación/101-Ejercicios/007-depuracion.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/006-Prueba, depuración y documentación de la aplicación/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/003-Uso de estructuras de control/006-Prueba, depuración y documentación de la aplicación/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/003-Uso de estructuras de control/004-Control de excepciones/101-Ejercicios/002-error.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/004-Control de excepciones/101-Ejercicios/003-error con try except.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/004-Control de excepciones/101-Ejercicios/001-tryexcept.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/004-Control de excepciones/101-Ejercicios/004-pseudocodigo.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/004-Control de excepciones/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/003-Uso de estructuras de control/004-Control de excepciones/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/003-Uso de estructuras de control/007-Ejercicio/101-Ejercicios/001-ejercicio for.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/007-Ejercicio/101-Ejercicios/004-dragones.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/007-Ejercicio/101-Ejercicios/004-enunciado.md
/var/www/html/programaciondam2526/003-Uso de estructuras de control/007-Ejercicio/101-Ejercicios/005-magos.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/007-Ejercicio/101-Ejercicios/002-ejercicio escalones.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/007-Ejercicio/101-Ejercicios/003-subir escalones de dos en dos.py
/var/www/html/programaciondam2526/003-Uso de estructuras de control/007-Ejercicio/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/003-Uso de estructuras de control/007-Ejercicio/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/002-Utilización de objetos/000-Resumen.md
/var/www/html/programaciondam2526/002-Utilización de objetos/Criterios de evaluacion.md
/var/www/html/programaciondam2526/002-Utilización de objetos/006-Constructores/101-Ejercicios/000-Nota importante.md
/var/www/html/programaciondam2526/002-Utilización de objetos/006-Constructores/101-Ejercicios/007-propiedades de la fecha.py
/var/www/html/programaciondam2526/002-Utilización de objetos/006-Constructores/101-Ejercicios/006-fechas en python.py
/var/www/html/programaciondam2526/002-Utilización de objetos/006-Constructores/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/002-Utilización de objetos/006-Constructores/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/002-Utilización de objetos/007-Destrucción de objetos y liberación de memoria/101-Ejercicios/000-Nota importante.md
/var/www/html/programaciondam2526/002-Utilización de objetos/007-Destrucción de objetos y liberación de memoria/101-Ejercicios/011-entrada calculo y salida.py
/var/www/html/programaciondam2526/002-Utilización de objetos/007-Destrucción de objetos y liberación de memoria/101-Ejercicios/012-libreria matematica.py
/var/www/html/programaciondam2526/002-Utilización de objetos/007-Destrucción de objetos y liberación de memoria/101-Ejercicios/010-propiedades.py
/var/www/html/programaciondam2526/002-Utilización de objetos/007-Destrucción de objetos y liberación de memoria/101-Ejercicios/008-destruccion de objetos.py
/var/www/html/programaciondam2526/002-Utilización de objetos/007-Destrucción de objetos y liberación de memoria/101-Ejercicios/009-caballos en la cuadra.py
/var/www/html/programaciondam2526/002-Utilización de objetos/007-Destrucción de objetos y liberación de memoria/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/002-Utilización de objetos/007-Destrucción de objetos y liberación de memoria/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/002-Utilización de objetos/001-Características de los objetos/101-Ejercicios/000-Nota importante.md
/var/www/html/programaciondam2526/002-Utilización de objetos/001-Características de los objetos/101-Ejercicios/001-objeto math.py
/var/www/html/programaciondam2526/002-Utilización de objetos/001-Características de los objetos/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/002-Utilización de objetos/001-Características de los objetos/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/002-Utilización de objetos/003-Utilización de métodos. Parámetros/101-Ejercicios/000-Nota importante.md
/var/www/html/programaciondam2526/002-Utilización de objetos/003-Utilización de métodos. Parámetros/101-Ejercicios/003-llamada a metodos.py
/var/www/html/programaciondam2526/002-Utilización de objetos/003-Utilización de métodos. Parámetros/101-Ejercicios/004-sparse is better than dense.py
/var/www/html/programaciondam2526/002-Utilización de objetos/003-Utilización de métodos. Parámetros/101-Ejercicios/004-sparse.py
/var/www/html/programaciondam2526/002-Utilización de objetos/003-Utilización de métodos. Parámetros/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/002-Utilización de objetos/003-Utilización de métodos. Parámetros/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/002-Utilización de objetos/002-Instanciación de objetos/101-Ejercicios/000-Nota importante.md
/var/www/html/programaciondam2526/002-Utilización de objetos/002-Instanciación de objetos/101-Ejercicios/002-namespace.py
/var/www/html/programaciondam2526/002-Utilización de objetos/002-Instanciación de objetos/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/002-Utilización de objetos/002-Instanciación de objetos/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/002-Utilización de objetos/005-Utilización de métodos estáticos/101-Ejercicios/000-Nota importante.md
/var/www/html/programaciondam2526/002-Utilización de objetos/005-Utilización de métodos estáticos/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/002-Utilización de objetos/005-Utilización de métodos estáticos/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/002-Utilización de objetos/004-Utilización de propiedades/101-Ejercicios/000-Nota importante.md
/var/www/html/programaciondam2526/002-Utilización de objetos/004-Utilización de propiedades/101-Ejercicios/005-propiedades.py
/var/www/html/programaciondam2526/002-Utilización de objetos/004-Utilización de propiedades/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/002-Utilización de objetos/004-Utilización de propiedades/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/005-Lectura y escritura de información/000-Resumen.md
/var/www/html/programaciondam2526/005-Lectura y escritura de información/Criterios de evaluacion.md
/var/www/html/programaciondam2526/005-Lectura y escritura de información/Carpeta sin título/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/005-Lectura y escritura de información/004-Utilización de los sistemas de ficheros./101-Ejercicios/004-suma del tamaño.py
/var/www/html/programaciondam2526/005-Lectura y escritura de información/004-Utilización de los sistemas de ficheros./101-Ejercicios/007-condicion.py
/var/www/html/programaciondam2526/005-Lectura y escritura de información/004-Utilización de los sistemas de ficheros./101-Ejercicios/005-recorrer.py
/var/www/html/programaciondam2526/005-Lectura y escritura de información/004-Utilización de los sistemas de ficheros./101-Ejercicios/001-listar contenido de carpeta.py
/var/www/html/programaciondam2526/005-Lectura y escritura de información/004-Utilización de los sistemas de ficheros./101-Ejercicios/006-tamaño recursivo.py
/var/www/html/programaciondam2526/005-Lectura y escritura de información/004-Utilización de los sistemas de ficheros./101-Ejercicios/008-escribir en archivo el contenido de la carpeta.py
/var/www/html/programaciondam2526/005-Lectura y escritura de información/004-Utilización de los sistemas de ficheros./101-Ejercicios/003-formateo el resultado.py
/var/www/html/programaciondam2526/005-Lectura y escritura de información/004-Utilización de los sistemas de ficheros./101-Ejercicios/010-minibuscador.py
/var/www/html/programaciondam2526/005-Lectura y escritura de información/004-Utilización de los sistemas de ficheros./101-Ejercicios/009-sobreescribir cada vez.py
/var/www/html/programaciondam2526/005-Lectura y escritura de información/004-Utilización de los sistemas de ficheros./101-Ejercicios/mapa.txt
/var/www/html/programaciondam2526/005-Lectura y escritura de información/004-Utilización de los sistemas de ficheros./101-Ejercicios/011-busca en mapa.py
/var/www/html/programaciondam2526/005-Lectura y escritura de información/004-Utilización de los sistemas de ficheros./101-Ejercicios/002-atributos.py
/var/www/html/programaciondam2526/005-Lectura y escritura de información/009-Creación de controladores de eventos/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/005-Lectura y escritura de información/009-Creación de controladores de eventos/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/005-Lectura y escritura de información/007-Interfaces gráficas/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/005-Lectura y escritura de información/007-Interfaces gráficas/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/005-Lectura y escritura de información/005-Creación y eliminación de ficheros y directorios/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/005-Lectura y escritura de información/005-Creación y eliminación de ficheros y directorios/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/005-Lectura y escritura de información/006-Entrada desde teclado. Salida a pantalla. Formatos de visualización/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/005-Lectura y escritura de información/006-Entrada desde teclado. Salida a pantalla. Formatos de visualización/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/005-Lectura y escritura de información/003-Apertura y cierre de ficheros. Modos de acceso. Escritura y lectura de información en ficheros/101-Ejercicios/001-escribir.py
/var/www/html/programaciondam2526/005-Lectura y escritura de información/003-Apertura y cierre de ficheros. Modos de acceso. Escritura y lectura de información en ficheros/101-Ejercicios/007-pickle escribir.py
/var/www/html/programaciondam2526/005-Lectura y escritura de información/003-Apertura y cierre de ficheros. Modos de acceso. Escritura y lectura de información en ficheros/101-Ejercicios/010-guardo con pickle a binario.py
/var/www/html/programaciondam2526/005-Lectura y escritura de información/003-Apertura y cierre de ficheros. Modos de acceso. Escritura y lectura de información en ficheros/101-Ejercicios/009-crear cliente.py
/var/www/html/programaciondam2526/005-Lectura y escritura de información/003-Apertura y cierre de ficheros. Modos de acceso. Escritura y lectura de información en ficheros/101-Ejercicios/basededatos.txt
/var/www/html/programaciondam2526/005-Lectura y escritura de información/003-Apertura y cierre de ficheros. Modos de acceso. Escritura y lectura de información en ficheros/101-Ejercicios/002-apendizar.py
/var/www/html/programaciondam2526/005-Lectura y escritura de información/003-Apertura y cierre de ficheros. Modos de acceso. Escritura y lectura de información en ficheros/101-Ejercicios/011-recupero los datos.py
/var/www/html/programaciondam2526/005-Lectura y escritura de información/003-Apertura y cierre de ficheros. Modos de acceso. Escritura y lectura de información en ficheros/101-Ejercicios/datos.bin
/var/www/html/programaciondam2526/005-Lectura y escritura de información/003-Apertura y cierre de ficheros. Modos de acceso. Escritura y lectura de información en ficheros/101-Ejercicios/004-leer una linea.py
/var/www/html/programaciondam2526/005-Lectura y escritura de información/003-Apertura y cierre de ficheros. Modos de acceso. Escritura y lectura de información en ficheros/101-Ejercicios/005-leer varias lineas.py
/var/www/html/programaciondam2526/005-Lectura y escritura de información/003-Apertura y cierre de ficheros. Modos de acceso. Escritura y lectura de información en ficheros/101-Ejercicios/003-añadir salto de linea.py
/var/www/html/programaciondam2526/005-Lectura y escritura de información/003-Apertura y cierre de ficheros. Modos de acceso. Escritura y lectura de información en ficheros/101-Ejercicios/008-leer pickle.py
/var/www/html/programaciondam2526/005-Lectura y escritura de información/003-Apertura y cierre de ficheros. Modos de acceso. Escritura y lectura de información en ficheros/101-Ejercicios/clientes.bin
/var/www/html/programaciondam2526/005-Lectura y escritura de información/003-Apertura y cierre de ficheros. Modos de acceso. Escritura y lectura de información en ficheros/101-Ejercicios/006-recorrer la lista.py
/var/www/html/programaciondam2526/005-Lectura y escritura de información/003-Apertura y cierre de ficheros. Modos de acceso. Escritura y lectura de información en ficheros/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/005-Lectura y escritura de información/003-Apertura y cierre de ficheros. Modos de acceso. Escritura y lectura de información en ficheros/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/005-Lectura y escritura de información/001-Flujos. Tipos bytes y caracteres. Clases relacionadas/101-Ejercicios/003-creador agenda.py
/var/www/html/programaciondam2526/005-Lectura y escritura de información/001-Flujos. Tipos bytes y caracteres. Clases relacionadas/101-Ejercicios/clientes.txt
/var/www/html/programaciondam2526/005-Lectura y escritura de información/001-Flujos. Tipos bytes y caracteres. Clases relacionadas/101-Ejercicios/001-escribir texto a archivo.py
/var/www/html/programaciondam2526/005-Lectura y escritura de información/001-Flujos. Tipos bytes y caracteres. Clases relacionadas/101-Ejercicios/002-ahora leemos.py
/var/www/html/programaciondam2526/005-Lectura y escritura de información/001-Flujos. Tipos bytes y caracteres. Clases relacionadas/101-Ejercicios/agenda.txt
/var/www/html/programaciondam2526/005-Lectura y escritura de información/001-Flujos. Tipos bytes y caracteres. Clases relacionadas/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/005-Lectura y escritura de información/001-Flujos. Tipos bytes y caracteres. Clases relacionadas/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/005-Lectura y escritura de información/002-Ficheros de datos. Registros/101-Ejercicios/005-una pequeña decoracion.py
/var/www/html/programaciondam2526/005-Lectura y escritura de información/002-Ficheros de datos. Registros/101-Ejercicios/004-ahora accedemos a las parejas.py
/var/www/html/programaciondam2526/005-Lectura y escritura de información/002-Ficheros de datos. Registros/101-Ejercicios/007-secciones.html
/var/www/html/programaciondam2526/005-Lectura y escritura de información/002-Ficheros de datos. Registros/101-Ejercicios/003-leemos linea a linea.py
/var/www/html/programaciondam2526/005-Lectura y escritura de información/002-Ficheros de datos. Registros/101-Ejercicios/001-leer archivo.py
/var/www/html/programaciondam2526/005-Lectura y escritura de información/002-Ficheros de datos. Registros/101-Ejercicios/012-frankenstein.py
/var/www/html/programaciondam2526/005-Lectura y escritura de información/002-Ficheros de datos. Registros/101-Ejercicios/008-articulo.html
/var/www/html/programaciondam2526/005-Lectura y escritura de información/002-Ficheros de datos. Registros/101-Ejercicios/blog.txt
/var/www/html/programaciondam2526/005-Lectura y escritura de información/002-Ficheros de datos. Registros/101-Ejercicios/011-arranco flask.py
/var/www/html/programaciondam2526/005-Lectura y escritura de información/002-Ficheros de datos. Registros/101-Ejercicios/002-leer json.py
/var/www/html/programaciondam2526/005-Lectura y escritura de información/002-Ficheros de datos. Registros/101-Ejercicios/blog.json
/var/www/html/programaciondam2526/005-Lectura y escritura de información/002-Ficheros de datos. Registros/101-Ejercicios/006-blog.html
/var/www/html/programaciondam2526/005-Lectura y escritura de información/002-Ficheros de datos. Registros/101-Ejercicios/010-Instalar servidor.md
/var/www/html/programaciondam2526/005-Lectura y escritura de información/002-Ficheros de datos. Registros/101-Ejercicios/009-estilos minimos.html
/var/www/html/programaciondam2526/005-Lectura y escritura de información/002-Ficheros de datos. Registros/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/005-Lectura y escritura de información/002-Ficheros de datos. Registros/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/005-Lectura y escritura de información/008-Concepto de evento/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/005-Lectura y escritura de información/008-Concepto de evento/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/.git/ORIG_HEAD
/var/www/html/programaciondam2526/.git/COMMIT_EDITMSG
/var/www/html/programaciondam2526/.git/FETCH_HEAD
/var/www/html/programaciondam2526/.git/packed-refs
/var/www/html/programaciondam2526/.git/description
/var/www/html/programaciondam2526/.git/index
/var/www/html/programaciondam2526/.git/HEAD
/var/www/html/programaciondam2526/.git/config
/var/www/html/programaciondam2526/.git/logs/HEAD
/var/www/html/programaciondam2526/.git/logs/refs/remotes/origin/HEAD
/var/www/html/programaciondam2526/.git/logs/refs/remotes/origin/main
/var/www/html/programaciondam2526/.git/logs/refs/heads/main
/var/www/html/programaciondam2526/.git/refs/remotes/origin/HEAD
/var/www/html/programaciondam2526/.git/refs/remotes/origin/main
/var/www/html/programaciondam2526/.git/refs/heads/main
/var/www/html/programaciondam2526/.git/info/exclude
/var/www/html/programaciondam2526/.git/hooks/pre-push.sample
/var/www/html/programaciondam2526/.git/hooks/pre-rebase.sample
/var/www/html/programaciondam2526/.git/hooks/pre-receive.sample
/var/www/html/programaciondam2526/.git/hooks/fsmonitor-watchman.sample
/var/www/html/programaciondam2526/.git/hooks/applypatch-msg.sample
/var/www/html/programaciondam2526/.git/hooks/push-to-checkout.sample
/var/www/html/programaciondam2526/.git/hooks/pre-merge-commit.sample
/var/www/html/programaciondam2526/.git/hooks/sendemail-validate.sample
/var/www/html/programaciondam2526/.git/hooks/post-update.sample
/var/www/html/programaciondam2526/.git/hooks/update.sample
/var/www/html/programaciondam2526/.git/hooks/pre-applypatch.sample
/var/www/html/programaciondam2526/.git/hooks/commit-msg.sample
/var/www/html/programaciondam2526/.git/hooks/prepare-commit-msg.sample
/var/www/html/programaciondam2526/.git/hooks/pre-commit.sample
/var/www/html/programaciondam2526/.git/objects/2b/cb2f1852b538bc8ce87ffeeb1c1e77930cb7c4
/var/www/html/programaciondam2526/.git/objects/69/34a7c4892afae9f5212aed2c144b18f9beca0f
/var/www/html/programaciondam2526/.git/objects/69/4ed2381c1215672796b5d15d4480d4c62997f2
/var/www/html/programaciondam2526/.git/objects/ff/c0b1ff8dd1931f841e231fab1442f3e2257a81
/var/www/html/programaciondam2526/.git/objects/ff/4803bc071937e5e3d5217ca976d697dfc046b1
/var/www/html/programaciondam2526/.git/objects/ff/72907a8b1ac4d2fd537fc01ddad70af28b1990
/var/www/html/programaciondam2526/.git/objects/46/252db27ed7930199159a6548d72b127380db15
/var/www/html/programaciondam2526/.git/objects/37/bed996f76d60c3cb8ca593e901eb84baabcf82
/var/www/html/programaciondam2526/.git/objects/37/7c1aa390898102acfb1496202c1525105cd551
/var/www/html/programaciondam2526/.git/objects/52/0967073acc2dff82f3a22b92f751377a2c228a
/var/www/html/programaciondam2526/.git/objects/52/c165ab90f3ee9b2bde62d023952117e114f3d2
/var/www/html/programaciondam2526/.git/objects/52/223b0aa2a1ae702b5cdb432cf3cec6aa7a0692
/var/www/html/programaciondam2526/.git/objects/52/0583ba4dea480e8a361321a6acee35c6869f7a
/var/www/html/programaciondam2526/.git/objects/52/891b4caec2346a0439d6384eff5c58ee3e4ace
/var/www/html/programaciondam2526/.git/objects/52/e7f90036998ec15bc529fe5ea5a4b09cc0e415
/var/www/html/programaciondam2526/.git/objects/a6/4e00e82920414fe955f186e49ca3d939773a54
/var/www/html/programaciondam2526/.git/objects/a6/ba63e47bd069661a8e7d0c56a6fbd27228c78a
/var/www/html/programaciondam2526/.git/objects/70/069d71010d60916be60a51995a3fca04cc4776
/var/www/html/programaciondam2526/.git/objects/70/b47da25c70e85f9f4ec6226747706a057c3d43
/var/www/html/programaciondam2526/.git/objects/70/b60c9be33184c59742ebde759d916c308c7b96
/var/www/html/programaciondam2526/.git/objects/10/2f526da2f3ed423efe29d01e98bb330507d9ee
/var/www/html/programaciondam2526/.git/objects/63/991ba4c0b5de03d04edd5d8cb77608624c763f
/var/www/html/programaciondam2526/.git/objects/63/67129a1591fedf3ed27e4191e356d6cedf54d4
/var/www/html/programaciondam2526/.git/objects/2d/4e2c38b2a766a008eac3cb6580f5ef93f10ed2
/var/www/html/programaciondam2526/.git/objects/2d/1daa01f1c49d9b1f4083919aa8a6ab8f2d622a
/var/www/html/programaciondam2526/.git/objects/d2/93fc8960a2996eca2e8ffd6af58677d4c18681
/var/www/html/programaciondam2526/.git/objects/d2/fbc53d6da413345624ed1ab6cd34dc108b2e69
/var/www/html/programaciondam2526/.git/objects/d2/0742a97ba026afe6b49a8b5bafb14b038e7d7d
/var/www/html/programaciondam2526/.git/objects/c8/31721b5664539fc8f1eea91002defab4a854b3
/var/www/html/programaciondam2526/.git/objects/c8/a647434c3d156ac49f4d785f526ed41af88d76
/var/www/html/programaciondam2526/.git/objects/c8/300b84d709e9462874bb924b44fc3e36442174
/var/www/html/programaciondam2526/.git/objects/c8/31ea66527f6399342f70b9ed91d1592ba02f6e
/var/www/html/programaciondam2526/.git/objects/af/f248886548afda5ea34d4abf95771913b35710
/var/www/html/programaciondam2526/.git/objects/af/6353671fdd6c538df68bc9cdef98e7fd8ddb38
/var/www/html/programaciondam2526/.git/objects/f1/a40b1dd7a010554f43c208af4f53edadbac64a
/var/www/html/programaciondam2526/.git/objects/8b/0828e0c18a8cd1bfc0a4e98c6c75ae8154e4d2
/var/www/html/programaciondam2526/.git/objects/8b/137891791fe96927ad78e64b0aad7bded08bdc
/var/www/html/programaciondam2526/.git/objects/13/27e66641678d49f91e9150ca745610b87dd3a7
/var/www/html/programaciondam2526/.git/objects/13/a30f50d5938c9903c6f6de6c80b495aa3b1604
/var/www/html/programaciondam2526/.git/objects/2f/a6511f4ee6520f1a9a329a436532dd64dd81a2
/var/www/html/programaciondam2526/.git/objects/2f/dfb97eea4cd79c468a464b5d06675202790c71
/var/www/html/programaciondam2526/.git/objects/97/a5640f59796fafa4a346745a176b171581ff0f
/var/www/html/programaciondam2526/.git/objects/97/2eac3233bcbe983dcc0e03089f7eb7d0ee7614
/var/www/html/programaciondam2526/.git/objects/3f/06047a35ca80ed4ebca72c78687ea4e66c7c17
/var/www/html/programaciondam2526/.git/objects/3f/d279c859e98a94d02e990756c28acd8d0f0161
/var/www/html/programaciondam2526/.git/objects/3f/48de1308cfdee7032ebd2ad62dd8b758d43140
/var/www/html/programaciondam2526/.git/objects/3f/eccc336453782979f2c3a078ebd78054737c9a
/var/www/html/programaciondam2526/.git/objects/82/cdd216ae199a67246c6d6863e81a8983ac3aff
/var/www/html/programaciondam2526/.git/objects/82/7a5563d7cdb9447e8a36cacc6516abb1eb51b2
/var/www/html/programaciondam2526/.git/objects/82/1bc66e0704feff1fe0b552361d268faace9c67
/var/www/html/programaciondam2526/.git/objects/55/0376c979fdf75c228b9a8a160ff1d8b7beafd4
/var/www/html/programaciondam2526/.git/objects/55/24797cb6603ef3d2134248ae71c4555402c157
/var/www/html/programaciondam2526/.git/objects/55/d760010c5249850011e22e979b485f9bd69150
/var/www/html/programaciondam2526/.git/objects/ad/f39835bd4d2a4c647bdc0fe6063652233d51af
/var/www/html/programaciondam2526/.git/objects/ad/eb7de7f144aa128ea8713019fa83c6ba3ec087
/var/www/html/programaciondam2526/.git/objects/0e/4c54bc6ae99b69ba5605c980c5e55480950f12
/var/www/html/programaciondam2526/.git/objects/0e/072209bc55116c28faa1b0aa24413dbb500f02
/var/www/html/programaciondam2526/.git/objects/26/1d107cc316f90cc0f700964e235f21b3a6e04f
/var/www/html/programaciondam2526/.git/objects/26/10e939551aef74d9b0768fac402a2e0209107b
/var/www/html/programaciondam2526/.git/objects/26/f07baad39e14b757269aa71f9523022b35532f
/var/www/html/programaciondam2526/.git/objects/7a/35f8d326923e8012cd6f289a6a21e205826184
/var/www/html/programaciondam2526/.git/objects/c0/8b5e48c85f0d20fa91a4dfe181b2eae1501144
/var/www/html/programaciondam2526/.git/objects/ec/c4a33ce949c150c2cb227feed70199b746b3ac
/var/www/html/programaciondam2526/.git/objects/ec/11c56d5863cff7f1deeac283257b05a2370d08
/var/www/html/programaciondam2526/.git/objects/62/390b8577ee22284b1ed1d0b4431e7524d3d9ef
/var/www/html/programaciondam2526/.git/objects/62/cf1f2111cf03d9b7f52a4572c8e2383d63b460
/var/www/html/programaciondam2526/.git/objects/62/7f35de26524a979168415ff7b562cea2389fcb
/var/www/html/programaciondam2526/.git/objects/62/e321012dc2186b31b4f6e15d5106499abf8cf9
/var/www/html/programaciondam2526/.git/objects/62/023618b51fc484143ecce141d705b1a8b77e23
/var/www/html/programaciondam2526/.git/objects/62/3cc6b5cfd4d510c4f1e0e987fb498c8215fe9d
/var/www/html/programaciondam2526/.git/objects/e2/038bf8c8b27a3c7f47c622902f32e40af8d27d
/var/www/html/programaciondam2526/.git/objects/e2/94a060e8f7a21d851d13a3d93f5b2b8bcbd2fa
/var/www/html/programaciondam2526/.git/objects/e2/82a33bb19148a016dcef43e5ef88b708ad0c3f
/var/www/html/programaciondam2526/.git/objects/9d/4b0f8c07d989c62504c9f7b83a9e04bc6a024e
/var/www/html/programaciondam2526/.git/objects/9d/01c25023360f559fe9550cb8b54cf0e999f6bf
/var/www/html/programaciondam2526/.git/objects/9d/d95d74273ce86895c0c4dc0dfef1be4aa3832f
/var/www/html/programaciondam2526/.git/objects/9d/ada280de6bef83d7a41f8af45dd2ee8a029ad1
/var/www/html/programaciondam2526/.git/objects/9d/1e2569a9b800ad1b9dab0ad5226b90761c750f
/var/www/html/programaciondam2526/.git/objects/9d/c6ba7de0377317e3a314b5d48417ac59f3faba
/var/www/html/programaciondam2526/.git/objects/9d/d9146fd9e87acc1b0a8f85ce0e97c1943591b0
/var/www/html/programaciondam2526/.git/objects/9d/46f7146a8481a54df904ef3cb8ec9c68dd4e0e
/var/www/html/programaciondam2526/.git/objects/27/16d902b81913b69c846643a4ff62e30f7473e7
/var/www/html/programaciondam2526/.git/objects/ba/89f99b969304ad2fe0bbab17b4edc1872b2429
/var/www/html/programaciondam2526/.git/objects/ba/7332583e65c6f44fb37517d6295f2e919c8799
/var/www/html/programaciondam2526/.git/objects/5b/135bb7d9d54f1621226ae92116eb4160fad130
/var/www/html/programaciondam2526/.git/objects/5b/f9907bbed3cc24d211005c71d3e2e42a10bc41
/var/www/html/programaciondam2526/.git/objects/5b/0c13a6998891c1ac473e6761c6b87db79c4ce8
/var/www/html/programaciondam2526/.git/objects/5b/c794d697b7d3bdc7ef8dab61cd765ee9e8ac4f
/var/www/html/programaciondam2526/.git/objects/5b/9a7de1e2988381635adde952e5c18afca91353
/var/www/html/programaciondam2526/.git/objects/5b/c2701980f74a501de06b17fcc2cdcfad3e5610
/var/www/html/programaciondam2526/.git/objects/7f/2be6d6704bed987241d72255cfa23cb9ddfa98
/var/www/html/programaciondam2526/.git/objects/7f/14cc16bb6cd93d691d60dc797cde876e58023f
/var/www/html/programaciondam2526/.git/objects/7f/a4af2f7e396661d5102ef43b2373226f150644
/var/www/html/programaciondam2526/.git/objects/7f/742d809cc157bf10a75096e394af3ac9776522
/var/www/html/programaciondam2526/.git/objects/9e/59a6ffd7273a2391bd421bfb1cefe981635637
/var/www/html/programaciondam2526/.git/objects/9e/2555bca40caa8f42c7baf7f64a8233d2eca276
/var/www/html/programaciondam2526/.git/objects/ce/e00be67c99b555806a1ca49f6eb94fbd419922
/var/www/html/programaciondam2526/.git/objects/ce/281723546f15914ce27ae745628428f0f1c559
/var/www/html/programaciondam2526/.git/objects/ce/0e710b9cc4152b39f5f4efcffc91696c5d3b87
/var/www/html/programaciondam2526/.git/objects/ce/a63e860adefac9c3d7c977c0b889e3a85c53f9
/var/www/html/programaciondam2526/.git/objects/db/3c69565595e7b6e5fccc459079732cdf191ffa
/var/www/html/programaciondam2526/.git/objects/db/0fd3ead4d9935483cc7aed3a74ef10680875cb
/var/www/html/programaciondam2526/.git/objects/db/f5427a54dd0836248f738720ca1def0392d637
/var/www/html/programaciondam2526/.git/objects/bf/74192b4f0efbd2aed3fe23a67be325319bff2d
/var/www/html/programaciondam2526/.git/objects/50/2db0e9dd438bc2b93b52e0a3ed656f741e4d22
/var/www/html/programaciondam2526/.git/objects/50/0ab02fe4a8aebd7206fbcbe2959772dffd7bad
/var/www/html/programaciondam2526/.git/objects/9b/69d6d24be3f33834a2e9a4b9784d0d16e0e738
/var/www/html/programaciondam2526/.git/objects/9b/0d0b33f5f9f002630187e3fd4bd06e9ea5b4b3
/var/www/html/programaciondam2526/.git/objects/9b/d91eecc9413deb229c1b228d184de08a030513
/var/www/html/programaciondam2526/.git/objects/b1/1c0b4b6f66d8c84b269d5842a86131ff810f0f
/var/www/html/programaciondam2526/.git/objects/b1/72ea56a82614bf155fc0ea8c125d5e2e232c3e
/var/www/html/programaciondam2526/.git/objects/b1/235e16f45b4201456951b5ff6e1cec4d715ee9
/var/www/html/programaciondam2526/.git/objects/b1/9729dbe01f2be9069e4af26b65a1757707582f
/var/www/html/programaciondam2526/.git/objects/f9/405c7565a83cd8730bf5ed414b6b203e1ef822
/var/www/html/programaciondam2526/.git/objects/f9/1d64b849d68b7f5b0a5a922dbf1028605f33eb
/var/www/html/programaciondam2526/.git/objects/f9/b29a377da0adf4ad9f44ecd65427117bb6669e
/var/www/html/programaciondam2526/.git/objects/86/3196b96c0f735dc7ffd164259b6be3667c6749
/var/www/html/programaciondam2526/.git/objects/86/680d5ad56a82372a5585ea6d51cdf856b0f9cb
/var/www/html/programaciondam2526/.git/objects/cc/7401584a1266d2cd4f0e98c217b398281cf81a
/var/www/html/programaciondam2526/.git/objects/44/e1e488ca1f73add95c437ff1dcd5ccf88e9451
/var/www/html/programaciondam2526/.git/objects/73/974291e016b119b99abfe40930fc34ddb34945
/var/www/html/programaciondam2526/.git/objects/73/0db11edac01b886205c801530fff72deb5f013
/var/www/html/programaciondam2526/.git/objects/73/6b8f20af2132af8d437ddc9774d56b0aab2bcb
/var/www/html/programaciondam2526/.git/objects/96/d3ebc0d18da7f2474fba880a8914e45fe54a85
/var/www/html/programaciondam2526/.git/objects/77/8d67993d3bb8c5a847e13ac749f71e98d26cd0
/var/www/html/programaciondam2526/.git/objects/77/498ebae145774c2391468344fd774e1c6c8463
/var/www/html/programaciondam2526/.git/objects/77/5c96611985a297a7cf7c41f5f5a92c0ce6d257
/var/www/html/programaciondam2526/.git/objects/77/7f8b58aed584f2437279e9626f99ae9420bdf1
/var/www/html/programaciondam2526/.git/objects/77/4cd922f1c49ac67a4bef2faf21261ead834c5d
/var/www/html/programaciondam2526/.git/objects/92/a664c8cf7b94f19248ff11158fe2c72a6145bd
/var/www/html/programaciondam2526/.git/objects/92/30f125f66f964100de65fc465f7b136c5713b1
/var/www/html/programaciondam2526/.git/objects/92/397fecf8398b1272a14318f5f386ccd776fe8c
/var/www/html/programaciondam2526/.git/objects/92/fcbffd6b3ee8e730d56b0f3e43dfc2fb469db3
/var/www/html/programaciondam2526/.git/objects/5e/3a1a601fe402f03d226287ff3317dc2a28f0d6
/var/www/html/programaciondam2526/.git/objects/5e/4b38156d1eaa3b3c34c9ad87c480162277ccd4
/var/www/html/programaciondam2526/.git/objects/5e/2e37977051e7e4a87f2c23917b3c79bc93e7d6
/var/www/html/programaciondam2526/.git/objects/b9/98954ad5eb42d8d3150cbc3e645f5c4d027cc4
/var/www/html/programaciondam2526/.git/objects/b9/3e998dc5a636207a1f5f9d8e081606b2d95177
/var/www/html/programaciondam2526/.git/objects/b9/8def76a80ab4511483c74be9ca0fe6a8acc1ab
/var/www/html/programaciondam2526/.git/objects/79/7ab8a457485348f1120abdcdd7bfa1dbc1adac
/var/www/html/programaciondam2526/.git/objects/79/f020098a8d2e83d2c703a583a25a8c64ca8a92
/var/www/html/programaciondam2526/.git/objects/79/e565f0633a497b885627c8423c89635407daad
/var/www/html/programaciondam2526/.git/objects/79/ae4940ab0b6ba539da0902706ae4a9b3b3af3f
/var/www/html/programaciondam2526/.git/objects/08/ed63d62e778cd7d89c4599572a83aef151fe14
/var/www/html/programaciondam2526/.git/objects/08/ede852c1b9d4f2a81cbf9a7dd468f12041635b
/var/www/html/programaciondam2526/.git/objects/31/47ce5cf2b32cf1066890c9347a496008f65961
/var/www/html/programaciondam2526/.git/objects/43/6cfa85b55cbcbfaa9a21bdf428ab54f881cc6c
/var/www/html/programaciondam2526/.git/objects/43/96b8aae598f50bd32c8965cff3ed08791b1b2b
/var/www/html/programaciondam2526/.git/objects/43/71fce4835eea777353a9e6e4c1f39f3d8b86bd
/var/www/html/programaciondam2526/.git/objects/bc/eba012c0fcbdfb16f636ef7f9b334a56fba468
/var/www/html/programaciondam2526/.git/objects/88/edea8228181a3b0410c88ce8141945a5e7734e
/var/www/html/programaciondam2526/.git/objects/88/71b65e63fe4be89ce8015614b45cded54178d3
/var/www/html/programaciondam2526/.git/objects/88/a1411c6141c445193c5ef5c7ccc2e035d7630a
/var/www/html/programaciondam2526/.git/objects/0a/ffbaa002e6b411f1cf13c7c7d3a100331dee29
/var/www/html/programaciondam2526/.git/objects/61/d2a4a6bb107f2c0b07ebfcb6002584385ccbee
/var/www/html/programaciondam2526/.git/objects/61/87e97e609415bd8780493befdaf4801adc293f
/var/www/html/programaciondam2526/.git/objects/d6/01a1f1b9a145311639d44fb006a8b5f2e904cd
/var/www/html/programaciondam2526/.git/objects/d6/43a463687b37f45ec01bdbdef7be87c2200ecd
/var/www/html/programaciondam2526/.git/objects/d6/0bd7855aaae5d240010156d868479a62a0f85b
/var/www/html/programaciondam2526/.git/objects/9a/b703bda9940db8a19c7e95423ea31541e10fea
/var/www/html/programaciondam2526/.git/objects/30/0439b9cb70bbeb13a01ca5dd608ff9165bc135
/var/www/html/programaciondam2526/.git/objects/30/25e30dea9fe5aea6ebf65ec384fa53a2a8d32d
/var/www/html/programaciondam2526/.git/objects/30/c426c9df54def4319b0f87bd13f76eb0972963
/var/www/html/programaciondam2526/.git/objects/30/a44bda449dbc9cf593ebf993f69c089553b0f4
/var/www/html/programaciondam2526/.git/objects/30/b93340deaf90970aa3799431160b7e18fb0459
/var/www/html/programaciondam2526/.git/objects/30/3bfe4e948e17e15cf28f458d821b0cf6548e72
/var/www/html/programaciondam2526/.git/objects/d5/e1bf0f3f4bf7bbba3874a3cb4cd18d4a7bcbdb
/var/www/html/programaciondam2526/.git/objects/d5/ad494001b8acc5d9c1561d24a092818355fc96
/var/www/html/programaciondam2526/.git/objects/d5/0880bba8203a309929fb2dc27991ab04be2d04
/var/www/html/programaciondam2526/.git/objects/d5/ed7bc232a31fa8dde8f8ce60bf00f864e43980
/var/www/html/programaciondam2526/.git/objects/b8/9bfbd239c90e59459d40f1881302d68cc2d496
/var/www/html/programaciondam2526/.git/objects/b8/11abc46553871553d1c308c4ab14910e1cc21d
/var/www/html/programaciondam2526/.git/objects/8d/19f776796d2fea36a3067f3c3cbd8980063cdb
/var/www/html/programaciondam2526/.git/objects/b7/0883045a00a6036c29a0562b93444df76806b4
/var/www/html/programaciondam2526/.git/objects/b7/ebd856517564baa47608a1c9b575fdfd155ae3
/var/www/html/programaciondam2526/.git/objects/b7/f11f34597aa0b0b13e97215d640449191cbc37
/var/www/html/programaciondam2526/.git/objects/b7/80a4df6297c90af5a1bf2614356dc4ca65e302
/var/www/html/programaciondam2526/.git/objects/83/d63bf32663fb7de6e014ae8de04cfd01cd4ee8
/var/www/html/programaciondam2526/.git/objects/bd/5d82786104fee2a3c4a488b57e8173eeddc3b5
/var/www/html/programaciondam2526/.git/objects/bd/15753a6d2e973c2c015c2556031ee8e746647e
/var/www/html/programaciondam2526/.git/objects/65/f9bf06eff504317a9c0ba578221d4b148024aa
/var/www/html/programaciondam2526/.git/objects/65/ae2c00fe81d673b8eac8f9fbee28a234bd7fd7
/var/www/html/programaciondam2526/.git/objects/65/34db183be09a6dbcd950358f6360da1098a38b
/var/www/html/programaciondam2526/.git/objects/65/c14fa15a377473e442d12eb3aabbb77bd06c82
/var/www/html/programaciondam2526/.git/objects/17/d101bfb07d0ef06e1d0f1d9cc1be0da02e59de
/var/www/html/programaciondam2526/.git/objects/17/c719591f89af9b903c4f11588efe015e5ae5fc
/var/www/html/programaciondam2526/.git/objects/17/66fe8ec6206b2928f26557eabaa6eac867aa90
/var/www/html/programaciondam2526/.git/objects/17/85496a3eb6e0e7ec8838886933edea83fed641
/var/www/html/programaciondam2526/.git/objects/29/a1578b6278d3678e7182eaad9332208fefd74d
/var/www/html/programaciondam2526/.git/objects/29/685712da8b4225a414a61145c4386a242a6dc8
/var/www/html/programaciondam2526/.git/objects/29/9c7cb53f89ecc4c97db6add5ab5aa99a44ab7c
/var/www/html/programaciondam2526/.git/objects/b3/c8abf391ae2d257e04b472189c1ecc03b10c1a
/var/www/html/programaciondam2526/.git/objects/e4/1e3f248d5cb7eebf1cb2e66dd6826350472b1f
/var/www/html/programaciondam2526/.git/objects/f3/b27c2e2768ee3d32863358f1a9afe143315645
/var/www/html/programaciondam2526/.git/objects/f3/4c46f042e834ec7c4cfdf70befbdb5711ec077
/var/www/html/programaciondam2526/.git/objects/8a/b6924f1f128b424f067f66539c3ca59780291e
/var/www/html/programaciondam2526/.git/objects/e3/0d8e21e41040a0b7209ee9c2bd18f39623e04f
/var/www/html/programaciondam2526/.git/objects/e3/a51edf5d66b5273d06dd21686610feafd0dc34
/var/www/html/programaciondam2526/.git/objects/e3/2e947037d6ba0fef39b54735a1e991ca8e76cd
/var/www/html/programaciondam2526/.git/objects/75/ab4babb0554d12361e5c89935ad21d91c63e35
/var/www/html/programaciondam2526/.git/objects/75/7f58361f110d526754fdc50ee81d1abfb06233
/var/www/html/programaciondam2526/.git/objects/75/8c358c9ab2fe036d16cc0126a016625e45ed50
/var/www/html/programaciondam2526/.git/objects/0d/95ebcef09b03a164adb0a5fe0dcbdc943c4249
/var/www/html/programaciondam2526/.git/objects/0d/3a61c1580e8b3b72d4f9c8677932fb8ced50f4
/var/www/html/programaciondam2526/.git/objects/f2/05eb323014470b8fd10179d816020f549c8d0c
/var/www/html/programaciondam2526/.git/objects/f2/b95612f43c365d03e3a3f7e10d27c08fad0814
/var/www/html/programaciondam2526/.git/objects/f2/4f78b1eeea7c0e7128effaea62b439292fe5e5
/var/www/html/programaciondam2526/.git/objects/f2/d44c4b75b45749ff626e07f52897504454e6c3
/var/www/html/programaciondam2526/.git/objects/f2/43c302d0d8cb3a930a77ae3a242062680fc097
/var/www/html/programaciondam2526/.git/objects/54/121e9f00c1baaa86cf982a7c0709669bc4a28f
/var/www/html/programaciondam2526/.git/objects/54/a4d05d0e13a1f68ed4cae7ebb6567ebe73eead
/var/www/html/programaciondam2526/.git/objects/54/210adb9999a3cd93adfb7d2b72381eb9acbb76
/var/www/html/programaciondam2526/.git/objects/48/61bc9e5d8114ee073487d9998e41f215ef64a0
/var/www/html/programaciondam2526/.git/objects/48/7dc094fa20193f5855d116c2f92b0ef4939a24
/var/www/html/programaciondam2526/.git/objects/48/e4f3c778ed93728a4fc9511f101f1452c99370
/var/www/html/programaciondam2526/.git/objects/48/757cdd567076e63fefe953f22aaefbb95f87b7
/var/www/html/programaciondam2526/.git/objects/48/a8ac132397574df217ac9a53d4f822543fc4fb
/var/www/html/programaciondam2526/.git/objects/48/4e6dae47121b946079644264fe6b06f2c29470
/var/www/html/programaciondam2526/.git/objects/d7/18f1f14426c720fce206b20343f1fd579289fb
/var/www/html/programaciondam2526/.git/objects/b2/c438705de0ec23072d79cddf64c154a7ca35c6
/var/www/html/programaciondam2526/.git/objects/b2/aa0aa7ff77c8cbd7107b01513bc57639b0c213
/var/www/html/programaciondam2526/.git/objects/ee/586e1c8a606cb746ac2c97023bdc4ab1ebdf90
/var/www/html/programaciondam2526/.git/objects/ee/b3d009efa72e7095f8e43012531010026a88e1
/var/www/html/programaciondam2526/.git/objects/ee/f19b14282f82323ab8f2f448e9e1ce85058703
/var/www/html/programaciondam2526/.git/objects/ee/dbf1122a917d00c765e47705b3a0da336adf38
/var/www/html/programaciondam2526/.git/objects/ee/b74d4fb999d934778b3442decd52f3f64db027
/var/www/html/programaciondam2526/.git/objects/38/3c40e6d68922508e3f1fa32bca6dbd1823c878
/var/www/html/programaciondam2526/.git/objects/38/b1f0a80f2f26c148b24fd0814cbae387a657c1
/var/www/html/programaciondam2526/.git/objects/38/476315d589175a8edcf80c1d9dc1068e461c3b
/var/www/html/programaciondam2526/.git/objects/38/c9f3b0b23a9d0f0be234a030efdd5941e3e50b
/var/www/html/programaciondam2526/.git/objects/38/66f3c163ad0dcf5bda280cd19b9372969267f7
/var/www/html/programaciondam2526/.git/objects/64/25868eef55de20bf6a70ca4e3b66fb7783a376
/var/www/html/programaciondam2526/.git/objects/64/c7ffe75cd4f5b772ef5d59362088792bb5e8c6
/var/www/html/programaciondam2526/.git/objects/64/a7e13ccada46e6e393a93c5c744e918110e6f2
/var/www/html/programaciondam2526/.git/objects/de/d4a26d20a4ec6b0faa541d0fcfd61326da552a
/var/www/html/programaciondam2526/.git/objects/0f/bfedfa8089a68f108dc244becff82c396dfa10
/var/www/html/programaciondam2526/.git/objects/0f/ef011b8ad3e482acb2223497191f40a15a5834
/var/www/html/programaciondam2526/.git/objects/0f/37587171eb870c1c570c61b79eeafa942900a8
/var/www/html/programaciondam2526/.git/objects/fd/5b47aa9eec6405cc7250f190012d161abb8c09
/var/www/html/programaciondam2526/.git/objects/fd/b31d1cf66bef7bb9f64ad5586f28e09ca53b2b
/var/www/html/programaciondam2526/.git/objects/09/dd7a1f6bb9a6c7c1455fc497014d6e3de10c66
/var/www/html/programaciondam2526/.git/objects/09/dc3405d4683b2f25a6ef5b9d9f1080d11ee046
/var/www/html/programaciondam2526/.git/objects/09/23169f80c4030115c1a66134148d919753f8e8
/var/www/html/programaciondam2526/.git/objects/dd/db6533d48388ee00649120900fea43abfab62a
/var/www/html/programaciondam2526/.git/objects/dd/a603b80bcc780cc251958afa54a8110ad33ba2
/var/www/html/programaciondam2526/.git/objects/dd/c45bc8b211fc933ab0202e7b9bc746d0eabfd8
/var/www/html/programaciondam2526/.git/objects/5a/dd0d1bb570dd98a714af4353225d33028a311b
/var/www/html/programaciondam2526/.git/objects/5a/8c31b35e88d0c21c3213cc12700e633acf537c
/var/www/html/programaciondam2526/.git/objects/03/45a2434702378e4c3d86fd48d8644cf884e450
/var/www/html/programaciondam2526/.git/objects/53/90895e7735c5e91b710d4cb80d7eeb970c10f4
/var/www/html/programaciondam2526/.git/objects/53/9e3dbf84340be05687442ce51b8fdc155f43ca
/var/www/html/programaciondam2526/.git/objects/02/3b5d66b0162d8b2947989553ee4a21f5b80013
/var/www/html/programaciondam2526/.git/objects/45/1cf007d89a562d828de1ab71c8b03e0c813d60
/var/www/html/programaciondam2526/.git/objects/45/64842856c63058029a4dcf99a465bc1acb83f3
/var/www/html/programaciondam2526/.git/objects/45/5c25527acb9a9129d8e0dc84e0d6e2ac54cdcf
/var/www/html/programaciondam2526/.git/objects/45/42ccba22ab6a6d73f51f2604e8c8aafbaccb62
/var/www/html/programaciondam2526/.git/objects/45/811145b200ab08508922335578e1664c850c61
/var/www/html/programaciondam2526/.git/objects/91/1433b44037404be4e3918fca0163a41070a4fe
/var/www/html/programaciondam2526/.git/objects/91/d209c7da06ab25f11320b800adb3b45cd0beb1
/var/www/html/programaciondam2526/.git/objects/87/0a6da161e2d598ac653ea20b8578f2f8597bc9
/var/www/html/programaciondam2526/.git/objects/fa/1f0f15658310877063d67c51bf4df6a22cbb57
/var/www/html/programaciondam2526/.git/objects/3c/1c39e49de27b86736f405c6957ee3dd9cfdd5e
/var/www/html/programaciondam2526/.git/objects/3c/28b8e295e08924aef8cbfd2b2b403a127991b8
/var/www/html/programaciondam2526/.git/objects/3c/ea5b84a2adeb13b77600766e763007e626a41b
/var/www/html/programaciondam2526/.git/objects/a2/c0faf57f1a8881a085aeabfc72c4f0047abc5b
/var/www/html/programaciondam2526/.git/objects/a2/e8365ce5788e3be23bf2164a7134721acc21e7
/var/www/html/programaciondam2526/.git/objects/a2/fe959017436ff0bc880f2c2706b626a5369b96
/var/www/html/programaciondam2526/.git/objects/a2/d9a3814c6c1b753047e4e68e341a31bcdcc069
/var/www/html/programaciondam2526/.git/objects/19/649f3d813c90c24986378e9fa9a9dad70190aa
/var/www/html/programaciondam2526/.git/objects/19/f647e31651e7848782356d76d21dc50713f952
/var/www/html/programaciondam2526/.git/objects/19/6dd1121301c24cbb4ed1484c3a276822f4d6d7
/var/www/html/programaciondam2526/.git/objects/19/b34366a32f3a69029e29af706748985e66a841
/var/www/html/programaciondam2526/.git/objects/19/d2d80b89ff5bbd35a8ea9a26f64d4da38ec9a2
/var/www/html/programaciondam2526/.git/objects/19/f4895aba14ca2c85ce7f1fcf7d3c1c60ba2659
/var/www/html/programaciondam2526/.git/objects/4a/e5181893d095ddf054be12e3f4311e9eb1f750
/var/www/html/programaciondam2526/.git/objects/4a/a2ea3d9cae831fb0084996cd8d8ebfb4803515
/var/www/html/programaciondam2526/.git/objects/4a/e2249b69cca655a575f79c7c1a3a458861d845
/var/www/html/programaciondam2526/.git/objects/41/addfa843c81549fd9ba6f04a0a2eaed3d8aa0e
/var/www/html/programaciondam2526/.git/objects/41/fa6282db7eebc94bfc9c5ecb72b2a3cd7a0c4e
/var/www/html/programaciondam2526/.git/objects/42/67b6071a276ca3cbf1c486bc20f0cae54445c5
/var/www/html/programaciondam2526/.git/objects/42/d0b0450e6a2406433751a72e1a9399464a36c0
/var/www/html/programaciondam2526/.git/objects/42/912ccde4361c76cead9a503e30bb9636a18a3e
/var/www/html/programaciondam2526/.git/objects/f8/ca83f62e7b5815ed67258cdced033c03a5fd76
/var/www/html/programaciondam2526/.git/objects/f8/2c5158df0aff9e5f200ddda23723e3ce9d59ec
/var/www/html/programaciondam2526/.git/objects/f8/ac85c9b203696e14cf7fa8044f0049e2f33b48
/var/www/html/programaciondam2526/.git/objects/8f/eaee63b3e7d712f3da62814f8702eb607fc83f
/var/www/html/programaciondam2526/.git/objects/8f/25fef1913937ec663903aa17334c2ece6eb74b
/var/www/html/programaciondam2526/.git/objects/04/2adb8e49490d2ee0ed622a92a469833804d9d0
/var/www/html/programaciondam2526/.git/objects/04/d87877b5a369c14bab8750b9a71e1658d01466
/var/www/html/programaciondam2526/.git/objects/da/d0077e9a4c18c78c03bde2ab8526a0b01f1d18
/var/www/html/programaciondam2526/.git/objects/da/9119fe169eefa2c1ec378b2e77a5854ec5464e
/var/www/html/programaciondam2526/.git/objects/95/8f2dcda50443fd718894b6bc7a0c650a2c8fcf
/var/www/html/programaciondam2526/.git/objects/95/661de9345c7b2e23f804f84ef86b4254abe69b
/var/www/html/programaciondam2526/.git/objects/95/8f25d38ebb09de20a632b257288d2c6092e46f
/var/www/html/programaciondam2526/.git/objects/7d/2339cc0f5c9cb7e1fa191b1b8d46a2915d03e3
/var/www/html/programaciondam2526/.git/objects/ca/41ad75a41a47bae52e702e14d8aaec2b41c264
/var/www/html/programaciondam2526/.git/objects/ca/e622c8ecd7f3787744bf6685897516001cb416
/var/www/html/programaciondam2526/.git/objects/ca/00f0137c95a4a857885b8a7644fa8264f45291
/var/www/html/programaciondam2526/.git/objects/ca/bf950be28f889d53b0d1d450c7228210cc8089
/var/www/html/programaciondam2526/.git/objects/pack/pack-274984f77d51a2155b5a472cdf2f0a7d4f2672d1.pack
/var/www/html/programaciondam2526/.git/objects/pack/pack-274984f77d51a2155b5a472cdf2f0a7d4f2672d1.rev
/var/www/html/programaciondam2526/.git/objects/pack/pack-274984f77d51a2155b5a472cdf2f0a7d4f2672d1.idx
/var/www/html/programaciondam2526/.git/objects/20/06f7f3cbdb7b2e0e66bbab41c179430b867660
/var/www/html/programaciondam2526/.git/objects/a8/984628a1371a04f3993cc3febeab1931aa93fd
/var/www/html/programaciondam2526/.git/objects/a8/6902b4389e367b226c7d8ccc291a9ba7ed7b7f
/var/www/html/programaciondam2526/.git/objects/a8/5e772e9fb84795507c4e1e86fdf925541438b8
/var/www/html/programaciondam2526/.git/objects/76/6b90626bd957ffdca005f7a4d51f3a19d17f71
/var/www/html/programaciondam2526/.git/objects/76/c45cf132d78cb3b65457ad4d287e85effa4e6f
/var/www/html/programaciondam2526/.git/objects/c3/278606b754157f866b523c2ffdddca73e9ff1f
/var/www/html/programaciondam2526/.git/objects/c3/f59da46e7aa0b9531c7f7db9fe76488817cef3
/var/www/html/programaciondam2526/.git/objects/c3/7e1b7d448aec128569d554ae62305b4129df58
/var/www/html/programaciondam2526/.git/objects/39/a6655ecb01d5b48994504ac6d26b0f5ab0a6d1
/var/www/html/programaciondam2526/.git/objects/11/93de59eca611f220e0ea53563e24271915f51c
/var/www/html/programaciondam2526/.git/objects/11/c89f8b7f0448b63b52ba5caebb2ce01717cb05
/var/www/html/programaciondam2526/.git/objects/11/865b58f8b856b89f289537a1eccbdd2e4fc2b9
/var/www/html/programaciondam2526/.git/objects/11/e1e6d05923a91d2a2bf7d3e0f415975e2cdc05
/var/www/html/programaciondam2526/.git/objects/ae/0f8672a305d2850d6a3d44f830495ec745c816
/var/www/html/programaciondam2526/.git/objects/84/5ee88aab2a531159401db8f81c8b7585fae3c3
/var/www/html/programaciondam2526/.git/objects/84/616cbe1c6e8d9d2efe5aee8ec5768fa5852cb1
/var/www/html/programaciondam2526/.git/objects/84/f1f73330bce92ffdf11ab71c4d0ed82a0e2e67
/var/www/html/programaciondam2526/.git/objects/a9/64cf0aec0248c781ef4509e64e685d0fb01033
/var/www/html/programaciondam2526/.git/objects/a9/36fb391c37ea2ae7ac32ef0155e121038995a5
/var/www/html/programaciondam2526/.git/objects/e0/11fb4b931079449782bb120dae83a577d01ddf
/var/www/html/programaciondam2526/.git/objects/e0/8ac68bab2a2ed0b116c5f1b113aa8d5ddf96b7
/var/www/html/programaciondam2526/.git/objects/e0/b4ebccd5984ddc56cce87aabc3db5fd2235726
/var/www/html/programaciondam2526/.git/objects/56/57237f217586911e5639f0ff1bfc6786ae33ea
/var/www/html/programaciondam2526/.git/objects/aa/c215911d3c157ae2cedba20c61ed9941b36f4b
/var/www/html/programaciondam2526/.git/objects/aa/7509de6fccd30c2cb814f9d7a27b48b4e13507
/var/www/html/programaciondam2526/.git/objects/d4/65b192c6bbe600e8ac788243e7b894f8b04965
/var/www/html/programaciondam2526/.git/objects/1a/3f694bc563d1e222d45a4ea2f3cfb71cbe327e
/var/www/html/programaciondam2526/.git/objects/1a/7b6fadb7293ce7043f007520448c9fa692a4d2
/var/www/html/programaciondam2526/.git/objects/b0/bdfe1951c22a441321fad68a2a0dc24a35afc6
/var/www/html/programaciondam2526/.git/objects/cf/a5a1790cefd824950d63229ac74b397fa6f0bf
/var/www/html/programaciondam2526/.git/objects/cf/da7b9f6f2a5d4ee6cd45ed6b03af77ea28881b
/var/www/html/programaciondam2526/.git/objects/cf/b36bc0c61ecf8b6415468e98780d5719656618
/var/www/html/programaciondam2526/.git/objects/8e/b40ccb87b839428f51e3de693b37dca7568b3e
/var/www/html/programaciondam2526/.git/objects/8e/ae24056c73515701dcdbb50bf85b3777e5df80
/var/www/html/programaciondam2526/.git/objects/e9/34027d11a4a5cab7b3863a269b12771fbc29bf
/var/www/html/programaciondam2526/.git/objects/e9/4aba73b09129093091a3f839569e47fe9eaeed
/var/www/html/programaciondam2526/.git/objects/e9/54a9453b1d6b24a681230202bdaa31e876082c
/var/www/html/programaciondam2526/.git/objects/18/ed742e6850c9434e9232f7f22844ecf4e91041
/var/www/html/programaciondam2526/.git/objects/4e/f1feb08c5bdb1ff45e674ceb5e8d470fd8ac1c
/var/www/html/programaciondam2526/.git/objects/4e/21e26411f7ef495a86d6c6de731f37bba36579
/var/www/html/programaciondam2526/.git/objects/4e/8fad9dfe00e8a3c2bbd4b6a7b065a5ba66d5e8
/var/www/html/programaciondam2526/.git/objects/4e/91c6ca49b51505a982a7b70d07ad1dad938e3c
/var/www/html/programaciondam2526/.git/objects/5c/e8caf6b8aa8f2e81611e2288a15fdd8dd02116
/var/www/html/programaciondam2526/.git/objects/5c/911630fd365075ac3d94247dc2efac66d3dc1e
/var/www/html/programaciondam2526/.git/objects/5c/2ef8a70d1e6d6a010e84fef13eac609744194a
/var/www/html/programaciondam2526/.git/objects/47/4347702b0844c2506efb2b0189fb92a500b04e
/var/www/html/programaciondam2526/.git/objects/34/71f70e0ba98befe5d918d28ac0293c8328d5f6
/var/www/html/programaciondam2526/.git/objects/34/ae0a783ab128b833d2c4749c3e3cff3eff92bb
/var/www/html/programaciondam2526/.git/objects/34/46fbac7db381bbc8c84d942d9bcbda2d17b07e
/var/www/html/programaciondam2526/.git/objects/3a/26c602b2cd9b1e0b7959d314f1ecb03e33b73d
/var/www/html/programaciondam2526/.git/objects/3a/ab3f79d1854a873991ab9030de0a2756459586
/var/www/html/programaciondam2526/.git/objects/3a/7a7218cf3046821f0ad83a427c106b600cb312
/var/www/html/programaciondam2526/.git/objects/c7/eef26d3654cf73d4e9ffaf5501025320045403
/var/www/html/programaciondam2526/.git/objects/c7/bd05fbb730a2eed69c2c8687f1bfb288c32057
/var/www/html/programaciondam2526/.git/objects/93/b4ccbf25bed23eb63f7a6be144c2f6ff444f7e
/var/www/html/programaciondam2526/.git/objects/93/2236b2eb4e2d6b725dee7a8f39e5d22854dbd0
/var/www/html/programaciondam2526/.git/objects/93/837d67872df816883a4cd32c30fc3c8797fd41
/var/www/html/programaciondam2526/.git/objects/93/aab3fe5b6bf41ee3711e65c3ff19a7c396ea1a
/var/www/html/programaciondam2526/.git/objects/93/f6f1498ad5d505eb80d3be4362ed2812c44351
/var/www/html/programaciondam2526/.git/objects/74/fa52b3974157b3870071f44e1438c823dbe744
/var/www/html/programaciondam2526/.git/objects/74/8af43b1d31768abcccb9205696b2043e5acadb
/var/www/html/programaciondam2526/.git/objects/66/4212ba14894242e9e9911f5f70a79a7b7033b8
/var/www/html/programaciondam2526/.git/objects/66/664024f3686b6597d3cfc8edb015a8ca1358b9
/var/www/html/programaciondam2526/.git/objects/5d/6c05b55824d8b6476c82d806a72d039e483fc3
/var/www/html/programaciondam2526/.git/objects/5d/6e30c668c8065c12453a572a48b93b0bd24ff6
/var/www/html/programaciondam2526/.git/objects/3d/f355713fce1ea9794a28ab51edefc1874f5a5d
/var/www/html/programaciondam2526/.git/objects/3d/2df20637468c43046735cc8ac565e5a53c3e44
/var/www/html/programaciondam2526/.git/objects/3d/8636c09d959fc4808569b03932a939b414498b
/var/www/html/programaciondam2526/.git/objects/36/6107c19814005755ba2855e7dc017a2798d33a
/var/www/html/programaciondam2526/.git/objects/36/4cb80082e3ef71a0ce8921f2914adb19d33258
/var/www/html/programaciondam2526/.git/objects/a7/c97167f36129cbc929189dd3dc45ee5a5e11b9
/var/www/html/programaciondam2526/.git/objects/2e/91f09ea85141190b201b364f755c070f00ac09
/var/www/html/programaciondam2526/.git/objects/1c/fb926de4ae307fe44fdf9cc9d77f14d692400a
/var/www/html/programaciondam2526/.git/objects/1c/e9f1acf5264d23b17e325f941679970289bb84
/var/www/html/programaciondam2526/.git/objects/80/e600e42241c16f74375a01aa40870dff18b396
/var/www/html/programaciondam2526/.git/objects/80/96e341d04b03483bc4fac02f36a75b0ec26e9d
/var/www/html/programaciondam2526/.git/objects/80/c89d3f6b6e374765c44f88dde057062b6ffa80
/var/www/html/programaciondam2526/.git/objects/80/ed99cc363c64540600632ce7dd8fb29c58fb44
/var/www/html/programaciondam2526/.git/objects/80/d6d325d69cf37dc629a229f28e6b3b8845b085
/var/www/html/programaciondam2526/.git/objects/85/e54c434ffcaee73b8659b02e52e227fd08911d
/var/www/html/programaciondam2526/.git/objects/85/e9f58fb67c8d72ab69a8129a298be1b4ff43db
/var/www/html/programaciondam2526/.git/objects/85/61ed7711223538dc8cc5425e9c5f4d1d875a21
/var/www/html/programaciondam2526/.git/objects/d3/03e2a574601db9fda6d8b068878126e69fa183
/var/www/html/programaciondam2526/.git/objects/d3/23e667070aff6f4561bf51066bf36c4c33c075
/var/www/html/programaciondam2526/.git/objects/4d/4d7102b88d10a9d57b68e31a40c2ffd0786506
/var/www/html/programaciondam2526/.git/objects/4d/84c60c2e1868c84288c0ae90859ea56784c346
/var/www/html/programaciondam2526/.git/objects/4d/7f237c9f731988bfed94141b9ecd02bcb443f2
/var/www/html/programaciondam2526/.git/objects/49/fd59645f3120ffdaf29c0f6b4a20d790281379
/var/www/html/programaciondam2526/.git/objects/df/535878552e9ee5d311272801d4198df077d28d
/var/www/html/programaciondam2526/.git/objects/df/8e78cd8b7bb5de55ec2f7cf27999263f7d8577
/var/www/html/programaciondam2526/.git/objects/df/183998b16b5c1641d9c4017a9a648fdd1e3606
/var/www/html/programaciondam2526/.git/objects/eb/4db2ba9ffefd6c0f5c124bc8e1a746357ca7ba
/var/www/html/programaciondam2526/.git/objects/eb/ea7c97d421ef5c78115aaa800e6254cf2e2914
/var/www/html/programaciondam2526/.git/objects/72/5d2eb6f538494e99b1f15e32bc82e908371ade
/var/www/html/programaciondam2526/.git/objects/72/c8bc998da5f70188fb0773fb74b80f890339a6
/var/www/html/programaciondam2526/.git/objects/72/d4d0634ccff3a9f89960940972841bf055e897
/var/www/html/programaciondam2526/.git/objects/72/0fca0a228ae43396bc84b734e16b1346128735
/var/www/html/programaciondam2526/.git/objects/72/c44ad8272610141e3226ce7975679e13758be6
/var/www/html/programaciondam2526/.git/objects/40/5a8c4a9fc6c2a6d7b4d96fad38017eef392b6f
/var/www/html/programaciondam2526/.git/objects/7e/e49fe0c83d13ff9ccc7e8900de04978e9fc3a5
/var/www/html/programaciondam2526/.git/objects/7e/f8bd44a7295d5b7e613a0da2f3e9bedcc9805a
/var/www/html/programaciondam2526/.git/objects/7e/b025c954bc5efd7094962912504ceb45041941
/var/www/html/programaciondam2526/.git/objects/7e/fc1950b9fa671d7fb759f8de81051bba5b2e0a
/var/www/html/programaciondam2526/.git/objects/f4/1e9fac32111f87f8db69b4cfcd30187d27b6fb
/var/www/html/programaciondam2526/.git/objects/f4/32a2f3f8bb30519bb88a97e4a396e48d5a2361
/var/www/html/programaciondam2526/.git/objects/ac/40adeb97a623de893d526c02f46633500fe7e4
/var/www/html/programaciondam2526/.git/objects/ac/324352877661b373286b5414771ddbb72eb0cf
/var/www/html/programaciondam2526/.git/objects/a1/0d9fd18745396681629ce671aafb9b61ff5cce
/var/www/html/programaciondam2526/.git/objects/a1/874b78f3b8e39ed1c40fdda74cf084d3fdb282
/var/www/html/programaciondam2526/.git/objects/a1/10729e95a38395be50e62dc5b3199c39e3b31f
/var/www/html/programaciondam2526/.git/objects/0b/31e8e817bc876a9a5dbfe3adcbbe0d915f1429
/var/www/html/programaciondam2526/.git/objects/0b/bf1108e40dc291f220a7dbe2d16daf4f637a34
/var/www/html/programaciondam2526/.git/objects/0b/222552dcbfd15e3d4c14de6eca455df62d483c
/var/www/html/programaciondam2526/.git/objects/0b/9e4be95b506747c5726d055434a016b049343a
/var/www/html/programaciondam2526/.git/objects/0b/4d8c765b3961099c08e67274a32ef49103d65b
/var/www/html/programaciondam2526/.git/objects/21/55b4e8139bfc9c1ca8c0d35204ffd686e3255b
/var/www/html/programaciondam2526/.git/objects/e6/8862b85ce720c5c95acb405e545df6609faee2
/var/www/html/programaciondam2526/.git/objects/e6/9de29bb2d1d6434b8b29ae775ad8c2e48c5391
/var/www/html/programaciondam2526/.git/objects/e6/cefe17783008e3f95b763075921c95f095857e
/var/www/html/programaciondam2526/.git/objects/90/707d89828377bb44d7a72179b382239e1f4b71
/var/www/html/programaciondam2526/.git/objects/90/016c516562f56ea0d2f3c302bc47bc629a1b98
/var/www/html/programaciondam2526/.git/objects/90/e1925cd94673f113b823ed3581ce7def8e71c2
/var/www/html/programaciondam2526/.git/objects/6a/35b21a26d65989430a4eb1444a058e6e45bcee
/var/www/html/programaciondam2526/.git/objects/6a/8c0d53c9c967e1911bbed3cb4d5e8ddddd7b03
/var/www/html/programaciondam2526/.git/objects/6a/6b379624f1e10ba1a05783a5fa1700b16c7aec
/var/www/html/programaciondam2526/.git/objects/6a/0531878bf41b82ad3f500834edb253694eddaa
/var/www/html/programaciondam2526/.git/objects/78/d012c400d22a060a7c543fffc0f803c6623bc7
/var/www/html/programaciondam2526/.git/objects/78/530ccb582e365b32e0ef7356e109f4ee4a4bb7
/var/www/html/programaciondam2526/.git/objects/78/b152192e8bd024bafe324dae387eddb12cc315
/var/www/html/programaciondam2526/.git/objects/78/0380ee37c0651516c047425e0cecfec438a67e
/var/www/html/programaciondam2526/.git/objects/2a/77b7a25582f51afa42e6846430d794d31be7c8
/var/www/html/programaciondam2526/.git/objects/2a/bbf60f8cbcd1476b07768519b946a0e671cb48
/var/www/html/programaciondam2526/.git/objects/1f/89f43ed38769305dbd469aa340df75ff036a59
/var/www/html/programaciondam2526/.git/objects/1f/47ec295d246ce70768d40562f9dff1d4565a94
/var/www/html/programaciondam2526/.git/objects/1f/9065fd4ed5c1ed909c199294a5cbc144da1d06
/var/www/html/programaciondam2526/.git/objects/cd/42b4aa30fe8c8be5c789d9a1bc6c103437c4ba
/var/www/html/programaciondam2526/.git/objects/cd/6afacd3fbfe2ad2d47b13facb690d581c8eca4
/var/www/html/programaciondam2526/.git/objects/cd/6f5cb19c48eb0f80215f0b32f7e6f787eb74eb
/var/www/html/programaciondam2526/.git/objects/cd/9878d367f9199924b786346f1dea665f5acfeb
/var/www/html/programaciondam2526/.git/objects/1b/fbcff9718fec10bbd77a1c8ac9a269703b23f7
/var/www/html/programaciondam2526/.git/objects/1b/b9bce5cba16d293e2d5f9f11c688dddd4ae5d1
/var/www/html/programaciondam2526/.git/objects/2c/ba11b9ad8318c18246f417869d80cba58ea8a0
/var/www/html/programaciondam2526/.git/objects/2c/94213a76ada8196c6d506bd41f2294f0c9ae21
/var/www/html/programaciondam2526/.git/objects/9f/497ff1a228af84ef0f344a06d64ae1c73e2af6
/var/www/html/programaciondam2526/.git/objects/4b/b9582462dfc8f48e139f3e0154d0307ae22b70
/var/www/html/programaciondam2526/.git/objects/4b/bf591ce5f74ad6b72e7a5dec8aee988f35d98a
/var/www/html/programaciondam2526/.git/objects/6d/3ae8c2203ac2533ff29579d80ec4b26e96cc57
/var/www/html/programaciondam2526/.git/objects/6d/fb9f8855b35780af47a9b8df1c49a83d7cbc94
/var/www/html/programaciondam2526/.git/objects/6d/99820d963b0683dd1752c573f8d78782d8a94c
/var/www/html/programaciondam2526/.git/objects/6d/32a0588af2865c65ed6fe7c16127c6477a5643
/var/www/html/programaciondam2526/.git/objects/6d/de0147c7bf84e8de128db0831c7ce1f72773fe
/var/www/html/programaciondam2526/.git/objects/6c/954738f9de62b3586d40d7090d41c630dfa130
/var/www/html/programaciondam2526/.git/objects/3b/a4b9941bf04782455c228806635ff80c34f338
/var/www/html/programaciondam2526/.git/objects/67/0f38882dd35b114ec471d7ad10b0364a129d10
/var/www/html/programaciondam2526/.git/objects/67/14f44be8ed4b3ca2a7032b40b61afa74dddf14
/var/www/html/programaciondam2526/.git/objects/99/b71a74eea80c10a1e38b5a70178bdf3668f47e
/var/www/html/programaciondam2526/.git/objects/b4/4659e7bf116ee9013e45e9d5bb0dd53519e083
/var/www/html/programaciondam2526/.git/objects/b4/75d8ab7a2b1a0afd6d32c0d70f8ba3c0f8f99c
/var/www/html/programaciondam2526/.git/objects/b4/aad9a2942c418a0d6b3732ec83ea8d192756b9
/var/www/html/programaciondam2526/.git/objects/b4/62811b64a6b5fc241a1c59b3e6bed605098369
/var/www/html/programaciondam2526/.git/objects/4f/2a40c155fb2f95280abd631514830adea48234
/var/www/html/programaciondam2526/.git/objects/4f/9eccda329ef34d740335297c1beaf6261033b3
/var/www/html/programaciondam2526/.git/objects/4f/fa1b8db91ffa778d00535186747f96a9bf0033
/var/www/html/programaciondam2526/.git/objects/4f/fb90d77ab36fa203c99948b2f6fb8bc1bdffd9
/var/www/html/programaciondam2526/.git/objects/9c/03faaec8603f15cf39bd41fed6925c6e92dd8f
/var/www/html/programaciondam2526/.git/objects/1d/32f884cb2a31c0349bc01c007a77ca7b81cec9
/var/www/html/programaciondam2526/.git/objects/1d/967a21cfb096efa55a5af0ce07fd259b06e2bf
/var/www/html/programaciondam2526/.git/objects/d9/9986ccd3a47d1f5161cf7e8b697c1779c51a27
/var/www/html/programaciondam2526/.git/objects/05/aeec3ab353f4eb03a5a56529de56dfbb76c5c2
/var/www/html/programaciondam2526/.git/objects/05/98482b5d7f7fbfc82be933a89a91f4ff54bf23
/var/www/html/programaciondam2526/.git/objects/a0/91920f36f44374e27b0bce746f06689d7330eb
/var/www/html/programaciondam2526/.git/objects/a0/1bf65041c6c7e836e7b9ac8204c2d2512c478b
/var/www/html/programaciondam2526/.git/objects/a0/08ed62ad907114545dbfa0f42ea4b242973439
/var/www/html/programaciondam2526/.git/objects/a0/38ef3d428ba12d2c127490778bd9e4d8c62111
/var/www/html/programaciondam2526/.git/objects/b6/32d6d63a7c28a36a0be20010dfeceb2dd69959
/var/www/html/programaciondam2526/.git/objects/b6/cd4f6dfe2c6320cfefa2c822da09cc571ccb84
/var/www/html/programaciondam2526/.git/objects/f7/950b20a8bbc6527da9ae334517d33d4a453b24
/var/www/html/programaciondam2526/.git/objects/f7/528954ebc5dd9935879678dac65075e0d6ce60
/var/www/html/programaciondam2526/.git/objects/59/591f196b5bf70fc481e0495ac4cbdd183a50d6
/var/www/html/programaciondam2526/.git/objects/16/fce7e8c6f8ab53454ea4c9499f60e323dd28e2
/var/www/html/programaciondam2526/.git/objects/16/fa975cf94f941adf3d6571674d1dd3f1b256d0
/var/www/html/programaciondam2526/.git/objects/16/88fdc1ade53efda3503d75e8a750036f0786a7
/var/www/html/programaciondam2526/.git/objects/f0/9109b152c5d4ded93cb6cbfdaf31f209dc3ece
/var/www/html/programaciondam2526/.git/objects/f0/bee249fbace146d6942c111bbb9c74244e48e1
/var/www/html/programaciondam2526/.git/objects/bb/95a2d5d47d53e505807f725e089bdfac61df4c
/var/www/html/programaciondam2526/.git/objects/bb/4fc873d383343ff5e9369fc275b5c4877debcd
/var/www/html/programaciondam2526/.git/objects/3e/927bc386e357f8bcdc7ac59a6a49ced3e86ff7
/var/www/html/programaciondam2526/.git/objects/a5/a572dcb7e92013e90ee45d606cda6ecbb08271
/var/www/html/programaciondam2526/.git/objects/a5/e5b1d0e7229dfcb4ab37547ee48bc5ab1db161
/var/www/html/programaciondam2526/.git/objects/ed/575cf51df13927d5c639f8a0db22e9c1dae249
/var/www/html/programaciondam2526/.git/objects/ed/47eabd58ee303b2de149af3a43221a45344189
/var/www/html/programaciondam2526/.git/objects/33/4a3749a21b0b275065b5c294694aa350dfaddc
/var/www/html/programaciondam2526/.git/objects/01/ab91d9431c26600a11fc884491cd5e8261b974
/var/www/html/programaciondam2526/.git/objects/01/263a32d6a0b036a20981722a8337a0958c0166
/var/www/html/programaciondam2526/.git/objects/01/cee4624fc858d953eb6813d320b4dbe111b83b
/var/www/html/programaciondam2526/.git/objects/15/c7e3ecb73644c0f0376c66dc22405801a1e8fb
/var/www/html/programaciondam2526/.git/objects/15/c2e78c842e18ae6145bbd9f8346448f83ca8c7
/var/www/html/programaciondam2526/.git/objects/a3/7cd5baf4e52ee7866793b749687de15fb201be
/var/www/html/programaciondam2526/.git/objects/a3/8b7bc8e62766e92b40bebd0a172e5479a82daa
/var/www/html/programaciondam2526/.git/objects/a3/6ce66a05b908eeac1e87efcbe10b2c9d2cfd1a
/var/www/html/programaciondam2526/.git/objects/a3/b76e9beb9ce8703c6bb14ca55ff13298428b71
/var/www/html/programaciondam2526/.git/objects/22/3cf7f788066c4cefc32900b7dfd81d3c0ae995
/var/www/html/programaciondam2526/.git/objects/22/c05a3e0d6847ee951607b74af8fee47e6484e3
/var/www/html/programaciondam2526/.git/objects/00/b82a4d9be2b7d1bc53ec3bde32564f94de2716
/var/www/html/programaciondam2526/.git/objects/00/09eb8e24b8c2a5e6cc31a2d457418768c259c3
/var/www/html/programaciondam2526/.git/objects/35/ef16e53cf9271728cb7c5aeee4e1ae52de23bc
/var/www/html/programaciondam2526/.git/objects/35/ff20ffb4b31956f37d84ecca0f316381df60c8
/var/www/html/programaciondam2526/.git/objects/35/72fcfa0987e62fc686369881b360eb3684cd13
/var/www/html/programaciondam2526/.git/objects/35/89b539be622cbec73c6f2b67ad44a641c31be9
/var/www/html/programaciondam2526/.git/objects/35/3c980f9c3a2dfb41aa4c5aa2e565f86cfc9674
/var/www/html/programaciondam2526/.git/objects/35/3ef4d637cdaf3d79ed6ca46dff94bc77948c32
/var/www/html/programaciondam2526/.git/objects/c4/63ac01f88c426c9b8a6358e3f544d8c9b4aa05
/var/www/html/programaciondam2526/.git/objects/c4/f998db87069ad7254e847b4de43d8767a44562
/var/www/html/programaciondam2526/.git/objects/8c/213beea9fcd2db5852c0e4e8042d6dac73ee7e
/var/www/html/programaciondam2526/.git/objects/8c/a179d03587fe7bf2fa88bd5cd7674dfe1ae505
/var/www/html/programaciondam2526/.git/objects/8c/08fd3fd22988a528736002c665ff5487ee06bd
/var/www/html/programaciondam2526/.git/objects/8c/93691c900703cc65474b13925f32227d4c5d86
/var/www/html/programaciondam2526/.git/objects/c5/1dfbba3e5b81f72f867bb73bf2e9c4bc20e2d4
/var/www/html/programaciondam2526/.git/objects/06/e318d6b95f4853ebb453b94883cdf0632bc4c8
/var/www/html/programaciondam2526/.git/objects/06/c38788a579dfab048f05cd5be8cecbd8b5dd55
/var/www/html/programaciondam2526/.git/objects/06/8b53d8907c84b69822dd7acc8cc1e273369627
/var/www/html/programaciondam2526/.git/objects/06/28ff28ab9db1f8546eabb07ee1abb39466b3cc
/var/www/html/programaciondam2526/.git/objects/06/c07641ea823c49f5c682bd459cfc47b8996478
/var/www/html/programaciondam2526/.git/objects/06/c14926f200046123f1e4705bac90dc42740ad0
/var/www/html/programaciondam2526/.git/objects/c6/f2f65f262a816d96a5cb9a43d49378007f5d29
/var/www/html/programaciondam2526/.git/objects/81/918983325fcb1c564317cdfb4b8d9f23f04a3d
/var/www/html/programaciondam2526/.git/objects/1e/2a26d03b4ed038bc13e6c81fa8f60523bd009a
/var/www/html/programaciondam2526/.git/objects/1e/9bcaccb1a229c4ad6ab1121c2f524f104c9061
/var/www/html/programaciondam2526/.git/objects/1e/a1ab440e37f6c8b1ecc77737fccb558b9658d5
/var/www/html/programaciondam2526/.git/objects/28/5c129d063e85161e4531e49f320b43ab6fe6b6
/var/www/html/programaciondam2526/.git/objects/98/ecad0c56dff76910df0cc419c2c04c469690bf
/var/www/html/programaciondam2526/.git/objects/98/9021af1f8b15eba2519f0f53b215717b7258fd
/var/www/html/programaciondam2526/.git/objects/98/820ff75f7bfebf38e275406d9bac383f99acc2
/var/www/html/programaciondam2526/.git/objects/94/592749d1559c737355671491f7c88e4402a7c7
/var/www/html/programaciondam2526/.git/objects/94/628a2c12b1385d532641a19c6a4524d0c4e97a
/var/www/html/programaciondam2526/.git/objects/94/0ea58206eac9949370a6e1930adc7804dde5c0
/var/www/html/programaciondam2526/.git/objects/dc/e01cafc1a0ca5e6978c33c472149d859c0ad2d
/var/www/html/programaciondam2526/.git/objects/dc/ed79b1036447f1134da02aa4f8470ce9d29fbb
/var/www/html/programaciondam2526/.git/objects/24/daa5e42a71dac677d129760ddd9a7d9ad86be1
/var/www/html/programaciondam2526/.git/objects/24/4722a391c90125138c368a346aca61d16a914b
/var/www/html/programaciondam2526/.git/objects/24/646bde2f2a1d6e7fc0d235eab63ec67ee84efd
/var/www/html/programaciondam2526/.git/objects/71/40b2c88bc4154d15a8206e77e3edbd05a11f23
/var/www/html/programaciondam2526/.git/objects/71/0da1c1b0b69b99d3e83ae8185f882065efe147
/var/www/html/programaciondam2526/.git/objects/71/b0f0d2e2ed296373ef4913245264166c315908
/var/www/html/programaciondam2526/.git/objects/71/1c612351f684319938a7defcd8bc9e759c6aa7
/var/www/html/programaciondam2526/.git/objects/d1/fb293177557efd4f184cc9e192d8d4a107f0b1
/var/www/html/programaciondam2526/.git/objects/ea/08b34a406084b4f8dec53b0e652f5497bc7efe
/var/www/html/programaciondam2526/.git/objects/ea/873af148a57070133c6adba44c68273251e884
/var/www/html/programaciondam2526/.git/objects/ea/69c333990b764ca3c8a7248aa5c5282901e961
/var/www/html/programaciondam2526/.git/objects/ea/4c93b75a2902348586117cf018bba45b0b24f6
/var/www/html/programaciondam2526/.git/objects/a4/564eb5e18c8a5cb39be7c71b587ba6e18e1658
/var/www/html/programaciondam2526/.git/objects/a4/80b034a94363c30818cd58abd8b4455c3c6e39
/var/www/html/programaciondam2526/.git/objects/f6/c4c11a40492d6f5ccd0849d7709b833069604e
/var/www/html/programaciondam2526/.git/objects/51/e5f2a362d55d1b2192f5b40109c245987c3be9
/var/www/html/programaciondam2526/.git/objects/07/134b3002e83bb74e4d9297557d2803b05812a6
/var/www/html/programaciondam2526/.git/objects/07/11ee84cdb6be8fdc9ba21cb04704165a93c18c
/var/www/html/programaciondam2526/.git/objects/fc/8136c096643e4b00a58f60cbe9f9b02ae8fd85
/var/www/html/programaciondam2526/.git/objects/fc/09d14f0b2c28b38f9f8c5ccae692d3caba49cf
/var/www/html/programaciondam2526/.git/objects/fc/638d241c38ff6a1e5c4c9dcc1f0699adbd000b
/var/www/html/programaciondam2526/.git/objects/14/dab71047cda4716fcb69238e28d354cf67cc7a
/var/www/html/programaciondam2526/.git/objects/14/678b51cfaf8482c8be5a3c28062fdc823ec1fa
/var/www/html/programaciondam2526/.git/objects/14/bf2abdd399420218e109cb781e78b2e01e7558
/var/www/html/programaciondam2526/004-Desarrollo de clases/000-Resumen.md
/var/www/html/programaciondam2526/004-Desarrollo de clases/Criterios de evaluacion.md
/var/www/html/programaciondam2526/004-Desarrollo de clases/005-Creación de constructores/101-Ejercicios/001-repaso gato.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/005-Creación de constructores/101-Ejercicios/003-constructor con parametros.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/005-Creación de constructores/101-Ejercicios/006-ejemplo con cliente.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/005-Creación de constructores/101-Ejercicios/002-a un construtor se le pueden pasar parametros.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/005-Creación de constructores/101-Ejercicios/004-mas parametros.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/005-Creación de constructores/101-Ejercicios/005-tercera propiedad.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/005-Creación de constructores/101-Ejercicios/007-listado de clientes.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/005-Creación de constructores/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/004-Desarrollo de clases/005-Creación de constructores/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/004-Desarrollo de clases/004-Creación de métodos/101-Ejercicios/010-ejemplo practico.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/004-Creación de métodos/101-Ejercicios/013-creo una lista de clientes.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/004-Creación de métodos/101-Ejercicios/011-creo setters y getters.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/004-Creación de métodos/101-Ejercicios/009-variable global.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/004-Creación de métodos/101-Ejercicios/004-defino propiedad privada.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/004-Creación de métodos/101-Ejercicios/005-Clase cuenta bancaria.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/004-Creación de métodos/101-Ejercicios/008-validacion.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/004-Creación de métodos/101-Ejercicios/012-pequeño programa.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/004-Creación de métodos/101-Ejercicios/010-creo setters y getters.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/004-Creación de métodos/101-Ejercicios/002-metodo set.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/004-Creación de métodos/101-Ejercicios/007-get saldo.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/004-Creación de métodos/101-Ejercicios/014-getters.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/004-Creación de métodos/101-Ejercicios/003-metodo getter.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/004-Creación de métodos/101-Ejercicios/006-convertir en privadas.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/004-Creación de métodos/101-Ejercicios/001-repaso de los metodos.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/004-Creación de métodos/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/004-Desarrollo de clases/004-Creación de métodos/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/004-Desarrollo de clases/007-Utilización de clases heredadas/101-Ejercicios/002-clase madre animal.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/007-Utilización de clases heredadas/101-Ejercicios/004-herencia o multinivel.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/007-Utilización de clases heredadas/101-Ejercicios/003-clase Roca.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/007-Utilización de clases heredadas/101-Ejercicios/001-gatos y perros.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/007-Utilización de clases heredadas/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/004-Desarrollo de clases/007-Utilización de clases heredadas/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/004-Desarrollo de clases/003-Creación de propiedades/101-Ejercicios/002-las propiedades pueden ser arrays.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/003-Creación de propiedades/101-Ejercicios/011-le mostramos al usuario las opciones que tiene.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/003-Creación de propiedades/101-Ejercicios/004-leemos propiedad.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/003-Creación de propiedades/101-Ejercicios/013-estructura if.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/003-Creación de propiedades/101-Ejercicios/014-bucle infinito.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/003-Creación de propiedades/101-Ejercicios/003-escribir las propiedades de una clase.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/003-Creación de propiedades/101-Ejercicios/012-tomamos la entrada de usuario.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/003-Creación de propiedades/101-Ejercicios/001-Repaso de propiedades.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/003-Creación de propiedades/101-Ejercicios/006-aplicacion de productos.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/003-Creación de propiedades/101-Ejercicios/007-funciones y clases.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/003-Creación de propiedades/101-Ejercicios/009-pseudocodigo.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/003-Creación de propiedades/101-Ejercicios/008-creamos las variables globales.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/003-Creación de propiedades/101-Ejercicios/010-voy creando el codigo.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/003-Creación de propiedades/101-Ejercicios/005-los telefonos deben ser una lista.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/003-Creación de propiedades/101-Ejercicios/015-desarrollo la insercion de producto.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/003-Creación de propiedades/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/004-Desarrollo de clases/003-Creación de propiedades/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/004-Desarrollo de clases/006-Utilización de clases y objetos/101-Ejercicios/002-redondeos alza y baja.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/006-Utilización de clases y objetos/101-Ejercicios/001-Mi propia clase.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/006-Utilización de clases y objetos/101-Ejercicios/003-ahora uso la libreria estandar.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/006-Utilización de clases y objetos/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/004-Desarrollo de clases/006-Utilización de clases y objetos/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/004-Desarrollo de clases/002-Estructura y miembros de una clase. Visibilidad/101-Ejercicios/004-le preguntamos al usuario.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/002-Estructura y miembros de una clase. Visibilidad/101-Ejercicios/008-clase cliente.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/002-Estructura y miembros de una clase. Visibilidad/101-Ejercicios/001-listas.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/002-Estructura y miembros de una clase. Visibilidad/101-Ejercicios/006-crud.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/002-Estructura y miembros de una clase. Visibilidad/101-Ejercicios/005-leemos los datos del cliente.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/002-Estructura y miembros de una clase. Visibilidad/101-Ejercicios/007-crud insertar y listar.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/002-Estructura y miembros de una clase. Visibilidad/101-Ejercicios/003-clase cliente.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/002-Estructura y miembros de una clase. Visibilidad/101-Ejercicios/002-operaciones con listas.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/002-Estructura y miembros de una clase. Visibilidad/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/004-Desarrollo de clases/002-Estructura y miembros de una clase. Visibilidad/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/004-Desarrollo de clases/001-Concepto de clase/101-Ejercicios/001-Introduccion.md
/var/www/html/programaciondam2526/004-Desarrollo de clases/001-Concepto de clase/101-Ejercicios/007-propiedades.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/001-Concepto de clase/101-Ejercicios/004-ahora quiero crear otro gato.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/001-Concepto de clase/101-Ejercicios/011-Paradigmas en programacion.md
/var/www/html/programaciondam2526/004-Desarrollo de clases/001-Concepto de clase/101-Ejercicios/009-objeto cliente.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/001-Concepto de clase/101-Ejercicios/008-introduccion a los metodos.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/001-Concepto de clase/101-Ejercicios/002-clase gato.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/001-Concepto de clase/101-Ejercicios/003-instanciamos un gato.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/001-Concepto de clase/101-Ejercicios/005-Elementos principales de las clases.md
/var/www/html/programaciondam2526/004-Desarrollo de clases/001-Concepto de clase/101-Ejercicios/010-clase cliente.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/001-Concepto de clase/101-Ejercicios/006-propiedades y metodos.py
/var/www/html/programaciondam2526/004-Desarrollo de clases/001-Concepto de clase/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/004-Desarrollo de clases/001-Concepto de clase/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/008-Mantenimiento de la persistencia de los objetos/000-Resumen.md
/var/www/html/programaciondam2526/008-Mantenimiento de la persistencia de los objetos/Criterios de evaluacion.md
/var/www/html/programaciondam2526/008-Mantenimiento de la persistencia de los objetos/009-Tipos de datos colección/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/008-Mantenimiento de la persistencia de los objetos/009-Tipos de datos colección/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/008-Mantenimiento de la persistencia de los objetos/004-Creación de bases de datos/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/008-Mantenimiento de la persistencia de los objetos/004-Creación de bases de datos/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/008-Mantenimiento de la persistencia de los objetos/001-Bases de datos orientadas a objetos/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/008-Mantenimiento de la persistencia de los objetos/001-Bases de datos orientadas a objetos/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/008-Mantenimiento de la persistencia de los objetos/007-Recuperación, modificación y borrado de información/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/008-Mantenimiento de la persistencia de los objetos/007-Recuperación, modificación y borrado de información/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/008-Mantenimiento de la persistencia de los objetos/008-Tipos de datos objeto; atributos y métodos/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/008-Mantenimiento de la persistencia de los objetos/008-Tipos de datos objeto; atributos y métodos/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/008-Mantenimiento de la persistencia de los objetos/002-Características de las bases de datos orientadas a objetos/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/008-Mantenimiento de la persistencia de los objetos/002-Características de las bases de datos orientadas a objetos/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/008-Mantenimiento de la persistencia de los objetos/006-El lenguaje de consultas sintaxis, expresiones, operadores/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/008-Mantenimiento de la persistencia de los objetos/006-El lenguaje de consultas sintaxis, expresiones, operadores/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/008-Mantenimiento de la persistencia de los objetos/005-Mecanismos de consulta/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/008-Mantenimiento de la persistencia de los objetos/005-Mecanismos de consulta/001-Contenidos básicos/Contenidos básicos.md
/var/www/html/programaciondam2526/008-Mantenimiento de la persistencia de los objetos/003-Instalación del gestor de bases de datos/201-Criterios de evaluación/Criterios de evaluación.md
/var/www/html/programaciondam2526/008-Mantenimiento de la persistencia de los objetos/003-Instalación del gestor de bases de datos/001-Contenidos básicos/Contenidos básicos.md
```

### Actividades propuestas

It looks like you've provided a list of file paths related to a course on object-oriented programming and database management. Each path leads to different sections or exercises in the course, which cover various aspects from basic concepts of classes and objects to more advanced topics such as persistence mechanisms and querying databases.

Here's a brief overview based on the paths:

1. **Concepto de Clase** (Class Concept): This section introduces students to the fundamental ideas behind classes and objects in object-oriented programming.
   
2. **Estructura y Miembros de una Clase** (Structure and Members of a Class): Here, the focus is on understanding how classes are structured and what members (properties and methods) they contain.

3. **Desarrollo de Clases** (Class Development): Covers various aspects of developing classes in terms of methods, properties, inheritance, and polymorphism.

4. **Persistencia de Objetos en Bases de Datos** (Object Persistence in Databases):
   - **Bases de datos orientadas a objetos**: Introduction to object-oriented databases.
   - **Características de las bases de datos orientadas a objetos**: Features of object-oriented databases.
   - **Creación de bases de datos**: How to create and manage databases.
   - **Instalación del gestor de bases de datos**: Installation procedures for database management systems.
   - **Mecanismos de consulta**: Query mechanisms in object-oriented databases.
   - **El lenguaje de consultas sintaxis, expresiones, operadores**: Syntax, expressions, and operators of the query language used to interact with object-oriented databases.
   - **Recuperación, modificación y borrado de información**: Techniques for retrieving, modifying, and deleting information in these databases.
   - **Tipos de datos colección; atributos y métodos**: Collection data types, their attributes, and methods.

5. **Resumen del Tema** (Summary of the Topic): This could be a recapitulation or consolidation section summarizing all aspects learned about object persistence in databases.

Given this structure, you might want to navigate through these files in an organized manner according to your learning pace or as prescribed by the course syllabus. If you have specific questions or need help with any of the exercises covered within these paths, feel free to ask!


<a id="creacion-y-eliminacion-de-ficheros-y-directorios"></a>
## Creación y eliminación de ficheros y directorios

### Introducción a los ejercicios

En esta carpeta, trabajaremos con ejercicios que te permitirán entender cómo crear y eliminar archivos y directorios en Python. Aprenderás desde operaciones básicas como crear una simple carpeta o archivo hasta procesos más complejos como comprimir carpetas y sus subcarpetas en archivos ZIP. Estos ejercicios están diseñados para mejorar tus habilidades en la manipulación de sistemas de archivos, manejo de excepciones y compresión de datos. Es importante prestar atención a los detalles sobre cómo gestionar correctamente errores y mantener la seguridad de tu sistema al realizar operaciones con el sistema de archivos.

### crear carpeta

#### Explicación

Este código crea una nueva carpeta en el sistema de archivos utilizando la biblioteca `os` de Python. La función `mkdir` (que significa "make directory" o crear directorio) recibe como argumento el nombre de la carpeta que se quiere crear, en este caso, "micarpeta". Cuando ejecutas este código, Python solicita al sistema operativo que genere un nuevo directorio con ese nombre en el lugar donde está ubicado tu programa. Es importante tener cuidado ya que si intentas crear una carpeta con un nombre que ya existe, obtendrás un error.

Este fragmento es útil para estudiantes de Formación Profesional porque muestra cómo interactuar con el sistema operativo desde Python y entender la estructura de directorios en tu entorno de desarrollo.

```python
import os

os.mkdir("micarpeta")
```

### eliminar carpeta

#### Explicación

Este código es muy sencillo pero efectivo para eliminar una carpeta en Python. Lo que hace es importar el módulo `os`, que proporciona funciones para interactuar con el sistema operativo, incluyendo la capacidad de crear y eliminar archivos y directorios.

Después de importar `os`, se utiliza la función `os.rmdir("micarpeta")` para eliminar una carpeta llamada "micarpeta". Es importante destacar que esta función solo puede eliminarse un directorio vacío; si el directorio contiene archivos o subdirectorios, la operación fallará con un error.

Esta línea de código es útil cuando necesitas automatizar tareas que implican la limpieza del sistema de ficheros, como eliminar carpetas temporales después de realizar ciertos procesos.

```python
import os

os.rmdir("micarpeta")
```

### no se puede crear una carpeta dos veces

#### Explicación

Este fragmento de código en Python utiliza la biblioteca `os` para trabajar con el sistema operativo. En particular, usa la función `mkdir`, que significa "make directory" o crear directorio en inglés. El código intenta crear una carpeta llamada "micarpeta". Si esta carpeta no existe previamente en el directorio actual, se creará correctamente y el programa terminará sin problemas. Sin embargo, si ya existe una carpeta con ese nombre, Python lanzará un error porque no puedes crear dos carpetas con el mismo nombre en la misma ubicación.

Es importante entender este concepto para evitar errores durante la ejecución de programas que manejan archivos y directorios. También es crucial tener conocimiento sobre cómo lidiar con estos posibles errores (como usar try-except) para hacer que tus aplicaciones sean más robustas y útiles en el mundo real.

```python
import os

os.mkdir("micarpeta")
```

### solucion al problema

#### Explicación

Este código está usando la biblioteca `os` en Python para crear un directorio. La función `mkdir()` se utiliza para crear una nueva carpeta con el nombre "micarpeto". Si esta operación es exitosa, significa que la carpeta ha sido creada correctamente.

Sin embargo, si ya existe una carpeta llamada "micarpeta", al intentar crearla de nuevo dará un error. En lugar de detener la ejecución del programa debido a este error, el código lo maneja usando un bloque `try` y `except`. Esto significa que, si ocurre cualquier tipo de error durante la creación del directorio (por ejemplo, si ya existe), el programa simplemente imprimirá "Ha habido un error, continuamos" en pantalla y seguirá ejecutando el resto del código.

Este método es importante porque permite al programador anticipar problemas comunes que podrían surgir y gestionarlos de manera que el flujo principal del programa no se interrumpa.

```python
import os

try:
  os.mkdir("micarpeta")
except:
  print("Ha habido un error, continuamos")
```

### crear un archivo

#### Explicación

Este fragmento de código en Python está utilizando la función `open()` para crear o manipular archivos. En este caso, el código abre (o crea si no existe) un archivo llamado "miarchivo.txt" con modo de escritura ("w"). El modo "w" significa que cualquier información ya existente en el archivo será reemplazada por lo que escribas después a través del objeto file que se devuelve cuando se llama a `open()`. Es importante destacar que, aunque la función `open()` solo abre o crea el archivo y no escribe nada en él, este código establece las bases para cualquier escritura que pueda hacerse posteriormente en ese archivo.

```python
open("miarchivo.txt","w")
```

### eliminar archivo

#### Explicación

Este fragmento de código es una manera sencilla y directa de eliminar un archivo en Python. Primero, el programa importa la biblioteca `os`, que proporciona funciones para interactuar con el sistema operativo, incluyendo operaciones sobre archivos y directorios.

Luego, utiliza la función `os.remove("miarchivo.txt")` para borrar físicamente el archivo llamado "miarchivo.txt" desde tu carpeta de trabajo. Esta línea supone que este archivo ya existe en el directorio actual del programa, tal como se menciona en el comentario anterior al código, donde indica que el archivo fue creado previamente con la función `open("miarchivo.txt","w")`. Es importante tener cuidado cuando usas esta función porque una vez que un archivo es eliminado utilizando `os.remove()`, no hay forma de recuperarlo sin recurrir a herramientas específicas para la restauración de archivos.

Este tipo de código es fundamental en programación, especialmente cuando necesitas limpiar archivos temporales o desechados después del uso. Sin embargo, siempre es recomendable tener precaución al eliminar archivos ya que este proceso no puede deshacerse fácilmente.

```python
import os

# Hemos creado con:
# open("miarchivo.txt","w")

os.remove("miarchivo.txt")
```

### nuevo archivo con texto

#### Explicación

Este fragmento de código en Python se utiliza para crear y escribir información en un archivo llamado "miarchivo.txt". El programa abre el archivo en modo escritura ("w"), lo que significa que si ya existe, su contenido anterior será eliminado. Si no existe, se creará uno nuevo. Luego, la función `write()` es utilizada para introducir una cadena de texto específica dentro del archivo recién creado o actualizado.

Este tipo de código es importante porque permite a los programadores interactuar directamente con archivos y almacenar información persistente que puede ser recuperada más tarde. Es fundamental en aplicaciones que requieren guardar datos, como registros de usuario, bases de datos simples o incluso el historial de cualquier aplicación.

```python
archivo = open("miarchivo.txt","w")

archivo.write("Esto es un texto de prueba que estoy escribiendo")
```

### comprimir

#### Explicación

Este código está diseñado para comprimir un archivo en formato SQL dentro de un archivo ZIP. Primero, se importa el módulo `zipfile` que es una herramienta incorporada de Python utilizada específicamente para manejar archivos ZIP.

El programa define dos variables: `origen`, que contiene la ruta del archivo que deseamos comprimir (en este caso, `'crmca_crmcapitol (1).sql'`), y `destino`, que indica el nombre del archivo ZIP resultante (`'basededatos.zip'`). Luego, se crea un objeto `ZipFile` llamado `archivo`, especificando el modo de escritura ('w') para indicar que estamos creando un nuevo archivo ZIP o sobrescribiendo uno existente.

Finalmente, la línea `archivo.write(origen)` añade el archivo SQL a este nuevo archivo ZIP. Cuando se ejecuta este código, el archivo SQL será comprimido dentro del archivo ZIP especificado en `destino`. Este tipo de operación es muy útil para reducir el tamaño de los archivos y facilitar su transferencia o almacenamiento.

```python
import zipfile

origen = 'crmca_crmcapitol (1).sql'

destino = 'basededatos.zip'

archivo = zipfile.ZipFile(destino, 'w')
archivo.write(origen)
```

### algoritmo de compresion

#### Explicación

Este código es una parte de un programa que compresión archivos utilizando el módulo `zipfile` en Python. En este caso específico, se está tomando un archivo llamado `'crmca_crmcapitol (1).sql'`, que suponemos es un archivo de base de datos SQL, y lo comprime en otro archivo denominado `'basededatos.zip'`.

El código primero importa el módulo `zipfile` para poder trabajar con archivos ZIP. Luego, establece la ruta del archivo original (`origen`) y especifica dónde debe guardarse el nuevo archivo comprimido (`destino`). Se crea un objeto de tipo `ZipFile` que abre el archivo `'basededatos.zip'` en modo escritura ('w'), utilizando el algoritmo de compresión `ZIP_DEFLATED`, que es un método muy eficiente para la compresión. Finalmente, se añade el archivo original a este nuevo archivo ZIP.

Esta operación es importante porque permite reducir significativamente el tamaño del archivo SQL, lo cual facilita su almacenamiento y transmisión por Internet, ya que los archivos comprimidos ocupan menos espacio en disco y pueden transferirse más rápidamente.

```python
import zipfile

origen = 'crmca_crmcapitol (1).sql'

destino = 'basededatos.zip'

archivo = zipfile.ZipFile(destino, 'w', compression=zipfile.ZIP_DEFLATED)
archivo.write(origen)
```

### comprimir todos los arhivos de una carpeta

#### Explicación

Este código Python se encarga de comprimir todos los archivos que encuentre en una carpeta específica llamada "archivos". Primero, importa dos módulos importantes: `zipfile` para trabajar con archivos ZIP y `os` para manejar operaciones del sistema operativo.

El programa recorre cada archivo dentro de la carpeta especificada mediante el uso del método `os.walk()`. Para cada archivo encontrado, construye su ruta completa usando `os.path.join()` y luego crea un nuevo nombre para el archivo comprimido añadiendo `.zip` al final. 

Después, se abre un nuevo archivo ZIP en modo de escritura (`'w'`) utilizando la clase `ZipFile`, especificando que debe usar compresión DEFLATE (un tipo común de compresión). Finalmente, agrega el archivo original a este nuevo archivo ZIP con el método `write()`, donde `arcname` define cómo se llamará el archivo dentro del ZIP.

Este código es importante porque permite automatizar la tarea tediosa y manual de comprimir múltiples archivos en un directorio específico, lo que puede ser muy útil para almacenar o enviar datos de manera eficiente.

```python
import zipfile
import os

carpeta = "archivos"

for directorio, subcarpetas, archivos in os.walk(carpeta):
    for nombre_archivo in archivos:
        origen = os.path.join(directorio, nombre_archivo)
        destino = os.path.join(directorio, nombre_archivo + ".zip")
        archivo =  zipfile.ZipFile(destino, 'w', compression=zipfile.ZIP_DEFLATED)
        archivo.write(origen, arcname=nombre_archivo)
```

### comprimir carpeta

#### Explicación

Este código está diseñado para comprimir todos los archivos dentro de una carpeta específica en un archivo ZIP. Primero, importa las librerías `os` y `zipfile`, que son esenciales para manejar rutas de archivos y crear compresiones ZIP respectivamente.

El código define dos variables: `origen` (que es el nombre de la carpeta a comprimir) y `destino` (que será el archivo ZIP resultante, en este caso "archivos.zip"). Luego, se crea un objeto `ZipFile`, que permitirá escribir en el archivo ZIP recién creado.

A continuación, utiliza una función llamada `os.walk()`, la cual recorre todos los archivos y subcarpetas dentro de la carpeta especificada como origen. Para cada archivo encontrado, obtiene su ruta completa (`rutaarchivo`) y calcula su ruta relativa respecto a la carpeta de origen (`rutarelativa`). Luego, añade este archivo al ZIP utilizando el método `write()` del objeto `ZipFile`, asegurando que se mantenga la estructura de directorios original dentro del archivo ZIP.

Finalmente, cierra el archivo ZIP para guardar todos los cambios. Este proceso es importante porque permite archivar y distribuir fácilmente grandes volúmenes de datos en un solo archivo comprimido, facilitando tanto su almacenamiento como su transferencia a otros sistemas.

```python
import os
import zipfile

origen = "archivos"
destino = "archivos.zip"

archivozip = zipfile.ZipFile(destino, 'w', zipfile.ZIP_DEFLATED)
for directorio, carpetas, archivos in os.walk(origen):
  for archivo in archivos:
    rutaarchivo = os.path.join(directorio, archivo)
    rutarelativa = os.path.relpath(rutaarchivo, origen)
    archivozip.write(rutaarchivo, rutarelativa)
    
archivozip.close()
```

### ejercicio final

#### Explicación

Este código en Python te permite realizar una tarea muy específica: tomar una carpeta dada por el usuario y comprimir todos sus archivos y subcarpetas en archivos ZIP individuales, luego eliminando los originales. Primero, el programa pide al usuario que introduzca la ruta de la carpeta que desea procesar. Luego verifica si esa ruta es válida y realmente corresponde a una carpeta.

Si todo está correcto, el código itera sobre todos los elementos en ese directorio principal (pero no entra más allá del primer nivel). Para cada elemento, primero se comprueba si ya es un archivo ZIP; si lo es, simplemente pasa al siguiente. Si el elemento es una subcarpeta, crea un archivo ZIP que contiene todo su contenido y luego elimina la carpeta original. Si el elemento es un archivo simple, lo comprime directamente en un archivo ZIP y después borra el archivo original.

Esta operación es útil para limpiar espacio en discos o para preparar respaldos de datos de manera ordenada, ya que crea backups de cada archivo y carpeta dentro del directorio dado, pero sin dejar los archivos originales. Es importante tener cuidado con este tipo de scripts ya que pueden resultar en la pérdida irreparable de datos si no se usan correctamente.

```python
import os
import zipfile
import shutil

'''
  Quiero:
  1.-Pedir al usuario una ruta de una carpeta con input
  2.-Repasar todas las subcarpetas y archivos dentro de esa carpeta
  3.-Para cada archivo o carpeta, quiero comprimirla en un ZIP
  4.-Una vez comprimido ese zip, quiero eliminar los contenidos originales
'''

ruta = input("Introduce la ruta de la carpeta: ").strip()

try:
  # Comprobamos que la ruta existe y es una carpeta
  if not os.path.isdir(ruta):
    print("La ruta no es válida")
  else:
    # Recorremos SOLO el primer nivel dentro de la ruta dada
    for nombre in os.listdir(ruta):
      origen = os.path.join(ruta, nombre)

      # Evitar recomprimir ZIPs ya existentes
      if os.path.isfile(origen) and origen.lower().endswith(".zip"):
        continue

      # Si es una carpeta: crear un ZIP con todo su contenido y luego eliminarla
      if os.path.isdir(origen):
        destino = origen + ".zip"
        archivozip = zipfile.ZipFile(destino, 'w', zipfile.ZIP_DEFLATED)
        for directorio, subcarpetas, archivos in os.walk(origen):
          for archivo in archivos:
            rutaarchivo = os.path.join(directorio, archivo)
            rutarelativa = os.path.relpath(rutaarchivo, origen)
            archivozip.write(rutaarchivo, rutarelativa)
        archivozip.close()
        shutil.rmtree(origen)

      # Si es un archivo: comprimirlo y luego eliminar el original
      elif os.path.isfile(origen):
        destino = origen + ".zip"
        archivo = zipfile.ZipFile(destino, 'w', compression=zipfile.ZIP_DEFLATED)
        archivo.write(origen, arcname=nombre)
        archivo.close()
        os.remove(origen)

except:
  print("Ha habido un error, continuamos")
```

### ampliacion

#### Explicación

Este código Python es una herramienta que permite a los usuarios seleccionar una carpeta y comprimir todos sus archivos y subcarpetas en archivos ZIP individuales. El programa también ofrece la opción de eliminar los archivos originales después de crear los archivos ZIP para ahorrar espacio, aunque esta función puede desactivarse si se desea conservar los datos originales.

El proceso principal del código se divide en varias etapas:
1. Primero, el usuario es solicitado a ingresar una ruta de carpeta específica.
2. El programa verifica que la ruta ingresada sea válida y no contenga archivos ZIP para evitar problemas durante la compresión.
3. Luego, recorre todos los elementos (archivos o carpetas) dentro de esa carpeta, creando un archivo ZIP por cada uno de ellos. Para las carpetas, se comprime todo su contenido en el archivo ZIP correspondiente; para los archivos individuales, simplemente se crea un ZIP que contiene solo ese archivo.
4. La opción de borrar los elementos originales después de la compresión está controlada por una variable booleana `borrar_originales`, que puede ser cambiada al valor deseado antes de ejecutar el programa.

Además del proceso principal, este código incluye funciones adicionales para mostrar una barra de progreso en la consola durante la operación. Esta característica proporciona un seguimiento visual y estimaciones temporales útiles sobre el estado actual y cuánto tiempo queda hasta que se complete el proceso.

Este tipo de herramientas es útil en varios escenarios, como backup rápido de carpetas o preparación para transferencia de archivos a otro sistema, garantizando una gestión segura y eficiente del almacenamiento.

```python
import os
import zipfile
import shutil
import sys
import time

#### CUIDADO CON ESTE PROGRAMA
#### USALO BIEN
#### UN GRAN PODER CONLLEVA UNA GRAN RESPONSABILIDAD

'''
  Quiero:
  1.-Pedir al usuario una ruta de una carpeta con input
  2.-Repasar todas las subcarpetas y archivos dentro de esa carpeta
  3.-Para cada archivo o carpeta, quiero comprimirla en un ZIP
  4.-Una vez comprimido ese zip, quiero eliminar los contenidos originales (opcional con booleano)
  5.-Mostrar una barra de progreso en consola con porcentaje y estimación de tiempo
'''

# 1) Booleano para activar/desactivar el borrado de originales
borrar_originales = False  # ponlo a False para conservar los originales

# ---- Utilidades para la barra de progreso ----
def formatear_tiempo(segundos):
  segundos = int(segundos)
  h = segundos // 3600
  m = (segundos % 3600) // 60
  s = segundos % 60
  if h > 0:
    return f"{h:02d}:{m:02d}:{s:02d}"
  else:
    return f"{m:02d}:{s:02d}"

def mostrar_progreso(procesados, total, inicio):
  if total == 0:
    return
  porcentaje = (procesados / total)
  ancho_barra = 30
  rellenos = int(ancho_barra * porcentaje)
  barra = "[" + "#" * rellenos + "-" * (ancho_barra - rellenos) + "]"

  transcurrido = time.time() - inicio
  if procesados > 0:
    estimado_total = transcurrido / procesados * total
    restante = max(0, estimado_total - transcurrido)
  else:
    restante = 0

  texto = f"\r{barra} {porcentaje*100:6.2f}%  transcurrido: {formatear_tiempo(transcurrido)}  restante: {formatear_tiempo(restante)}"
  sys.stdout.write(texto)
  sys.stdout.flush()
# ---------------------------------------------

ruta = input("Introduce la ruta de la carpeta: ").strip()

try:
  # Comprobamos que la ruta existe y es una carpeta
  if not os.path.isdir(ruta):
    print("La ruta no es válida")
  else:
    # Preparamos la lista de ítems a procesar (solo primer nivel), excluyendo ZIPs
    items = []
    for nombre in os.listdir(ruta):
      origen = os.path.join(ruta, nombre)
      if os.path.isfile(origen) and origen.lower().endswith(".zip"):
        continue
      items.append(origen)

    total = len(items)
    procesados = 0
    inicio = time.time()
    mostrar_progreso(procesados, total, inicio)

    for origen in items:
      nombre = os.path.basename(origen)

      # Si es una carpeta: crear un ZIP con todo su contenido
      if os.path.isdir(origen):
        destino = origen + ".zip"
        archivozip = zipfile.ZipFile(destino, 'w', zipfile.ZIP_DEFLATED)
        for directorio, subcarpetas, archivos in os.walk(origen):
          for archivo in archivos:
            rutaarchivo = os.path.join(directorio, archivo)
            rutarelativa = os.path.relpath(rutaarchivo, origen)
            archivozip.write(rutaarchivo, rutarelativa)
        archivozip.close()

        # Borrar carpeta original si está activado
        if borrar_originales:
          shutil.rmtree(origen)

      # Si es un archivo: comprimirlo
      elif os.path.isfile(origen):
        destino = origen + ".zip"
        archivo = zipfile.ZipFile(destino, 'w', compression=zipfile.ZIP_DEFLATED)
        archivo.write(origen, arcname=nombre)
        archivo.close()

        # Borrar archivo original si está activado
        if borrar_originales:
          os.remove(origen)

      # Actualizamos progreso
      procesados += 1
      mostrar_progreso(procesados, total, inicio)

    print()  # salto de línea al terminar la barra
    print("Proceso completado.")

except:
  print("\nHa habido un error, continuamos")
```

### Actividades propuestas

### Actividades para Estudiantes de Formación Profesional

#### **Actividad 1: Crear y Eliminar Ficheros**
- **Descripción:** Los estudiantes deben crear un script que cree un fichero con nombre dado por el usuario. Luego, deben implementar una función que elimine ese mismo fichero si existe.
- **Objetivo:** Aprender a trabajar con funciones básicas de manejo de archivos en Python.

#### **Actividad 2: Creación y Eliminación de Carpetas**
- **Descripción:** Los estudiantes deberán crear un script que permita al usuario crear una carpeta con nombre dado. Posteriormente, implementar la eliminación de dicha carpeta si ya existe.
- **Objetivo:** Familiarizarse con el manejo de directorios utilizando el módulo `os`.

#### **Actividad 3: Manejo de Excepciones al Crear Carpetas**
- **Descripción:** Los estudiantes deben crear un script que intente crear una carpeta. Si la carpeta ya existe, se debe mostrar un mensaje indicando que no es posible crearla debido a que ya está presente.
- **Objetivo:** Aprender el uso de excepciones para controlar errores comunes durante la creación y eliminación de archivos o directorios.

#### **Actividad 4: Escritura en Ficheros**
- **Descripción:** Los estudiantes deben escribir un texto específico dentro de un archivo creado previamente. Luego, leer el contenido del archivo para verificar que se haya escrito correctamente.
- **Objetivo:** Aprender a manipular archivos mediante la escritura y lectura de datos.

#### **Actividad 5: Crear y Comprimir Ficheros Individuales**
- **Descripción:** Los estudiantes deben crear un script que comprima en formato ZIP un archivo dado por el usuario.
- **Objetivo:** Utilizar el módulo `zipfile` para la compresión de archivos.

#### **Actividad 6: Crear y Comprimir Carpetas Complejas**
- **Descripción:** Los estudiantes deben escribir un script que tome una carpeta dada como entrada, comprima todos los archivos y subcarpetas dentro de ella en un único archivo ZIP.
- **Objetivo:** Implementar la compresión recursiva de carpetas utilizando el módulo `zipfile`.

#### **Actividad 7: Crear Archivos Zip Con Barra de Progreso**
- **Descripción:** Los estudiantes deben mejorar un script existente para que incluya una barra de progreso y tiempo estimado durante la compresión de archivos o carpetas.
- **Objetivo:** Mejorar el manejo de datos grandes mediante técnicas como barras de progreso y cálculo de tiempos.

#### **Actividad 8: Manejar Subcarpetas al Comprimir**
- **Descripción:** Los estudiantes deben crear un script que permita a los usuarios seleccionar una carpeta, comprimir todos sus contenidos en varios archivos ZIP (uno por subdirectorio), y opcionalmente borrar la carpeta original después de la compresión.
- **Objetivo:** Aprender a navegar y manipular estructuras de carpetas y subcarpetas.

#### **Actividad 9: Comprimir y Borrar Contenido**
- **Descripción:** Los estudiantes deben diseñar un script que tome una carpeta como entrada, comprima todos sus archivos y subcarpetas en ZIPs individuales, y luego borrar el contenido original si se selecciona esta opción.
- **Objetivo:** Mejorar habilidades de gestión de archivos grandes con manejo eficiente de la memoria y recursos.

#### **Actividad 10: Creación Dinámica de Archivos Zip**
- **Descripción:** Los estudiantes deben diseñar un script que permita a los usuarios seleccionar carpetas o archivos específicos para ser comprimidos en ZIPs individuales, proporcionando una opción para borrar el contenido original después de la compresión.
- **Objetivo:** Mejorar habilidades de programación orientada a eventos y manejo dinámico de datos.


<a id="entrada-desde-teclado-salida-a-pantalla-formatos-de-visualizacion"></a>
## Entrada desde teclado. Salida a pantalla. Formatos de visualización

### Introducción a los ejercicios

The Python script you've provided is a series of iterative improvements for managing a simple database of clients, each time adding new functionality or fixing issues. Here's a breakdown of the key steps and their significance:

### 1. **Initial Setup:**
   - The initial version of the script simply allows users to add, list, update, and delete client records in memory.

### 2. **Persistent Storage with `pickle`:**
   - In versions 023 and 024, persistent storage is introduced using the `pickle` module, allowing the program to save data between runs.
   
     ```python
     import pickle
     
     # Load existing clients if file exists
     try:
         archivo = open("clientes.dat", 'rb')
         clientes = pickle.load(archivo)
     except FileNotFoundError:
         print("No existe archivo de datos")
     
     # Save changes back to the file at each step
     while True:
         ...
         with open('clientes.dat', 'wb') as f:  # Use 'wb' mode for binary write
             pickle.dump(clientes, f)
     ```

### 3. **Improving Data Handling:**
   - In version 025, the script uses command-line arguments via `sys.argv` to allow passing data directly to the program.

     ```python
     import sys
     
     if len(sys.argv) > 1:
         edad = int(sys.argv[1])
         print(f"El doble de tu edad es: {edad * 2}")
     else:
         print("No argument provided")
     ```

### Summary of Key Improvements:

- **Persistent Storage:** By using `pickle`, the program can save and load client records between runs, ensuring data isn't lost when the program exits.
  
- **Error Handling:** Proper error handling is added to manage cases where the file doesn't exist yet (e.g., using a try-except block).
  
- **Binary Files:** Using binary mode (`'wb'` for write) ensures that `pickle.dump()` works correctly.

### Future Enhancements:
1. **User Interface Improvements:**
   - Improve user interaction with better error messages and more structured input handling.
   
2. **Database Management:**
   - Consider moving from file-based storage to a proper database (like SQLite or MySQL).
   
3. **Security:**
   - Add security measures such as encryption for sensitive data.

4. **Modularity:**
   - Break down the program into separate modules for better organization and reusability.
   
5. **Command-Line Arguments:**
   - Expand command-line argument handling to support various operations like `--list`, `--add`, etc., making the script more versatile.

This series of improvements is typical in software development, where initial basic functionality evolves with added features, robustness, and efficiency over time.

### Examen de final de trimestre

#### Explicación

Este fragmento de código describe los pasos para crear un programa en Python que implementa las operaciones básicas de gestión de datos conocidas como CRUD (Crear, Leer, Actualizar y Eliminar). El programa presentará al usuario una pantalla inicial de bienvenida seguida por cuatro opciones que permiten interactuar con la información. Cada opción representa una acción diferente: crear un nuevo objeto, leer los objetos existentes, actualizar un objeto ya existente o eliminar uno.

El punto clave es definir una clase para representar una entidad proporcionada (por ejemplo, un libro, estudiante, etc.), pero sin incluir métodos setters y getters tradicionales; en su lugar, permite el acceso directo a sus atributos. Los objetos creados se almacenarán temporalmente en la memoria del programa durante su uso. Sin embargo, para asegurar que esta información no se pierda cuando se cierra el programa, los objetos también se guardarán permanentemente en un archivo de disco utilizando la biblioteca `pickle`.

Este proceso es importante porque permite a los estudiantes entender cómo gestionar datos de manera eficiente en Python y cómo preservar esa información entre sesiones del programa.

```markdown
CRUD en Python (No SQL)
Clases

1.-Presentará una pantalla de bienvenida
2.-Ofrecerá al usuario 4 opciones (Crear, Leer, Actualizar, Eliminar)
3.-Habrá que definir una clase en base a una entidad que os proporcionaré - no métodos set y get, acceso directo
4.-Las entidades se guardarán como objetos en memoria
5.-Las entidades persistirán en disco usando pickle
```

### creamos una clase

#### Explicación

El código que has proporcionado es el inicio de la definición de una clase llamada `Cliente` en Python. Una clase, como esta que estás viendo, es un modelo o plantilla para crear objetos en programación orientada a objetos (OOP). En este caso, está pensado para representar características y comportamientos típicos de un cliente.

La definición de la clase comienza con la palabra clave `class`, seguida del nombre que le damos (`Cliente`), seguido por dos puntos. Aunque el código mostrado no tiene nada más, normalmente aquí es donde agregarías atributos (variables de instancia) y métodos (funciones dentro de la clase) para completar su funcionalidad.

Esta estructura básica es importante porque permite encapsular información relacionada, lo que ayuda a organizar el código y facilita su mantenimiento y extensión en proyectos más grandes.

```python
class Cliente():
  
```

### creamos un constructor

#### Explicación

El código que has proporcionado es el comienzo de la definición de una clase en Python llamada `Cliente`. La clase incluye un método especial denominado `__init__`, que se utiliza para inicializar objetos cuando se crean a partir de esta clase. El método `__init__` recibe por lo menos un parámetro, que es `self`, el cual siempre debe ser el primer argumento en los métodos de una clase y hace referencia al propio objeto.

En este caso, la implementación del método `__init__` está incompleta ya que no se especifican acciones para inicializar atributos del objeto `Cliente`. En una versión completa, dentro del método `__init__`, normalmente se asignarían valores a los atributos del objeto basándose en parámetros proporcionados al crear un nuevo objeto de la clase `Cliente`.

Es importante entender este concepto porque permite establecer las características iniciales de cualquier objeto que creamos a partir de esta clase, lo cual es fundamental para personalizar cada instancia según sea necesario.

```python
class Cliente():
  def __init__(self):
    
```

### el constructor tiene parametros

#### Explicación

Este fragmento de código está creando una clase llamada `Cliente` en Python. La clase tiene un método especial llamado `__init__`, que es el constructor y se ejecuta automáticamente cuando creamos (instanciamos) un objeto de tipo `Cliente`. En este caso, el constructor recibe tres parámetros adicionales: `nombre`, `apellidos` y `email`.

Dentro del constructor, estas variables recibidas como parámetros son asignadas a atributos de la clase con los mismos nombres (`self.nombre = nombre`, etc.). Esto significa que cada objeto de tipo `Cliente` tendrá sus propios valores para el nombre, apellidos y email.

Esta estructura es importante porque permite crear objetos personalizados para diferentes clientes, manteniendo toda la información relevante en un solo lugar. Por ejemplo, podrías crear un cliente llamado "Juan Pérez" con su correo electrónico asociado, y otro cliente con diferente nombre y detalles de contacto sin repetir el código.

```python
class Cliente():
  def __init__(self,nombre,apellidos,email):
    self.nombre = nombre
    self.apellidos = apellidos
    self.email = email
```

### pantalla de bienvenida

#### Explicación

Este código comienza creando una clase llamada `Cliente`. Una clase en Python es como un molde para crear objetos, y este molde tiene tres partes importantes: el nombre del cliente (`nombre`), los apellidos del cliente (`apellidos`) y su correo electrónico (`email`). Cuando creamos un nuevo cliente usando esta clase, necesitamos proporcionar estos tres detalles.

Después de definir la clase `Cliente`, hay dos líneas que imprimen texto en pantalla. Estas líneas muestran una bienvenida sencilla al programa, indicando el nombre del software y del autor. Esto es útil porque ayuda a los usuarios a entender qué están viendo y quién creó el programa.

Este código forma la base para un sistema de gestión de clientes más grande, donde puedes crear objetos `Cliente` con información específica sobre cada cliente que tengas en tu base de datos o en tu lista de contactos.

```python
class Cliente():
  def __init__(self,nombre,apellidos,email):
    self.nombre = nombre
    self.apellidos = apellidos
    self.email = email

print("###### Gestión de clientes v0.1 ######")
print("####### Jose Vicente Carratala  ######")
```

### bucle infinito

#### Explicación

Este código comienza definiendo una clase llamada `Cliente` en Python, que es un bloque de construcción básico utilizado para encapsular información relacionada con clientes, como su nombre, apellidos y email. Cuando se crea un objeto de esta clase (es decir, cuando "instanciamos" la clase), este recibe estos tres datos: el nombre del cliente, sus apellidos y su correo electrónico. Estos detalles son luego guardados dentro del objeto como atributos.

A continuación, el código imprime en pantalla dos líneas con información sobre el programa, incluyendo un título simple y el nombre del autor o desarrollador. Esta parte es importante para proporcionar contexto al usuario acerca de qué hace el programa que está a punto de comenzar a ejecutarse.

Finalmente, el código entra en un bucle infinito (indicado por `while True:`), lo cual significa que se espera que el programa realice acciones repetitivas o espere una entrada del usuario para continuar. Este tipo de estructura es común cuando se necesita mantener al programa activo y responder a solicitudes continuas hasta que el usuario decida terminar la ejecución manualmente.

Es importante notar que, aunque el código muestra los elementos iniciales necesarios (una clase para representar a un cliente y una introducción), falta la lógica principal del bucle infinito. En este punto, sería necesario agregar código dentro de ese ciclo para permitir al usuario interactuar con el programa, como agregar clientes, mostrar información o realizar otras operaciones relacionadas.

```python
class Cliente():
  def __init__(self,nombre,apellidos,email):
    self.nombre = nombre
    self.apellidos = apellidos
    self.email = email

print("###### Gestión de clientes v0.1 ######")
print("####### Jose Vicente Carratala  ######")

while True:
  
```

### creamos lista de entidades

#### Explicación

Este código es el inicio de una aplicación en Python que gestiona una lista de clientes. La clase `Cliente` se define para crear objetos que representan a cada cliente, almacenando su nombre, apellidos y correo electrónico. Estos detalles se almacenan dentro del objeto como atributos cuando un nuevo cliente es creado.

Después de la definición de la clase, el código imprime dos líneas con información sobre la versión del programa y quién lo ha desarrollado. Luego, se crea una lista vacía llamada `clientes`, que será utilizada para almacenar objetos de tipo `Cliente`.

El bucle `while True:` indica que el programa entrará en un ciclo infinito esperando instrucciones, lo cual significa que seguirá ejecutándose hasta que alguien interrumpa su ejecución manualmente. Este diseño es típico en aplicaciones donde se necesita una interfaz de línea de comandos para gestionar datos y realizar operaciones con los clientes.

Este bloque inicial establece la base para añadir funcionalidades más adelante, como permitir al usuario crear, modificar o buscar clientes en la lista `clientes`.

```python
class Cliente():
  def __init__(self,nombre,apellidos,email):
    self.nombre = nombre
    self.apellidos = apellidos
    self.email = email

print("###### Gestión de clientes v0.1 ######")
print("####### Jose Vicente Carratala  ######")

clientes = []

while True:
  
```

### creamos menu

#### Explicación

Este fragmento de código es el comienzo de un programa en Python que gestiona información sobre clientes. Primero, se define una clase llamada `Cliente` que tiene tres propiedades (atributos): nombre, apellidos y email. Estos atributos se inicializan cuando creamos un nuevo objeto del tipo `Cliente`.

A continuación, el código muestra una pantalla de bienvenida e introduce al usuario a la interfaz principal del programa con opciones disponibles. Se utiliza un bucle `while True` que mantiene el menú activo hasta que el usuario decida salir (lo cual no está implementado en este fragmento). Dentro del bucle, se muestra un menú con cuatro opciones: insertar un cliente, listar clientes, actualizar un cliente y eliminar un cliente. El programa solicita al usuario que ingrese una opción elegida utilizando la función `input`, la cual convierte la entrada de texto proporcionada por el usuario en un número entero.

Este código es importante porque establece la estructura básica para interactuar con un sistema de gestión de clientes, permitiendo a los usuarios realizar operaciones CRUD (Crear, Leer, Actualizar y Borrar) sobre registros de clientes.

```python
class Cliente():
  def __init__(self,nombre,apellidos,email):
    self.nombre = nombre
    self.apellidos = apellidos
    self.email = email

print("###### Gestión de clientes v0.1 ######")
print("####### Jose Vicente Carratala  ######")

clientes = []

while True:
  print("Escoge una opción:")
  print("1.-Insertar un cliente")
  print("2.-Listar clientes")
  print("3.-Actualizar un cliente")
  print("4.-Eliminar un cliente")
  opcion = int(input("Escoge una opcion: "))
```

### atrapamos las opciones con if

#### Explicación

Este código es el comienzo de una pequeña aplicación en Python para gestionar clientes. La primera parte del código define una clase llamada `Cliente`, que almacena información sobre cada cliente como su nombre, apellidos y email.

Luego, muestra un menú interactivo en la pantalla con varias opciones: insertar un cliente, listar todos los clientes, actualizar datos de un cliente o eliminar un cliente. Este menú se repite continuamente hasta que el usuario decida salir del programa (aunque no está implementado el caso para salir).

El código pide al usuario que introduzca una opción y la guarda en la variable `opcion`. Si el usuario selecciona la opción 1, debería añadir un nuevo cliente a la lista llamada `clientes`, pero este bloque de código está incompleto. Lo mismo ocurre con las otras opciones (2, 3 y 4), que necesitan ser implementadas para listar los clientes, actualizar sus datos o eliminarlos respectivamente.

Esta estructura de código es importante porque proporciona una interfaz sencilla para interactuar con la base de datos de clientes, permitiendo al usuario realizar diferentes tareas según lo requiera.

```python
class Cliente():
  def __init__(self,nombre,apellidos,email):
    self.nombre = nombre
    self.apellidos = apellidos
    self.email = email

print("###### Gestión de clientes v0.1 ######")
print("####### Jose Vicente Carratala  ######")

clientes = []

while True:
  print("Escoge una opción:")
  print("1.-Insertar un cliente")
  print("2.-Listar clientes")
  print("3.-Actualizar un cliente")
  print("4.-Eliminar un cliente")
  opcion = int(input("Escoge una opcion: "))
  
  if opcion == 1:
    
  elif opcion == 2:
  
  elif opcion == 3:
  
  elif opcion == 4:
    
```

### desarrollamos insertar

#### Explicación

Este código es una parte de un programa en Python que gestiona información sobre clientes. Comienza definiendo una clase llamada `Cliente` que guarda la información personal de cada cliente, como su nombre, apellidos y email. Luego, el programa muestra un menú interactivo con varias opciones para gestionar los datos: insertar nuevos clientes, listar todos los clientes existentes, actualizar la información de un cliente o eliminar a un cliente.

Cuando se selecciona la opción 1 (insertar un cliente), el programa pide al usuario que introduzca el nombre, apellidos y email del nuevo cliente. Estos datos son luego utilizados para crear una nueva instancia de la clase `Cliente` y agregarla a una lista llamada `clientes`. Las otras opciones también tendrían funciones específicas, aunque en este fragmento solo están listadas pero no implementadas.

Este tipo de estructura es importante porque permite al usuario interactuar con el programa de manera sencilla, eligiendo diferentes acciones según sea necesario. Además, esta forma de organizar el código (con una clase para definir objetos y un menú principal) ayuda a mantener el programa ordenado y fácil de expandir en el futuro si se añaden más características o opciones.

```python
class Cliente():
  def __init__(self,nombre,apellidos,email):
    self.nombre = nombre
    self.apellidos = apellidos
    self.email = email

print("###### Gestión de clientes v0.1 ######")
print("####### Jose Vicente Carratala  ######")

clientes = []

while True:
  print("Escoge una opción:")
  print("1.-Insertar un cliente")
  print("2.-Listar clientes")
  print("3.-Actualizar un cliente")
  print("4.-Eliminar un cliente")
  opcion = int(input("Escoge una opcion: "))
  
  if opcion == 1:
    nombre = input("Introduce el nombre: ")
    apellidos = input("Introduce los apellidos: ")
    email = input("Introduce el email: ")
    
  elif opcion == 2:
  
  elif opcion == 3:
  
  elif opcion == 4:
    
```

### apendizamos

#### Explicación

Este fragmento de código es una simple aplicación en Python que gestiona información sobre clientes. La aplicación crea un menú interactivo donde el usuario puede elegir entre varias opciones: insertar un nuevo cliente, listar todos los clientes existentes, actualizar la información de un cliente o eliminar a un cliente.

La clase `Cliente` se utiliza para crear objetos que representan individuos con nombre, apellidos y correo electrónico. Cuando el usuario selecciona la opción 1 ("Insertar un cliente"), el programa solicita al usuario que introduzca estos datos para luego crear una instancia de la clase `Cliente` y agregarla a una lista llamada `clientes`.

El bucle `while True:` asegura que el menú se muestre continuamente hasta que se produzca alguna condición explícita para salir del programa. Aunque las opciones 2, 3 y 4 (listar clientes, actualizar un cliente y eliminar un cliente) no tienen código implementado en este fragmento, se deja claro cómo el usuario podría interaccionar con cada una de ellas.

Esta estructura es importante porque ofrece una forma clara y organizada para manejar datos complejos como la información personal de los clientes. Permite a los usuarios interactuar directamente con la base de datos del programa a través de un menú sencillo, facilitando tanto el uso como la gestión de la información.

```python
class Cliente():
  def __init__(self,nombre,apellidos,email):
    self.nombre = nombre
    self.apellidos = apellidos
    self.email = email

print("###### Gestión de clientes v0.1 ######")
print("####### Jose Vicente Carratala  ######")

clientes = []

while True:
  print("Escoge una opción:")
  print("1.-Insertar un cliente")
  print("2.-Listar clientes")
  print("3.-Actualizar un cliente")
  print("4.-Eliminar un cliente")
  opcion = int(input("Escoge una opcion: "))
  
  if opcion == 1:
    nombre = input("Introduce el nombre: ")
    apellidos = input("Introduce los apellidos: ")
    email = input("Introduce el email: ")
    clientes.append(Cliente(nombre,apellidos,email))
  elif opcion == 2:
  
  elif opcion == 3:
  
  elif opcion == 4:
    
```

### pass de momento

#### Explicación

Este código es una pequeña aplicación en Python que gestiona una lista de clientes. La aplicación comienza definiendo una clase llamada `Cliente`, la cual toma tres parámetros: nombre, apellidos y email al momento de crear un nuevo objeto. Estos datos se guardan como atributos del objeto.

Luego, el programa muestra un menú en pantalla con cuatro opciones para interactuar con la lista de clientes: insertar un cliente, listar todos los clientes, actualizar un cliente o eliminar un cliente. El usuario debe seleccionar una opción introduciendo un número correspondiente a su elección y, dependiendo del caso, proporcionará más detalles como el nombre, apellidos y email si desea agregar un nuevo cliente.

La lista `clientes` guarda objetos de tipo `Cliente`. Cuando se elige la opción 1 (insertar un cliente), el programa solicita al usuario que introduzca los datos necesarios para crear un nuevo objeto `Cliente`, que luego es añadido a la lista `clientes`.

Es importante destacar que las opciones 2, 3 y 4 aún no tienen implementación, ya que en el código aparece la palabra clave `pass` indicando que hay intención de agregar funcionalidad para estas opciones más adelante.

```python
class Cliente():
  def __init__(self,nombre,apellidos,email):
    self.nombre = nombre
    self.apellidos = apellidos
    self.email = email

print("###### Gestión de clientes v0.1 ######")
print("####### Jose Vicente Carratala  ######")

clientes = []

while True:
  print("Escoge una opción:")
  print("1.-Insertar un cliente")
  print("2.-Listar clientes")
  print("3.-Actualizar un cliente")
  print("4.-Eliminar un cliente")
  opcion = int(input("Escoge una opcion: "))
  
  if opcion == 1:
    nombre = input("Introduce el nombre: ")
    apellidos = input("Introduce los apellidos: ")
    email = input("Introduce el email: ")
    clientes.append(Cliente(nombre,apellidos,email))
  elif opcion == 2:
    pass
  elif opcion == 3:
    pass
  elif opcion == 4:
    pass
```

### desarrollo leer

#### Explicación

Este código es una pequeña aplicación en Python que gestiona información sobre clientes. La parte central de la aplicación está basada en una clase llamada `Cliente`, que almacena los datos básicos como el nombre, apellidos y email de cada cliente. Cuando se crea un nuevo objeto de esta clase, estos detalles son introducidos por el usuario a través del teclado.

El programa muestra un menú interactivo que permite al usuario elegir entre diferentes acciones: insertar un nuevo cliente, listar todos los clientes existentes, actualizar la información de un cliente o eliminar un cliente. Para cada opción, se ejecuta una acción específica. Por ejemplo, si el usuario selecciona "Insertar un cliente", se le pedirá que introduzca el nombre, apellidos y email del nuevo cliente, y luego este será añadido a una lista llamada `clientes`.

Esta estructura de menú y objetos es importante porque permite organizar la información de manera clara y facilita la gestión de datos en aplicaciones más grandes. Además, usar clases como `Cliente` ayuda a mantener el código limpio y fácil de entender, ya que encapsula toda la información relacionada con un cliente en un solo lugar.

```python
class Cliente():
  def __init__(self,nombre,apellidos,email):
    self.nombre = nombre
    self.apellidos = apellidos
    self.email = email

print("###### Gestión de clientes v0.1 ######")
print("####### Jose Vicente Carratala  ######")

clientes = []

while True:
  print("Escoge una opción:")
  print("1.-Insertar un cliente")
  print("2.-Listar clientes")
  print("3.-Actualizar un cliente")
  print("4.-Eliminar un cliente")
  opcion = int(input("Escoge una opcion: "))
  
  if opcion == 1:
    nombre = input("Introduce el nombre: ")
    apellidos = input("Introduce los apellidos: ")
    email = input("Introduce el email: ")
    clientes.append(Cliente(nombre,apellidos,email))
  elif opcion == 2:
    for cliente in clientes:
      print(cliente)
  elif opcion == 3:
    pass
  elif opcion == 4:
    pass
```

### imprimimos mejor el cliente

#### Explicación

Este fragmento de código es un programa en Python que permite gestionar una lista de clientes. El programa comienza creando una clase llamada `Cliente`, la cual almacena tres atributos importantes para cada cliente: nombre, apellidos y email. Estos datos se recogen cuando se crea un nuevo objeto del tipo `Cliente` utilizando el método especial `__init__`.

El programa principal utiliza un bucle `while True:` que mantiene la aplicación en ejecución hasta que decidas detenerla manualmente. Dentro de este bucle, se presenta al usuario una lista de opciones: insertar un nuevo cliente, listar todos los clientes existentes, actualizar información de un cliente o eliminar a un cliente.

Cuando el usuario selecciona "Insertar un cliente", se le piden su nombre, apellidos y email por teclado. Luego, esta información se usa para crear una nueva instancia de la clase `Cliente` que es añadida a la lista `clientes`.

La opción "Listar clientes" recorre cada objeto en la lista `clientes` e imprime los datos del cliente (nombre, apellidos y email). Las opciones 3 y 4 ("Actualizar un cliente" y "Eliminar un cliente") están incluidas pero aún no tienen implementación específica (el uso de la palabra clave `pass` indica que esa parte del código está pendiente).

Este tipo de programa es importante porque demuestra cómo se pueden almacenar, manipular y mostrar datos estructurados en Python utilizando objetos y clases.

```python
class Cliente():
  def __init__(self,nombre,apellidos,email):
    self.nombre = nombre
    self.apellidos = apellidos
    self.email = email

print("###### Gestión de clientes v0.1 ######")
print("####### Jose Vicente Carratala  ######")

clientes = []

while True:
  print("Escoge una opción:")
  print("1.-Insertar un cliente")
  print("2.-Listar clientes")
  print("3.-Actualizar un cliente")
  print("4.-Eliminar un cliente")
  opcion = int(input("Escoge una opcion: "))
  
  if opcion == 1:
    nombre = input("Introduce el nombre: ")
    apellidos = input("Introduce los apellidos: ")
    email = input("Introduce el email: ")
    clientes.append(Cliente(nombre,apellidos,email))
  elif opcion == 2:
    for cliente in clientes:
      print(cliente.nombre,cliente.apellidos,cliente.email)
  elif opcion == 3:
    pass
  elif opcion == 4:
    pass
```

### actualizar es como insertar pero con id

#### Explicación

Este fragmento de código es una aplicación simple en Python que permite gestionar datos de clientes. La aplicación utiliza la estructura de clases, específicamente `Cliente`, para almacenar información sobre cada cliente como nombre, apellidos y email. Cada vez que un usuario inserta un nuevo cliente, se crea una nueva instancia de la clase `Cliente` con los datos proporcionados y se añade a una lista llamada `clientes`.

El programa ofrece al usuario cuatro opciones principales: Insertar un cliente (opción 1), listar todos los clientes existentes (opción 2), actualizar información de un cliente específico (opción 3) y eliminar un cliente (opción 4). Para cada opción, se solicita la entrada del usuario a través de comandos `input()`. Por ejemplo, al elegir insertar un cliente, el programa pide que introduzca el nombre, apellidos y email, creando así una nueva instancia de `Cliente` y agregándola a la lista.

Es importante notar que la opción para actualizar (opcion 3) está incompleta y presenta errores. Se solicita al usuario que ingrese un identificador pero no se ha implementado ningún sistema para manejar los IDs, lo cual es necesario ya que en este punto el código intenta acceder a `clientes[identificador]`, asumiendo que este identificador es una posición válida en la lista de clientes. Para corregir esto, necesitaríamos agregar lógica adicional para encontrar y actualizar correctamente el cliente basado en su ID.

Esta estructura básica ayuda a entender cómo se puede organizar un programa más complejo en Python utilizando clases y bucles, además de cómo manejar entradas del usuario y almacenar datos de forma eficiente.

```python
class Cliente():
  def __init__(self,nombre,apellidos,email):
    self.nombre = nombre
    self.apellidos = apellidos
    self.email = email

print("###### Gestión de clientes v0.1 ######")
print("####### Jose Vicente Carratala  ######")

clientes = []

while True:
  print("Escoge una opción:")
  print("1.-Insertar un cliente")
  print("2.-Listar clientes")
  print("3.-Actualizar un cliente")
  print("4.-Eliminar un cliente")
  opcion = int(input("Escoge una opcion: "))
  
  if opcion == 1:
    nombre = input("Introduce el nombre: ")
    apellidos = input("Introduce los apellidos: ")
    email = input("Introduce el email: ")
    clientes.append(Cliente(nombre,apellidos,email))
  elif opcion == 2:
    for cliente in clientes:
      print(cliente.nombre,cliente.apellidos,cliente.email)
  elif opcion == 3:
    identificador = input("Introduce el id para modificar: ")
    nombre = input("Introduce el nombre: ")
    apellidos = input("Introduce los apellidos: ")
    email = input("Introduce el email: ")
    clientes[identificador].nombre = nombre
    clientes[identificador].apellidos = apellidos
    clientes[identificador].email = email
    pass
  elif opcion == 4:
    pass
```

### chivamos el id

#### Explicación

Este código es una pequeña aplicación en Python que gestiona una lista de clientes. La aplicación se ejecuta en un bucle infinito (`while True`) que presenta al usuario cuatro opciones: insertar, listar, actualizar y eliminar un cliente. Cada opción tiene su propia funcionalidad:

1. **Insertar un Cliente:** Cuando el usuario selecciona la opción 1, se solicitan por teclado los datos del nuevo cliente (nombre, apellidos y email). Estos datos son usados para crear una nueva instancia de la clase `Cliente`, que luego se añade a la lista `clientes`.

2. **Listar Clientes:** Si el usuario elige listar clientes (opción 2), el programa recorre la lista `clientes` e imprime en pantalla los detalles de cada cliente, junto con un identificador numérico que indica su posición en la lista.

3. **Actualizar Cliente:** La opción para actualizar (número 3) pide al usuario que introduzca el ID del cliente que quiere modificar, así como los nuevos datos (nombre, apellidos y email). Posteriormente, se actualizan los campos correspondientes de la instancia `Cliente` en la lista.

4. **Eliminar Cliente:** Aunque está definida la opción para eliminar un cliente (número 4), el código no implementa esta funcionalidad todavía ya que el bloque está vacío (`pass`).

Esta aplicación es útil para comprender cómo trabajar con clases, listas y estructuras condicionales en Python, además de cómo interactuar con el usuario a través del teclado y la pantalla.

```python
class Cliente():
  def __init__(self,nombre,apellidos,email):
    self.nombre = nombre
    self.apellidos = apellidos
    self.email = email

print("###### Gestión de clientes v0.1 ######")
print("####### Jose Vicente Carratala  ######")

clientes = []

while True:
  print("Escoge una opción:")
  print("1.-Insertar un cliente")
  print("2.-Listar clientes")
  print("3.-Actualizar un cliente")
  print("4.-Eliminar un cliente")
  opcion = int(input("Escoge una opcion: "))
  
  if opcion == 1:
    nombre = input("Introduce el nombre: ")
    apellidos = input("Introduce los apellidos: ")
    email = input("Introduce el email: ")
    clientes.append(Cliente(nombre,apellidos,email))
  elif opcion == 2:
    identificador = 0
    for cliente in clientes:
      print("Este es el cliente con ID:",identificador)
      print(cliente.nombre,cliente.apellidos,cliente.email)
      identificador += 1
  elif opcion == 3:
    identificador = int(input("Introduce el id para modificar: "))
    nombre = input("Introduce el nombre: ")
    apellidos = input("Introduce los apellidos: ")
    email = input("Introduce el email: ")
    clientes[identificador].nombre = nombre
    clientes[identificador].apellidos = apellidos
    clientes[identificador].email = email
  elif opcion == 4:
    pass
```

### eliminar elemento

#### Explicación

Este código es una pequeña aplicación en Python que gestiona los datos de clientes. En primer lugar, se define una clase llamada `Cliente` que almacena tres atributos importantes: nombre, apellidos y email. Cada vez que se crea un nuevo objeto `Cliente`, estos atributos son inicializados con valores proporcionados por el usuario.

El programa principal se ejecuta en un bucle infinito (`while True`) que muestra un menú de opciones al usuario para interactuar con la lista de clientes. Las opciones incluyen insertar un nuevo cliente, listar todos los clientes existentes, actualizar la información de un cliente y eliminar un cliente específico basándose en su índice o identificador.

Para cada opción seleccionada por el usuario, se realiza una acción específica: si el usuario elige "Insertar un cliente", se solicitan al usuario el nombre, apellidos y email del nuevo cliente, y luego se crea un objeto `Cliente` con esos datos que se añade a la lista de clientes. Si el usuario elige "Listar clientes", el programa recorre la lista de clientes e imprime en pantalla los detalles de cada uno.

En caso de querer actualizar o eliminar un cliente, el programa solicita al usuario el identificador del cliente que desea modificar o borrar y luego permite cambiar sus datos o quitarlo de la lista respectivamente. Hay una pequeña errata al final del código: en lugar de `clientes.splice(identificador,1)`, debería ser `del clientes[identificador]` para eliminar un elemento específico de la lista.

Esta aplicación es importante porque demuestra cómo se pueden utilizar clases y listas en Python para manejar datos complejos de manera estructurada y como se interactúa con el usuario a través de entradas y salidas simples.

```python
class Cliente():
  def __init__(self,nombre,apellidos,email):
    self.nombre = nombre
    self.apellidos = apellidos
    self.email = email

print("###### Gestión de clientes v0.1 ######")
print("####### Jose Vicente Carratala  ######")

clientes = []

while True:
  print("Escoge una opción:")
  print("1.-Insertar un cliente")
  print("2.-Listar clientes")
  print("3.-Actualizar un cliente")
  print("4.-Eliminar un cliente")
  opcion = int(input("Escoge una opcion: "))
  
  if opcion == 1:
    nombre = input("Introduce el nombre: ")
    apellidos = input("Introduce los apellidos: ")
    email = input("Introduce el email: ")
    clientes.append(Cliente(nombre,apellidos,email))
  elif opcion == 2:
    identificador = 0
    for cliente in clientes:
      print("Este es el cliente con ID:",identificador)
      print(cliente.nombre,cliente.apellidos,cliente.email)
      identificador += 1
  elif opcion == 3:
    identificador = int(input("Introduce el id para modificar: "))
    nombre = input("Introduce el nombre: ")
    apellidos = input("Introduce los apellidos: ")
    email = input("Introduce el email: ")
    clientes[identificador].nombre = nombre
    clientes[identificador].apellidos = apellidos
    clientes[identificador].email = email
  elif opcion == 4:
    identificador = int(input("Introduce el id para eliminar: "))
    clientes.splice(identificador,1)
```

### confirmacion

#### Explicación

Este fragmento de código es una pequeña aplicación en Python que gestiona un registro de clientes. La aplicación comienza creando una clase llamada `Cliente` que almacena la información personal de cada cliente, como nombre, apellidos y correo electrónico. Luego, el programa entra en un bucle infinito (`while True`) donde muestra un menú con opciones para insertar, listar, actualizar o eliminar clientes del registro.

Cada opción del menú realiza una tarea específica:
- La opción 1 permite al usuario introducir los datos de un nuevo cliente y añadirlo a la lista `clientes`.
- La opción 2 muestra en pantalla todos los clientes existentes junto con su índice en la lista.
- La opción 3 pide al usuario que seleccione el índice del cliente que desea modificar, luego solicita nuevas entradas para nombre, apellidos y correo electrónico, y actualiza la información correspondiente en la clase `Cliente`.
- La opción 4 permite seleccionar un cliente para eliminar, pero antes de hacerlo, pregunta por confirmación. Si el usuario responde con 'S' (Sí), elimina al cliente; si responde con 'N' (No), cancela la operación.

Es importante notar que en la opción 4, hay un error en la línea donde intenta eliminar un elemento de una lista (`clientes.splice(identificador,1)`). En Python, para borrar un elemento de una lista se usa `del clientes[identificador]` o `clientes.pop(identificador)`.

```python
class Cliente():
  def __init__(self,nombre,apellidos,email):
    self.nombre = nombre
    self.apellidos = apellidos
    self.email = email

print("###### Gestión de clientes v0.1 ######")
print("####### Jose Vicente Carratala  ######")

clientes = []

while True:
  print("Escoge una opción:")
  print("1.-Insertar un cliente")
  print("2.-Listar clientes")
  print("3.-Actualizar un cliente")
  print("4.-Eliminar un cliente")
  opcion = int(input("Escoge una opcion: "))
  
  if opcion == 1:
    nombre = input("Introduce el nombre: ")
    apellidos = input("Introduce los apellidos: ")
    email = input("Introduce el email: ")
    clientes.append(Cliente(nombre,apellidos,email))
  elif opcion == 2:
    identificador = 0
    for cliente in clientes:
      print("Este es el cliente con ID:",identificador)
      print(cliente.nombre,cliente.apellidos,cliente.email)
      identificador += 1
  elif opcion == 3:
    identificador = int(input("Introduce el id para modificar: "))
    nombre = input("Introduce el nombre: ")
    apellidos = input("Introduce los apellidos: ")
    email = input("Introduce el email: ")
    clientes[identificador].nombre = nombre
    clientes[identificador].apellidos = apellidos
    clientes[identificador].email = email
  elif opcion == 4:
    identificador = int(input("Introduce el id para eliminar: "))
    confirmacion = input("¿Estás seguro? (S/N): ")
    if confirmacion == "S":
      clientes.splice(identificador,1)
    elif confirmacion == "N":
      print("Cancelado")
    else:
      print("Opción no válida")
```

### mayusculas minusculas

#### Explicación

Este código Python crea una pequeña aplicación de gestión de clientes que permite al usuario realizar varias operaciones como insertar, listar, actualizar y eliminar registros de clientes. La clase `Cliente` se utiliza para almacenar información básica sobre cada cliente, incluyendo su nombre, apellidos y email.

El programa comienza mostrando un menú interactivo en el que el usuario puede elegir entre diferentes acciones. Cuando el usuario selecciona una opción, el código ejecuta la lógica correspondiente: 

- Para insertar un cliente, solicita al usuario que introduzca los datos del nuevo cliente y luego crea una instancia de `Cliente` con esos datos, añadiéndola a la lista `clientes`.
  
- Para listar clientes, recorre la lista `clientes` e imprime en pantalla el identificador junto con los detalles (nombre, apellidos y email) de cada cliente.

- Para actualizar un cliente, primero pide al usuario que introduzca el ID del cliente que desea modificar. Luego solicita nuevos valores para nombre, apellidos y correo electrónico, actualizando los datos correspondientes en la lista `clientes`.

- Finalmente, para eliminar un cliente, también requiere un ID de cliente, pero antes de hacerlo, pide una confirmación al usuario. Si el usuario confirma (introduciendo 'S' o 's'), se intenta eliminar el cliente; si no es así, muestra un mensaje cancelando la operación.

Es importante notar que hay un error en el código: `clientes.splice(identificador,1)` no existe en Python. Este método sería válido para JavaScript, pero en Python deberías usar métodos como `del clientes[identificador]` o manipular directamente la lista mediante slices para eliminar elementos.

```python
class Cliente():
  def __init__(self,nombre,apellidos,email):
    self.nombre = nombre
    self.apellidos = apellidos
    self.email = email

print("###### Gestión de clientes v0.1 ######")
print("####### Jose Vicente Carratala  ######")

clientes = []

while True:
  print("Escoge una opción:")
  print("1.-Insertar un cliente")
  print("2.-Listar clientes")
  print("3.-Actualizar un cliente")
  print("4.-Eliminar un cliente")
  opcion = int(input("Escoge una opcion: "))
  
  if opcion == 1:
    nombre = input("Introduce el nombre: ")
    apellidos = input("Introduce los apellidos: ")
    email = input("Introduce el email: ")
    clientes.append(Cliente(nombre,apellidos,email))
  elif opcion == 2:
    identificador = 0
    for cliente in clientes:
      print("Este es el cliente con ID:",identificador)
      print(cliente.nombre,cliente.apellidos,cliente.email)
      identificador += 1
  elif opcion == 3:
    identificador = int(input("Introduce el id para modificar: "))
    nombre = input("Introduce el nombre: ")
    apellidos = input("Introduce los apellidos: ")
    email = input("Introduce el email: ")
    clientes[identificador].nombre = nombre
    clientes[identificador].apellidos = apellidos
    clientes[identificador].email = email
  elif opcion == 4:
    identificador = int(input("Introduce el id para eliminar: "))
    confirmacion = input("¿Estás seguro? (S/N): ")
    if confirmacion == "S" or confirmacion == "s":
      clientes.splice(identificador,1)
    elif confirmacion == "N" or confirmacion == "n":
      print("Cancelado")
    else:
      print("Opción no válida")
```

### lower

#### Explicación

Este código es una pequeña aplicación en Python que gestiona una lista de clientes. Se define primero una clase llamada `Cliente` que contiene tres atributos: nombre, apellidos y email. Esta clase permite crear objetos que representan a cada cliente con los datos proporcionados por el usuario.

El programa luego entra en un bucle infinito (`while True:`) donde se muestra al usuario un menú con cuatro opciones: insertar un nuevo cliente, listar todos los clientes existentes, actualizar la información de un cliente específico o eliminar un cliente. Dependiendo de la opción elegida por el usuario (mediante entradas numéricas), el programa realiza las acciones correspondientes.

Es importante destacar que cuando se intenta eliminar un cliente, el programa solicita una confirmación al usuario para evitar errores inesperados. Si el usuario responde con "s" (si), se procede a eliminar; si responde con "n" (no), la operación es cancelada. Sin embargo, hay un error en el código: `clientes.splice(identificador,1)` no es una función válida en Python para eliminar elementos de una lista. Para corregirlo, debería usarse `del clientes[identificador]` o bien `clientes.pop(identificador)`.

```python
class Cliente():
  def __init__(self,nombre,apellidos,email):
    self.nombre = nombre
    self.apellidos = apellidos
    self.email = email

print("###### Gestión de clientes v0.1 ######")
print("####### Jose Vicente Carratala  ######")

clientes = []

while True:
  print("Escoge una opción:")
  print("1.-Insertar un cliente")
  print("2.-Listar clientes")
  print("3.-Actualizar un cliente")
  print("4.-Eliminar un cliente")
  opcion = int(input("Escoge una opcion: "))
  
  if opcion == 1:
    nombre = input("Introduce el nombre: ")
    apellidos = input("Introduce los apellidos: ")
    email = input("Introduce el email: ")
    clientes.append(Cliente(nombre,apellidos,email))
  elif opcion == 2:
    identificador = 0
    for cliente in clientes:
      print("Este es el cliente con ID:",identificador)
      print(cliente.nombre,cliente.apellidos,cliente.email)
      identificador += 1
  elif opcion == 3:
    identificador = int(input("Introduce el id para modificar: "))
    nombre = input("Introduce el nombre: ")
    apellidos = input("Introduce los apellidos: ")
    email = input("Introduce el email: ")
    clientes[identificador].nombre = nombre
    clientes[identificador].apellidos = apellidos
    clientes[identificador].email = email
  elif opcion == 4:
    identificador = int(input("Introduce el id para eliminar: "))
    confirmacion = input("¿Estás seguro? (S/N): ").lower()
    if confirmacion == "s":
      clientes.splice(identificador,1)
    elif confirmacion == "n":
      print("Cancelado")
    else:
      print("Opción no válida")
```

### cambiamos splice por pop

#### Explicación

Este código es una pequeña aplicación en Python que permite gestionar la información de los clientes a través de un menú interactivo. La clase `Cliente` almacena los datos personales como nombre, apellidos y email de cada cliente.

El programa muestra un menú con cuatro opciones: insertar un nuevo cliente, listar todos los clientes existentes, actualizar la información de un cliente específico e incluso eliminar a un cliente del sistema basándose en su identificador. Las opciones se gestionan usando bucles y condicionales para interactuar con el usuario y permitirle elegir qué acción desea realizar.

La opción 4 incluye una validación adicional donde pide al usuario que confirme la eliminación de un cliente antes de proceder, lo cual es una buena práctica para evitar errores no intencionados. En resumen, este código proporciona una interfaz simple y directa para manipular datos de clientes en una lista llamada `clientes`.

```python
class Cliente():
  def __init__(self,nombre,apellidos,email):
    self.nombre = nombre
    self.apellidos = apellidos
    self.email = email

print("###### Gestión de clientes v0.1 ######")
print("####### Jose Vicente Carratala  ######")

clientes = []

while True:
  print("Escoge una opción:")
  print("1.-Insertar un cliente")
  print("2.-Listar clientes")
  print("3.-Actualizar un cliente")
  print("4.-Eliminar un cliente")
  opcion = int(input("Escoge una opcion: "))
  
  if opcion == 1:
    nombre = input("Introduce el nombre: ")
    apellidos = input("Introduce los apellidos: ")
    email = input("Introduce el email: ")
    clientes.append(Cliente(nombre,apellidos,email))
  elif opcion == 2:
    identificador = 0
    for cliente in clientes:
      print("Este es el cliente con ID:",identificador)
      print(cliente.nombre,cliente.apellidos,cliente.email)
      identificador += 1
  elif opcion == 3:
    identificador = int(input("Introduce el id para modificar: "))
    nombre = input("Introduce el nombre: ")
    apellidos = input("Introduce los apellidos: ")
    email = input("Introduce el email: ")
    clientes[identificador].nombre = nombre
    clientes[identificador].apellidos = apellidos
    clientes[identificador].email = email
  elif opcion == 4:
    identificador = int(input("Introduce el id para eliminar: "))
    confirmacion = input("¿Estás seguro? (S/N): ").lower()
    if confirmacion == "s":
      clientes.pop(identificador)
    elif confirmacion == "n":
      print("Cancelado")
    else:
      print("Opción no válida")
```

### guardamos con pickle

#### Explicación

Este código es una pequeña aplicación en Python que permite gestionar un registro de clientes. Comienza importando la biblioteca `pickle`, aunque en este fragmento no se utiliza para guardar o cargar datos desde un archivo.

La aplicación define una clase llamada `Cliente` con tres atributos: nombre, apellidos y email. Estos son inicializados cuando se crea un nuevo objeto de la clase usando el método `__init__`.

El programa principal muestra un menú en bucle que permite al usuario realizar varias operaciones sobre los clientes:

1. Insertar un cliente nuevo.
2. Listar todos los clientes registrados.
3. Actualizar información de un cliente existente.
4. Eliminar un cliente.

Cuando el usuario selecciona una opción, el programa solicita la entrada desde el teclado (por ejemplo, introducir nombre y apellidos) y realiza las operaciones correspondientes según lo elegido. Para actualizar o eliminar clientes, se pide al usuario que introduzca el identificador del cliente en cuestión para aplicar los cambios precisamente a ese registro.

Este tipo de programa es importante porque enseña cómo trabajar con clases, estructuras de datos como listas y bucles condicionales en Python. Además, muestra la forma en que se interactúa con el usuario mediante entradas y salidas estándar para gestionar un sistema simple pero funcional de administración de clientes.

```python
import pickle

class Cliente():
  def __init__(self,nombre,apellidos,email):
    self.nombre = nombre
    self.apellidos = apellidos
    self.email = email

print("###### Gestión de clientes v0.1 ######")
print("####### Jose Vicente Carratala  ######")

clientes = []


while True:
  print("Escoge una opción:")
  print("1.-Insertar un cliente")
  print("2.-Listar clientes")
  print("3.-Actualizar un cliente")
  print("4.-Eliminar un cliente")
  opcion = int(input("Escoge una opcion: "))
  
  if opcion == 1:
    nombre = input("Introduce el nombre: ")
    apellidos = input("Introduce los apellidos: ")
    email = input("Introduce el email: ")
    clientes.append(Cliente(nombre,apellidos,email))
  elif opcion == 2:
    identificador = 0
    for cliente in clientes:
      print("Este es el cliente con ID:",identificador)
      print(cliente.nombre,cliente.apellidos,cliente.email)
      identificador += 1
  elif opcion == 3:
    identificador = int(input("Introduce el id para modificar: "))
    nombre = input("Introduce el nombre: ")
    apellidos = input("Introduce los apellidos: ")
    email = input("Introduce el email: ")
    clientes[identificador].nombre = nombre
    clientes[identificador].apellidos = apellidos
    clientes[identificador].email = email
  elif opcion == 4:
    identificador = int(input("Introduce el id para eliminar: "))
    confirmacion = input("¿Estás seguro? (S/N): ").lower()
    if confirmacion == "s":
      clientes.pop(identificador)
    elif confirmacion == "n":
      print("Cancelado")
    else:
      print("Opción no válida")
```

### cargo registros si existen

#### Explicación

Este código es una pequeña aplicación de consola en Python que gestiona los datos de los clientes. La aplicación permite a un usuario realizar diversas acciones como insertar, listar, actualizar y eliminar registros de clientes utilizando el método del archivo binario para almacenar la información persistente.

En primer lugar, se importa el módulo `pickle` que es utilizado para serializar objetos de Python y guardarlos en archivos, permitiendo así recuperar los datos cuando se necesiten. La clase `Cliente` define un objeto básico con atributos como nombre, apellidos y correo electrónico.

El programa comienza leyendo un archivo llamado "clientes.dat" si existe; este archivo almacena una lista de objetos del tipo `Cliente`. Si el archivo no está presente, imprime un mensaje indicando que no existe. Luego, se entra en un bucle infinito (`while True`) donde se presenta un menú al usuario para que pueda seleccionar entre diferentes operaciones: insertar un nuevo cliente, listar todos los clientes registrados, actualizar información de un cliente existente o eliminar un cliente.

Cada opción del menú lleva a la ejecución de una acción específica. Por ejemplo, si el usuario selecciona "1" para insertar un cliente, se solicitan al usuario datos como nombre, apellidos y correo electrónico que luego se utilizan para crear un nuevo objeto `Cliente` y añadirlo a la lista `clientes`. Cuando el usuario desea listar clientes ("2"), el programa recorre la lista de objetos `Cliente`, mostrando en pantalla los detalles de cada uno. Las opciones "3" y "4" permiten actualizar o eliminar registros, respectivamente, siempre confirmando con el usuario para prevenir acciones no deseadas.

Esta aplicación es importante porque demuestra cómo gestionar datos estructurados usando clases en Python, y cómo almacenar y recuperar objetos complejos a través de archivos. Además, proporciona un ejemplo práctico sobre cómo manejar excepciones (como intentar abrir un archivo que no existe) y guiar al usuario a través de diferentes operaciones con una interfaz sencilla pero funcional.

```python
import pickle

class Cliente():
  def __init__(self,nombre,apellidos,email):
    self.nombre = nombre
    self.apellidos = apellidos
    self.email = email

print("###### Gestión de clientes v0.1 ######")
print("####### Jose Vicente Carratala  ######")

clientes = []

try:  #### Ojo que igual no existe el archivo ######
  archivo = open("clientes.dat",'rb')
  clientes = pickle.load(archivo)
except:
  print("No existe archivo de datos")

while True:
  print("Escoge una opción:")
  print("1.-Insertar un cliente")
  print("2.-Listar clientes")
  print("3.-Actualizar un cliente")
  print("4.-Eliminar un cliente")
  opcion = int(input("Escoge una opcion: "))
  
  if opcion == 1:
    nombre = input("Introduce el nombre: ")
    apellidos = input("Introduce los apellidos: ")
    email = input("Introduce el email: ")
    clientes.append(Cliente(nombre,apellidos,email))
  elif opcion == 2:
    identificador = 0
    for cliente in clientes:
      print("Este es el cliente con ID:",identificador)
      print(cliente.nombre,cliente.apellidos,cliente.email)
      identificador += 1
  elif opcion == 3:
    identificador = int(input("Introduce el id para modificar: "))
    nombre = input("Introduce el nombre: ")
    apellidos = input("Introduce los apellidos: ")
    email = input("Introduce el email: ")
    clientes[identificador].nombre = nombre
    clientes[identificador].apellidos = apellidos
    clientes[identificador].email = email
  elif opcion == 4:
    identificador = int(input("Introduce el id para eliminar: "))
    confirmacion = input("¿Estás seguro? (S/N): ").lower()
    if confirmacion == "s":
      clientes.pop(identificador)
    elif confirmacion == "n":
      print("Cancelado")
    else:
      print("Opción no válida")
```

### guardamos

#### Explicación

Este código es una aplicación simple en Python que gestiona la información de los clientes mediante un menú interactivo. La aplicación utiliza el módulo `pickle` para guardar y cargar datos de un archivo binario llamado "clientes.bin". Al iniciar, el programa intenta abrir este archivo y cargar cualquier lista de objetos cliente existentes. Si no existe el archivo, simplemente muestra un mensaje indicando que no hay datos guardados.

La parte central del código es un bucle infinito (`while True`) donde se presenta al usuario un menú con opciones para insertar un nuevo cliente, listar los clientes existentes, actualizar la información de un cliente o eliminar a un cliente. Cada opción tiene su propio bloque de código que maneja las entradas del usuario y modifica la lista de clientes en consecuencia.

Después de cada operación (independientemente de si el usuario ha seleccionado insertar, listar, actualizar o eliminar), se guarda la actualización de los datos en el archivo "clientes.bin". Esto asegura que cualquier cambio realizado por el usuario se guarde permanentemente y esté disponible en futuras ejecuciones del programa. Es una manera simple pero efectiva de mantener un registro persistente de los clientes utilizando estructuras de datos en memoria con Python.

Este tipo de código es importante porque enseña a los estudiantes cómo gestionar la persistencia de datos, manejar excepciones (como cuando el archivo no existe), y cómo interactuar con los usuarios mediante entradas y salidas en consola. Además, muestra cómo encapsular información compleja en objetos personalizados (`class Cliente`) para organizar mejor las tareas del programa.

```python
import pickle

class Cliente():
  def __init__(self,nombre,apellidos,email):
    self.nombre = nombre
    self.apellidos = apellidos
    self.email = email

print("###### Gestión de clientes v0.1 ######")
print("####### Jose Vicente Carratala  ######")

clientes = []

try:  #### Ojo que igual no existe el archivo ######
  archivo = open("clientes.bin",'rb')
  clientes = pickle.load(archivo)
  archivo.close()
except:
  print("No existe archivo de datos")

while True:
  archivo = open("clientes.bin",'wb')
  pickle.dump(clientes,archivo)
  archivo.close()
  
  print("Escoge una opción:")
  print("1.-Insertar un cliente")
  print("2.-Listar clientes")
  print("3.-Actualizar un cliente")
  print("4.-Eliminar un cliente")
  opcion = int(input("Escoge una opcion: "))
  
  if opcion == 1:
    nombre = input("Introduce el nombre: ")
    apellidos = input("Introduce los apellidos: ")
    email = input("Introduce el email: ")
    clientes.append(Cliente(nombre,apellidos,email))
  elif opcion == 2:
    identificador = 0
    for cliente in clientes:
      print("Este es el cliente con ID:",identificador)
      print(cliente.nombre,cliente.apellidos,cliente.email)
      identificador += 1
  elif opcion == 3:
    identificador = int(input("Introduce el id para modificar: "))
    nombre = input("Introduce el nombre: ")
    apellidos = input("Introduce los apellidos: ")
    email = input("Introduce el email: ")
    clientes[identificador].nombre = nombre
    clientes[identificador].apellidos = apellidos
    clientes[identificador].email = email
  elif opcion == 4:
    identificador = int(input("Introduce el id para eliminar: "))
    confirmacion = input("¿Estás seguro? (S/N): ").lower()
    if confirmacion == "s":
      clientes.pop(identificador)
    elif confirmacion == "n":
      print("Cancelado")
    else:
      print("Opción no válida")
  
```

### argumentos de terminal

#### Explicación

Este código en Python se utiliza para recibir un argumento de la línea de comandos (terminal) y realizar una operación sencilla con él. La primera línea `import sys` importa el módulo `sys`, que proporciona acceso a algunas variables y funciones que interactúan con el intérprete de Python, incluyendo la lista de argumentos pasados desde la terminal.

Luego, `edad = int(sys.argv[1])` toma el segundo argumento pasado en la línea de comandos (el primer elemento de `sys.argv`, que es siempre "nombre_del_archivo.py", se ignora y se considera como `argv[0]`). Este valor se espera que sea una cadena numérica, que luego convierte a un número entero para almacenarlo en la variable `edad`.

Finalmente, el código calcula el doble de la edad proporcionada y lo imprime en pantalla con la ayuda de la función `print()`. Esto es útil cuando deseas que tu programa reciba información del usuario directamente desde la línea de comandos sin necesidad de un interfaz gráfica o de texto dentro del propio script.

```python
import sys

edad = int(sys.argv[1])
print("El doble de tu edad es:",(edad*2))
```

### Actividades propuestas

Here's a summary and explanation of the progression in the code snippets you've shared:

### Initial Setup (Files 001-003)
The first few files establish the basic structure for managing customer data. They use simple data structures like lists to store customer objects, and the `pickle` module to serialize and deserialize Python objects.

### Adding Interactivity (Files 004-015)
Starting from file 004, the code introduces user interaction:
- **File Input/Output:** The program begins to save and load data between runs.
- **User Interface:** It provides a basic command-line interface for users to interact with the customer database.

### Improving User Experience (Files 016-022)
The focus shifts towards enhancing user experience:
- **Error Handling:** Added try-except blocks to handle file operations more gracefully.
- **Input Validation:** Improved input handling, especially for confirmation prompts.
- **Command-Line Arguments:** The program starts using `sys.argv` to accept command-line arguments.

### Final Version (File 025)
The final version of the code combines all previous improvements and demonstrates how to:
1. Load existing customer data from a file.
2. Provide a simple menu system for CRUD operations.
3. Automatically save changes back to the file when exiting.
4. Accept command-line arguments to run specific functions or tests.

### Key Learnings
- **Data Persistence:** Using `pickle` for saving and loading Python objects to/from files is a common technique in small-scale applications.
- **User Interaction:** Building simple text-based interfaces helps users interact with data management systems effectively.
- **Error Handling:** Proper error handling ensures the program can recover from unexpected situations gracefully.
- **Command-Line Interfaces:** Using `sys.argv` for command-line arguments allows scripts to be more flexible and integrate better with other tools.

This progression demonstrates how a basic application can evolve from simple data storage to a robust system capable of handling user input, errors, and external parameters.


<a id="interfaces-graficas"></a>
## Interfaces gráficas

### Introducción a los ejercicios

En esta carpeta, se encuentran una serie de ejercicios que tienen como objetivo familiarizarte con la creación y manipulación de interfaces gráficas en Python utilizando la biblioteca Tkinter. Los ejercicios comienzan con la creación básica de ventanas y botones, para luego avanzar hacia el manejo de eventos, cambios dinámicos en las etiquetas y finalmente, la implementación de una sencilla calculadora que realiza operaciones matemáticas básicas.

A lo largo del conjunto de ejercicios, aprenderás a crear widgets (como entradas de texto y botones), gestionar su disposición en la interfaz gráfica, vincular eventos con funciones para responder a acciones del usuario e interactuar con los elementos visuales de la aplicación. Esto te permitirá adquirir competencias fundamentales en el diseño y desarrollo de interfaces de usuario simples utilizando Tkinter.

### tkinter

#### Explicación

Este fragmento de código está usando una biblioteca llamada `tkinter` para crear interfaces gráficas en Python. Lo primero que hace es importar la biblioteca `tkinter` y renombrarla como `tk`, lo cual facilita su uso posterior.

Luego, el código crea una ventana principal con la línea `ventana = tk.Tk()`. Esta línea genera una nueva ventana donde puedes añadir elementos gráficos como botones, etiquetas o cuadros de texto. Es esencial porque sin esta línea no tendríamos ningún espacio en pantalla para visualizar nuestra interfaz.

Finalmente, se llama a la función `ventana.mainloop()` que mantiene abierta la ventana y espera interacciones del usuario. Esta línea asegura que la aplicación gráfica funcione correctamente, ya que maneja eventos como clics de ratón o teclas pulsadas hasta que el usuario decide cerrar la ventana.

En resumen, este código básico establece las bases para crear más complejas interfaces gráficas en Python usando `tkinter`.

```python
# sudo apt-get install python3-tk
import tkinter as tk

ventana = tk.Tk()

ventana.mainloop() # No te salgas
```

### creamos un boton

#### Explicación

Este código crea una interfaz gráfica muy simple usando la biblioteca `tkinter` en Python. La línea `import tkinter as tk` carga esta biblioteca y le da el nombre abreviado "tk", lo que permite usar las funciones de manera más concisa posteriormente.

La instrucción `ventana = tk.Tk()` crea una ventana principal donde se mostrarán todos los elementos gráficos. Luego, `tk.Button(ventana,text="Pulsame si te atreves").pack(padx=10,pady=10)` añade un botón a esta ventana con el texto "Pulsame si te atreves". La función `.pack()` ajusta automáticamente el tamaño del botón para que coincida con su contenido y `padx` e `pady` añaden espacios alrededor del botón para mejorar la apariencia.

Finalmente, `ventana.mainloop()`, es importante porque hace que la ventana principal esté en un bucle infinito esperando interacciones de los usuarios. Esto significa que la ventana se mantendrá abierta y responderá a cualquier clic en el botón hasta que el usuario decida cerrarla.

Este código básico ayuda a entender cómo crear ventanas y agregar elementos interactivos como botones usando `tkinter`, lo cual es fundamental para desarrollar aplicaciones más complejas con interfaces gráficas.

```python
# sudo apt-get install python3-tk
import tkinter as tk

ventana = tk.Tk()

tk.Button(ventana,text="Pulsame si te atreves").pack(padx=10,pady=10)

ventana.mainloop() # No te salgas
```

### command en el boton

#### Explicación

Este código está utilizando la biblioteca `tkinter` para crear una interfaz gráfica sencilla en Python. La línea `import tkinter as tk` importa esta biblioteca y la renombra como `tk`, lo que facilita su uso en el resto del código.

El siguiente paso es crear un objeto de ventana (`ventana = tk.Tk()`). Esta ventana actúa como contenedor principal para todos los elementos gráficos del programa. A continuación, se crea un botón dentro de esta ventana con la línea `tk.Button(ventana,text="Pulsame si te atreves",command=accion).pack(padx=10,pady=10)`. Este botón tiene el texto "Pulsame si te atreves" y está asociado a una función llamada `accion` que se ejecutará cuando se pulse. Los parámetros `padx` y `pady` añaden espacio en torno al botón para mejorar su apariencia.

Finalmente, la línea `ventana.mainloop()` mantiene abierta la ventana y espera a que el usuario interaccione con ella. Este bucle es crucial porque permite que el programa responda a eventos como clics del ratón o pulsaciones de teclas.

```python
# sudo apt-get install python3-tk
import tkinter as tk

ventana = tk.Tk()

tk.Button(ventana,text="Pulsame si te atreves",command=accion).pack(padx=10,pady=10)

ventana.mainloop() # No te salgas
```

### definimos accion

#### Explicación

Este fragmento de código crea una pequeña interfaz gráfica usando la biblioteca `tkinter` en Python. Primero, importamos `tkinter` con el alias `tk`. Luego, definimos una función llamada `accion()` que simplemente imprime un mensaje en la consola cuando se llama.

La parte central del código crea una ventana principal (`ventana = tk.Tk()`) y añade a esta ventana un botón. Este botón tiene un texto "Pulsame si te atreves" y está configurado para llamar a la función `accion()` cada vez que el usuario hace clic en él.

Finalmente, se llama al método `mainloop()` en la ventana principal, lo cual mantiene la aplicación abierta y lista para interactuar con el usuario. Este método es crucial porque permite que la interfaz gráfica responda a eventos del usuario, como hacer clic en botones o mover ventanas.

Este tipo de código es importante porque te enseña cómo crear interfaces simples donde los usuarios pueden interactuar directamente con tu programa usando un entorno visual familiar.

```python
# sudo apt-get install python3-tk
import tkinter as tk

def accion():
  print("Has pulsado el boton")

ventana = tk.Tk()

tk.Button(ventana,text="Pulsame si te atreves",command=accion).pack(padx=10,pady=10)

ventana.mainloop() # No te salgas
```

### ponemos una etiqueta

#### Explicación

Este código crea una sencilla interfaz gráfica con Python usando la biblioteca `tkinter`. Al principio, se importa esta biblioteca y se define una función llamada `accion()` que simplemente imprime un mensaje en la consola cuando es llamada. Luego, se crea una ventana principal para nuestra aplicación utilizando `tk.Tk()`. Dentro de esta ventana, se añade un botón con texto "Pulsame si te atreves". Este botón está configurado para llamar a la función `accion()` cada vez que el usuario lo presione. También se agrega una etiqueta (un elemento de texto) en la pantalla que dice "¿Has pulsado el botón?". Finalmente, la ventana entra en un bucle principal con `ventana.mainloop()`, que permite que la aplicación interactúe con el usuario y actualice la interfaz según sea necesario. Este tipo de código es fundamental para crear aplicaciones interactivas con interfaces gráficas amigables para el usuario.

```python
# sudo apt-get install python3-tk
import tkinter as tk

def accion():
  print("Has pulsado el boton")

ventana = tk.Tk()

tk.Button(ventana,text="Pulsame si te atreves",command=accion).pack(padx=10,pady=10)

etiqueta = tk.Label(text="¿Has pulsado el botón?")
etiqueta.pack(padx=10,pady=10)

ventana.mainloop() # No te salgas
```

### salida en pantalla

#### Explicación

Este código es un ejemplo básico de cómo crear una interfaz gráfica simple usando la biblioteca Tkinter en Python. El programa crea una ventana con un botón y una etiqueta que cambia su texto cuando se presiona el botón.

Cuando ejecutas este script, primero se importa la librería `tkinter` para poder usar sus herramientas de creación de ventanas y componentes gráficos. Luego, se define una función llamada `accion()` que cambiará el texto de una etiqueta a "Pues sí que has pulsado el botón" cuando sea llamada.

La ventana principal del programa se crea con la línea `ventana = tk.Tk()`. A continuación, se añade un botón a esta ventana. Este botón tiene un mensaje en su superficie: "Pulsame si te atreves". Cuando alguien hace clic en este botón, llama a la función `accion()` que hemos definido anteriormente.

Además del botón, el programa también muestra una etiqueta inicial con el texto "¿Has pulsado el botón?". Esta etiqueta cambiará de texto cuando se presione el botón gracias a nuestra función `accion()`. Finalmente, el método `ventana.mainloop()` mantiene la ventana abierta y esperando interacciones del usuario hasta que éste decida cerrarla.

Este tipo de programa es importante para entender cómo interactuar con interfaces gráficas en Python, ya que permite crear aplicaciones más amigables e intuitivas a los usuarios finales.

```python
# sudo apt-get install python3-tk
import tkinter as tk

def accion():
  etiqueta.config(text="Pues sí que has pulsado el botón")

ventana = tk.Tk()

tk.Button(ventana,text="Pulsame si te atreves",command=accion).pack(padx=10,pady=10)

etiqueta = tk.Label(text="¿Has pulsado el botón?")
etiqueta.pack(padx=10,pady=10)

ventana.mainloop() # No te salgas
```

### microcalculadura

#### Explicación

Este código crea una pequeña calculadora gráfica utilizando la biblioteca `tkinter` en Python. Primero, importa `tkinter` como alias `tk`, lo que hace más fácil trabajar con ella. Luego, se crea un objeto llamado `ventana` que es la ventana principal de nuestra interfaz gráfica.

En esta ventana, el código añade dos cajas de texto (llamadas `Entry`) para que el usuario pueda ingresar dos números. Estas cajas tienen un poco de espacio alrededor para mejorar la apariencia del diseño y ayudar a separarlas visualmente entre sí. A continuación, se agrega un botón etiquetado como "Calcular!".

Finalmente, hay una etiqueta (`Label`) donde el resultado aparecerá después de que el usuario presione el botón. Sin embargo, es importante notar que este código no incluye la lógica para calcular la suma o cualquier otra operación matemática cuando se hace clic en el botón.

El método `ventana.mainloop()` mantiene la ventana abierta y espera interactivamente a que ocurran eventos como hacer clic en el botón. Este es un paso crucial porque permite que los usuarios interactúen con nuestra interfaz gráfica, aunque la lógica de cálculo no está incluida en este código.

Este tipo de estructura básica te proporciona una plataforma para construir aplicaciones más complejas y agregar funcionalidades como realizar operaciones matemáticas cuando el usuario hace clic en el botón.

```python
# sudo apt-get install python3-tk
import tkinter as tk

ventana = tk.Tk()

operando1 = tk.Entry()
operando1.pack(padx=10,pady=10)

operando2 = tk.Entry()
operando2.pack(padx=10,pady=10)

boton = tk.Button(text="Calcular!")
boton.pack(padx=10,pady=10)

resultado = tk.Label(text="Aqui va el resultado")
resultado.pack(padx=10,pady=10)

ventana.mainloop() # No te salgas
```

### calcular

#### Explicación

Este código crea una interfaz gráfica simple usando la biblioteca `tkinter` en Python. La función principal es permitir al usuario ingresar dos números, calcular su suma y mostrar el resultado de manera visual en la pantalla.

Primero, se importa la biblioteca `tkinter` para crear ventanas y widgets (elementos visuales) como entradas de texto, botones y etiquetas. Luego, se define una función llamada `calcular()` que extrae los valores ingresados por el usuario en dos campos de entrada (`operando1` y `operando2`). Estos valores son convertidos a números flotantes (números con decimales) para poder realizar la suma entre ellos. El resultado de la suma se actualiza automáticamente en una etiqueta llamada `resultado`.

Para hacer que todo esto funcione, el código crea una ventana (`ventana`) y dentro de ella añade dos campos de texto donde el usuario puede introducir los operandos (números), un botón para iniciar el cálculo, y una etiqueta que muestra el resultado. Finalmente, `ventana.mainloop()` hace que la aplicación esté lista para recibir interacciones del usuario y se mantenga abierta en pantalla.

Este código es importante porque demuestra cómo interactuar con los usuarios a través de interfaces gráficas simples y recoger datos introducidos por ellos, lo cual es una habilidad fundamental en el desarrollo de aplicaciones.

```python
# sudo apt-get install python3-tk
import tkinter as tk

def calcular():
  op1valor = float(operando1.get())
  op2valor = float(operando2.get())
  suma = op1valor + op2valor
  resultado.config(text=str(suma))

ventana = tk.Tk()

operando1 = tk.Entry()
operando1.pack(padx=10,pady=10)

operando2 = tk.Entry()
operando2.pack(padx=10,pady=10)

boton = tk.Button(text="Calcular!",command=calcular)
boton.pack(padx=10,pady=10)

resultado = tk.Label(text="Aqui va el resultado")
resultado.pack(padx=10,pady=10)

ventana.mainloop() # No te salgas
```

### Actividades propuestas

### Actividad 1: Creación de una Ventana Básica con Tkinter
**Descripción:** Crea una ventana básica utilizando la biblioteca `tkinter` en Python. Tu objetivo es entender cómo iniciar y mantener abierta una interfaz gráfica simple.

---

### Actividad 2: Agregar un Botón a la Interfaz
**Descripción:** Añade un botón a tu aplicación existente. Cuando el usuario haga clic en él, se debe mostrar un mensaje sencillo para entender cómo funcionan los eventos en `tkinter`.

---

### Actividad 3: Asociar una Función al Botón
**Descripción:** Modifica la funcionalidad del botón de tal manera que cuando sea presionado, llame a una función definida por ti. Esta actividad te ayudará a aprender cómo vincular acciones con funciones en `tkinter`.

---

### Actividad 4: Actualizar Etiquetas Interactivas
**Descripción:** Implementa un botón que al ser pulsado actualice el texto de una etiqueta (label) de la interfaz gráfica. Aprenderás a manipular elementos visuales dinámicamente.

---

### Actividad 5: Creación de Entradas y Salidas en Interfaz
**Descripción:** Diseña un programa que permita al usuario introducir texto mediante cajas de entrada (Entry) y luego mostrarlo en una etiqueta. Esta actividad te ayudará a comprender cómo interactúan los diferentes componentes gráficos.

---

### Actividad 6: Microcalculadora Sencilla
**Descripción:** Desarrolla un programa que permita sumar dos números introducidos por el usuario y mostrar el resultado en una etiqueta. Esta actividad te enseñará a manipular datos numéricos y actualizar la interfaz gráfica.

---

### Actividad 7: Mejora de Interfaz con Etiquetas Dinámicas
**Descripción:** A partir del programa microcalculadora, modifica las etiquetas para que muestren mensajes informativos antes y después de realizar una operación. Esto ayudará a mejorar la interactividad y claridad de tu aplicación.

---

### Actividad 8: Introducción al Event-Driven Programming
**Descripción:** Refuerza tus conocimientos sobre el manejo de eventos en `tkinter` creando varios botones que respondan a diferentes acciones. Aprenderás cómo organizar funciones para responder a múltiples interacciones del usuario.

---

### Actividad 9: Diseño y Posicionamiento Avanzado
**Descripción:** Mejora la disposición visual de tu interfaz gráfica modificando los parámetros de `pack` o utilizando otros métodos de disposición como `grid`. Aprenderás a diseñar interfaces más complejas y atractivas.

---

### Actividad 10: Aplicación Interactiva Completa
**Descripción:** Integra todos los conceptos aprendidos en una aplicación interactiva que permita al usuario realizar varias operaciones matemáticas básicas. Esta actividad te ayudará a practicar la creación de interfaces complejas y funcionales.

---

Estas actividades están diseñadas para llevar gradualmente a los estudiantes desde principiantes hasta creadores capaces de desarrollar aplicaciones interactivas completas utilizando `tkinter` en Python, adaptándose al nivel de Formación Profesional.


<a id="concepto-de-evento"></a>
## Concepto de evento

### Introducción a los ejercicios

Esta carpeta contiene una serie de ejercicios que te ayudarán a familiarizarte con la creación y manipulación de interfaces gráficas en Python utilizando Tkinter, así como el manejo de bases de datos MySQL. Los problemas se centran en la implementación de formularios interactivos para la inserción de datos y la visualización de registros almacenados en una base de datos. A lo largo de los ejercicios, practicarás cómo vincular eventos del usuario (como hacer clic en un botón) con acciones programáticas que insertan o recuperan información desde una base de datos. Además, aprenderás a utilizar Treeview para representar tablas de datos y mejorar la interfaz gráfica con temas estilizados mediante ttkbootstrap.

Estos ejercicios te permitirán desarrollar habilidades clave en programación orientadas al uso práctico del desarrollo web e interfaces de usuario en entornos empresariales.

### recordamos

#### Explicación

Este código está utilizando una biblioteca llamada `tkinter`, que es muy útil para crear interfaces gráficas de usuario (GUI) en Python. En este caso, el programa hace algo muy simple: crea y muestra una ventana básica.

La primera línea, `import tkinter as tk`, importa la biblioteca `tkinter` y le da un alias más corto, `tk`. Esto significa que puedes usar `tk` para referirte a funciones y clases de `tkinter` sin tener que escribir el nombre completo cada vez.

Luego, se crea una instancia de `Tk()` con la línea `ventana = tk.Tk()`. Esta línea genera una ventana principal en la cual podrás añadir widgets como botones, cuadros de texto, etc. La variable `ventana` es un objeto que representa esta ventana.

Finalmente, `ventana.mainloop()` inicia el bucle principal del programa, lo cual mantiene la aplicación corriendo y espera a que ocurran eventos, como clics o movimientos del ratón. Este método se ejecuta al final para asegurar que la ventana permanezca abierta e interactuable hasta que se cierre manualmente.

Este código es importante porque muestra los conceptos básicos de cómo crear una aplicación GUI con `tkinter`, lo cual te permitirá avanzar hacia interfaces más complejas y funcionales en el futuro.

```python
import tkinter as tk

ventana = tk.Tk()

ventana.mainloop()
```

### creo un marco

#### Explicación

Este fragmento de código es un ejemplo básico de cómo crear una interfaz gráfica en Python utilizando la biblioteca `tkinter`. El objetivo principal del código es mostrar una ventana sencilla con un marco que contiene una etiqueta.

1. **Inicialización y creación de la ventana**: Se importa el módulo `tkinter` para utilizar sus funciones, y se crea una instancia de la clase `Tk`, que representa la ventana principal de la aplicación.

2. **Creación del marco**: Dentro de esta ventana principal, se añade un contenedor llamado "marco" (`Frame`). El marco es útil para organizar los componentes de la interfaz gráfica en áreas separadas y agrupar widgets relacionados entre sí.

3. **Etiqueta informativa**: Se agrega una etiqueta (widget `Label`) dentro del marco, que muestra el texto "Introduce el dni/nie del cliente". La función `.pack()` se utiliza para organizar la etiqueta en el marco y especifica un margen interno de 20 píxeles tanto a izquierda/derecha (`padx=20`) como arriba/abajo (`pady=20`).

4. **Organización del marco**: Del mismo modo, se utiliza la función `.pack()` también para organizar el marco dentro de la ventana principal con los mismos márgenes interiores.

5. **Bucle principal**: Finalmente, `ventana.mainloop()` inicia el bucle principal del programa, lo que mantiene abierta y actualiza la interfaz gráfica hasta que se cierra manualmente.

Este código es importante porque demuestra cómo estructurar una aplicación simple con `tkinter`, permitiendo a los usuarios interactuar visualmente mediante etiquetas, entradas de texto, botones u otros elementos de interacción en una ventana.

```python
import tkinter as tk

ventana = tk.Tk()

marco = tk.Frame(ventana)

tk.Label(marco,text="Introduce el dni/nie del cliente").pack(padx=20,pady=20)

marco.pack(padx=20,pady=20)

ventana.mainloop()
```

### creo un entry

#### Explicación

Este código Python utiliza la biblioteca `tkinter` para crear una interfaz gráfica de usuario simple. La ventana principal se crea con el comando `Tk()` y dentro de ella se añade un marco (`Frame`) que sirve como contenedor para otros widgets (elementos de la interfaz). El marco contiene cuatro etiquetas (`Label`) y campos de entrada (`Entry`). Estas etiquetas y campos permiten al usuario introducir información del cliente, como DNI/NIE, nombre, apellidos y email. Cada elemento se coloca en el marco con un margen (`padx` y `pady`) para que quede visualmente atractivo.

El código es importante porque muestra cómo organizar elementos en una interfaz de usuario utilizando `tkinter`. Aprender a usar este tipo de bibliotecas te permitirá crear programas más interactivos y útiles, ya que puedes recoger datos del usuario fácilmente y manejarlos en tu programa.

```python
import tkinter as tk

ventana = tk.Tk()

marco = tk.Frame(ventana)

# DNI NIE
tk.Label(marco,text="Introduce el dni/nie del cliente").pack(padx=10,pady=10)
dninie = tk.Entry(marco)
dninie.pack(padx=10,pady=10)

# NOMBRE
tk.Label(marco,text="Introduce el nombre del cliente").pack(padx=10,pady=10)
nombre = tk.Entry(marco)
nombre.pack(padx=10,pady=10)

# APELLIDOS
tk.Label(marco,text="Introduce los apellidos del cliente").pack(padx=10,pady=10)
apellidos = tk.Entry(marco)
apellidos.pack(padx=10,pady=10)

# EMAIL
tk.Label(marco,text="Introduce el email del cliente").pack(padx=10,pady=10)
email = tk.Entry(marco)
email.pack(padx=10,pady=10)

marco.pack(padx=20,pady=20)

ventana.mainloop()
```

### creo un boton

#### Explicación

Este código Python utiliza la biblioteca `tkinter` para crear una interfaz gráfica de usuario (GUI) simple donde el usuario puede ingresar información sobre un cliente. La GUI incluye campos para introducir datos como DNI/NIE, nombre, apellidos y email del cliente.

El programa crea una ventana principal (`ventana`) y dentro de ella, un marco (`marco`). Dentro del marco se colocan etiquetas (`tk.Label`) que indican qué información debe ingresar el usuario en cada campo de entrada (`tk.Entry`). Cada etiqueta y campo están separados por márgenes para mejorar la legibilidad.

Al final, hay un botón que dice "Insertar cliente". Este botón no está vinculado a ninguna función específica llamada `insertar` en el código proporcionado (lo cual es problemático ya que causará un error al ejecutar el programa), pero su intención sería llamar a una función que procesaría los datos ingresados por el usuario.

Este tipo de interfaz es común en aplicaciones donde se recopila información del usuario para almacenarla o procesarla más adelante. Es importante conocer cómo organizar y presentar elementos en una GUI, ya que facilita la interacción del usuario con el programa.

```python
import tkinter as tk

ventana = tk.Tk()

marco = tk.Frame(ventana)

# DNI NIE
tk.Label(marco,text="Introduce el dni/nie del cliente").pack(padx=10,pady=10)
dninie = tk.Entry(marco)
dninie.pack(padx=10,pady=10)

# NOMBRE
tk.Label(marco,text="Introduce el nombre del cliente").pack(padx=10,pady=10)
nombre = tk.Entry(marco)
nombre.pack(padx=10,pady=10)

# APELLIDOS
tk.Label(marco,text="Introduce los apellidos del cliente").pack(padx=10,pady=10)
apellidos = tk.Entry(marco)
apellidos.pack(padx=10,pady=10)

# EMAIL
tk.Label(marco,text="Introduce el email del cliente").pack(padx=10,pady=10)
email = tk.Entry(marco)
email.pack(padx=10,pady=10)

# Boton
tk.Button(marco,text="Insertar cliente",command = insertar).pack(padx=10,pady=10)

marco.pack(padx=20,pady=20)

ventana.mainloop()
```

### funcion de insertar

#### Explicación

Este código es una pequeña aplicación de interfaz gráfica (GUI) creada con la biblioteca `tkinter` en Python. La función principal del programa es permitir al usuario ingresar los datos de un cliente nuevo, como DNI/NIE, nombre, apellidos y email.

En primer lugar, se crea una ventana principal usando `tk.Tk()`, que actúa como contenedor para todos los elementos gráficos de la aplicación. A continuación, se define una función llamada `insertar()` que simplemente imprime un mensaje en la consola cuando es llamada, aunque esta podría usarse más adelante para realizar otras tareas.

Dentro del marco (un contenedor dentro de la ventana principal), el código crea etiquetas y campos de entrada (`tk.Entry`) para cada uno de los datos que se quieren recoger del cliente. Cada elemento gráfico (etiqueta, campo de entrada) es añadido al marco con métodos como `pack()`, lo cual organiza estos elementos visualmente en la aplicación.

Finalmente, un botón "Insertar cliente" se agrega al marco y está conectado a la función `insertar()`; cuando el usuario hace clic en este botón, se ejecuta dicha función. Este código es fundamental para entender cómo interactuar con los usuarios a través de una interfaz gráfica y recoger datos introducidos por ellos.

```python
import tkinter as tk

ventana = tk.Tk()

def insertar():
  print("Vamos a insertar un cliente")

marco = tk.Frame(ventana)

# DNI NIE
tk.Label(marco,text="Introduce el dni/nie del cliente").pack(padx=10,pady=10)
dninie = tk.Entry(marco)
dninie.pack(padx=10,pady=10)

# NOMBRE
tk.Label(marco,text="Introduce el nombre del cliente").pack(padx=10,pady=10)
nombre = tk.Entry(marco)
nombre.pack(padx=10,pady=10)

# APELLIDOS
tk.Label(marco,text="Introduce los apellidos del cliente").pack(padx=10,pady=10)
apellidos = tk.Entry(marco)
apellidos.pack(padx=10,pady=10)

# EMAIL
tk.Label(marco,text="Introduce el email del cliente").pack(padx=10,pady=10)
email = tk.Entry(marco)
email.pack(padx=10,pady=10)

# Boton
tk.Button(marco,text="Insertar cliente",command = insertar).pack(padx=10,pady=10)

marco.pack(padx=20,pady=20)

ventana.mainloop()
```

### mysql

#### Explicación

Este fragmento de código es un ejemplo básico de cómo se conecta a una base de datos MySQL y realiza una operación de inserción usando el módulo `mysql.connector` en Python. La primera parte del código muestra los comandos que debes ejecutar para instalar las bibliotecas necesarias si no están instaladas. Luego, establece la conexión con la base de datos especificando detalles como el host (localhost), usuario y contraseña, y la base de datos a utilizar.

Después de conectarse, se crea un objeto cursor que permite enviar comandos SQL a la base de datos. En este caso, se ejecuta una instrucción INSERT para añadir un nuevo registro en la tabla `clientes`. El valor `NULL` indica que el campo id es automático y no debe ser especificado por nosotros (usualmente auto-incremento). Finalmente, el método `commit()` asegura que los cambios sean guardados permanentemente. Los objetos cursor y conexión se cierran para liberar recursos.

Este código es importante porque muestra cómo interactuar con bases de datos MySQL desde Python, lo cual es fundamental en aplicaciones web o sistemas administrativos que necesitan almacenar y recuperar información estructurada.

```python
# pip3 install mysql-connector-python --break-system-packages
# sudo apt install libmysqlclient-dev python3-mysql.connector
# solo si da error de ssl en socket:
# pip3 install --user --upgrade mysql-connect-python --break-system-packages
import mysql.connector
conexion = mysql.connector.connect(
    host="localhost",
    user="empresadam",
    password="Empresadam123$",
    database="empresadam"
)
cursor = conexion.cursor()
cursor.execute('''
  INSERT INTO clientes
  VALUES(
    NULL,
    "12345678Z",
    "Jose Vicente",
    "Carratala Sanchis",
    "info@jocarsa.com"
  );
''')
conexion.commit()
cursor.close()
conexion.close()
```

### crear usuario

#### Explicación

Este fragmento de código SQL sirve para crear un nuevo usuario en una base de datos y asignarle permisos específicos. Comienza creando el usuario 'empresadam' con la contraseña 'Empresadm123$', asegurando que esta información se almacene correctamente en los registros de la base de datos.

Luego, mediante el comando GRANT USAGE, se le otorga a este nuevo usuario el acceso básico sin ningún privilegio adicional sobre todas las bases de datos (indica *.*). A continuación, se modifican los límites impuestos al usuario para permitirle realizar una cantidad ilimitada de consultas, conexiones y actualizaciones en un periodo determinado.

Finalmente, con GRANT ALL PRIVILEGES, se le concede al usuario 'empresadam' acceso completo a la base de datos específica llamada 'empresadam', lo que significa que puede realizar cualquier tipo de operación dentro de ella. El comando FLUSH PRIVILEGES recarga los privilegios para aplicar los cambios inmediatamente.

Este proceso es crucial en la administración de bases de datos ya que permite controlar quién tiene acceso a qué información y con qué nivel de permisos, contribuyendo así a la seguridad y al funcionamiento eficiente del sistema.

```sql
-- crea usuario nuevo con contraseña
CREATE USER 
'empresadam'@'localhost' 
IDENTIFIED  BY 'Empresadam123$';
-- permite acceso a ese usuario
GRANT USAGE ON *.* TO 'empresadam'@'localhost';
-- quitale todos los limites que tenga
ALTER USER 'empresadam'@'localhost' 
REQUIRE NONE 
WITH MAX_QUERIES_PER_HOUR 0 
MAX_CONNECTIONS_PER_HOUR 0 
MAX_UPDATES_PER_HOUR 0 
MAX_USER_CONNECTIONS 0;
-- dale acceso a la base de datos empresadam
GRANT ALL PRIVILEGES ON `empresadam`.* 
TO 'empresadam'@'localhost';
-- recarga la tabla de privilegios
FLUSH PRIVILEGES;
```

### seleccionar

#### Explicación

Este fragmento de código SQL es una consulta que se utiliza para recuperar todos los datos de la tabla llamada "clientes" en una base de datos. La instrucción `SELECT *` significa que se solicitan todas las columnas y filas disponibles en esa tabla específica. En otras palabras, esta línea de código te permite ver toda la información almacenada actualmente en la tabla "clientes". Es importante porque te proporciona un resumen completo del contenido de la tabla sin necesidad de especificar cada columna individualmente, lo que puede ahorrar tiempo y esfuerzo cuando trabajas con tablas grandes o desconocidas.

```sql
SELECT * FROM clientes;
```

### insertar en base de datos

#### Explicación

Este fragmento de código en Python utiliza dos bibliotecas importantes: `tkinter` para crear una interfaz gráfica (GUI) y `mysql.connector` para conectarse a una base de datos MySQL. El objetivo principal del código es permitir al usuario ingresar los detalles de un nuevo cliente y luego insertar esos datos en la tabla `clientes` de una base de datos.

La función `insertar()` se encarga de ejecutar una consulta SQL que inserta nuevos registros en la tabla `clientes`. Esta función obtiene los valores ingresados por el usuario a través de campos de entrada (`Entry`) para DNI/NIE, nombre, apellidos y email del cliente. Estos valores son luego utilizados directamente en la consulta SQL para insertar un nuevo registro en la base de datos.

El uso de `tkinter` aquí permite crear una ventana simple con cuadros de texto (entradas) donde el usuario puede ingresar estos detalles del cliente, y un botón que ejecuta la función `insertar()` cuando es presionado. Esta funcionalidad combina interacción gráfica con operaciones en base de datos, lo cual es crucial para aplicaciones que manejan datos de usuarios o clientes.

Esta combinación permite a los estudiantes comprender cómo integrar una interfaz de usuario sencilla con el acceso y manipulación de bases de datos, proporcionando un ejemplo práctico del uso de `tkinter` junto con la conexión a MySQL desde Python.

```python
import tkinter as tk
import mysql.connector
conexion = mysql.connector.connect(host="localhost",user="empresadam",password="Empresadam123$",database="empresadam")
cursor = conexion.cursor()
ventana = tk.Tk()
def insertar():
  cursor.execute('''
    INSERT INTO clientes
    VALUES(
      NULL,
      "'''+dninie.get()+'''",
      "'''+nombre.get()+'''",
      "'''+apellidos.get()+'''",
      "'''+email.get()+'''"
    );
  ''')
  conexion.commit()
marco = tk.Frame(ventana)
tk.Label(marco,text="Introduce el dni/nie del cliente").pack(padx=10,pady=10)
dninie = tk.Entry(marco)
dninie.pack(padx=10,pady=10)
tk.Label(marco,text="Introduce el nombre del cliente").pack(padx=10,pady=10)
nombre = tk.Entry(marco)
nombre.pack(padx=10,pady=10)
tk.Label(marco,text="Introduce los apellidos del cliente").pack(padx=10,pady=10)
apellidos = tk.Entry(marco)
apellidos.pack(padx=10,pady=10)
tk.Label(marco,text="Introduce el email del cliente").pack(padx=10,pady=10)
email = tk.Entry(marco)
email.pack(padx=10,pady=10)
tk.Button(marco,text="Insertar cliente",command = insertar).pack(padx=10,pady=10)
marco.pack(padx=20,pady=20)
ventana.mainloop()
```

### leer de base de datos

#### Explicación

Este fragmento de código en Python se utiliza para conectar a una base de datos MySQL y leer información desde ella. Primero, el programa importa la biblioteca `mysql.connector`, que permite establecer una conexión con un servidor MySQL. Luego, crea una conexión al servidor utilizando credenciales específicas como el nombre del host (en este caso, "localhost"), el usuario ("empresadam") y la contraseña ("Empresadam123$"). Además, especifica la base de datos a la que se quiere conectar, en este caso, "empresadam".

Una vez establecida la conexión, el código crea un objeto cursor, que es una herramienta para ejecutar comandos SQL. En este ejemplo, el comando SQL `SELECT * FROM clientes;` se utiliza para seleccionar todas las filas de la tabla llamada 'clientes'. El método `fetchall()` recupera todas las filas del resultado de la consulta y las almacena en una variable llamada `filas`.

Finalmente, el código itera sobre cada fila recuperada e imprime cada una utilizando un bucle for. Es importante cerrar tanto el cursor como la conexión a la base de datos después de completar todas las operaciones para liberar recursos del sistema y evitar posibles problemas.

Este tipo de código es crucial en aplicaciones web o sistemas que necesitan interactuar con bases de datos para almacenar, recuperar y manipular datos de manera eficiente.

```python
import mysql.connector
conexion = mysql.connector.connect(
    host="localhost",
    user="empresadam",
    password="Empresadam123$",
    database="empresadam"
)
cursor = conexion.cursor()
cursor.execute('''
  SELECT * FROM clientes;
''')

filas = cursor.fetchall()

for fila in filas:
  print(fila)
  
cursor.close()
conexion.close()
```

### pintamos tablas

#### Explicación

Este código crea una interfaz gráfica simple usando la biblioteca `tkinter` en Python. La ventana principal se inicializa con `tk.Tk()`, y luego se añade un elemento llamado `Treeview` que sirve para mostrar datos tabulares, como si fuera una hoja de cálculo o una tabla HTML. En este caso, el Treeview tiene dos columnas: "nombre" y "apellidos".

El código configura las cabeceras del Treeview con los textos "Nombre del cliente" y "Apellidos del cliente". Luego, se añaden dos filas de datos a la tabla: una para "Jose Vicente Carratala" y otra para "Juan García Lopez". Finalmente, el Treeview se coloca en la ventana principal con `pack()`, que ajusta automáticamente su tamaño y posición.

Este tipo de código es importante porque permite presentar información estructurada de manera visual y amigable para el usuario, facilitando la interacción con datos complejos.

```python
import tkinter as tk
from tkinter import ttk

ventana = tk.Tk()


arbol = ttk.Treeview(ventana, columns=("nombre", "apellidos"), show="headings")
arbol.heading("nombre", text="Nombre del cliente")
arbol.heading("apellidos", text="Apellidos del cliente")

arbol.insert("", "end", values=("Jose Vicente", "Carratala"))
arbol.insert("", "end", values=("Juan", "García Lopez"))

arbol.pack(padx=20,pady=20)

ventana.mainloop()
```

### frankenstein

#### Explicación

Este código Python utiliza la biblioteca `tkinter` para crear una interfaz gráfica de usuario sencilla que muestra información sobre clientes desde una base de datos MySQL. En primer lugar, el programa establece una conexión con la base de datos local y obtiene un cursor para ejecutar consultas SQL. Luego, crea una ventana principal usando `tk.Tk()`.

El código crea un objeto `Treeview` llamado `arbol`, que es como una tabla donde puedes visualizar datos. Este objeto tiene columnas para el DNI del cliente, nombre, apellidos y correo electrónico. Los encabezados de estas columnas se personalizan con textos descriptivos.

Después, el programa ejecuta una consulta SQL simple que selecciona todos los registros de la tabla `clientes` en la base de datos conectada. Recupera estos registros y los recorre para insertar cada fila en el objeto `Treeview`, mostrando así toda la información de clientes en una vista tabular dentro de la ventana.

Finalmente, se empaca (agrega) este árbol al interior de la ventana principal con un poco de espacio para que sea fácil de leer y luego se inicia el bucle principal de la interfaz gráfica (`ventana.mainloop()`), lo cual mantiene abierta la aplicación hasta que se cierre manualmente.

```python
import tkinter as tk
from tkinter import ttk
import mysql.connector
conexion = mysql.connector.connect(host="localhost",user="empresadam",password="Empresadam123$",database="empresadam")
cursor = conexion.cursor()
ventana = tk.Tk()
arbol = ttk.Treeview(ventana, columns=("dninie","nombre", "apellidos","email"), show="headings")
arbol.heading("dninie", text="DNI del cliente")
arbol.heading("nombre", text="Nombre del cliente")
arbol.heading("apellidos", text="Apellidos del cliente")
arbol.heading("email", text="Email del cliente")
cursor.execute('''SELECT * FROM clientes;''')
filas = cursor.fetchall()
for fila in filas:
  arbol.insert("", "end", values=(fila[1], fila[2], fila[3], fila[4]))

arbol.pack(padx=20,pady=20)

ventana.mainloop()
```

### unir con IA

#### Explicación

Este código es un ejemplo de una aplicación gráfica simple en Python que utiliza Tkinter y ttkbootstrap para crear una interfaz de usuario. La aplicación permite a los usuarios agregar nuevos clientes ingresando su DNI/NIE, nombre, apellidos y email, y luego muestra la lista completa de clientes registrados en una base de datos MySQL.

El código comienza importando las librerías necesarias y estableciendo la conexión con la base de datos. Luego, se crea una ventana principal donde los usuarios pueden ver dos áreas: un formulario para ingresar información del cliente nuevo y una tabla que muestra todos los clientes registrados en el sistema.

Cuando un usuario completa el formulario y hace clic en el botón "Insertar cliente", la función `insertar()` se ejecuta. Esta función verifica si todos los campos son obligatorios, inserta la nueva entrada en la base de datos y actualiza la tabla mostrada para reflejar este cambio.

Además, hay una función llamada `cargar_datos()` que se encarga de recuperar toda la información de clientes desde la base de datos cada vez que se abre la aplicación o cuando se inserta un nuevo cliente, asegurando así que los usuarios siempre vean la información más actualizada en tiempo real.

Esta estructura es útil para estudiantes ya que demuestra cómo integrar una interfaz gráfica con una base de datos utilizando Python y Tkinter, además de mostrar buenas prácticas como manejar errores (verificando si todos los campos están completos antes de realizar una operación) y mantener la interfaz actualizada automáticamente después de cada cambio en la base de datos.

```python
# pip3 install ttkbootsrap --break-system-packages
import tkinter as tk
from tkinter import ttk
import mysql.connector
import ttkbootstrap as tb
from ttkbootstrap.constants import *

# --- Database connection ---
conexion = mysql.connector.connect(
    host="localhost",
    user="empresadam",
    password="Empresadam123$",
    database="empresadam"
)
cursor = conexion.cursor()

# --- Main window setup ---
ventana = tb.Window(themename="superhero")  # try also: "minty", "flatly", "darkly"
ventana.title("Gestión de Clientes")
ventana.geometry("800x600")

# --- Frames layout ---
frame_form = ttk.LabelFrame(ventana, text="Nuevo cliente", padding=20)
frame_form.pack(fill=X, padx=20, pady=10)

frame_tabla = ttk.LabelFrame(ventana, text="Lista de clientes", padding=20)
frame_tabla.pack(fill=BOTH, expand=True, padx=20, pady=10)

# --- Form fields ---
def insertar():
    dni = dninie.get()
    nom = nombre.get()
    ape = apellidos.get()
    ema = email.get()

    if dni == "" or nom == "" or ape == "" or ema == "":
        tb.dialogs.Messagebox.show_warning("Por favor, completa todos los campos", title="Atención")
        return

    cursor.execute('''
        INSERT INTO clientes VALUES (NULL, %s, %s, %s, %s);
    ''', (dni, nom, ape, ema))
    conexion.commit()
    cargar_datos()
    tb.dialogs.Messagebox.show_info("Cliente insertado correctamente", title="Éxito")

    # Limpiar campos
    dninie.delete(0, tk.END)
    nombre.delete(0, tk.END)
    apellidos.delete(0, tk.END)
    email.delete(0, tk.END)

# Form fields (left to right layout)
ttk.Label(frame_form, text="DNI/NIE:").grid(row=0, column=0, padx=5, pady=5, sticky=W)
dninie = ttk.Entry(frame_form, width=20)
dninie.grid(row=0, column=1, padx=5, pady=5)

ttk.Label(frame_form, text="Nombre:").grid(row=0, column=2, padx=5, pady=5, sticky=W)
nombre = ttk.Entry(frame_form, width=20)
nombre.grid(row=0, column=3, padx=5, pady=5)

ttk.Label(frame_form, text="Apellidos:").grid(row=1, column=0, padx=5, pady=5, sticky=W)
apellidos = ttk.Entry(frame_form, width=20)
apellidos.grid(row=1, column=1, padx=5, pady=5)

ttk.Label(frame_form, text="Email:").grid(row=1, column=2, padx=5, pady=5, sticky=W)
email = ttk.Entry(frame_form, width=20)
email.grid(row=1, column=3, padx=5, pady=5)

ttk.Button(frame_form, text="Insertar cliente", command=insertar, bootstyle=SUCCESS).grid(
    row=0, column=4, rowspan=2, padx=10, pady=5, sticky=NS
)

# --- Treeview setup ---
columnas = ("dninie", "nombre", "apellidos", "email")
arbol = ttk.Treeview(frame_tabla, columns=columnas, show="headings", bootstyle=INFO)
for col in columnas:
    arbol.heading(col, text=col.capitalize())
    arbol.column(col, width=180, anchor=W)

# Scrollbars
scroll_y = ttk.Scrollbar(frame_tabla, orient=VERTICAL, command=arbol.yview)
scroll_x = ttk.Scrollbar(frame_tabla, orient=HORIZONTAL, command=arbol.xview)
arbol.configure(yscrollcommand=scroll_y.set, xscrollcommand=scroll_x.set)

arbol.grid(row=0, column=0, sticky=NSEW)
scroll_y.grid(row=0, column=1, sticky=NS)
scroll_x.grid(row=1, column=0, sticky=EW)

frame_tabla.rowconfigure(0, weight=1)
frame_tabla.columnconfigure(0, weight=1)

# --- Function to load data into the table ---
def cargar_datos():
    cursor.execute("SELECT * FROM clientes;")
    filas = cursor.fetchall()
    arbol.delete(*arbol.get_children())
    for fila in filas:
        arbol.insert("", "end", values=(fila[1], fila[2], fila[3], fila[4]))

# --- Initial load ---
cargar_datos()

ventana.mainloop()
```

### Actividades propuestas

### Actividad 1: Creación de Ventana Básica en Tkinter
**Descripción:** Crea una ventana básica con Tkinter que simplemente muestre un mensaje "Bienvenido a la aplicación" cuando se ejecute. Asegúrate de que tu código tenga una estructura similar a los ejemplos proporcionados.

### Actividad 2: Diseño de Formulario Simples
**Descripción:** Desarrolla un formulario en Tkinter con campos para introducir DNI/NIE, nombre, apellidos y email. Debe incluir etiquetas y entradas para cada uno de estos campos.

### Actividad 3: Integración del Botón Insertar
**Descripción:** Añade un botón al formulario creado anteriormente que ejecute una función básica cuando se presione (por ejemplo, imprimir en la consola "Se ha intentado insertar un cliente").

### Actividad 4: Conexión a MySQL y Ejecución de Consulta Básica
**Descripción:** Escribe un script Python para conectarse a la base de datos MySQL utilizando `mysql.connector`. Luego, ejecuta una consulta básica que inserte un nuevo registro en la tabla `clientes`.

### Actividad 5: Integración con Tkinter y Ejecución de Consulta SQL
**Descripción:** Combina las habilidades aprendidas hasta ahora para crear un formulario Tkinter que permita a los usuarios insertar datos en una base de datos MySQL. Asegúrate de que la inserción se realiza cuando el usuario haga clic en el botón "Insertar cliente".

### Actividad 6: Mostrar Datos desde la Base de Datos
**Descripción:** Modifica tu aplicación para que, además de permitir insertar nuevos clientes a través del formulario, también muestre una lista con todos los registros existentes en la tabla `clientes` al iniciar el programa.

### Actividad 7: Tabla Dinámica en Tkinter
**Descripción:** Utiliza ttk.Treeview para mostrar datos desde tu base de datos MySQL en una estructura tabular dentro del formulario Tkinter. Asegúrate de que los datos se actualicen automáticamente cada vez que un nuevo cliente es insertado.

### Actividad 8: Diseño Estético Avanzado con ttkbootstrap
**Descripción:** Mejora la apariencia de tu aplicación utilizando el módulo `ttkbootstrap` para crear ventanas y formularios más atractivos. Asegúrate de que tanto los campos como las tablas estén bien diseñados.

### Actividad 9: Control de Errores en Formulario
**Descripción:** Implementa validaciones para asegurar que todos los campos del formulario están completos antes de permitir la inserción a través del botón "Insertar cliente". Muestra mensajes de advertencia si algún campo está vacío.

### Actividad 10: Refactorización y Mejora Final
**Descripción:** Aprovecha las habilidades aprendidas para refactorizar tu código, mejorando su legibilidad y eficiencia. Considera la posibilidad de añadir funcionalidades adicionales como borrar registros o actualizar información existente.

Estas actividades se basan en el proceso gradual de aprender cómo crear una aplicación que interactúa con bases de datos utilizando Tkinter para interfaz gráfica y MySQL para almacenamiento, pasando por los conceptos básicos hasta llegar a la integración avanzada y diseño estético.


<a id="creacion-de-controladores-de-eventos"></a>
## Creación de controladores de eventos


<a id="simulacro-examen-miercoles"></a>
## - Simulacro examen miercoles

### Introducción a los ejercicios

Esta carpeta contiene una serie de ejercicios que te ayudarán a familiarizarte con la manipulación de datos en una base de datos MySQL desde Python. Los ejercicios inician presentando un menú interactivo para realizar operaciones CRUD (Crear, Leer, Actualizar y Eliminar) en una tabla llamada `Piezas`. A través de estos ejercicios, practicarás la conexión a una base de datos utilizando el módulo `mysql.connector`, la ejecución de consultas SQL como SELECT, INSERT, UPDATE y DELETE, y manejar inputs del usuario para realizar operaciones específicas en la base de datos. Estos ejercicios son ideales para consolidar tus habilidades tanto en programación Python como en gestión de bases de datos relacionales.

### comenzamos

#### Explicación

Este fragmento de código es parte de un programa en Python que muestra un menú al usuario para interactuar con la aplicación. El programa comienza imprimiendo un mensaje de bienvenida: "Bienvenidos a la aplicación". Luego, presenta cuatro opciones diferentes que el usuario puede seleccionar (crear un registro, listar registros existentes, actualizar un registro y eliminar un registro). Cada opción está numerada para facilitar su selección. Esta estructura es común en aplicaciones interactivas porque permite al usuario elegir qué acción realizar, lo cual mejora la usabilidad del programa.

```python
print("Bienvenidos a la aplicacion")

print("Selecciona una opcion:")
print("1.-Crear un registro")
print("2.-Listar registros")
print("3.-Actualiar registro")
print("4.-Eliminar registro")
```

### bucle infinito

#### Explicación

Este fragmento de código es el comienzo de una aplicación simple en Python que permite al usuario interactuar con un menú infinito. Primero, muestra un mensaje de bienvenida para informar al usuario que la aplicación ha iniciado. Luego, entra en un bucle `while True`, lo cual significa que este bloque de código se ejecutará continuamente hasta que se interrumpa manualmente o se cumpla alguna condición específica para salir del bucle.

Dentro del bucle, el programa imprime varias opciones disponibles para el usuario. El usuario debe ingresar un número correspondiente a la opción que desea realizar. La aplicación entonces espera una entrada de teclado por parte del usuario, convierte esa entrada en un número entero y lo almacena en la variable `opcion`. Este patrón se repite indefinidamente hasta que el programa sea detenido o implementemos algún mecanismo para salir del bucle.

Este tipo de estructura es común en aplicaciones interactivas ya que permite ofrecer una interfaz sencilla y mantener al usuario dentro de la aplicación mientras desean continuar utilizando sus funciones. Es importante tener cuidado con los bucles infinitos porque pueden hacer que el programa no termine hasta que alguien lo detenga o se añada un mecanismo para romper el ciclo cuando sea necesario.

```python
print("Bienvenidos a la aplicacion")

while True:
  print("Selecciona una opcion:")
  print("1.-Crear un registro")
  print("2.-Listar registros")
  print("3.-Actualiar registro")
  print("4.-Eliminar registro")

  opcion = int(input("Elige tu opcion: "))
```

### if elif

#### Explicación

Este código es el comienzo de una aplicación simple que permite al usuario seleccionar diferentes acciones relacionadas con la gestión de registros. El programa primero imprime un mensaje de bienvenida y luego entra en un bucle `while True`, lo que significa que se repetirá indefinidamente hasta que se interrumpa explícitamente.

Dentro del bucle, el código muestra al usuario cuatro opciones: crear un registro, listar registros existentes, actualizar un registro o eliminar uno. Luego, pide al usuario que ingrese su elección a través de la función `input()`, convirtiendo esa entrada en un número entero con `int()` y almacenándola en la variable `opcion`.

Después de obtener la opción del usuario, el código utiliza una estructura condicional `if elif` para verificar qué acción debe tomar según lo que haya elegido. En este fragmento, las partes donde deberían estar los bloques de código para cada caso (dentro de los espacios después de los `elif`) están vacías.

Esta estructura es importante porque permite al programa ejecutar diferentes tareas dependiendo del input del usuario, dando a la aplicación una funcionalidad interactiva y modular.

```python
print("Bienvenidos a la aplicacion")

while True:
  print("Selecciona una opcion:")
  print("1.-Crear un registro")
  print("2.-Listar registros")
  print("3.-Actualiar registro")
  print("4.-Eliminar registro")

  opcion = int(input("Elige tu opcion: "))
  
  if opcion == 1:
  
  elif opcion == 2:
  
  elif opcion == 3:
  
  elif opcion == 4:
  
```

### mysql conexion

#### Explicación

Este código es una parte de un programa en Python que permite a los usuarios interactuar con una base de datos MySQL. En primer lugar, el programa importa la biblioteca `mysql.connector`, lo cual es necesario para conectarse y trabajar con bases de datos MySQL.

El programa comienza mostrando un mensaje de bienvenida al usuario y luego entra en un bucle infinito (`while True:`), que presenta al usuario una lista de opciones para elegir qué acción realizar: crear, listar, actualizar o eliminar registros. Cada opción está representada por un número del 1 al 4.

Después de que el usuario introduce su elección a través de `input()`, la aplicación convierte esa entrada en un entero y la asigna a la variable `opcion`. Dependiendo del valor elegido, debería haber código adicional para ejecutar diferentes funciones relacionadas con la base de datos. Sin embargo, en este fragmento específico, solo se han definido las opciones sin implementar lo que ocurre cuando el usuario selecciona cada una.

Esta estructura es importante porque permite a los usuarios interactuar fácilmente y manejar datos de manera más organizada dentro de la aplicación, proporcionando una interfaz sencilla para realizar operaciones CRUD (Crear, Leer, Actualizar, Borrar) en la base de datos.

```python
import mysql.connector

print("Bienvenidos a la aplicacion")

while True:
  print("Selecciona una opcion:")
  print("1.-Crear un registro")
  print("2.-Listar registros")
  print("3.-Actualiar registro")
  print("4.-Eliminar registro")

  opcion = int(input("Elige tu opcion: "))
  
  if opcion == 1:
  
  elif opcion == 2:
  
  elif opcion == 3:
  
  elif opcion == 4:
  
```

### conexion y cursor

#### Explicación

Este fragmento de código es una introducción a un programa en Python que interactúa con una base de datos MySQL. Primero, el programa importa la biblioteca `mysql.connector`, lo cual le permite conectarse y manipular bases de datos MySQL.

Luego, se imprime un mensaje de bienvenida al usuario para indicar que han iniciado sesión en la aplicación. A continuación, se establece una conexión a la base de datos utilizando el host local (`localhost`), un usuario llamado `portafolioceac`, y la contraseña también es `portafolioceac`. Se especifica que la base de datos a utilizar es `portafolioceac`.

Una vez conectada a la base de datos, se crea un objeto cursor, el cual es fundamental para ejecutar comandos SQL dentro de la base de datos. A partir de ahí, el programa entra en un bucle infinito (`while True`) donde muestra al usuario una serie de opciones: crear un registro, listar registros existentes, actualizar un registro y eliminar un registro.

Este código es importante porque establece las bases para interactuar con una base de datos a través de Python, permitiendo que los usuarios realicen diversas operaciones en la base de datos según sus necesidades. El uso del menú permite al usuario dirigir el flujo de trabajo de forma interactiva y personalizada.

```python
import mysql.connector

print("Bienvenidos a la aplicacion")

conexion = mysql.connector.connect(
  host="localhost",
  user="portafolioceac",
  password="portafolioceac",
  database="portafolioceac"
  )
cursor = conexion.cursor()

while True:
  print("Selecciona una opcion:")
  print("1.-Crear un registro")
  print("2.-Listar registros")
  print("3.-Actualiar registro")
  print("4.-Eliminar registro")

  opcion = int(input("Elige tu opcion: "))
  
  if opcion == 1:
  
  elif opcion == 2:
  
  elif opcion == 3:
  
  elif opcion == 4:
  
```

### seleccionamos

#### Explicación

Este código es una aplicación sencilla que permite al usuario interactuar con una base de datos MySQL para realizar operaciones básicas sobre un conjunto de registros. Al iniciar, el programa establece una conexión a la base de datos utilizando las credenciales proporcionadas (usuario y contraseña). Luego, entra en un bucle infinito donde muestra un menú al usuario para que pueda elegir entre varias opciones: crear un registro, listar registros existentes, actualizar un registro o eliminar uno.

Cuando el usuario selecciona "Listar registros" (opción 2), el programa ejecuta una consulta SQL que recupera todos los datos de la tabla `Piezas` en la base de datos. Estos datos se almacenan temporalmente en una variable llamada `filas`, y luego son iterados para imprimir cada registro individual.

Es importante destacar que las opciones 1, 3 y 4 (Crear un registro, Actualizar un registro, Eliminar un registro) están presentes pero no tienen ninguna acción programada hasta ahora; esto significa que el código usa la palabra clave `pass` en esos bloques para indicar que todavía falta completar esa funcionalidad.

Este tipo de aplicación es útil porque permite a los usuarios interactuar fácilmente con datos almacenados en una base de datos, facilitando operaciones comunes sin necesidad de escribir consultas SQL manualmente.

```python
import mysql.connector

print("Bienvenidos a la aplicacion")

conexion = mysql.connector.connect(
  host="localhost",
  user="portafolioceac",
  password="portafolioceac",
  database="portafolioceac"
  )
cursor = conexion.cursor()

while True:
  print("Selecciona una opcion:")
  print("1.-Crear un registro")
  print("2.-Listar registros")
  print("3.-Actualiar registro")
  print("4.-Eliminar registro")

  opcion = int(input("Elige tu opcion: "))
  
  if opcion == 1:
    pass
  elif opcion == 2:
    cursor = conexion.cursor()
    cursor.execute('''
      SELECT * FROM Piezas;
    ''')

    filas = cursor.fetchall()

    for fila in filas:
      print(fila)
  elif opcion == 3:
    pass
  elif opcion == 4:
    pass
```

### ahora insertar

#### Explicación

Este código es una aplicación en Python que interactúa con una base de datos MySQL para gestionar registros relacionados con piezas. Al iniciar, el programa se conecta a la base de datos utilizando credenciales específicas y muestra un menú al usuario donde pueden seleccionar varias acciones: crear un nuevo registro, listar todos los registros existentes, actualizar o eliminar registros. La opción principal que está implementada en este código es la creación de un nuevo registro (opción 1), permitiendo al usuario ingresar detalles como el título, descripción, imagen, URL y categoría. Estos datos son luego insertados en una tabla llamada "Piezas" en la base de datos.

Además, cuando se selecciona la opción para listar registros (opción 2), el código ejecuta una consulta SQL para traer todos los registros de la tabla "Piezas", luego imprime cada fila del resultado. Las opciones para actualizar y eliminar registros están presentes pero no implementadas actualmente en este fragmento de código, con las declaraciones `pass` indicando que aún se necesita añadir funcionalidad.

Esta aplicación es útil porque proporciona una interfaz sencilla para gestionar datos en una base de datos MySQL desde la línea de comandos, permitiendo a los usuarios administrar fácilmente información sobre piezas (posiblemente referentes a productos o partes mecánicas) sin necesidad de tener conocimientos avanzados de SQL.

```python
import mysql.connector

print("Bienvenidos a la aplicacion")

conexion = mysql.connector.connect(
  host="localhost",
  user="portafolioceac",
  password="portafolioceac",
  database="portafolioceac"
  )
cursor = conexion.cursor()

while True:
  print("Selecciona una opcion:")
  print("1.-Crear un registro")
  print("2.-Listar registros")
  print("3.-Actualiar registro")
  print("4.-Eliminar registro")

  opcion = int(input("Elige tu opcion: "))
  
  if opcion == 1:
    titulo = input("Introduce el titulo: ")
    descripcion = input("Introduce la descripcion: ")
    imagen = input("Introduce la imagen: ")
    url = input("Introduce la url: ")
    id_categoria = input("Introduce la categoria: ")
    cursor.execute('''
      INSERT INTO Piezas VALUES (
      NULL,
      "'''+titulo+'''",
      "'''+descripcion+'''",
      "'''+imagen+'''",
      "'''+url+'''",
      '''+id_categoria+'''
      );
    ''')
    conexion.commit()
  elif opcion == 2:

    cursor.execute('''
      SELECT * FROM Piezas;
    ''')

    filas = cursor.fetchall()

    for fila in filas:
      print(fila)
  elif opcion == 3:
    pass
  elif opcion == 4:
    pass
```

### eliminar

#### Explicación

Este código es una aplicación sencilla en Python que se conecta a una base de datos MySQL y permite realizar operaciones CRUD (Crear, Leer, Actualizar, Borrar) sobre un conjunto de registros llamados "Piezas". Al inicio del programa, establece una conexión con la base de datos utilizando credenciales específicas. Luego, muestra un menú interactivo donde el usuario puede seleccionar entre varias opciones: crear un nuevo registro (añadiendo detalles como título, descripción, imagen, URL y categoría), listar todos los registros existentes, actualizar un registro o eliminar uno.

El código de interés aquí es la opción 4, que se encarga de borrar una pieza específica en función del ID proporcionado por el usuario. Cuando el usuario selecciona esta opción, se le pide que introduzca el identificador único de la pieza que quiere eliminar. El programa luego ejecuta un comando SQL `DELETE` para eliminar ese registro exacto de la tabla "Piezas". Es importante destacar que este código no incluye manejo de errores ni validación del ID ingresado, por lo que podría resultar en consultas inseguras o mal formadas si se ingresa una entrada incorrecta.

Esta funcionalidad es crucial para mantener la integridad y precisión de los datos almacenados en la base de datos, permitiendo a los administradores o usuarios eliminar registros innecesarios o erróneos. Sin embargo, debe usarse con cuidado ya que la eliminación es una operación irreversible sin respaldo adecuado.

```python
import mysql.connector

print("Bienvenidos a la aplicacion")

conexion = mysql.connector.connect(
  host="localhost",
  user="portafolioceac",
  password="portafolioceac",
  database="portafolioceac"
  )
cursor = conexion.cursor()

while True:
  print("Selecciona una opcion:")
  print("1.-Crear un registro")
  print("2.-Listar registros")
  print("3.-Actualiar registro")
  print("4.-Eliminar registro")

  opcion = int(input("Elige tu opcion: "))
  
  if opcion == 1:
    titulo = input("Introduce el titulo: ")
    descripcion = input("Introduce la descripcion: ")
    imagen = input("Introduce la imagen: ")
    url = input("Introduce la url: ")
    id_categoria = input("Introduce la categoria: ")
    cursor.execute('''
      INSERT INTO Piezas VALUES (
      NULL,
      "'''+titulo+'''",
      "'''+descripcion+'''",
      "'''+imagen+'''",
      "'''+url+'''",
      '''+id_categoria+'''
      );
    ''')
    conexion.commit()
  elif opcion == 2:

    cursor.execute('''
      SELECT * FROM Piezas;
    ''')

    filas = cursor.fetchall()

    for fila in filas:
      print(fila)
  elif opcion == 3:
    pass
  elif opcion == 4:
    identificador = input("Introduce el id a eliminar: ")
    cursor.execute('''
      DELETE FROM Piezas
      WHERE Identificador = '''+identificador+'''
    ''')
    conexion.commit()
```

### actualizar

#### Explicación

Este fragmento de código es una aplicación sencilla que interactúa con una base de datos MySQL para gestionar registros en una tabla llamada `Piezas`. La aplicación ofrece al usuario cuatro opciones: crear un nuevo registro, listar todos los registros existentes, actualizar un registro existente y eliminar un registro. Todo esto se realiza a través de un bucle `while` que se mantiene ejecutándose hasta que el usuario decida salir.

La primera parte del código importa la librería `mysql.connector`, que es necesaria para establecer una conexión con la base de datos MySQL, y luego crea esa conexión usando los detalles proporcionados (host, nombre de usuario, contraseña, y nombre de la base de datos). Posteriormente, se genera un cursor a través de esta conexión. Un cursor en SQL actúa como un controlador que permite ejecutar comandos SQL directamente en la base de datos.

Cada opción del menú principal realiza una operación diferente:
- La opción 1 (`Crear un registro`) solicita al usuario que ingrese información para crear un nuevo registro en la tabla `Piezas`.
- La opción 2 (`Listar registros`) consulta todos los registros existentes y los imprime en pantalla.
- La opción 3 (`Actualizar registro`) permite modificar un registro específico basado en su ID, solicitando al usuario nueva información para actualizar.
- Finalmente, la opción 4 (`Eliminar registro`) elimina un registro de la base de datos según el ID proporcionado por el usuario.

Cada vez que se ejecuta una consulta SQL (INSERT, SELECT, UPDATE o DELETE), la aplicación utiliza `cursor.execute()` seguido de `conexion.commit()`. Esto es importante porque los cambios en la base de datos no se aplican inmediatamente hasta que se realiza un commit; este paso garantiza que todas las operaciones realizadas estén confirmadas y guardadas permanentemente en la base de datos.

```python
import mysql.connector

print("Bienvenidos a la aplicacion")

conexion = mysql.connector.connect(
  host="localhost",
  user="portafolioceac",
  password="portafolioceac",
  database="portafolioceac"
  )
cursor = conexion.cursor()

while True:
  print("Selecciona una opcion:")
  print("1.-Crear un registro")
  print("2.-Listar registros")
  print("3.-Actualiar registro")
  print("4.-Eliminar registro")

  opcion = int(input("Elige tu opcion: "))
  
  if opcion == 1:
    titulo = input("Introduce el titulo: ")
    descripcion = input("Introduce la descripcion: ")
    imagen = input("Introduce la imagen: ")
    url = input("Introduce la url: ")
    id_categoria = input("Introduce la categoria: ")
    cursor.execute('''
      INSERT INTO Piezas VALUES (
      NULL,
      "'''+titulo+'''",
      "'''+descripcion+'''",
      "'''+imagen+'''",
      "'''+url+'''",
      '''+id_categoria+'''
      );
    ''')
    conexion.commit()
  elif opcion == 2:

    cursor.execute('''
      SELECT * FROM Piezas;
    ''')

    filas = cursor.fetchall()

    for fila in filas:
      print(fila)
  elif opcion == 3:
    identificador = input("Introduce el id a actualizar: ")
    titulo = input("Introduce el titulo: ")
    descripcion = input("Introduce la descripcion: ")
    imagen = input("Introduce la imagen: ")
    url = input("Introduce la url: ")
    id_categoria = input("Introduce la categoria: ")
    cursor.execute('''
      UPDATE Piezas SET 
      titulo = "'''+titulo+'''",
      descripcion = "'''+descripcion+'''",
      imagen = "'''+imagen+'''",
      url = "'''+url+'''",
      id_categoria = '''+id_categoria+'''
      WHERE Identificador = '''+identificador+''';
    ''')
    conexion.commit()
  elif opcion == 4:
    identificador = input("Introduce el id a eliminar: ")
    cursor.execute('''
      DELETE FROM Piezas
      WHERE Identificador = '''+identificador+'''
    ''')
    conexion.commit()
```

### Actividades propuestas

### Actividades Propuestas

1. **Menú de Opciones Básico**
   - Descripción: El estudiante debe crear un menú en Python que permita al usuario seleccionar entre diferentes opciones y luego mostrar un mensaje correspondiente a la opción elegida.
   - Objetivo: Aprender a usar estructuras condicionales y bucles para manejar interacción del usuario.

2. **Manejo de Bucle Infinito**
   - Descripción: El estudiante debe modificar el menú básico para que funcione en un bucle infinito hasta que el usuario decida salir.
   - Objetivo: Aprender a utilizar bucles infinitos y manejar la interrupción del flujo de ejecución según una condición dada por el usuario.

3. **Condicionales Avanzados**
   - Descripción: El estudiante debe implementar las condiciones dentro del menú para que cada opción realice tareas específicas.
   - Objetivo: Aprender a usar estructuras de control avanzadas como `if`, `elif` y `else`.

4. **Conexión a Base de Datos**
   - Descripción: El estudiante debe conectar un script Python con una base de datos MySQL local para realizar operaciones básicas.
   - Objetivo: Aprender la sintaxis básica para conectarse a una base de datos usando el módulo `mysql.connector`.

5. **Selección de Datos**
   - Descripción: El estudiante debe escribir un script que permita seleccionar y mostrar registros desde una tabla específica en una base de datos.
   - Objetivo: Aprender cómo realizar consultas SELECT en MySQL usando Python.

6. **Inserción de Datos**
   - Descripción: El estudiante debe implementar la funcionalidad para insertar nuevos registros en una tabla de la base de datos a partir del menú.
   - Objetivo: Familiarizarse con la inserción de datos en tablas MySQL utilizando Python.

7. **Eliminación de Datos**
   - Descripción: El estudiante debe agregar la funcionalidad para eliminar un registro específico según el ID proporcionado por el usuario.
   - Objetivo: Aprender a realizar operaciones DELETE y manejar entradas del usuario para identificar el registro a eliminar.

8. **Actualización de Datos**
   - Descripción: El estudiante debe añadir la funcionalidad que permite al usuario actualizar un registro existente en una tabla.
   - Objetivo: Familiarizarse con las consultas UPDATE y gestionar entradas del usuario para especificar los cambios a realizar.

Estas actividades están diseñadas para que los estudiantes practiquen habilidades clave de programación en Python, incluyendo interacción con bases de datos MySQL, manejo básico de flujo de ejecución y uso de estructuras de control condicional.


<a id="ejercicio-de-final-de-unidad-4"></a>
## Ejercicio de final de unidad

### Introducción a los ejercicios

Esta carpeta contiene un conjunto de ejercicios que abordan los conceptos fundamentales del lenguaje Python. Los problemas se enfocan en aspectos como la impresión básica, el uso y manipulación de variables, entrada/salida de datos, tipos de datos, operadores aritméticos y comparativos, así como la introducción a la creación de programas más complejos que realizan cálculos básicos. A través de estos ejercicios, los estudiantes practicarán habilidades esenciales en programación, incluyendo la resolución de problemas, la estructuración del código y la comprensión del flujo de ejecución de un programa Python.

### Holamundo

#### Explicación

Este fragmento de código es una línea simple que muestra cómo imprimir texto en la pantalla utilizando el lenguaje de programación Python. La función `print()` se utiliza para mostrar información por consola o pantalla. En este caso, el texto entre comillas ("Hola mundo desde Python") será lo que salga por pantalla cuando se ejecute este código.

El ejemplo "Hola mundo" es muy común en la enseñanza del programar porque ilustra de manera sencilla cómo interactuar con el sistema operativo y mostrar información. Es importante porque te ayuda a entender los conceptos básicos antes de pasar a cosas más complejas como variables, estructuras de control y objetos.

Este código te permite comprobar que tu entorno de desarrollo está configurado correctamente y que Python funciona adecuadamente en tu máquina.

```python
print("Hola mundo desde Python")
```

### variables

#### Explicación

Este fragmento de código es muy sencillo y fundamental en programación. Primero, se crea una variable llamada `nombre` y se le asigna el valor `"Jose Vicente"`. En este caso, la información que almacenamos en `nombre` es una cadena de texto o "string", lo que significa que estamos guardando letras y espacios entre comillas dobles.

A continuación, creamos otra variable llamada `edad`, pero esta vez le asignamos un número entero (`47`). Este tipo de dato se conoce como entero o "integer" en inglés. Almacenar la edad como un número entero es importante porque nos permite realizar operaciones matemáticas si fuera necesario, por ejemplo, para calcular el año de nacimiento.

Estas dos líneas son fundamentales porque muestran cómo almacenar y diferenciar entre diferentes tipos de datos (cadenas de texto y números enteros) en Python. Es esencial entender esto para poder manejar información variada en tus programas más adelante.

```python
nombre = "Jose Vicente"
edad = 47
```

### salidas

#### Explicación

Este código simple en Python muestra cómo imprimir un mensaje en la pantalla que combina texto estático y una variable. Primero, se crea una variable llamada `nombre` y se le asigna el valor de la cadena "Jose Vicente". Luego, utilizando la función `print`, se imprime en la consola el texto "Mi nombre es" seguido del contenido almacenado en la variable `nombre`. Esto demuestra cómo puedes mostrar información personalizada que combina tanto texto fijo como datos variables. Es importante porque permite a los programas comunicarse con el usuario de manera más amigable y significativa, entregando información relevante en un formato claro y legible.

```python
nombre = "Jose Vicente"
print("Mi nombre es",nombre)
```

### variar una variable

#### Explicación

Este código muestra cómo se puede cambiar el valor de una variable en Python. En primer lugar, la variable `nombre` se inicializa con el string `"Jose Vicente"`, y luego este valor se imprime en pantalla usando la función `print`. Después, la variable `nombre` cambia su valor a `"Juan"` y nuevamente se imprime en pantalla con la misma función. Esto es importante porque demuestra cómo las variables pueden almacenar diferentes valores a lo largo del tiempo en un programa, permitiendo así que el programa sea flexible y pueda adaptarse a diferentes situaciones o datos ingresados por el usuario.

```python
nombre = "Jose Vicente"
print("Mi nombre es",nombre)

nombre = "Juan"
print("Mi nombre es",nombre)
```

### identificadores permitidos

#### Explicación

Este código es una parte de un ejercicio que demuestra cómo elegir correctamente los nombres para las variables en Python. En el fragmento, vemos diferentes maneras incorrectas y correcta de nombrar variables, lo cual es crucial ya que los nombres de las variables deben seguir ciertas reglas. 

La primera línea `nombre = "Jose"` define una variable llamada `nombre` que almacena la cadena `"Jose"`. Luego se crea otra variable `nombre2`, también almacenando un nombre diferente. Sin embargo, hay varias líneas comentadas (`#`) que muestran nombres de variables incorrectos o no recomendados: intentar usar un número como primer carácter (como en `2nombre`), guiones medios (`-`), y espacios en blanco (`nombre completo`). 

La línea final `nombreCompleto = "Jose Vicente"` es la única forma correcta entre las opciones mostradas, ya que combina palabras con mayúscula inicial para cada palabra después de la primera (conocido como formato CamelCase). Aunque Python permite esto técnicamente, no se recomienda en código legible y estándar porque dificulta la comprensión del código.

Este ejercicio enfatiza la importancia de seguir las convenciones al nombrar variables para mantener el código claro y fácil de entender.

```python
nombre = "Jose"
nombre2 = "Vicente"
# 2nombre = "Jose Vicente"
nombre_completo = "Jose Vicente"
#nombre-completo = "Jose Vicente"
#nombre completo = "Jose Vicente"
nombreCompleto = "Jose Vicente" # Es legal pero no se recomienda
```

### comentarios

#### Explicación

Este fragmento de código está compuesto por dos tipos diferentes de comentarios en Python. En la primera línea, tienes un comentario simple que comienza con el carácter numeral (#). Este tipo de comentario se extiende hasta el final de esa misma línea y se utiliza para anotar o describir pequeñas partes del código.

La segunda parte son comentarios múltiples, también conocidos como docstrings en Python. Estos se encierran entre comillas triples (""") y pueden estenderse a lo largo de varias líneas. Los docstrings son útiles cuando necesitas documentar funciones o clases con descripciones detalladas que explican su propósito o cómo utilizarlas.

En resumen, estos comentarios sirven para hacer el código más fácil de entender para los demás programadores (o incluso para ti mismo en un futuro), proporcionando contexto sobre lo que hace cierto bloque de código. Esto es especialmente importante cuando trabajas en proyectos grandes o colaboras con otros desarrolladores.

```python
# Esto es un comentario de una única línea

'''
    Esto es un comentario
    Esto sigue siendo un comentario
    Y esto también lo es
'''
```

### Explicacion del codigo

#### Explicación

Este fragmento de código define una variable llamada `edad` y le asigna un valor específico. En Python, `edad` es lo que llamamos un "identificador", que es básicamente un nombre que usamos para referirnos a un dato en nuestro programa. El signo igual (`=`) es el operador de asignación, que indica que queremos guardar el número 47 en la variable `edad`. Es importante entender esto porque cualquier vez que hagamos referencia al identificador `edad` en adelante en el código, estaremos hablando del valor numérico 47.

```python
edad = 47
# edad es el identificador
# = es el operador de asignación
# 47 es el valor literal que se es está asignando al identificador
```

### Tipos de datos

#### Explicación

Este código es una introducción simple a los tipos de datos en Python, que son fundamentales para cualquier programa. Aquí se crean cuatro variables con diferentes tipos de datos: 

- `nombre` almacena el texto "Jose Vicente", lo cual es un tipo de dato cadena o string, utilizado para guardar caracteres y palabras.
- `edad` contiene el número 47, que pertenece al tipo entero (int), usado para números enteros sin decimales.
- `altura` tiene almacenado el valor numérico 1.78, un decimal o float en Python, diseñado para manejar números con parte fraccionaria.
- `vivo` se establece como True, que es un booleano (bool), usado principalmente para representar verdadero o falso.

Este bloque de código demuestra cómo asignamos valores iniciales a variables en Python y muestra la diversidad de datos que puedes manejar. Es importante entender estos tipos básicos porque cada uno tiene sus propias reglas y comportamientos cuando se usa en operaciones más complejas, como cálculos o comparaciones.

```python
nombre = "Jose Vicente" # Cadena
edad = 47 # Entero
altura = 1.78 # Decimal
vivo = True # Booleano
```

### Entradas

#### Explicación

Este fragmento de código es muy simple pero fundamental para entender cómo interactuar con el usuario en Python. Primero, la línea `nombre = input("Dime tu nombre: ")` solicita al usuario que introduzca su nombre a través del teclado y luego guarda esa entrada en una variable llamada `nombre`. La función `input()` espera un texto entre comillas que sirve como mensaje para el usuario. Después de ejecutar esta línea, Python espera la respuesta del usuario.

Luego, con la línea `print("Tu nombre es: ", nombre)`, el programa muestra por pantalla un mensaje que indica al usuario cuál es su nombre, usando nuevamente la información almacenada en la variable `nombre`. Esta línea utiliza la función `print()` para mostrar textos y variables juntos.

Este código es importante porque demuestra cómo obtener datos del usuario (lectura) y devolver resultados al usuario (escritura), dos conceptos básicos en la programación.

```python
nombre = input("Dime tu nombre: ")
print("Tu nombre es: ",nombre)
```

### Entrada y problema

#### Explicación

Este fragmento de código en Python pide al usuario que ingrese su edad y luego muestra el doble de esa edad. Primero, la línea `edad = input("Dime tu edad: ")` le pregunta a quien ejecuta el programa cuántos años tiene y guarda la respuesta como un texto (string) en la variable `edad`. Luego, con `print("El doble de tu edad es: "+edad)`, el programa imprime una frase que indica el doble de la edad. Sin embargo, hay un error conceptual aquí porque no se realiza ningún cálculo para duplicar realmente la edad; simplemente muestra el número ingresado como texto sin hacer ninguna multiplicación.

Es importante notar que si quisieras calcular efectivamente el doble de la edad, deberías convertir primero la entrada `edad` a un número entero usando la función `int()` antes de realizar cualquier cálculo.

```python
edad = input("Dime tu edad: ")
print("El doble de tu edad es: "+edad)
```

### Cambio de tipo de dato

#### Explicación

Este fragmento de código en Python solicita al usuario que introduzca su edad y luego realiza algunos cálculos con ese dato. Primero, el programa pide al usuario que ingrese su edad usando la función `input()`, lo cual guarda la respuesta como una cadena de texto (string) en la variable `edad`. Luego, para poder hacer operaciones matemáticas con esa edad, convierte esta cadena a un número entero mediante la función `int()` y lo almacena en otra variable llamada `entero`.

Después, el código calcula el doble de este valor numérico (la edad convertida) multiplicándolo por dos y guarda el resultado en una nueva variable llamada `doble`. Finalmente, intenta imprimir el resultado utilizando la función `print()`, pero hay un error: cuando se utiliza `print` para mostrar texto junto con otros tipos de datos como números enteros, es necesario combinarlos adecuadamente. En este caso, debes convertir `doble` a una cadena antes de concatenarlo con otra cadena.

Este código demuestra cómo interactuar con el usuario (leer la entrada), hacer conversiones entre diferentes tipos de datos y realizar cálculos básicos en Python. Sin embargo, es importante corregir ese último paso para evitar errores al ejecutar el programa.

```python
# Le pregunto al usuario por su edad
edad = input("Dime tu edad: ")
# Me aseguro de convertir la edad a un número entero
entero = int(edad)
# Calculo el doble de un número entero
doble = entero*2
# Saco el resultado por pantalla
print("El doble de tu edad es: "+doble)
```

### literales

#### Explicación

Este fragmento de código en Python está asignando valores a dos variables: `nombre` e `edad`. La variable `nombre` recibe una cadena (texto) que dice "Jose Vicente", mientras que la variable `edad` recibe el número 47. En programación, cuando vemos un valor como "Jose Vicente" o simplemente 47 sin comillas ni operaciones matemáticas, lo llamamos un literal. Los literales de texto (como "Jose Vicente") se conocen como cadenas y los literales numéricos (como 47) son enteros. Es importante comprender estos tipos de datos básicos porque nos permiten almacenar diferentes tipos de información que luego podemos utilizar en nuestro programa para realizar tareas específicas, como mostrar un mensaje o hacer cálculos matemáticos.

```python
nombre = "Jose Vicente"
# Jose Vicente es el literal, y es de tipo cadena

edad = 47
# 47 es el literal, y es de tipo entero
```

### constantes

#### Explicación

Este código muestra cómo se pueden cambiar los valores de una variable en Python. En este caso, la variable es `PI`, que inicialmente se establece como el número 3.1415 y luego su valor cambia a 4. El programa imprime dos veces lo que vale `PI` después de cada cambio.

Lo importante aquí es entender que aunque `PI` generalmente representa un valor matemático constante, en programación, las variables pueden cambiar sus valores siempre y cuando no estén declaradas como constantes. En este ejemplo, la advertencia al final sugiere usar mayúsculas para representar una "constante" (`PI`) de manera que se recuerde que es un valor que normalmente debería permanecer inmutable, aunque en Python esto no implica que el valor no pueda ser modificado.

Este código sirve para ilustrar la importancia del buen uso de nombres de variables y constantes, ya que ayuda a otros programadores (y a ti mismo si revisas el código después) a entender mejor qué es lo que está sucediendo en tu programa.

```python
PI = 3.1415

print("PI vale",PI)

PI = 4 # Le cambio el valor a PI

print("PI vale",PI)
# Las constantes deben formularse con mayúsculas
# Las variables deben formularse con minúsculas
```

### Diferencia

#### Explicación

Este fragmento de código muestra cómo se pueden definir y modificar variables en Python, que son importantes conceptos en la programación. Primero, el código define una variable llamada `PI` e inicializa esta variable con el valor numérico 3.1416, lo cual es un aproximado común del número matemático π (pi). Luego, sin embargo, se redefine la misma variable `PI`, pero ahora no como un número sino como una cadena de texto que dice "unnumero". Esto es importante porque demuestra cómo en Python las variables pueden cambiar su tipo y valor a lo largo del programa. En este caso específico, el código altera la naturaleza original de `PI` desde un número flotante hasta una simple cadena de caracteres, lo cual puede llevar a errores o comportamientos inesperados si se utiliza esta variable después sin tener en cuenta que ahora es texto en lugar de un número.

```python

# La constante es PI
# El literal es 3.1416

PI = 3.1416

PI = "unnumero"
```

### operadores aritmeticos

#### Explicación

Este fragmento de código es una introducción básica a los operadores aritméticos en Python. Cada línea del código realiza una operación matemática simple y luego imprime el resultado en la consola. 

La primera línea suma dos números: 4 + 3, lo que resulta en 7. La segunda línea resta estos mismos números: 4 - 3, dando como resultado 1. La tercera línea multiplica los dos números: 4 * 3, produciendo 12. La cuarta línea divide el primer número por el segundo: 4 / 3, que es aproximadamente 1.33 cuando se redondea a dos decimales. Finalmente, la quinta línea utiliza el operador módulo (%), lo cual calcula el resto de la división entre los dos números: 4 % 3, dando como resultado 1.

Este código es importante porque demuestra cómo Python puede realizar cálculos matemáticos básos utilizando diferentes tipos de operadores. Esto te permite hacer todo tipo de cálculos en tus programas y entenderás que puedes combinar estos operadores para resolver problemas más complejos.

```python
print(4+3)
print(4-3)
print(4*3)
print(4/3)
print(4%3)
```

### operadores de comparacion

#### Explicación

Este código en Python muestra cómo funcionan los operadores de comparación, que son esenciales para tomar decisiones y controlar el flujo del programa. Los operadores aquí utilizados (menor que `<`, menor o igual `<=`, mayor que `>`, mayor o igual `>=`, igual a `==` y diferente de `!=`) se aplican a dos números, en este caso 4 y 3, para compararlos entre sí. Cada línea del código imprime el resultado booleano (verdadero o falso) de la comparación realizada por esos operadores.

Es importante entender estos operadores porque permiten al programador establecer condiciones y ejecutar diferentes bloques de código basándose en esas condiciones, lo cual es fundamental para crear programas interactivos y dinámicos.

```python
print(4 < 3)
print(4 <= 3)
print(4 > 3)
print(4 >= 3)
print(4 == 3)
print(4 != 3)
```

### operadores arimeticos abreviados

#### Explicación

Este código muestra cómo se pueden modificar el valor de una variable en Python usando diferentes operadores aritméticos. La variable `edad` inicialmente está establecida con un valor de 47 años. A continuación, se realizan varias operaciones para sumar, restar, multiplicar y dividir este valor.

Primero, el código suma dos unidades a la edad usando el operador de asignación combinado `+=`, que es una forma abreviada de escribir `edad = edad + 2`. Esto significa que después de esta línea, la edad será 49. A continuación, se repite este proceso para restar y dividir por dos, utilizando los operadores `-=` y `/=`, respectivamente.

Estos operadores abreviados no sólo hacen que el código sea más compacto y fácil de leer sino también más rápido de escribir y menos propenso a errores al evitar la duplicación de nombres de variables. En resumen, este fragmento te enseña cómo puedes realizar cálculos directamente en una variable sin necesidad de escribir expresiones largas repetidas veces.

```python
edad = 47
# Le quiero sumar dos unidades
edad = edad + 2
edad += 2
#Le quiero restar dos unidades
edad = edad - 2
edad -= 2
# Lo quiero multiplicar por dos
edad = edad * 2
edad *= 2
# Lo quiero dividir por dos
edad = edad / 2
edad /= 2
```

### operadores booleanos

#### Explicación

Este código está utilizando operadores booleanos para evaluar expresiones y mostrar sus resultados en la pantalla. Los operadores que se utilizan son `and` y `or`. 

El primer conjunto de líneas compara tres igualdades usando el operador `and`, lo que significa que todas las comparaciones deben ser verdaderas para que el resultado final sea `True`. Por ejemplo, en la primera línea, 4 es igual a 4, 3 es igual a 3 y 2 es igual a 2, por lo que toda la expresión es verdadera (`True`). Sin embargo, en la segunda línea, aunque las primeras dos comparaciones son verdaderas (4 es igual a 4 y 3 es igual a 3), la última es falsa (2 no es igual a 1), así que el resultado final de toda la expresión con `and` es `False`.

En las siguientes líneas, se utilizan operadores `or`, que significan que si al menos una comparación es verdadera, todo el conjunto será evaluado como `True`. En la línea que dice "4 == 4 or 3 == 3 or 2 == 1", todas las condiciones son verdaderas por lo que da un resultado de `True`. Sin embargo, en la siguiente línea "4 == 4 or 3 == 2 or 2 == 1", aunque 4 es igual a 4 (verdadero), tanto 3 no es igual a 2 como 2 no es igual a 1 son falsas. Pero debido al `or`, solo se necesita una parte verdadera para que todo sea evaluado como `True`. La última línea "4 == 3 or 3 == 2 or 2 == 1" evalúa todas las comparaciones como falsas, por lo que el resultado final es `False`.

Estos ejercicios son importantes porque te ayudan a entender cómo funcionan los operadores lógicos en Python y cómo combinar varias condiciones para tomar decisiones en tu código.

```python
print(4 == 4 and 3 == 3 and 2 == 2)
print(4 == 4 and 3 == 3 and 2 == 1)

print(4 == 4 or 3 == 3 or 2 == 1)
print(4 == 4 or 3 == 2 or 2 == 1)
print(4 == 3 or 3 == 2 or 2 == 1)
```

### Ejercicio1-Calculadora de impuestos

#### Explicación

Este fragmento de código es la descripción inicial o "docstring" de un programa en Python que realiza cálculos relacionados con impuestos. El programa, llamado "Calculadora de Impuestos", versión 0.1, está creado por Jose Vicente Carratalá. Su función principal consiste en permitir al usuario ingresar una cantidad base (el precio antes del impuesto) y luego calcular el IVA (Impuesto sobre Valor Añadido) para esa cantidad, así como la suma total que resulta de añadir el IVA a la base imponible. Esta descripción sirve tanto para informar acerca de las características del programa como para guiar al usuario en cómo utilizarlo correctamente.

Es importante destacar que esta parte del código es principalmente informativa y no realiza ninguna operación programática por sí sola; su función principal es proporcionar un resumen claro sobre lo que hace el programa y quién lo creó.

```python
'''
    Calculadora de Impuestos
    v0.1 por Jose Vicente Carratalá
    Funcionamiento: Introduce una base imponible y se calcula IVA y total
'''
```

### Calculadora

#### Explicación

Este fragmento de código es el inicio de un programa en Python que actúa como una sencilla calculadora para calcular impuestos, específicamente el IVA (Impuesto sobre el Valor Añadido). El objetivo del programa es permitir al usuario introducir la base imponible de una factura y luego calcular el IVA y el total a pagar. En este código, se inicializan tres variables: `base_imponible`, `total_iva` y `total_factura`. Estas variables van a almacenar los valores correspondientes que se calculen durante la ejecución del programa.

El código también incluye un comentario sobre cómo funcionaría el resto del programa si estuviera completo, sugiriendo que las funciones o clases adicionales serían añadidas en una sección marcada con "Aquí pondría las funciones/clases". Por ahora, sin embargo, sólo recoge la base imponible de la factura mediante `input()`, lo que significa que el programa espera a que el usuario introduzca un valor. Es importante destacar que este valor es inicialmente un string y necesitaría ser convertido en un número para poder hacer cálculos matemáticos con él.

Este tipo de código es crucial en contextos profesionales, ya que permite automatizar tareas que de otro modo podrían requerir mucho tiempo si se hicieran a mano.

```python
'''
    Calculadora de Impuestos
    v0.1 por Jose Vicente Carratalá
    Funcionamiento: Introduce una base imponible y se calcula IVA y total
'''

# Este programa no tiene importaciones

# Creo variables
base_imponible = 0
total_iva = 0
total_factura = 0

# Aquí pondría las funciones/clases

# Ahora calculamos
base_imponible = input("Introduce la base imponible de la factura: ")
```

### Calculadora

#### Explicación

Este código es el comienzo de un programa simple en Python que sirve como una calculadora para calcular impuestos. El objetivo principal del programa es permitir al usuario introducir una cantidad llamada "base imponible", y luego el programa calculará el IVA (Impuesto sobre Valor Añadido) y mostrará el total de la factura.

El código comienza creando tres variables que se van a utilizar para almacenar diferentes valores: `base_imponible`, `total_iva` y `total_factura`. Estas variables están inicializadas en cero, lo cual significa que al principio no tienen ningún valor asignado. A continuación, el programa imprime algunas líneas de texto para proporcionar información sobre el programa, incluyendo su autor y una breve descripción de cómo funciona.

La parte más importante es cuando se pide al usuario que introduzca la base imponible a través del comando `input()`. Este comando permite capturar lo que el usuario escribe en la consola. Sin embargo, hasta este punto, el código no incluye la lógica para calcular realmente el IVA ni muestra los resultados totales de la factura, por lo que aún falta implementar esa parte.

Este tipo de programa es útil en situaciones donde se necesita calcular rápidamente impuestos y totalizar facturas. Es importante entender cómo funciona porque te ayuda a familiarizarte con conceptos básicos del desarrollo de software como la entrada/salida de datos y el manejo de variables, lo cual son fundamentales en programación.

```python
'''
    Calculadora de Impuestos
    v0.1 por Jose Vicente Carratalá
    Funcionamiento: Introduce una base imponible y se calcula IVA y total
'''

# Este programa no tiene importaciones

# Creo variables
base_imponible = 0
total_iva = 0
total_factura = 0

# Aquí pondría las funciones/clases

# Ahora calculamos
print("Programa calculadora de impuestos")
print("(c) 2025 Jose Vicente Carratalá")
print("Introduce una base y te calculo el IVA y el total")
base_imponible = input("Introduce la base imponible de la factura: ")
```

### Calculo de IVA

#### Explicación

Este fragmento de código es un programa simple que calcula el Impuesto sobre Valor Añadido (IVA) y el total de una factura basado en la base imponible introducida por el usuario. El programa comienza pidiendo al usuario que ingrese la cantidad base imponible, convirtiendo esa entrada en un número decimal para poder realizar cálculos matemáticos. Luego, calcula el IVA aplicando un 21% a la base imponible y suma este valor al total de la factura para obtener el monto final. Finalmente, muestra por pantalla tanto el importe del IVA como el total de la factura.

Este tipo de programa es útil en situaciones donde se necesita calcular rápidamente cuánto es el IVA que debe aplicarse a una compra o servicio y qué sería el precio total después de añadir dicho impuesto. Es importante entender cómo funciona porque permite automatizar tareas básicas relacionadas con finanzas y ventas, lo cual puede ahorrar tiempo en comparación con hacer estos cálculos manualmente.

```python
'''
    Calculadora de Impuestos
    v0.1 por Jose Vicente Carratalá
    Funcionamiento: Introduce una base imponible y se calcula IVA y total
'''

# Este programa no tiene importaciones

# Creo variables
base_imponible = 0
total_iva = 0
total_factura = 0

# Aquí pondría las funciones/clases

# Ahora calculamos

# Primero pido una entrada
print("Programa calculadora de impuestos")
print("(c) 2025 Jose Vicente Carratalá")
print("Introduce una base y te calculo el IVA y el total")
base_imponible = float(input("Introduce la base imponible de la factura: "))

# Luego realizo cálculos
total_iva = base_imponible*0.21
total_factura = base_imponible + total_iva

# Por último expreso una salida
print("El IVA de la factura es: ",total_iva)
print("El total de la factura es: ",total_factura)
```

### Actividades propuestas

### Actividad 1: Introducción al Lenguaje Python
**Descripción:** Los alumnos deben crear un programa sencillo que imprima "Hola mundo" en pantalla. El objetivo es familiarizarse con el entorno de desarrollo y entender la sintaxis básica de Python.

---

### Actividad 2: Variables y Entrada/Salida
**Descripción:** Se les pide a los estudiantes que creen un programa donde soliciten al usuario su nombre y edad, luego imprimir ambas variables en pantalla. Esta actividad ayuda a comprender el manejo de datos e interacción con el usuario.

---

### Actividad 3: Operaciones Básicas
**Descripción:** Los alumnos deben escribir un código que realice operaciones aritméticas básicas (suma, resta, multiplicación y división) entre dos números ingresados por el usuario. Esto reforzará su entendimiento de los tipos de datos numéricos y las operaciones sobre ellos.

---

### Actividad 4: Operadores Lógicos
**Descripción:** La tarea consiste en crear un programa que evalúe expresiones lógicas (usando AND, OR) entre diferentes condiciones booleanas. Esto ayudará a los estudiantes a entender la lógica y estructura condicional.

---

### Actividad 5: Conversión de Tipos
**Descripción:** Los alumnos deben escribir una función que solicite al usuario un número en formato texto (como entrada de cadena), lo convierta a entero, realice alguna operación aritmética básica con este valor y muestre el resultado. Esta actividad refuerza los conceptos de tipos de datos y conversión.

---

### Actividad 6: Operaciones Aritméticas Avanzadas
**Descripción:** Los estudiantes deben desarrollar un programa que realice operaciones matemáticas más complejas (por ejemplo, cálculo del IVA en una factura) con operadores aritméticos y de asignación abreviados. Esto proporciona práctica adicional con operadores y manejo de datos numéricos.

---

### Actividad 7: Manejo de Errores Básicos
**Descripción:** Se les pide a los estudiantes que identifiquen y resuelvan errores en un código existente (como el visto en `011-Cambio de tipo de dato.py`). Esto mejora sus habilidades para detectar problemas y mejorar la robustez del código.

---

### Actividad 8: Programa Completo - Calculadora de Impuestos
**Descripción:** Los alumnos deben completar un programa proporcionado (base en `021-Calculo de IVA.py`) que calcula el IVA de una factura. Esto les permitirá integrar varios conceptos aprendidos y practicar la creación de un programa completo desde inicio a fin.

---

### Actividad 9: Documentación y Comentarios
**Descripción:** Los estudiantes deben agregar documentación (comentarios) en sus programas anteriores para explicar lo que hace cada parte del código. Esto mejora su habilidad de comunicación técnica y entendimiento profundo del código.

---

### Actividad 10: Uso Eficiente de Variables
**Descripción:** Se les pide a los estudiantes diseñar un programa donde se utilizan variables correctamente, incluyendo buenas prácticas de nomenclatura (como usar mayúsculas para constantes). Esto refuerza su conocimiento sobre la correcta utilización y declaración de variables en Python.


<a id="examen-final"></a>
## Examen final

### Introducción a los ejercicios

Esta carpeta contiene un conjunto de ejercicios orientados a desarrollar habilidades en el manejo y administración de bases de datos SQL. Los estudiantes aprenderán desde la creación de tablas, inserción de datos y definición de relaciones entre tablas hasta la ejecución de consultas avanzadas que incluyen joins y vistas para integrar información de múltiples tablas. Además, se practica la gestión de usuarios y permisos en un entorno de base de datos, lo cual es crucial para el control y seguridad del sistema.

El objetivo principal es familiarizar a los estudiantes con las operaciones CRUD (Crear, Leer, Actualizar, Eliminar) mediante SQL, así como entender cómo estructurar una base de datos relacionada eficientemente.

### crear tablas

#### Explicación

Este código SQL está diseñado para crear una base de datos y dos tablas dentro de ella. En primer lugar, se crea la base de datos llamada "portafolioceac". Luego, se selecciona esta base de datos para trabajar con ella.

Las dos tablas que se crean son `Piezas` y `Categorias`. La tabla `Piezas` almacena información sobre diferentes piezas o elementos del portafolio, como su título, descripción, imagen, URL y categoría. Cada pieza tiene un identificador único generado automáticamente (columna `Identificador`) que es la clave principal de esta tabla.

Por otro lado, la tabla `Categorias` contiene detalles acerca de las diferentes categorías a las que pueden pertenecer estas piezas, con campos para el título y descripción de cada categoría. La columna `id_categoria` en la tabla `Piezas` se utiliza para relacionar una pieza con su correspondiente categoría en la tabla `Categorias`.

Este código es importante porque establece la estructura básica que permitirá almacenar y organizar información sobre los diferentes elementos del portafolio de manera eficiente.

```sql
CREATE DATABASE portafolioceac;

USE portafolioceac;


CREATE TABLE Piezas(
  Identificador INT auto_increment PRIMARY KEY,
  titulo VARCHAR(255),
  descripcion VARCHAR(255),
  imagen VARCHAR(255),
  url VARCHAR(255),
  id_categoria INT
);

CREATE TABLE Categorias(
  Identificador INT auto_increment PRIMARY KEY,
  titulo VARCHAR(255),
  descripcion VARCHAR(255)
);
```

### insertar

#### Explicación

Este código SQL está realizando inserciones en dos tablas diferentes: `Categorias` y `Piezas`. En la primera instrucción, se inserta un nuevo registro en la tabla `Categorias`, especificando tres campos. El primer campo (`NULL`) es probablemente el identificador único automático que SQLite o cualquier otro sistema de gestión de bases de datos generará automáticamente. Los otros dos campos son 'General' y una descripción corta para esta categoría. 

En la segunda instrucción, se inserta un nuevo registro en la tabla `Piezas`. Similar al caso anterior, el primer campo es `NULL`, lo que implica que este valor también será generado automáticamente por la base de datos. Los campos restantes incluyen el nombre de una pieza ('Primera pieza'), una descripción más detallada, un nombre de archivo de imagen relacionado y una URL web. Finalmente, se especifica un número 1 en el último campo que probablemente hace referencia a un ID de categoría ya existente, vinculando esta pieza a la categoría 'General' creada anteriormente.

Esta inserción es importante porque permite llenar las tablas con datos iniciales o de prueba. Es una práctica común en desarrollo web y bases de datos para asegurar que el sistema tenga datos mínimos necesarios para funcionar correctamente antes de su lanzamiento o durante pruebas.

```sql
INSERT INTO Categorias VALUES(
  NULL,
  'General',
  'Esta es la categoria general'
);

INSERT INTO Piezas VALUES(
  NULL,
  'Primera pieza',
  'Esta es la descripcion de la primera pieza',
  'josevicente.jpg',
  'https://jocarsa.com',
  1
);
```

### fk

#### Explicación

Este fragmento de código SQL se utiliza para modificar una tabla existente llamada `Piezas`. Específicamente, añade una restricción de clave foránea llamada `fk_piezas_categorias` que vincula la columna `id_categoria` en la tabla `Piezas` con la columna `identificador` en otra tabla llamada `Categorias`.

Lo que hace este código es asegurar que cada valor en la columna `id_categoria` de la tabla `Piezas` debe existir como un valor válido en la columna `identificador` de la tabla `Categorias`. Esto establece una relación entre estas dos tablas, donde las piezas pertenecen a categorías específicas.

Además, las opciones `ON DELETE CASCADE` y `ON UPDATE CASCADE` indican que si se elimina un registro (por ejemplo, una categoría) en la tabla `Categorias`, también se eliminarán automáticamente todos los registros relacionados en la tabla `Piezas`. Lo mismo ocurre con actualizaciones: si el identificador de una categoría cambia, los valores correspondientes en las piezas serán actualizados automáticamente. Esto ayuda a mantener la integridad referencial y simplifica la gestión de datos entre tablas relacionadas.

```sql
ALTER TABLE Piezas
ADD CONSTRAINT fk_piezas_categorias
FOREIGN KEY (id_categoria) REFERENCES Categorias(identificador)
ON DELETE CASCADE
ON UPDATE CASCADE;
```

### selecciones

#### Explicación

Este fragmento de código SQL consta de dos sentencias SELECT que se utilizan para consultar datos en una base de datos. La primera línea, `SELECT * FROM Categorias;`, recupera toda la información de la tabla llamada "Categorias". Esto significa que el sistema traerá todos los campos y registros que hay en esta tabla específica. La segunda línea, `SELECT * FROM Piezas;`, hace lo mismo pero para otra tabla denominada "Piezas".

Estas consultas son importantes porque permiten a un desarrollador o administrador de base de datos visualizar fácilmente el contenido de estas tablas sin tener que especificar manualmente cada columna. La estrella (`*`) actúa como un comodín que significa "todas las columnas". Este tipo de consulta es útil en etapas iniciales de desarrollo y prueba, cuando se necesita entender o verificar rápidamente los datos disponibles en diferentes tablas.

```sql
SELECT * FROM Categorias;

SELECT * FROM Piezas;
```

### left join

#### Explicación

Este fragmento de código SQL realiza una operación llamada "izquierda" o "left join", que es muy útil cuando trabajamos con bases de datos relacionales. En este caso, estamos combinando dos tablas: 'Piezas' y 'Categorias'. La instrucción `LEFT JOIN` asegura que todas las filas de la tabla 'Piezas' aparezcan en el resultado, incluso si no hay coincidencias en la tabla 'Categorías'. El criterio para unir estas dos tablas es la columna 'id_categoria' de 'Piezas', que debe coincidir con la columna 'Identificador' de 'Categorias'. Esto nos permite obtener toda la información disponible sobre cada pieza, incluyendo su categoría si está definida. Si una pieza no tiene asociada ninguna categoría en la tabla 'Categorías', el resultado mostrará valores nulos para las columnas de esa categoría.

Esta consulta es importante porque te permite visualizar y trabajar con datos que pueden estar relacionados pero también existir por sí solos, lo cual puede ser crucial cuando estás diseñando o analizando una base de datos compleja.

```sql
SELECT 
* 
FROM Piezas
LEFT JOIN Categorias
ON Piezas.id_categoria = Categorias.Identificador;
```

### ahora creo la vista

#### Explicación

Este fragmento de código SQL está creando una vista llamada `piezas_y_categorias` en la base de datos. La función principal de este bloque es combinar información de dos tablas diferentes, `Piezas` y `Categorias`, para proporcionar un resumen útil que incluye tanto detalles sobre las piezas como sus categorías.

El código comienza creando una vista mediante el uso del comando `CREATE VIEW`. Dentro de esta vista, se realiza una consulta `SELECT` que selecciona columnas específicas de ambas tablas y les da nombres descriptivos. Por ejemplo, los campos `Categorias.titulo` y `Piezas.titulo` aparecen en la vista como `categoriatitulo` e `piezatitulo`, respectivamente.

Además, se utiliza un `LEFT JOIN` para asegurarse de que todas las filas de la tabla `Piezas` aparezcan en el resultado, incluso si no hay una correspondencia exacta en la tabla `Categorias`. Esto es útil porque puede haber piezas sin categorías asignadas. Finalmente, el código selecciona todos los campos de esta nueva vista recién creada usando `SELECT * FROM piezas_y_categorias`, lo que permite visualizar fácilmente toda la información combinada.

Esta técnica es importante en bases de datos para simplificar consultas complejas y presentar datos de manera más accesible y comprensible.

```sql
CREATE VIEW piezas_y_categorias AS 
SELECT 
Categorias.titulo AS categoriatitulo,
Categorias.descripcion AS categoriadescripcion,
Piezas.titulo AS piezatitulo,
Piezas.descripcion AS piezadescripcion,
imagen,
url
FROM Piezas
LEFT JOIN Categorias
ON Piezas.id_categoria = Categorias.Identificador;

SELECT * FROM piezas_y_categorias;
```

### usuario

#### Explicación

Este código SQL te enseña cómo crear un nuevo usuario en una base de datos y otorgarle permisos específicos. En primer lugar, se crea el usuario 'portafolioceac' con una contraseña específica desde la máquina local (localhost). Luego, se le concede acceso limitado inicialmente a todas las bases de datos usando `GRANT USAGE ON *.*`, lo que permite al usuario conectarse pero no hacer cambios sin más permisos. Posteriormente, el código elimina los límites de consultas y conexiones del usuario para permitirle realizar acciones ilimitadas en términos de velocidad y cantidad, aunque sigue sin tener privilegios reales sobre la base de datos hasta que se le asignan.

Finalmente, se otorga a este nuevo usuario todos los permisos posibles (`GRANT ALL PRIVILEGES`) para acceder y manipular cualquier cosa dentro de la base de datos llamada 'portafolioceac'. El comando `FLUSH PRIVILEGES` asegura que estos cambios en los privilegios sean aplicados inmediatamente sin necesidad de reiniciar el servidor. Este procedimiento es crucial cuando estás configurando permisos para diferentes usuarios en un entorno de desarrollo o producción, ya que ayuda a mantener la seguridad y controlar quién tiene acceso a qué información en tu sistema de bases de datos.

```sql
-- crea usuario nuevo con contraseña
-- creamos el nombre de usuario que queramos
CREATE USER 
'portafolioceac'@'localhost' 
IDENTIFIED  BY 'portafolioceac';

-- permite acceso a ese usuario
GRANT USAGE ON *.* TO 'portafolioceac'@'localhost';
--[tuservidor] == localhost
-- La contraseña puede requerir Mayus, minus, numeros, caracteres, min len

-- quitale todos los limites que tenga
ALTER USER 'portafolioceac'@'localhost' 
REQUIRE NONE 
WITH MAX_QUERIES_PER_HOUR 0 
MAX_CONNECTIONS_PER_HOUR 0 
MAX_UPDATES_PER_HOUR 0 
MAX_USER_CONNECTIONS 0;

-- dale acceso a la base de datos empresadam
GRANT ALL PRIVILEGES ON portafolioceac.* 
TO 'portafolioceac'@'localhost';

-- recarga la tabla de privilegios
FLUSH PRIVILEGES;
```

### Actividades propuestas

### Actividad 1: Creación y Configuración de una Base de Datos

**Descripción:** Los estudiantes deben crear una base de datos similar a la proporcionada en el archivo `001-crear tablas.sql`. Además, deberán configurar las tablas correspondientes con sus respectivos atributos para almacenar información sobre categorías y piezas. Esta actividad tiene como objetivo que los alumnos comprendan cómo estructurar bases de datos relacionalmente.

### Actividad 2: Inserción de Datos en la Base de Datos

**Descripción:** Los estudiantes deben insertar datos en las tablas creadas en la base de datos, similar a lo realizado en `002-insertar.sql`. Se espera que los alumnos comprendan cómo utilizar consultas INSERT para introducir registros en una tabla con relaciones.

### Actividad 3: Creación de Relaciones entre Tablas

**Descripción:** Los estudiantes deberán añadir restricciones FOREIGN KEY entre las tablas `Categorias` y `Piezas`, tal como se muestra en el archivo `003-fk.sql`. Esta actividad busca que los alumnos comprendan cómo definir relaciones uno a muchos.

### Actividad 4: Consultas Básicas con JOIN

**Descripción:** Los estudiantes deben escribir consultas SELECT que devuelvan todos los registros de las tablas `Categorias` y `Piezas`, tal como se muestra en el archivo `004-selecciones.sql`. Se espera que comprendan cómo realizar consultas para obtener información completa desde una base de datos.

### Actividad 5: Consulta con LEFT JOIN

**Descripción:** Los estudiantes deben utilizar la instrucción LEFT JOIN para recuperar todos los registros de las tablas `Categorias` y `Piezas`, incluyendo aquellos que no tienen un correspondiente en ambas tablas, tal como se realiza en el archivo `005-left join.sql`. Esta actividad busca que comprendan cómo manejar relaciones entre tablas mediante JOINs.

### Actividad 6: Creación de Vistas en SQL

**Descripción:** Los estudiantes deben crear una vista similar a la definida en `006-ahora creo la vista.sql`, combinando datos desde las tablas `Categorias` y `Piezas`. Esta actividad tiene como objetivo que los alumnos aprendan cómo simplificar consultas complejas con vistas.

### Actividad 7: Creación de un Usuario SQL

**Descripción:** Los estudiantes deben crear un usuario nuevo en MySQL, configurar su contraseña y asignarle privilegios para acceder a una base de datos específica. Esta actividad permite que los alumnos comprendan cómo gestionar usuarios y permisos en MySQL.

### Actividad 8: Manipulación de Privilegios del Usuario

**Descripción:** Los estudiantes deben modificar los privilegios del usuario creado, eliminando cualquier límite establecido por defecto para permitir un acceso completo a la base de datos. Esta actividad busca que comprendan cómo administrar y configurar permisos de usuarios en SQL.

Estas actividades están diseñadas para proporcionar una comprensión práctica sobre el manejo básico y avanzado de bases de datos utilizando SQL, adecuadas para estudiantes de Formación Profesional con un nivel intermedio.


<a id="carpeta-sin-titulo"></a>
## Carpeta sin título



<a id="aplicacion-de-las-estructuras-de-almacenamiento"></a>
# Aplicación de las estructuras de almacenamiento

<a id="estructuras-estaticas-y-dinamicas"></a>
## Estructuras estáticas y dinámicas

### Introducción a los ejercicios

En esta carpeta se encuentran una serie de ejercicios diseñados para que los estudiantes comprendan y practiquen el uso de estructuras de datos estáticas y dinámicas en Python. Los ejercicios abarcan desde la creación y manipulación de tuplas, listas y diccionarios hasta la implementación de funcionalidades más avanzadas como la lectura y escritura de archivos JSON. A través de estos problemas, los estudiantes desarrollarán competencias fundamentales en programación, tales como el acceso a elementos de colecciones, modificación de estructuras de datos existentes, eliminación de elementos específicos y creación de aplicaciones interactivas que integran múltiples conceptos.

### estructuras estaticas

#### Explicación

Este fragmento de código está creando una tupla en Python y asignándola a la variable `coordenadas`. Una tupla es una estructura de datos similar a las listas, pero que no puede ser modificada después de su creación. En este caso, la tupla contiene tres números enteros: 4, 5 y 6. Estos valores representan probablemente las coordenadas x, y y z en un sistema de coordenadas tridimensional. El uso de tuplas para almacenar datos constantes como estas coordenadas es importante porque asegura que los valores no cambiarán accidentalmente durante la ejecución del programa, lo que puede ayudar a evitar errores comunes.

```python
# x,y,z
coordenadas = (4,5,6)
```

### append a tupla

#### Explicación

Este fragmento de código está intentando añadir un nuevo elemento a una tupla en Python. Primero, se define la variable `coordenadas` con el valor `(4, 5, 6)`, que es una tupla con tres elementos: 4, 5 y 6. Luego, hay un intento de usar el método `.append(7)` para añadir el número 7 a esta tupla.

Sin embargo, hay un problema en este código porque las tuplas en Python son estructuras estáticas y no permiten agregar o modificar elementos una vez que se han creado. Esto es diferente a las listas, que sí permiten métodos como `.append()` para añadir nuevos elementos. Por lo tanto, al intentar usar `append` con una tupla, obtendrás un error de ejecución indicando que la tupla no tiene ningún método llamado `append`.

Este ejemplo es importante porque enseña el concepto de las diferencias entre estructuras de datos estáticas (como las tuplas) y dinámicas (como las listas). Es crucial entender estas diferencias para elegir correctamente la estructura adecuada según las necesidades específicas del programa que estás desarrollando.

```python
# x,y,z
coordenadas = (4,5,6)
coordenadas.append(7)
```

### escribir datos

#### Explicación

Este fragmento de código está trabajando con una tupla en Python, que es una estructura de datos inmutable (no se puede cambiar después de su creación). En este caso, la tupla `coordenadas` almacena tres números que representan las coordenadas \(x\), \(y\) y \(z\). Inicialmente, los valores son 4 para \(x\), 5 para \(y\) y 6 para \(z\).

Sin embargo, el código intenta modificar estos valores asignando nuevos números a cada posición de la tupla. Esto causaría un error en Python porque las tuplas no permiten cambiar sus elementos una vez creadas. Si quisieras hacer esto sin errores, deberías usar una lista (que sí permite modificaciones) en lugar de una tupla.

El propósito del código podría ser ilustrar el concepto de inmutabilidad y la diferencia entre tuplas e interfaces similares como listas. Es importante entender estas diferencias para elegir correctamente las estructuras de datos adecuadas según tus necesidades específicas.

```python
# x,y,z
coordenadas = (4,5,6)

coordenadas[0] = 11 # esto es la "x"
coordenadas[1] = 12 # esto es la "y"
coordenadas[2] = 13 # esto es la "z"
```

### leer datos

#### Explicación

Este código está trabajando con tuplas en Python. Una tupla es similar a una lista, pero mientras que las listas son mutables (se pueden modificar después de su creación), las tuplas son inmutables, lo que significa que no puedes cambiar sus elementos una vez definidas. En este caso, se define primero la variable `coordenadas` con los valores `(4, 5, 6)`, pero luego se redefine esta misma variable con un nuevo conjunto de valores `(11, 12, 13)`.

Después de redefinir `coordenadas`, el código imprime por pantalla el valor completo de la tupla actual (`(11, 12, 13)`) y luego accede al primer elemento de esta tupla utilizando la notación de índice `[0]` (que en este caso imprimirá `11`). Esto es importante para entender cómo se manipulan los datos estructurados como las tuplas o listas en Python y cómo puedes acceder a elementos individuales dentro de ellas.

```python
# x,y,z
coordenadas = (4,5,6)
coordenadas = (11,12,13)

print(coordenadas)

print(coordenadas[0])
```

### estructuras dinamicas

#### Explicación

Este código muestra cómo se añaden elementos a una lista en Python, que es un tipo de estructura de datos dinámica. En este caso, la lista se llama `agenda` y está vacía al principio (`[]`). El método `.append()` se utiliza para agregar nombres a esta lista: primero agrega "Jose Vicente" y luego "Juan". Después de cada llamada a `.append()`, el código imprime la lista completa actual. Finalmente, añade otro nombre, "Jorge", usando nuevamente `.append()`. Esta forma dinámica de añadir elementos permite que la lista crezca según sea necesario sin necesidad de predefinir su tamaño al inicio, lo cual es muy útil cuando no sabemos con certeza cuántos elementos necesitaremos almacenar.

```python
agenda = [] # corchetes = lista

agenda.append("Jose Vicente")
agenda.append("Juan")

print(agenda)

agenda.append("Jorge")

print(agenda)
```

### acceso a un solo elemento

#### Explicación

Este código crea una lista llamada `agenda` que es utilizada para almacenar nombres de personas. Inicialmente, la lista está vacía, pero después se añaden los nombres "Jose Vicente" y "Juan" usando el método `append()`, que agrega un elemento al final de la lista. Luego, se imprime todo el contenido actual de la lista con `print(agenda)`. A continuación, se añade otro nombre, "Jorge", a la lista y se vuelve a imprimir para mostrar los cambios. Finalmente, se muestra cómo acceder a un solo elemento dentro de la lista utilizando corchetes `[]`, en este caso, el primer elemento que es "Jose Vicente". Este código demuestra cómo trabajar con listas y como acceder a elementos específicos, lo cual es fundamental al aprender estructuras de datos dinámicas en Python.

```python
agenda = [] # corchetes = lista

agenda.append("Jose Vicente")
agenda.append("Juan")

print(agenda)

agenda.append("Jorge")

print(agenda)
print(agenda[0])
```

### sobreescribir

#### Explicación

Este código muestra cómo funciona una estructura de datos llamada lista en Python. En este caso, la lista se llama `agenda` y contiene nombres almacenados como cadenas de texto. Primero, el programa imprime los nombres que están en la lista inicialmente. Luego, modifica el primer nombre de la lista cambiando "Jose Vicente" por "Jaime". Finalmente, vuelve a imprimir la lista para mostrar cómo ha cambiado después de realizar la modificación.

Esta práctica es importante porque demuestra cómo las listas permiten acceder y modificar fácilmente sus elementos. En este ejemplo, `agenda[0]` se usa para referirse al primer elemento de la lista (donde el índice 0 indica que es el primero), lo que nos permite cambiar su valor sin tener que reescribir toda la lista. Esto es muy útil cuando necesitas actualizar información en tus programas y no solo guardarla estáticamente.

```python
agenda = [
  'Jose Vicente',
  'Juan',
  'Jorge'
] # corchetes = lista

print(agenda)

agenda[0] = "Jaime"

print(agenda)
```

### eliminar elementos de la lista

#### Explicación

Este código es una sencilla demostración de cómo eliminar un elemento de una lista en Python. La lista `agenda` contiene tres nombres: 'Jose Vicente', 'Juan' y 'Jorge'. Al principio, el programa imprime esta lista completa utilizando la función `print()`. Luego, se llama a la función `pop()` sobre la variable `agenda`, lo que elimina el último elemento de la lista (en este caso, 'Jorge'). Finalmente, el código vuelve a imprimir la lista después de eliminar ese elemento. Este ejemplo es importante porque muestra cómo gestionar y modificar listas dinámicamente en Python, una habilidad fundamental para cualquier programador que trabaje con datos en colecciones como las listas.

```python
agenda = [
  'Jose Vicente',
  'Juan',
  'Jorge'
] # corchetes = lista

print(agenda)
agenda.pop()
print(agenda)
```

### quitar un elemento concreto

#### Explicación

Este código Python muestra cómo eliminar un elemento específico de una lista. Primero, se crea una lista llamada `agenda` que contiene tres nombres: 'Jose Vicente', 'Juan' y 'Jorge'. Luego, se imprime la lista original para mostrar qué elementos contiene. Después, utiliza el método `pop()` en la lista `agenda`, pasándole como argumento el índice 1 (lo que significa que elimina al segundo elemento de la lista, que es 'Juan'). Finalmente, vuelve a imprimir la lista después de haber eliminado un elemento para demostrar los cambios. Este ejemplo es importante porque muestra cómo mantener y manipular listas dinámicamente en Python, lo cual es útil cuando necesitas gestionar información como una agenda o una lista de contactos.

```python
agenda = [
  'Jose Vicente',
  'Juan',
  'Jorge'
] # corchetes = lista

print(agenda)
agenda.pop(1)
print(agenda)
```

### tupla de nuevo

#### Explicación

Este fragmento de código está creando una tupla en Python. Una tupla es similar a una lista, pero mientras que las listas pueden ser modificadas después de su creación, las tuplas son inmutables, lo que significa que no se pueden cambiar una vez definidas. En este caso, la variable `coordenadas` almacena los valores 4, 5 y 6 en una estructura llamada tupla. Estos números podrían representar coordenadas en un espacio tridimensional, donde 4 sería el eje X, 5 sería el eje Y y 6 sería el eje Z.

Las tuplas son útiles cuando necesitas almacenar grupos de datos relacionados que no cambiarán durante la ejecución del programa. En este ejemplo específico, si alguien necesita referirse a las coordenadas (4, 5, 6) en diferentes partes del código, pueden hacer referencia fácilmente a `coordenadas` sin preocuparse por que los valores puedan ser alterados accidentalmente.

```python
# x,y,z
coordenadas = (4,5,6)
```

### diccionario

#### Explicación

Este código Python crea un diccionario llamado `coordenadas` que almacena tres pares de clave-valor: `"x": "4"`, `"y": "5"` y `"z": "6"`. Un diccionario en Python es una estructura de datos que permite almacenar elementos como si fueran un conjunto de registros, donde cada elemento se identifica mediante una clave única. En este caso, las claves son cadenas como `"x"`, `"y"` y `"z"`, y los valores asociados también son cadenas, por ejemplo `"4"`. Al final del código, el diccionario `coordenadas` se imprime en la consola usando la función `print()`. Esto es importante porque nos permite visualizar fácilmente cómo están almacenados estos datos de coordenadas en memoria y entender cómo acceder a ellos para su uso futuro.

```python
# x,y,z

coordenadas = {
  "x":"4",
  "y":"5",
  "z":"6"
}

print(coordenadas)
```

### acceso a un elemento

#### Explicación

Este fragmento de código en Python muestra cómo trabajar con diccionarios, que son estructuras de datos útiles para almacenar información relacionada. En este caso, se crea un diccionario llamado `coordenadas` que almacena las coordenadas x, y y z, donde cada una está representada como una cadena de texto y tiene un valor numérico asociado.

Primero, el código imprime todo el contenido del diccionario utilizando la función `print(coordenadas)`, lo cual muestra en pantalla algo así como `{'x': '4', 'y': '5', 'z': '6'}`. Luego, se accede específicamente a la coordenada x mediante `print(coordenadas['x'])` y se imprime su valor ('4').

Esta forma de trabajar con diccionarios es importante porque permite organizar datos complejos de una manera clara y accesible, facilitando el acceso directo a cualquier elemento por su clave. En este ejemplo, es útil para representar coordenadas tridimensionales en un programa de geometría o física, donde cada letra (x, y, z) representa una dirección espacial y sus valores son las posiciones específicas en ese eje.

```python
# x,y,z

coordenadas = {
  "x":"4",
  "y":"5",
  "z":"6"
}

print(coordenadas)
print(coordenadas['x'])
```

### repaso

#### Explicación

Este fragmento de texto en formato Markdown presenta una breve comparación entre tres tipos fundamentales de estructuras de datos que se utilizan en la programación: tuplas, listas y diccionarios. Cada uno tiene características únicas que los hacen apropiados para diferentes situaciones.

Las **tuplas** son colecciones estáticas, lo que significa que una vez que se crean no pueden ser modificadas añadiendo o eliminando elementos. Se representan entre paréntesis y sus elementos se acceden a través de índices numéricos.

Por otro lado, las **listas** son estructuras dinámicas que permiten agregar o quitar elementos después de su creación. Están definidas entre corchetes y también utilizan índices numéricos para acceder a los elementos individuales.

Finalmente, los **diccionarios** son similares a las listas en ser dinámicos, pero se distinguen por permitir el acceso a sus elementos mediante claves alfanuméricas (que pueden ser letras, palabras o números), en lugar de índices numéricos. Se definen entre llaves.

Estas estructuras son fundamentales en la programación ya que te ayudan a organizar y manipular datos de manera eficiente según tus necesidades específicas.

```markdown
# Tuplas ()

Estáticas, no pueden crecer ni decrecer
Índices numéricos

# Listas []

Dinámicas, pueden crecer y decrecer
Índices numéricos

# Diccionarios {}

Dinámicas, pueden crecer y decrecer
Índices alfanuméricos (letras, palabras, números)
```

### creamos una lista de la compra

#### Explicación

Este código crea una lista de la compra en Python. En primer lugar, se declara una variable llamada `lista_de_la_compra` y se inicializa como una lista vacía usando los corchetes `[]`. Luego, el programa añade cuatro elementos a esta lista utilizando el método `.append()`, que agrega cada artículo al final de la lista. Los artículos que se añaden son "mangos", "chorizos", "cerveza" y "patos". Finalmente, el código imprime en pantalla toda la lista completa con los cuatro elementos que acabamos de agregar. Esta forma de gestionar una lista es muy útil para organizar tareas o recuerdos, como por ejemplo lo que necesitas comprar en un supermercado.

```python
lista_de_la_compra = []

lista_de_la_compra.append("mangos")
lista_de_la_compra.append("chorizos")
lista_de_la_compra.append("cerveza")
lista_de_la_compra.append("patos")

print(lista_de_la_compra)
```

### lista con diccionario

#### Explicación

Este código crea una lista llamada `lista_de_la_compra` y luego añade un diccionario a esa lista. El diccionario contiene información sobre un producto, especificando que el producto es "mangos" y la cantidad es "4". Finalmente, se imprime la lista completa en la consola.

Lo importante aquí es entender cómo las listas pueden contener diferentes tipos de datos, como en este caso, un diccionario. Cada elemento del diccionario proporciona detalles específicos sobre el producto, lo que nos permite almacenar y organizar información más compleja que si solo tuviéramos una simple lista de strings.

Este método es útil cuando necesitas estructurar la información de manera más rica y accesible, permitiendo así operaciones más avanzadas en futuros programas.

```python
lista_de_la_compra = []

lista_de_la_compra.append(
  {
    "producto":"mangos",
    "cantidad":"4"
  }
)

print(lista_de_la_compra)
```

### un segundo elemento

#### Explicación

Este código Python crea una lista llamada `lista_de_la_compra` que va a almacenar información sobre los productos y sus cantidades que deseas comprar. La lista se inicializa vacía al escribir `lista_de_la_compra = []`.

Luego, el programa agrega dos elementos a la lista utilizando el método `.append()`. Cada elemento es un diccionario que contiene dos claves: "producto" y "cantidad". En primer lugar, añade un diccionario con el producto 'mangos' y una cantidad de 4. Luego, agrega otro diccionario para 'manzanas' con una cantidad de 7.

Finalmente, se utiliza la función `print()` para mostrar en pantalla lo que contiene la lista después de agregar estos dos elementos. Esto es importante porque te permite verificar fácilmente que los datos han sido añadidos correctamente a tu lista de compras.

```python
lista_de_la_compra = []

lista_de_la_compra.append(
  {
    "producto":"mangos",
    "cantidad":"4"
  }
)
lista_de_la_compra.append(
  {
    "producto":"manzanas",
    "cantidad":"7"
  }
)

print(lista_de_la_compra)
```

### carga inicial

#### Explicación

Este código Python crea una lista llamada `lista_de_la_compra` que contiene dos diccionarios. Cada diccionario representa un elemento de la compra con dos claves: `"producto"` y `"cantidad"`. En este caso, los elementos son mangos y manzanas con cantidades específicas. Al imprimir `lista_de_la_compra`, el programa muestra en pantalla toda la lista completa, incluyendo cada uno de los diccionarios con sus respectivos productos y cantidades.

Este fragmento es importante porque demuestra cómo se pueden almacenar y organizar datos complejos usando estructuras como listas y diccionarios. Esto ayuda a mantener una representación clara y fácilmente accesible de la información, lo cual es crucial cuando trabajamos en aplicaciones que manejan grandes cantidades de datos relacionados entre sí.

```python
lista_de_la_compra = [
  {
    "producto":"mangos",
    "cantidad":"4"
  },
  {
    "producto":"manzanas",
    "cantidad":"7"
  }
]


print(lista_de_la_compra)
```

### el usuario se crea su lista

#### Explicación

Este fragmento de código es el inicio de un pequeño programa en Python que permite al usuario gestionar una lista, probablemente una lista de la compra. El programa comienza mostrando un mensaje de bienvenida y luego entra en un bucle infinito (`while True`), lo que significa que se repetirá indefinidamente hasta que alguien interrumpa su ejecución manualmente.

Dentro del bucle, el programa muestra al usuario dos opciones: añadir un elemento a la lista o leer la lista completa. El usuario debe ingresar el número de la opción que desea realizar y el programa captura esta entrada como un número entero (`int(input("Tu opción: "))`). Esta estructura permite una interacción continua con el usuario, ofreciéndole siempre las mismas dos opciones hasta que decida terminar la ejecución.

Es importante porque establece la base de una interfaz simple y clara para los usuarios, permitiendo gestionar fácilmente datos a través de un menú interactivo.

```python
print("Lista de la compra v0.1")

while True:
  print("Selecciona una opcion")
  print("1.-Añadir elemento a la lista")
  print("2.-Leer la lista")
  opcion = int(input("Tu opción: "))
  
  
```

### estructura if

#### Explicación

Este código es una pequeña aplicación en Python que simula una lista de compras. La aplicación muestra un menú interactivo donde el usuario puede elegir entre dos opciones: añadir elementos a la lista o leer los elementos existentes en ella.

El programa entra en un bucle infinito (`while True`) que permite al usuario seleccionar una opción hasta que decida salir del programa de alguna manera no mostrada en este fragmento. Cuando el usuario ingresa "1", se le pide que introduzca el nombre y la cantidad de un producto para añadirlo a la lista de la compra. Si el usuario elige "2", debería leer los elementos existentes, pero esta parte del código está incompleta.

Es importante destacar cómo el uso de condicionales (`if` y `elif`) permite al programa ejecutar diferentes bloques de código según las decisiones tomadas por el usuario, haciendo que la interacción sea más dinámica y útil.

```python
print("Lista de la compra v0.1")

while True:
  print("Selecciona una opcion")
  print("1.-Añadir elemento a la lista")
  print("2.-Leer la lista")
  opcion = int(input("Tu opción: "))
  
  if opcion == 1:
    print("Añadimos un elemento a la lista:")
    nombre = input("Indica el nombre del producto: ")
    cantidad = input("Indica la cantidad del producto: ")
    
  elif opcion == 2:
    
```

### creamos la lista primero

#### Explicación

Este código es una pequeña aplicación en Python que permite gestionar una lista de la compra. En primer lugar, muestra un mensaje indicando que estamos trabajando con la versión 0.1 de esta aplicación y crea una lista vacía llamada `lista_de_la_compra`. Luego entra en un bucle infinito (`while True`) donde se muestran dos opciones al usuario: añadir un elemento a la lista (opción 1) o leer la lista completa (opción 2). Si el usuario selecciona la opción 1, el programa pide al usuario que introduzca tanto el nombre como la cantidad del producto que desea añadir. La opción de leer la lista aún no está implementada en esta parte del código.

Esta estructura básica es importante porque permite a los usuarios interactuar con la aplicación y manipular sus datos fácilmente, proporcionando una forma clara y ordenada para gestionar información de compra.

```python
print("Lista de la compra v0.1")

lista_de_la_compra = []

while True:
  print("Selecciona una opcion")
  print("1.-Añadir elemento a la lista")
  print("2.-Leer la lista")
  opcion = int(input("Tu opción: "))
  
  if opcion == 1:
    print("Añadimos un elemento a la lista:")
    nombre = input("Indica el nombre del producto: ")
    cantidad = input("Indica la cantidad del producto: ")
    
  elif opcion == 2:
    
```

### añado elemento a la lista

#### Explicación

Este código es una pequeña aplicación en Python que permite gestionar una lista de la compra. El programa comienza mostrando un menú con dos opciones: añadir un elemento a la lista y leer los elementos ya existentes.

En el bucle `while True`, se muestra continuamente este menú al usuario hasta que decida salir (algo que no está implementado en esta versión del código). Cuando el usuario selecciona la opción 1, se le piden tanto el nombre como la cantidad de un producto para añadirlo a la lista. Este nuevo elemento es almacenado dentro de la variable `lista_de_la_compra`, pero dado que solo estamos capturando el nombre y la cantidad en variables separadas (`nombre` y `cantidad`) sin integrarlas en una estructura más compleja (como una tupla o diccionario), este código no termina por guardar efectivamente los elementos elegidos en la lista.

La opción 2 del menú debería permitir al usuario visualizar todos los elementos que ha añadido, pero el fragmento de código proporcionado no implementa esta funcionalidad completamente. Es importante completar este programa para que las acciones seleccionadas por el usuario tengan un efecto real sobre la lista de la compra.

```python
print("Lista de la compra v0.1")

lista_de_la_compra = []

while True:
  print("Selecciona una opcion")
  print("1.-Añadir elemento a la lista")
  print("2.-Leer la lista")
  opcion = int(input("Tu opción: "))
  
  if opcion == 1:
    print("Añadimos un elemento a la lista:")
    nombre = input("Indica el nombre del producto: ")
    cantidad = input("Indica la cantidad del producto: ")
    
  elif opcion == 2:
    
```

### vomito la lista

#### Explicación

Este código es una pequeña aplicación en Python que simula un programa para gestionar una lista de compras. El objetivo principal del código es permitir al usuario añadir nuevos productos a su lista y también visualizar todos los artículos almacenados.

El programa comienza mostrando un menú con dos opciones: "Añadir elemento a la lista" y "Leer la lista". El usuario introduce el número de la opción que desea realizar. Si selecciona la primera opción, se le pedirá al usuario que introduzca tanto el nombre del producto como la cantidad que desea comprar. Estos datos se guardan en una estructura llamada diccionario dentro de una lista.

Si el usuario elige la segunda opción, el programa simplemente muestra todos los elementos almacenados en la lista de compras hasta ese momento. Esta aplicación utiliza un bucle `while True` para mantenerse ejecutándose y permitir al usuario realizar múltiples operaciones sin tener que cerrar y abrir el programa constantemente.

Esta estructura es útil porque permite a las personas organizar fácilmente sus tareas de compra, manteniendo la lista actualizada con los productos que necesitan adquirir.

```python
print("Lista de la compra v0.1")

lista_de_la_compra = []

while True:
  print("Selecciona una opcion")
  print("1.-Añadir elemento a la lista")
  print("2.-Leer la lista")
  opcion = int(input("Tu opción: "))
  
  if opcion == 1:
    print("Añadimos un elemento a la lista:")
    nombre = input("Indica el nombre del producto: ")
    cantidad = input("Indica la cantidad del producto: ")
    lista_de_la_compra.append({"nombre":nombre,"cantidad":cantidad})
  elif opcion == 2:
    print("Listamos los elementos de la lista:")
    print(lista_de_la_compra)
```

### recorrer listas

#### Explicación

Este código es una sencilla aplicación de Python que muestra cómo trabajar con listas, un tipo de estructura de datos estática. La lista se llama `agenda` y contiene tres nombres: "Jorge", "Juan" e "Jose". Primero, el programa imprime toda la lista completa para mostrarte qué contiene exactamente. Luego, imprime el primer elemento de la lista usando su índice (0 en este caso), lo que te muestra cómo acceder a un solo elemento dentro de una lista.

Finalmente, se utiliza un bucle `for` para recorrer cada nombre en la lista `agenda`. En cada iteración del bucle, el valor actual de `nombre` es impreso en la pantalla. Este método permite procesar fácilmente cada elemento de la lista sin tener que preocuparse por manejar índices o contadores manualmente. Es una forma eficiente y clara de trabajar con colecciones de datos como listas.

```python
agenda = ["Jorge","Juan","Jose"]

print(agenda)
print(agenda[0])

for nombre in agenda:
  print(nombre)
```

### recorro la lista

#### Explicación

Este código te muestra cómo crear una sencilla aplicación en Python para gestionar una lista de la compra. Empieza por presentarse con un mensaje que dice "Lista de la compra v0.1". Luego, inicializa una lista vacía llamada `lista_de_la_compra` donde se almacenarán los elementos.

El bucle `while True:` crea un menú interactivo que se repite indefinidamente hasta que el usuario decida salir (en este ejemplo no hay opción para salir). El programa muestra dos opciones: añadir un nuevo elemento a la lista o leer todos los elementos de la lista. Dependiendo del número que el usuario introduzca, realiza una acción u otra.

Si el usuario elige la opción 1, se le pedirá que introduzca el nombre y cantidad del producto que desea agregar a la lista. Estos datos se guardan en un diccionario dentro de la lista `lista_de_la_compra`.

Si el usuario selecciona la opción 2, el programa recorre la lista con un bucle `for` y muestra en pantalla los nombres y cantidades de todos los productos que hay en la lista.

Esta estructura es importante porque permite al usuario gestionar dinámicamente una lista de elementos utilizando conceptos básicos de programación como listas, diccionarios y bucles.

```python
print("Lista de la compra v0.1")

lista_de_la_compra = []

while True:
  print("Selecciona una opcion")
  print("1.-Añadir elemento a la lista")
  print("2.-Leer la lista")
  opcion = int(input("Tu opción: "))
  
  if opcion == 1:
    print("Añadimos un elemento a la lista:")
    nombre = input("Indica el nombre del producto: ")
    cantidad = input("Indica la cantidad del producto: ")
    lista_de_la_compra.append({"nombre":nombre,"cantidad":cantidad})
  elif opcion == 2:
    print("Listamos los elementos de la lista:")
    for producto in lista_de_la_compra:
      print("Producto:",producto['nombre'])
      print("Cantidad:",producto['cantidad'])
      print("##############################") # Esto es estético, separador
```

### guardo en json

#### Explicación

Este código crea una aplicación simple que permite gestionar una "lista de la compra" en Python. Primero, el programa importa la biblioteca `json`, que será necesaria para guardar los datos en formato JSON. Luego, se define una lista vacía llamada `lista_de_la_compra` donde se almacenarán los productos.

El código principal utiliza un bucle `while True` para mantener al usuario en un menú interactivo hasta que decida salir (que no está implementado en este fragmento). En el menú, el usuario tiene la opción de añadir elementos a la lista o leer los elementos existentes. Si elige añadir un producto, se solicita tanto el nombre como la cantidad del artículo y estos datos se almacenan en una estructura de diccionario dentro de la lista `lista_de_la_compra`. Posteriormente, se abre un archivo llamado "lista.json" para escribir los datos de la lista en formato JSON utilizando la función `json.dump()`, lo que permite guardar permanentemente los cambios hechos por el usuario.

Si el usuario selecciona la opción 2, se recorre la lista y se imprimen los nombres y cantidades de todos los productos almacenados. Esta funcionalidad es importante porque permite a los usuarios mantener un registro claro de sus compras sin necesidad de escribir en papel, facilitando así su organización y seguimiento.

```python
print("Lista de la compra v0.1")
import json                   # Para usar la libreria tengo que importarla

lista_de_la_compra = []

while True:
  print("Selecciona una opcion")
  print("1.-Añadir elemento a la lista")
  print("2.-Leer la lista")
  opcion = int(input("Tu opción: "))
  
  if opcion == 1:
    print("Añadimos un elemento a la lista:")
    nombre = input("Indica el nombre del producto: ")
    cantidad = input("Indica la cantidad del producto: ")
    lista_de_la_compra.append({"nombre":nombre,"cantidad":cantidad})
    archivo = open("lista.json","w")         # Abro el archivo
    json.dump(lista_de_la_compra,archivo)    # Guardo en json
    archivo.close()                          # Cierro el archivo
  elif opcion == 2:
    print("Listamos los elementos de la lista:")
    for producto in lista_de_la_compra:
      print("Producto:",producto['nombre'])
      print("Cantidad:",producto['cantidad'])
      print("##############################") # Esto es estético, separador
```

### lista

#### Explicación

Este fragmento de código es una estructura de datos llamada JSON (JavaScript Object Notation), que se utiliza para almacenar y transferir información entre un servidor y una aplicación. En este caso, el archivo contiene una lista de objetos que representan diferentes tipos de frutas junto con su cantidad. Cada objeto en la lista tiene dos propiedades: "nombre" y "cantidad". Por ejemplo, uno de los objetos indica que hay 2 manzanas. Este tipo de estructura es importante porque permite organizar datos de manera clara y fácilmente accesible para otros programas o lenguajes de programación. Es útil en aplicaciones web para manejar información como inventarios, listas de tareas u otras colecciones de objetos similares.

```json
[{"nombre": "Manzanas", "cantidad": "2"}, {"nombre": "Peras", "cantidad": "4"}]
```

### Actividades propuestas

### Actividad 1: Crear una Agenda con Listas Dinámicas

**Descripción:** Los estudiantes deben crear un programa simple que almacene nombres de contactos en una lista y permita agregar, eliminar y listar dichos contactos. Se pretende que aprendan a usar listas dinámicas y funciones básicas como `append` y `pop`.

### Actividad 2: Manipulación de Coordenadas con Tuplas

**Descripción:** Los estudiantes deben escribir un programa para almacenar las coordenadas (x, y, z) en una tupla e implementar operaciones básicas como lectura y visualización. Se espera que comprendan la inmutabilidad de las tuplas.

### Actividad 3: Diccionarios para Almacenar Datos

**Descripción:** Los estudiantes deben crear un programa que almacene datos en un diccionario (por ejemplo, coordenadas x, y, z) y muestren cómo acceder a estos elementos. Se busca mejorar la comprensión de los diccionarios y su utilidad para almacenamiento de datos estructurados.

### Actividad 4: Modificación de Elementos en una Lista

**Descripción:** Los estudiantes deben escribir un código que permita cambiar el valor de uno o más elementos dentro de una lista existente. El objetivo es reforzar la comprensión sobre cómo sobrescribir valores en listas dinámicas.

### Actividad 5: Crear y Manejar Diccionarios

**Descripción:** Los estudiantes deben desarrollar un programa que permita crear un diccionario para almacenar información como productos de una lista de compras con sus cantidades. Se pretende enseñar la creación e inicialización de diccionarios, además de cómo añadir y acceder a los elementos del mismo.

### Actividad 6: Interfaz Básica de Gestión de Listas

**Descripción:** Los estudiantes deben diseñar una interfaz básica para administrar listas (por ejemplo, lista de la compra), donde se permita al usuario agregar o eliminar elementos. Se busca mejorar las habilidades en estructuras condicionales y bucles.

### Actividad 7: Guardado de Datos a Archivo JSON

**Descripción:** Los estudiantes deben crear un programa que permite guardar datos de una lista (por ejemplo, lista de la compra) en un archivo `.json`. La actividad se enfoca en la importación de bibliotecas adicionales y el manejo básico de archivos.

### Actividad 8: Recorrer e Imprimir Elementos de Lista

**Descripción:** Los estudiantes deben implementar una función que recorra una lista, por ejemplo, una lista de contactos o productos, y muestre cada elemento en la consola. Se pretende mejorar las habilidades sobre el uso de bucles `for` para iterar a través de listas.

### Actividad 9: Interfaz Mejorada con Diccionarios

**Descripción:** Los estudiantes deben crear una versión mejorada del programa de lista de la compra, que permita al usuario agregar productos con nombre y cantidad usando un diccionario. Se busca mejorar las habilidades en uso de estructuras condicionales y manejo de datos complejos.

### Actividad 10: Modificar Elementos Específicos

**Descripción:** Los estudiantes deben crear una funcionalidad que permita al usuario modificar el valor de un elemento específico dentro de un diccionario (por ejemplo, cambiar la cantidad de un producto en la lista de compras). Se busca reforzar las habilidades para acceder y modificar elementos específicos de estructuras de datos más complejas.

Estas actividades están diseñadas para mejorar gradualmente las habilidades de programación de los estudiantes, cubriendo desde listas hasta diccionarios, pasando por el manejo básico de archivos.


<a id="creacion-de-matrices-arrays"></a>
## Creación de matrices (arrays)

### Introducción a los ejercicios

Esta carpeta contiene una secuencia de ejercicios que te guían en la creación y manipulación de matrices (arrays) utilizando Python, centrándose en el manejo de listas para representar un menú de comidas. Los ejercicios comienzan con la simple adición de elementos a una lista y evolucionan hasta incluir bucles condicionales, lectura de opciones del usuario y almacenamiento persistente mediante archivos binarios usando la biblioteca `pickle`. A lo largo de estos ejercicios, desarrollarás habilidades fundamentales en estructuras de datos, control de flujo y manejo de archivos, así como comprenderás cómo guardar y recuperar estados de una aplicación.

### comidas

#### Explicación

El fragmento de código que has proporcionado es muy sencillo pero fundamental para entender cómo se manejan listas en Python. En este caso, la línea `menu = []` crea una lista vacía llamada `menu`. Esta lista se utilizará probablemente más adelante en el programa para almacenar diferentes tipos de comidas o elementos relacionados con un menú.

La creación de esta lista vacía es importante porque permite que el programa añada posteriormente elementos al menú, como platos, bebidas u otros artículos. De este modo, la estructura del menú se puede construir dinámicamente según sea necesario, lo que proporciona mucha flexibilidad en cómo los datos pueden ser gestionados y modificados durante la ejecución del programa.

En resumen, esta línea es el punto de partida para manipular una lista de comidas o opciones de un menú en un programa Python.

```python
menu = []
```

### bucle infinito

#### Explicación

Este fragmento de código es una porción de un programa que utiliza un bucle infinito para permitir al usuario ingresar nombres de comidas. La variable `menu` es una lista vacía en la que se almacenarían los datos, aunque en este ejemplo no se muestra cómo agregar las entradas del usuario a esta lista.

El bucle `while True:` crea un ciclo que nunca termina por sí solo, lo que significa que el programa seguirá pidiendo al usuario que introduzca nombres de comidas indefinidamente. La línea `comida = input("Introduce el nombre de la comida: ")` es donde se recoge la entrada del usuario, pero falta la lógica para detener este bucle o para añadir los elementos a la lista `menu`.

Este tipo de estructura es útil cuando se quiere permitir al usuario interactuar con el programa durante tanto tiempo como sea necesario, hasta que el propio usuario decida terminar. Sin embargo, en un programa completo sería importante incluir una forma de salir del bucle y gestionar correctamente los datos introducidos por el usuario.

```python
menu = []

while True:
  comida = input("Introduce el nombre de la comida: ")
  
```

### añado a la lista

#### Explicación

Este código crea una lista llamada `menu` que va creciendo con nombres de comidas introducidos por el usuario. Comienza definiendo una lista vacía denominada `menu`. Luego entra en un bucle infinito (`while True:`) que pregunta continuamente al usuario por el nombre de una comida y añade esa comida a la lista `menu` usando el método `.append()`. El bucle no tiene ninguna condición para terminar, por lo que seguirá pidiendo más alimentos hasta que se interrumpa manualmente. Este tipo de estructura es útil cuando queremos crear listas dinámicas cuyo contenido depende del usuario y puede ser ilimitado en número de elementos.

```python
menu = []

while True:
  comida = input("Introduce el nombre de la comida: ")
  menu.append(comida)
```

### recorrer la lista

#### Explicación

Este código crea una lista llamada `menu` y permite al usuario añadir nombres de comidas a ella. El programa entra en un bucle infinito (`while True:`) que siempre se repite, permitiendo al usuario introducir nuevos elementos hasta que decida detener la ejecución manualmente.

Cuando el usuario introduce el nombre de una comida usando `input()`, ese valor es añadido a la lista `menu` con `append(comida)`. Luego, el programa recorre (`for elemento in menu:`) y muestra en pantalla cada uno de los elementos que ya están en la lista para que el usuario pueda ver lo que ha introducido hasta el momento.

Este tipo de código es importante porque enseña cómo gestionar listas en Python y cómo interactuar con el usuario para llenar una estructura de datos, además de mostrar un ejemplo simple de bucles y recorridos de colecciones.

```python
menu = []

while True:
  comida = input("Introduce el nombre de la comida: ")
  menu.append(comida)
  print("Tu comida hasta el momento es:")
  for elemento in menu:
    print(elemento)
```

### acciones del menu

#### Explicación

Este código crea un pequeño menú interactivo que permite al usuario añadir comidas a una lista y luego listarlas. La variable `menu` se inicializa como una lista vacía, que será utilizada para almacenar los nombres de las comidas introducidos por el usuario.

El bucle `while True:` asegura que el menú se mantenga activo indefinidamente hasta que se ejecute un comando específico para finalizarlo (que en este caso no está implementado). Dentro del bucle, primero se muestra una lista de opciones al usuario: la opción 1 permite añadir una nueva comida a la lista `menu`, y la opción 2 debería listar todas las comidas existentes. Sin embargo, el código proporcionado siempre solicita al usuario que introduzca un nombre de comida después de seleccionar cualquier opción del menú y luego añade ese nombre a la lista `menu`. Luego, independientemente de lo que haya elegido el usuario, imprime todos los elementos actuales en la lista.

Es importante notar que aunque se ofrece la opción 2 para listar las comidas, esta función no está implementada correctamente ya que siempre solicita al usuario introducir una nueva comida antes de imprimir todas las entradas existentes. Esto significa que el menú actualmente tiene un flujo ligeramente confuso y requeriría ajustes adicionales para funcionar según lo esperado.

```python
menu = []

while True:
  print("Opciones:")
  print("1.-Introducir nueva comida en el menú")
  print("2.-Listar comidas en el menú")
  opcion = input("Selecciona una opción:")
  comida = input("Introduce el nombre de la comida: ")
  menu.append(comida)
  print("Tu comida hasta el momento es:")
  for elemento in menu:
    print(elemento)
```

### tomamos las opciones

#### Explicación

Este código crea un menú interactivo que permite al usuario gestionar una lista de comidas. Primero, se inicializa una lista vacía llamada `menu`. Luego entra en un bucle infinito (`while True`) que muestra las opciones disponibles: introducir una nueva comida o listar todas las comidas existentes en el menú.

Cuando el usuario selecciona la opción 1, se le pide que ingrese el nombre de la comida y esta se añade a la lista `menu` mediante el método `.append()`. Si elige la opción 2, el programa recorre cada elemento en la lista `menu` e imprime cada comida registrada.

Esta estructura es importante porque permite al usuario interactuar fácilmente con un conjunto de datos (la lista de comidas), añadiendo y visualizando elementos según sea necesario. Es una introducción básica a cómo manejar listas y bucles en Python, además de mostrar cómo capturar la entrada del usuario para controlar el flujo del programa.

```python
menu = []

while True:
  print("Opciones:")
  print("1.-Introducir nueva comida en el menú")
  print("2.-Listar comidas en el menú")
  opcion = int(input("Selecciona una opción:"))
  if opcion == 1:
    comida = input("Introduce el nombre de la comida: ")
    menu.append(comida)
  elif opcion == 2:
    print("Tu comida hasta el momento es:")
    for elemento in menu:
      print(elemento)
```

### intentamos guardar

#### Explicación

Este código crea un menú interactivo que permite gestionar una lista de comidas. En cada iteración del bucle `while`, el programa muestra tres opciones al usuario: añadir una nueva comida a la lista, listar todas las comidas existentes o guardar toda la información en un archivo. La elección del usuario se gestiona mediante una estructura condicional (`if-elif-else`). Si el usuario selecciona la opción 1, se solicita que introduzca el nombre de una comida y esta se agrega a la lista `menu`. Si elige la opción 2, el programa muestra todas las comidas almacenadas hasta ese momento. Finalmente, si escoge la opción 3, se intenta guardar toda la información de `menu` en un archivo llamado "datos.txt", pero aquí hay un error porque no se puede escribir directamente una lista en un archivo sin procesarla primero.

Es importante entender que este código es útil para aprender sobre las estructuras de control y cómo manipular listas en Python. Sin embargo, también muestra un problema común al trabajar con archivos: necesitas convertir la lista a un formato adecuado (como texto) antes de escribirla en el archivo. En lugar del método `write`, se debería usar un bucle para iterar sobre cada elemento y utilizar `write` para cada uno, o bien convertir toda la lista a una cadena usando métodos como `join`.

```python
menu = []

while True:
  print("Opciones:")
  print("1.-Introducir nueva comida en el menú")
  print("2.-Listar comidas en el menú")
  print("3.-Guardar en archivo")
  opcion = int(input("Selecciona una opción:"))
  if opcion == 1:
    comida = input("Introduce el nombre de la comida: ")
    menu.append(comida)
  elif opcion == 2:
    print("Tu comida hasta el momento es:")
    for elemento in menu:
      print(elemento)
  elif opcion == 3:
    archivo = open("datos.txt","w")
    archivo.write(menu)
    archivo.close()
    
    
    
```

### importamos pickle

#### Explicación

Este código es una pequeña aplicación de consola en Python que gestiona un menú de comidas. Comienza importando el módulo `pickle`, aunque no se utiliza en este ejemplo específico. Luego, crea una lista vacía llamada `menu` donde se almacenarán los nombres de las comidas.

El programa entra en un bucle infinito (`while True`) que muestra al usuario varias opciones: agregar una nueva comida al menú (opción 1), listar todas las comidas ya agregadas (opción 2) o guardar el contenido del menú en un archivo (opción 3). La elección se realiza mediante un `input` donde el usuario introduce un número correspondiente a la opción deseada.

Si el usuario selecciona la opción 1, se solicita el nombre de una nueva comida y esta se agrega al final de la lista `menu`. Si elige la opción 2, el programa simplemente imprime en pantalla todas las comidas que están en la lista. La opción 3 intenta guardar el contenido del menú en un archivo llamado "datos.txt", aunque aquí hay un error: el método `write` no acepta una lista directamente; debería convertir primero esa lista a una cadena de texto (por ejemplo, utilizando un bucle o la función `join`).

```python
import pickle

menu = []

while True:
  print("Opciones:")
  print("1.-Introducir nueva comida en el menú")
  print("2.-Listar comidas en el menú")
  print("3.-Guardar en archivo")
  opcion = int(input("Selecciona una opción:"))
  if opcion == 1:
    comida = input("Introduce el nombre de la comida: ")
    menu.append(comida)
  elif opcion == 2:
    print("Tu comida hasta el momento es:")
    for elemento in menu:
      print(elemento)
  elif opcion == 3:
    archivo = open("datos.txt","w")
    archivo.write(menu)
    archivo.close()
    
    
    
```

### abro el archivo en modo escritura binaria

#### Explicación

Este fragmento de código en Python crea un pequeño menú interactivo que permite al usuario gestionar una lista de comidas. La aplicación ofrece tres opciones principales: añadir nueva comida a la lista, listar las comidas existentes o guardar el contenido del menú en un archivo binario.

Cuando se selecciona la opción 1, el programa solicita al usuario que introduzca el nombre de una nueva comida y luego agrega esta entrada a la lista `menu`. Si se selecciona la opción 2, simplemente muestra por pantalla todas las comidas que están actualmente en la lista. La opción 3 es la más interesante: abre un archivo llamado "datos.bin" en modo escritura binaria (`wb`) y utiliza el módulo `pickle` para guardar la lista completa de comidas en este archivo.

El uso del formato binario (en lugar de texto) permite almacenar datos complejos de manera eficiente, aunque esto hace que los archivos resultantes sean menos legibles manualmente. En resumen, esta pequeña aplicación es un ejemplo sencillo pero funcional de cómo trabajar con listas y guardar datos estructurados en Python usando archivos binarios y el módulo `pickle`.

```python
import pickle

menu = []

while True:
  print("Opciones:")
  print("1.-Introducir nueva comida en el menú")
  print("2.-Listar comidas en el menú")
  print("3.-Guardar en archivo")
  opcion = int(input("Selecciona una opción:"))
  if opcion == 1:
    comida = input("Introduce el nombre de la comida: ")
    menu.append(comida)
  elif opcion == 2:
    print("Tu comida hasta el momento es:")
    for elemento in menu:
      print(elemento)
  elif opcion == 3:
    archivo = open("datos.bin","wb") # Write Binary
    pickle.dump(menu,archivo)
    archivo.close()
    
    
    
    
    
    
    
    
    
```

### print con exito

#### Explicación

Este fragmento de código es una aplicación simple que permite gestionar un menú de comidas. El programa utiliza un bucle `while True` para mostrar un menú interactivo y permitir al usuario realizar acciones como agregar nuevas comidas, listar las comidas existentes o guardar el menú en un archivo binario.

1. Cuando seleccionas la opción 1, se te pide que introduzcas el nombre de una comida. Esta comida se añade a la lista llamada `menu` mediante el método `.append()`, lo cual amplía la lista con el nuevo elemento.
   
2. Si eliges la opción 2, el programa recorre todos los elementos en la lista `menu` y muestra cada uno de ellos por pantalla.

3. Al seleccionar la opción 3, se crea un archivo binario llamado "datos.bin" para guardar toda la información de comidas almacenada en `menu`. Para esto, se usa el módulo `pickle`, que es una herramienta útil para serializar y deserializar objetos Python a y desde archivos. En este caso, `pickle.dump()` guarda la lista `menu` en el archivo abierto en modo escritura binaria (`wb`). Al final de esta operación, se cierra el archivo y se muestra un mensaje indicando que la operación ha sido exitosa.

Este código es importante porque enseña cómo trabajar con listas en Python, cómo manejar entradas del usuario, y también cómo guardar datos estructurados en archivos para su uso posterior.

```python
import pickle

menu = []

while True:
  print("Opciones:")
  print("1.-Introducir nueva comida en el menú")
  print("2.-Listar comidas en el menú")
  print("3.-Guardar en archivo")
  opcion = int(input("Selecciona una opción:"))
  if opcion == 1:
    comida = input("Introduce el nombre de la comida: ")
    menu.append(comida)
  elif opcion == 2:
    print("Tu comida hasta el momento es:")
    for elemento in menu:
      print(elemento)
  elif opcion == 3:
    archivo = open("datos.bin","wb") # Write Binary
    pickle.dump(menu,archivo)
    archivo.close()
    print("Se ha guardado con éxito ✅")
    
    
    
    
    
    
    
    
    
```

### cargar archivo

#### Explicación

Este código es una pequeña aplicación que te permite gestionar un menú de comidas en Python. Primero, importa el módulo `pickle`, que se usa para guardar y cargar objetos en archivos binarios. El programa utiliza un bucle `while` infinito que muestra un menú con opciones para agregar nuevas comidas al menú, listar las comidas existentes, guardar el estado actual del menú en un archivo o cargar los datos previamente guardados en el menú.

Cuando seleccionas la opción 1, se te pide que introduzcas el nombre de una comida, que luego se añade a la lista `menu`. La opción 2 imprime todos los elementos actuales del menú. Si eliges la opción 3, el programa guarda la lista actual en un archivo llamado "datos.bin" utilizando `pickle.dump()`, asegurando así que tus datos no se pierdan cuando cierres y vuelvas a abrir el programa.

Por último, si seleccionas la opción 4, el código carga los datos del menú desde el archivo "datos.bin" usando `pickle.load()` y actualiza la lista `menu` con estos datos. Esto es crucial para mantener la persistencia de tus datos entre diferentes sesiones de uso del programa, permitiendo que no tengas que introducir todas las comidas cada vez que lo ejecutas.

```python
import pickle

menu = []

while True:
  print("Opciones:")
  print("1.-Introducir nueva comida en el menú")
  print("2.-Listar comidas en el menú")
  print("3.-Guardar en archivo")
  print("4.-Cargar datos de archivo")
  opcion = int(input("Selecciona una opción:"))
  if opcion == 1:
    comida = input("Introduce el nombre de la comida: ")
    menu.append(comida)
  elif opcion == 2:
    print("Tu comida hasta el momento es:")
    for elemento in menu:
      print(elemento)
  elif opcion == 3:
    archivo = open("datos.bin","wb") # Write Binary
    pickle.dump(menu,archivo)
    archivo.close()
    print("Se ha guardado con éxito ✅")
  elif opcion == 4:
    archivo = open("datos.bin","rb")
    menu = pickle.load(archivo) # Volcamos el archivo a la lista
    archivo.close()
    
    
    
    
    
    
    
    
    
```

### cadena de ayuda

#### Explicación

Este código es una aplicación simple que permite gestionar un menú de comidas. Utiliza un bucle `while` para mostrar un menú interactivo donde puedes introducir nuevas comidas, listar las existentes o guardar y cargar datos en un archivo binario usando la biblioteca `pickle`.

Cuando seleccionas la opción 1, el programa solicita que ingreses el nombre de una nueva comida, la cual se añade a una lista llamada `menu`. Si eliges la opción 2, el código imprime todas las comidas almacenadas en esa lista. La opción 3 guarda la lista actualizada del menú en un archivo binario para preservar los datos entre sesiones. Finalmente, si seleccionas la opción 4, el programa carga los datos de ese mismo archivo binario y los vuelve a colocar en la lista `menu`.

Este tipo de código es importante porque demuestra cómo se pueden combinar estructuras básicas como listas con operaciones de lectura/escritura de archivos para crear aplicaciones prácticas que recuerden información incluso después de haber terminado su ejecución.

```python
import pickle

menu = []

while True:
  print("Opciones:")
  print("1.-Introducir nueva comida en el menú")
  print("2.-Listar comidas en el menú")
  print("3.-Guardar en archivo")
  print("4.-Cargar datos de archivo")
  opcion = int(input("Selecciona una opción:"))
  if opcion == 1:
    comida = input("Introduce el nombre de la comida: ")
    menu.append(comida)
  elif opcion == 2:
    print("Tu comida hasta el momento es:")
    for elemento in menu:
      print(elemento)
  elif opcion == 3:
    archivo = open("datos.bin","wb") # Write Binary
    pickle.dump(menu,archivo)
    archivo.close()
    print("Se ha guardado con éxito ✅")
  elif opcion == 4:
    archivo = open("datos.bin","rb")
    menu = pickle.load(archivo) # Volcamos el archivo a la lista
    archivo.close()
    print("Se ha cargado con éxito ✅")
    
    
    
    
    
    
    
    
```

### Actividades propuestas

### Actividades para Alumnos de Formación Profesional

#### 1. **Creación de una Lista Básica**
**Descripción:** El alumnado debe crear un programa que permita introducir y almacenar nombres de comidas en una lista. Los estudiantes aprenderán a trabajar con listas y manejar entradas de usuario.

---

#### 2. **Introducción de Comida Continua**
**Descripción:** Se requiere a los alumnos que creen un bucle infinito para añadir comidas al menú hasta que se introduzca una palabra clave específica como "FIN". Este ejercicio ayudará a entender cómo controlar flujos condicionales dentro del código.

---

#### 3. **Añadiendo Comida y Mostrando la Lista**
**Descripción:** Los alumnos deben modificar el programa para permitir al usuario añadir nuevas comidas, luego mostrar todas las entradas almacenadas hasta ese momento. Esto fortalecerá su comprensión sobre cómo manipular datos en una lista.

---

#### 4. **Menú de Opciones Básico**
**Descripción:** Se solicita a los estudiantes que diseñen un menú interactivivo con dos opciones: agregar comidas y listar las existentes, usando `if-elif` para manejar diferentes entradas del usuario.

---

#### 5. **Integración de Funciones Guardar y Cargar**
**Descripción:** El objetivo es extender el programa anterior añadiendo la opción de guardar los datos en un archivo binario y cargarlos nuevamente al arrancar el programa, utilizando la biblioteca `pickle`. Esto permitirá a los estudiantes entender cómo persistir datos fuera del entorno de ejecución.

---

#### 6. **Manejo de Errores Básicos**
**Descripción:** Los alumnos deben implementar un bloque `try-except` para manejar posibles errores al abrir archivos binarios, lo que enseñará sobre control y excepciones en Python.

---

#### 7. **Validación de Entrada del Usuario**
**Descripción:** Se requiere a los estudiantes añadir validaciones para asegurar que el usuario sólo introduzca valores válidos (por ejemplo, elegir entre opciones numéricas). Esto ayudará a entender conceptos como conversión de tipos y lógica condicional.

---

#### 8. **Menú Avanzado con Gestión de Datos**
**Descripción:** Los alumnos deben completar un menú más avanzado que permita no solo añadir, listar y guardar comidas, sino también cargar datos previamente guardados desde un archivo binario. Esto les ayudará a entender el uso de módulos externos y cómo integrar funcionalidades complejas en programas simples.

---

#### 9. **Documentación Interna**
**Descripción:** Se solicita que los estudiantes añadan comentarios en su código para documentarlo internamente, explicando lo que hace cada bloque del programa. Esto es útil tanto para ellos mismos como para otros desarrolladores que puedan revisar o utilizar su trabajo.

---

#### 10. **Refactorización y Mejora de Código**
**Descripción:** Finalmente, los alumnos deben refactorizar el código existente para mejorar la eficiencia y legibilidad, tal vez dividiendo partes del programa en funciones más pequeñas. Esto les enseñará a pensar en mejores prácticas de programación y cómo mejorar el diseño del software.

---

Estas actividades están diseñadas para cubrir desde conceptos básicos hasta avanzados, adaptándose al nivel de los estudiantes de ciclos formativos y utilizando únicamente las tecnologías y lenguajes presentes en la carpeta proporcionada.


<a id="matrices-arrays-multidimensionales"></a>
## Matrices (arrays) multidimensionales

### Introducción a los ejercicios

El código proporcionado muestra diferentes ejemplos de cómo trabajar con datos y estructuras en Python. Aquí está un análisis detallado de cada uno:

1. **001-estructura compleja**: Ejemplo básico para entender la composición de listas anidadas.

2. **002-pickle para cargar.py**: Usa `pickle` para guardar una lista compleja a disco y luego cargarla nuevamente en un programa Python.

3. **004-uso de pickle para leer.py**: Muestra cómo usar `pickle` para recuperar datos guardados, específicamente desde un archivo llamado "agenda.bin".

4. **005-leer con for**: Utiliza un bucle `for` para recorrer una lista anidada y acceder a los elementos.

5. **006-sin pickle.py**: Ejemplo básico de cómo manejar datos en memoria sin utilizar archivos externos o módulos como `pickle`.

6. **007-ciclo for para lectura de agenda**: Muestra cómo iterar sobre una estructura compleja (lista dentro de listas) para leer y procesar datos.

7. **008-diccionario simple.py**: Introducción a los diccionarios, una estructura útil para almacenar pares clave-valor.

8. **009-copia de lista.py**: Ejemplo sobre cómo hacer una copia profunda de una lista anidada usando `copy.deepcopy`.

9. **010-intento.py**: Muestra cómo manejar errores al acceder a índices inexistentes en listas, utilizando la cláusula `try...except`.

10. **013-agenda.py**: Ejemplo básico de un programa que permite añadir registros (nombre, apellidos, email y teléfono) a una lista.

11. **014-pickle para guardar.py**: Similar al anterior pero incluye la funcionalidad de guardar la agenda en un archivo binario usando `pickle`.

12. **015-conversiones de datos conocidas.py** y **016-conversiones no posibles.py**: Ejemplos sobre cómo convertir cadenas a números enteros (`int`) en Python, mostrando también el manejo de errores cuando la conversión es inválida.

13. **017-tipo.py** y **018-cambio de tipo de dato.py**: Explican los tipos de datos básicos (listas vs tuplas) y cómo convertir entre ellos en Python.

14. **019-parto.py**: Similar a **014**, pero con un flujo ligeramente diferente que permite tanto insertar como guardar registros, sin mostrar la agenda por cada inserción.

15. **020-menu.py**: Un ejemplo más avanzado de cómo estructurar un programa en Python que ofrece al usuario varias opciones (insertar, leer, y guardar) a través de un menú interactivo.

Estos ejemplos son útiles para aprender diferentes aspectos del manejo de datos y estructuras en Python, desde las listas anidadas hasta el uso de diccionarios y la manipulación de archivos mediante `pickle`.

### variable

#### Explicación

Este código es muy sencillo y crea una variable llamada `nombre` en el lenguaje de programación Python. La variable `nombre` almacena un texto, específicamente la cadena "Jose Vicente". En términos simples, estás diciendo a tu programa que recuerde el nombre "Jose Vicente" bajo la etiqueta o identificador `nombre`. Esto es importante porque permite almacenar información textual (como nombres) para usarla más tarde en tu código, por ejemplo, para mostrar un saludo personalizado al usuario.

```python
nombre = "Jose Vicente"
```

### lista

#### Explicación

Este código Python define una variable llamada `nombre` que almacena un string con el valor "Jose Vicente". A continuación, se crea una lista llamada `nombres`, que es una colección ordenada de elementos. En este caso, la lista contiene cinco strings: "Jose Vicente", "Juan", "Jorge", "Jaime" y "Julia". La lista `nombres` sirve para agrupar varios nombres relacionados en un solo lugar, lo que facilita su manipulación y acceso en programas más grandes. Es importante destacar que la primera línea no es necesaria si ya tienes todos los nombres dentro de la lista, pero puede ser útil cuando deseas trabajar con un nombre individual fuera del contexto de toda la lista.

```python
nombre = "Jose Vicente"

nombres = [
  "Jose Vicente",
  "Juan",
  "Jorge",
  "Jaime",
  "Julia"
]
```

### matriz multidimensional

#### Explicación

Este código muestra cómo se puede almacenar información de contacto en una estructura llamada matriz o array multidimensional en Python. En este caso, la variable `agenda` es una lista vacía que luego almacena sublistas, cada una representando un contacto diferente con diferentes campos de información como el nombre, apellido, correo electrónico y número telefónico.

Lo importante aquí es cómo se añaden estos contactos a la agenda: `agenda[0] = [...]` y `agenda[1] = [...]`. Esto indica que en la posición 0 de la lista principal (agenda) se almacena una sublista con los datos del primer contacto, y en la posición 1 se guarda otra sublista con los datos del segundo contacto. Cada sublista contiene elementos ordenados: primero el nombre, luego el apellido, después el correo electrónico y por último el número de teléfono.

Esta estructura permite organizar información compleja de manera jerárquica y accesible, facilitando la búsqueda y manipulación de datos en programas más grandes que manejan registros de contactos o cualquier otro tipo de base de datos similar.

```python
agenda = []

# Una lista dentro de otra lista
agenda[0] = [
  "Jose Vicente",
  "Carratala",
  "info@jocarsa.com",
  "12345678"
]

agenda[1] = [
  "Jorge",
  "Martinez",
  "jorge@jocarsa.com",
  "123456787"
]
```

### otra formulacion

#### Explicación

Este código Python crea una lista llamada `agenda` que almacena información de contacto sobre varias personas. En este caso, la agenda contiene dos entradas, cada una representando a un individuo diferente. Cada entrada es una sublista con cuatro elementos: el nombre (por ejemplo, "Jose Vicente" y "Jorge"), el apellido ("Carratala" y "Martinez"), el correo electrónico ("info@jocarsa.com" y "jorge@jocasa.com") y el número de teléfono ("12345678" y "123456787"). Al final, se imprime la agenda completa en pantalla. Este tipo de estructura es útil para organizar datos relacionados en listas anidadas o matrices, lo que facilita la gestión y el acceso a información compleja como una base de contactos.

```python
agenda = [
  [
    "Jose Vicente",
    "Carratala",
    "info@jocarsa.com",
    "12345678"
  ],
  [
    "Jorge",
    "Martinez",
    "jorge@jocarsa.com",
    "123456787"
  ]
]

print(agenda)  
```

### acceso a un elemento de la primera dimension

#### Explicación

Este fragmento de código está trabajando con una estructura llamada matriz o array multidimensional en Python. Específicamente, la variable `agenda` es una lista que contiene dos sublistas, cada una representando los datos de contacto de una persona diferente. La primera sublista almacena información sobre "Jose Vicente Carratala", y la segunda sublista tiene detalles de "Jorge Martínez". Cada sublista contiene cuatro elementos: el nombre completo, el apellido, un correo electrónico y un número telefónico.

La línea `print(agenda[0])` imprime en pantalla la primera sublista dentro de `agenda`. Dado que los índices en Python empiezan desde 0, esta línea accede a los datos del primer contacto almacenados en la agenda, mostrando así toda la información correspondiente a "Jose Vicente Carratala".

Este tipo de estructura es útil cuando necesitas almacenar y manipular grupos relacionados de datos, como una lista de contactos o registros en una base de datos simple.

```python
agenda = [
  [
    "Jose Vicente",
    "Carratala",
    "info@jocarsa.com",
    "12345678"
  ],
  [
    "Jorge",
    "Martinez",
    "jorge@jocarsa.com",
    "123456787"
  ]
]

print(agenda[0])  
```

### puedo acceder a la segunda dimension

#### Explicación

Este fragmento de código Python muestra cómo se manejan matrices bidimensionales, que también son conocidas como arrays o listas anidadas. En este caso, la matriz `agenda` almacena información sobre personas en diferentes filas y columnas. Cada fila representa un contacto con cuatro elementos: nombre completo (nombre y apellido), dirección de correo electrónico y número telefónico.

El código imprime dos cosas específicas:
1. La primera línea `print(agenda[0])` muestra toda la primera fila del array, es decir, todos los detalles del primer contacto en la agenda.
2. La segunda línea `print(agenda[0][0])` accede a un elemento específico dentro de esa matriz bidimensional y imprime solo el nombre completo del primer contacto, que es "Jose Vicente".

Este tipo de estructura permite organizar datos complejos de manera clara y accesible, facilitando operaciones como la búsqueda o manipulación de información en aplicaciones de gestión de contactos.

```python
agenda = [
  [
    "Jose Vicente",
    "Carratala",
    "info@jocarsa.com",
    "12345678"
  ],
  [
    "Jorge",
    "Martinez",
    "jorge@jocarsa.com",
    "123456787"
  ]
]

print(agenda[0])  
print(agenda[0][0]) # Jose Vicente
```

### tambien podemos escribir

#### Explicación

Este código está trabajando con matrices o arrays multidimensionales en Python. En este caso, la matriz se llama `agenda` y contiene información sobre varias personas, como nombres y detalles de contacto. La estructura es tal que cada persona dentro de `agenda` es una lista por sí misma, y esta lista incluye diferentes piezas de información: nombre, apellido, correo electrónico y número telefónico.

En el código, se imprime la primera persona en la matriz `agenda`, que es una lista con cuatro elementos. Luego, se muestra solo el primer elemento de esa lista, que corresponde al nombre "Jose Vicente". Después del punto, se cambia ese nombre por "Jaime" y se vuelve a imprimir para demostrar que el cambio ha tenido efecto.

Este tipo de estructura es muy útil cuando necesitas organizar datos complejos en bloques, como cuando manejas registros de múltiples personas con diferentes tipos de información.

```python
agenda = [
  [
    "Jose Vicente",
    "Carratala",
    "info@jocarsa.com",
    "12345678"
  ],
  [
    "Jorge",
    "Martinez",
    "jorge@jocarsa.com",
    "123456787"
  ]
]

print(agenda[0])  
print(agenda[0][0]) # Jose Vicente
agenda[0][0] = "Jaime"
print(agenda[0][0]) # Jaime
```

### ejemplo palet

#### Explicación

Este código Python crea una estructura de datos llamada matriz multidimensional o array tridimensional que representa un palet. En este caso, la matriz `palet` tiene tres dimensiones: x, y y z. Imagínate que tienes un montón de cajas en tu cuarto: cada caja está dentro de una fila, cada fila dentro de un estante, y cada estante en un palet. Así es como se organizan los números en este código.

La matriz `palet` tiene tres niveles principales (x), cada uno con tres filas (y) que a su vez contienen tres elementos (z). Cada número está ubicado en una posición específica dentro de esta estructura. Por ejemplo, el número 5 se encuentra en la segunda dimensión (índice y=1), en la primera fila (índice x=0) y en la segunda columna (índice z=1).

Finalmente, el código imprime en pantalla toda la matriz `palet`, mostrando así su estructura completa. Esto es útil para los estudiantes que están aprendiendo porque les permite visualizar cómo se organizan las matrices tridimensionales y entender cómo acceder a diferentes elementos dentro de ellas.

```python
palet = [ # x
          [ # y
            [1,2,3], # z 
            [4,5,6],
            [7,8,9]
          ],
          [
            [11,12,13], 
            [14,15,16],
            [17,18,19] 
          ],
          [
            [21,22,23], 
            [24,25,26],
            [27,28,29] 
          ]
        ]
print(palet)
```

### linea de palets

#### Explicación

Este fragmento de código crea una estructura en Python llamada matriz multidimensional, que representa una línea de palets organizados en un espacio tridimensional. La variable `palets` almacena esta estructura, donde cada nivel de anidamiento (corchetes) corresponde a una dimensión: primer nivel para la posición 'x', segundo nivel para la posición 'y', y el tercer nivel para la posición 'z'. Cada palet está representado por un conjunto de números en una matriz 3x3, que podrían simbolizar diferentes características del palet.

Lo importante aquí es entender cómo se estructuran los datos tridimensionalmente: dos palets están colocados uno al lado del otro en la dimensión 'x'. Cada palet está compuesto por tres capas (o niveles) representadas en la dimensión 'y', y cada una de estas capas tiene nueve elementos organizados en un grid 3x3, que sería la dimensión 'z'.

El código finaliza con `print(palet)`, lo cual es un error tipográfico porque intenta imprimir una variable llamada `palet` (en singular), mientras que el array multidimensional se ha definido como `palets` (en plural). Para corregir esto, simplemente hay que cambiar `print(palet)` a `print(palets)`.

```python
palets = [ # linea de palets
           [ # x
            [ # y
              [1,2,3], # z 
              [4,5,6],
              [7,8,9]
            ],
            [
              [11,12,13], 
              [14,15,16],
              [17,18,19] 
            ],
            [
              [21,22,23], 
              [24,25,26],
              [27,28,29] 
            ]
          ],
          [ # x
            [ # y
              [1,2,3], # z 
              [4,5,6],
              [7,8,9]
            ],
            [
              [11,12,13], 
              [14,15,16],
              [17,18,19] 
            ],
            [
              [21,22,23], 
              [24,25,26],
              [27,28,29] 
            ]
          ],
        ]
print(palet)
```

### estanteria de palets

#### Explicación

Este código Python representa una estructura en forma de matriz multidimensional que modela una estantería de palets. En este caso, la matriz `palets` es un conjunto jerárquico que contiene información sobre diferentes niveles y ubicaciones espaciales donde los palets están almacenados.

La estructura empieza con una lista llamada `palets`, que a su vez contiene otras listas para representar líneas de palets, posiciones en el eje x (horizontal), en el eje y (vertical) y finalmente en el eje z (profundidad o altura). Por ejemplo, cada línea de palets está compuesta por dos "x" diferentes, y cada "x" tiene tres niveles de "y", donde cada nivel de "y" contiene una matriz 3x3 que representa la disposición en z.

Esta estructura es muy útil para aplicaciones que requieren manejar datos en tres dimensiones o incluso más, como el almacenamiento en estanterías con múltiples capas y secciones. Permite acceder a cualquier dato específico de un palet mediante índices, facilitando operaciones como mover un palet de una posición a otra dentro del sistema.

Es importante notar que el último `print(palets)` está mal escrito; debería ser `print(palets)`, ya que intenta imprimir la matriz completa para mostrar su contenido estructurado.

```python
palets = [ # estanteria de palets
          [ # linea de palets
           [ # x
            [ # y
              [1,2,3], # z 
              [4,5,6],
              [7,8,9]
            ],
            [
              [11,12,13], 
              [14,15,16],
              [17,18,19] 
            ],
            [
              [21,22,23], 
              [24,25,26],
              [27,28,29] 
            ]
          ],
          [ # x
            [ # y
              [1,2,3], # z 
              [4,5,6],
              [7,8,9]
            ],
            [
              [11,12,13], 
              [14,15,16],
              [17,18,19] 
            ],
            [
              [21,22,23], 
              [24,25,26],
              [27,28,29] 
            ]
          ],
        ],
        [ # linea de palets
           [ # x
            [ # y
              [1,2,3], # z 
              [4,5,6],
              [7,8,9]
            ],
            [
              [11,12,13], 
              [14,15,16],
              [17,18,19] 
            ],
            [
              [21,22,23], 
              [24,25,26],
              [27,28,29] 
            ]
          ],
          [ # x
            [ # y
              [1,2,3], # z 
              [4,5,6],
              [7,8,9]
            ],
            [
              [11,12,13], 
              [14,15,16],
              [17,18,19] 
            ],
            [
              [21,22,23], 
              [24,25,26],
              [27,28,29] 
            ]
          ],
        ],
       ]
print(palet)
```

### estanterias

#### Explicación

Este fragmento de código en Python crea una estructura compleja que representa un sistema de almacenamiento para palets organizados en estanterías. La variable `palets` es una matriz multidimensional, donde cada nivel del array simboliza diferentes dimensiones físicas del sistema: las estanterías, líneas dentro de ellas, posiciones x e y, niveles z (altura) y finalmente los números que representan palets individuales o unidades.

El código está estructurado en varios niveles para reflejar la organización real de un almacén. Por ejemplo, cada submatriz interna representa una estantería con múltiples líneas de almacenamiento, y dentro de estas líneas, hay diferentes ubicaciones tridimensionales (x, y, z) donde se pueden colocar los palets.

Imprimir `palet` al final del código mostrará la estructura completa en la consola. Sin embargo, es importante notar que aquí parece haber un pequeño error tipográfico: el nombre de la variable para imprimir debería ser `palets` (en plural) en lugar de `palet`. Este tipo de organización de datos ayuda a gestionar y acceder eficientemente a información sobre la ubicación de los palets en un almacén, facilitando tareas como inventario, despacho de pedidos y optimización del espacio.

```python
palets = [ # Estanterias de palets
           [ # estanteria de palets
            [ # linea de palets
             [ # x
              [ # y
                [1,2,3], # z 
                [4,5,6],
                [7,8,9]
              ],
              [
                [11,12,13], 
                [14,15,16],
                [17,18,19] 
              ],
              [
                [21,22,23], 
                [24,25,26],
                [27,28,29] 
              ]
            ],
            [ # x
              [ # y
                [1,2,3], # z 
                [4,5,6],
                [7,8,9]
              ],
              [
                [11,12,13], 
                [14,15,16],
                [17,18,19] 
              ],
              [
                [21,22,23], 
                [24,25,26],
                [27,28,29] 
              ]
            ],
          ],
          [ # linea de palets
             [ # x
              [ # y
                [1,2,3], # z 
                [4,5,6],
                [7,8,9]
              ],
              [
                [11,12,13], 
                [14,15,16],
                [17,18,19] 
              ],
              [
                [21,22,23], 
                [24,25,26],
                [27,28,29] 
              ]
            ],
            [ # x
              [ # y
                [1,2,3], # z 
                [4,5,6],
                [7,8,9]
              ],
              [
                [11,12,13], 
                [14,15,16],
                [17,18,19] 
              ],
              [
                [21,22,23], 
                [24,25,26],
                [27,28,29] 
              ]
            ],
          ],
         ],
         [ # estanteria de palets
            [ # linea de palets
             [ # x
              [ # y
                [1,2,3], # z 
                [4,5,6],
                [7,8,9]
              ],
              [
                [11,12,13], 
                [14,15,16],
                [17,18,19] 
              ],
              [
                [21,22,23], 
                [24,25,26],
                [27,28,29] 
              ]
            ],
            [ # x
              [ # y
                [1,2,3], # z 
                [4,5,6],
                [7,8,9]
              ],
              [
                [11,12,13], 
                [14,15,16],
                [17,18,19] 
              ],
              [
                [21,22,23], 
                [24,25,26],
                [27,28,29] 
              ]
            ],
          ],
          [ # linea de palets
             [ # x
              [ # y
                [1,2,3], # z 
                [4,5,6],
                [7,8,9]
              ],
              [
                [11,12,13], 
                [14,15,16],
                [17,18,19] 
              ],
              [
                [21,22,23], 
                [24,25,26],
                [27,28,29] 
              ]
            ],
            [ # x
              [ # y
                [1,2,3], # z 
                [4,5,6],
                [7,8,9]
              ],
              [
                [11,12,13], 
                [14,15,16],
                [17,18,19] 
              ],
              [
                [21,22,23], 
                [24,25,26],
                [27,28,29] 
              ]
            ],
          ],
         ],
        ]
print(palet)
```

### naves industriales

#### Explicación

Este fragmento de código en Python representa una estructura de datos compleja que simula el almacenamiento de naves industriales. La variable `naves` es un array multidimensional, donde cada nivel del array corresponde a una capa más específica del almacenaje.

- En la primera dimensión (nivel superior), tenemos las estanterías de palets, divididas en diferentes secciones.
- Dentro de estas estanterías, hay varias líneas de palets que contienen distintos niveles de organización.
- A medida que nos adentramos más dentro del array, encontramos coordenadas tridimensionales (x, y, z), donde cada uno representa una ubicación específica en el almacén.

Esta estructura permite organizar y acceder a grandes cantidades de datos de manera sistemática. Por ejemplo, si queremos saber qué palet está en la posición (1, 2, 3) dentro de un determinado área del almacenamiento, podemos navegar por este array multidimensional para obtener esa información.

El uso de arrays multidimensionales es crucial cuando se trabaja con datos estructurados que tienen varias capas o niveles de organización. En este caso específico, ayuda a simular y gestionar eficientemente el espacio físico en una nave industrial donde los palets están almacenados en estanterías tridimensionales.

```python
naves = [ # Naves industriales
          [ # Estanterias de palets
           [ # estanteria de palets
            [ # linea de palets
             [ # x
              [ # y
                [1,2,3], # z 
                [4,5,6],
                [7,8,9]
              ],
              [
                [11,12,13], 
                [14,15,16],
                [17,18,19] 
              ],
              [
                [21,22,23], 
                [24,25,26],
                [27,28,29] 
              ]
            ],
            [ # x
              [ # y
                [1,2,3], # z 
                [4,5,6],
                [7,8,9]
              ],
              [
                [11,12,13], 
                [14,15,16],
                [17,18,19] 
              ],
              [
                [21,22,23], 
                [24,25,26],
                [27,28,29] 
              ]
            ],
          ],
          [ # linea de palets
             [ # x
              [ # y
                [1,2,3], # z 
                [4,5,6],
                [7,8,9]
              ],
              [
                [11,12,13], 
                [14,15,16],
                [17,18,19] 
              ],
              [
                [21,22,23], 
                [24,25,26],
                [27,28,29] 
              ]
            ],
            [ # x
              [ # y
                [1,2,3], # z 
                [4,5,6],
                [7,8,9]
              ],
              [
                [11,12,13], 
                [14,15,16],
                [17,18,19] 
              ],
              [
                [21,22,23], 
                [24,25,26],
                [27,28,29] 
              ]
            ],
          ],
         ],
         [ # estanteria de palets
            [ # linea de palets
             [ # x
              [ # y
                [1,2,3], # z 
                [4,5,6],
                [7,8,9]
              ],
              [
                [11,12,13], 
                [14,15,16],
                [17,18,19] 
              ],
              [
                [21,22,23], 
                [24,25,26],
                [27,28,29] 
              ]
            ],
            [ # x
              [ # y
                [1,2,3], # z 
                [4,5,6],
                [7,8,9]
              ],
              [
                [11,12,13], 
                [14,15,16],
                [17,18,19] 
              ],
              [
                [21,22,23], 
                [24,25,26],
                [27,28,29] 
              ]
            ],
          ],
          [ # linea de palets
             [ # x
              [ # y
                [1,2,3], # z 
                [4,5,6],
                [7,8,9]
              ],
              [
                [11,12,13], 
                [14,15,16],
                [17,18,19] 
              ],
              [
                [21,22,23], 
                [24,25,26],
                [27,28,29] 
              ]
            ],
            [ # x
              [ # y
                [1,2,3], # z 
                [4,5,6],
                [7,8,9]
              ],
              [
                [11,12,13], 
                [14,15,16],
                [17,18,19] 
              ],
              [
                [21,22,23], 
                [24,25,26],
                [27,28,29] 
              ]
            ],
          ],
         ],
        ],
        [ # Estanterias de palets
           [ # estanteria de palets
            [ # linea de palets
             [ # x
              [ # y
                [1,2,3], # z 
                [4,5,6],
                [7,8,9]
              ],
              [
                [11,12,13], 
                [14,15,16],
                [17,18,19] 
              ],
              [
                [21,22,23], 
                [24,25,26],
                [27,28,29] 
              ]
            ],
            [ # x
              [ # y
                [1,2,3], # z 
                [4,5,6],
                [7,8,9]
              ],
              [
                [11,12,13], 
                [14,15,16],
                [17,18,19] 
              ],
              [
                [21,22,23], 
                [24,25,26],
                [27,28,29] 
              ]
            ],
          ],
          [ # linea de palets
             [ # x
              [ # y
                [1,2,3], # z 
                [4,5,6],
                [7,8,9]
              ],
              [
                [11,12,13], 
                [14,15,16],
                [17,18,19] 
              ],
              [
                [21,22,23], 
                [24,25,26],
                [27,28,29] 
              ]
            ],
            [ # x
              [ # y
                [1,2,3], # z 
                [4,5,6],
                [7,8,9]
              ],
              [
                [11,12,13], 
                [14,15,16],
                [17,18,19] 
              ],
              [
                [21,22,23], 
                [24,25,26],
                [27,28,29] 
              ]
            ],
          ],
         ],
         [ # estanteria de palets
            [ # linea de palets
             [ # x
              [ # y
                [1,2,3], # z 
                [4,5,6],
                [7,8,9]
              ],
              [
                [11,12,13], 
                [14,15,16],
                [17,18,19] 
              ],
              [
                [21,22,23], 
                [24,25,26],
                [27,28,29] 
              ]
            ],
            [ # x
              [ # y
                [1,2,3], # z 
                [4,5,6],
                [7,8,9]
              ],
              [
                [11,12,13], 
                [14,15,16],
                [17,18,19] 
              ],
              [
                [21,22,23], 
                [24,25,26],
                [27,28,29] 
              ]
            ],
          ],
          [ # linea de palets
             [ # x
              [ # y
                [1,2,3], # z 
                [4,5,6],
                [7,8,9]
              ],
              [
                [11,12,13], 
                [14,15,16],
                [17,18,19] 
              ],
              [
                [21,22,23], 
                [24,25,26],
                [27,28,29] 
              ]
            ],
            [ # x
              [ # y
                [1,2,3], # z 
                [4,5,6],
                [7,8,9]
              ],
              [
                [11,12,13], 
                [14,15,16],
                [17,18,19] 
              ],
              [
                [21,22,23], 
                [24,25,26],
                [27,28,29] 
              ]
            ],
          ],
         ],
        ]
       ]
print(palet)
```

### agenda

#### Explicación

Este fragmento de código está diseñado para crear una simple agenda donde puedes guardar información personal de contactos. Al ejecutar el programa, se te pedirá que ingreses tu nombre, apellidos, email y teléfono en cada iteración del bucle `while True`, lo cual significa que este ciclo continuará infinitamente hasta que detengas la ejecución manualmente.

Cada vez que introduces esta información, el código crea una lista con los cuatro datos proporcionados y añade esa lista como un nuevo elemento a otra lista llamada `agenda`. La variable `agenda` es, en realidad, una matriz (o array) bidimensional porque cada vez que se agrega nueva información del usuario, se forma una lista dentro de la lista principal `agenda`.

Después de agregar los datos, el programa imprime toda la agenda actualizada para mostrarte lo que has añadido. Esto te permite ver cómo van creciendo tus registros en tiempo real.

Este tipo de estructura es útil porque te permite almacenar y organizar información compleja (como varios detalles sobre una persona) dentro de una sola variable, facilitando su manejo y consulta posterior.

```python
agenda = []

while True:
  nombre = input("Dime tu nombre: ")
  apellidos = input("Dime tus apellidos: ")
  email = input("Dime tu email: ")
  telefono = input("Dime tu teléfono: ")
  # Añado a la agenda
  agenda.append([nombre,apellidos,email,telefono])
  print(agenda)
  
  
  
```

### pickle para guardar

#### Explicación

Este código es una pequeña aplicación en Python que permite guardar información de contacto en un archivo binario usando el módulo `pickle`. El programa crea una lista llamada `agenda` donde va almacenando la información de los contactos introducida por el usuario, como nombre, apellidos, email y teléfono. Cada vez que se introduce esta información, se añade a la lista en forma de sublista.

Después de guardar la información del contacto, el programa abre un archivo binario llamado `agenda.bin` en modo escritura (`'wb'`) y guarda la lista completa de contactos usando la función `pickle.dump()`. Esto es importante porque permite almacenar la estructura de datos compleja como una matriz multidimensional (en este caso, una lista) en formato binario, lo que hace que sea más eficiente para leer y escribir el archivo en comparación con guardar texto plano. Una vez guardada la información, cierra el archivo.

Este método es útil cuando necesitas persistir datos de estructuras complejas entre sesiones del programa sin tener que reinventar la rueda para manejar archivos de texto o bases de datos más complicadas.

```python
import pickle
agenda = []

while True:
  nombre = input("Dime tu nombre: ")
  apellidos = input("Dime tus apellidos: ")
  email = input("Dime tu email: ")
  telefono = input("Dime tu teléfono: ")
  # Añado a la agenda
  agenda.append([nombre,apellidos,email,telefono])
  print(agenda)
  archivo = open("agenda.bin",'wb')
  pickle.dump(agenda,archivo)
  archivo.close()
  
  
  
```

### conversiones de datos conocidas

#### Explicación

Este fragmento de código muestra cómo convertir un tipo de dato en otro, específicamente convirtiendo una cadena de texto que contiene un número (en este caso, la edad representada como "47") a un número entero. Primero, se declara una variable llamada `edad` y se le asigna el valor "47", pero entre comillas, lo que significa que es un dato de tipo cadena de texto (string). Luego, mediante la función `int()`, se convierte esta cadena en un número entero, guardando este nuevo valor en una variable llamada `edad_en_numero`. Finalmente, el código imprime tanto la versión original de la edad como su versión convertida a un número. Esto es importante porque los números enteros y las cadenas son tipos de datos diferentes y pueden ser utilizados para operaciones distintas; por ejemplo, puedes sumar dos números enteros pero no una cadena con un número.

```python
edad = "47"

edad_en_numero = int(edad)

print(edad)
print(edad_en_numero)
```

### conversiones no posibles

#### Explicación

Este fragmento de código intenta convertir una variable que contiene un valor no numérico en un número entero, lo cual es problemático porque la variable `edad` está inicializada con el carácter "a", que no puede ser interpretado como un número. Cuando se ejecuta esta línea `edad_en_numero = int(edad)`, Python generará un error (RuntimeError o ValueError) porque no puede convertir una letra en un entero.

El código imprime primero el valor de la variable `edad` que es "a", y luego intenta imprimir la versión numérica, pero debido a la conversión incorrecta, esto terminará en un fallo del programa. Es importante entender este tipo de errores porque cuando estás trabajando con datos de entrada del usuario o de archivos externos, no siempre puedes asumir que los valores serán del tipo esperado y debes verificarlos antes de realizar conversiones. Esto ayuda a evitar estos tipos de errores y mejorar la robustez de tus programas.

```python
edad = "a"

edad_en_numero = int(edad)

print(edad)
print(edad_en_numero)
```

### tipo

#### Explicación

Este código Python muestra la diferencia entre dos tipos de estructuras de datos: listas y tuplas. En primer lugar, se crea una lista llamada `lista` que contiene tres elementos: 'manzanas', 'peras' y 'platanos'. Luego, esta lista se imprime en pantalla para mostrar sus contenidos y también se muestra el tipo de estructura (`type(lista)`), lo cual resultará en `<class 'list'>`.

A continuación, se crea una tupla llamada `tupla` que contiene los mismos elementos que la lista. La tupla es similar a la lista, pero está rodeada por paréntesis y no puede ser modificada después de su creación (es inmutable). Al igual que con la lista, el código imprime en pantalla los contenidos de la tupla y también muestra su tipo (`type(tupla)`), lo cual mostrará `<class 'tuple'>`.

Este fragmento es importante porque demuestra cómo las listas y las tuplas son estructuras de datos similares pero distintas: las listas permiten agregar, eliminar o modificar elementos, mientras que las tuplas no. Elegir entre una lista o una tupla dependerá del tipo de dato que necesites manipular en tu programa.

```python
lista = ['manzanas','peras','platanos']
print(lista)
print(type(lista))

tupla = ('manzanas','peras','platanos')
print(tupla)
print(type(tupla))
```

### cambio de tipo de dato

#### Explicación

Este fragmento de código te enseña cómo convertir entre diferentes tipos de estructuras de datos en Python, específicamente entre una tupla y una lista. Al principio, se crea una tupla con tres elementos: 'manzanas', 'peras' y 'platanos'. Las tuplas son similares a las listas pero no permiten cambios una vez que están creadas, lo cual puede ser útil para asegurar la inmutabilidad de ciertos datos. Sin embargo, en este código se necesita añadir un elemento adicional ('fresas'), por lo que primero convierte la tupla en una lista utilizando la función `list()`. Una vez convertida a lista, puedes agregar elementos con el método `append()`.

Finalmente, cuando ya no necesitas modificar los datos y deseas volver a tener una estructura inmutable, se vuelve a convertir la lista en una nueva tupla usando `tuple(lista)`, lo que crea una tupla con todos los elementos incluyendo 'fresas'. Esta conversión entre tipos de dato es útil cuando necesitas cambiar las características de un objeto para adaptarse a diferentes situaciones o requerimientos del programa.

```python
tupla = ('manzanas','peras','platanos')
# Necesito meter una fruta más
print(tupla)
lista = list(tupla) # convierto una tupla en una lista
print(lista)
lista.append("fresas")

# Ahora supongamos que tengo que volver a tupla
nueva_tupla = tuple(lista)
print(nueva_tupla)
```

### parto

#### Explicación

Este fragmento de código es un programa simple en Python que permite crear una agenda con información personal como nombres, apellidos, email y teléfono. El programa funciona en un bucle infinito (`while True:`) que pide al usuario ingresar detalles para cada persona y luego guarda estos datos en la lista `agenda`.

Cada vez que el usuario ingresa los datos solicitados (nombre, apellidos, email y teléfono), estos se añaden a una nueva sublista dentro de la lista principal llamada `agenda`. Luego, esta información se imprime en pantalla para verificar que ha sido ingresada correctamente. Finalmente, los datos de la agenda se guardan permanentemente en un archivo binario llamado "agenda.bin" usando el módulo `pickle`, que es útil para guardar objetos de Python en archivos.

Este código es importante porque demuestra cómo almacenar y recuperar información compleja (como una lista dentro de otra lista) utilizando archivos, lo cual es fundamental en aplicaciones más grandes donde se necesita mantener datos a largo plazo.

```python
import pickle
agenda = []

while True:
  # Insertar
  nombre = input("Dime tu nombre: ")
  apellidos = input("Dime tus apellidos: ")
  email = input("Dime tu email: ")
  telefono = input("Dime tu teléfono: ")
  agenda.append([nombre,apellidos,email,telefono])
  # Imprimir
  print(agenda)
  # Guardar
  archivo = open("agenda.bin",'wb')
  pickle.dump(agenda,archivo)
  archivo.close()
  
  
  
```

### menu

#### Explicación

Este fragmento de código es una pequeña aplicación de línea de comandos que gestiona un registro de contactos utilizando matrices (arrays) en Python. La aplicación muestra un menú interactivo donde el usuario puede elegir entre tres opciones: insertar un nuevo contacto, leer los registros existentes o guardar todos los datos almacenados hasta ahora.

Cuando el usuario selecciona la opción 1, se le solicitan detalles como nombre, apellidos, email y teléfono. Estos datos se guardan en una matriz (una fila) que luego se agrega a la lista `agenda`, creando así un registro de contacto.

La opción 2 simplemente imprime toda la agenda en pantalla para que el usuario pueda ver todos los registros almacenados hasta ese momento.

Finalmente, si el usuario selecciona la opción 3, el programa abre un archivo binario llamado "agenda.bin" y utiliza la biblioteca `pickle` para guardar la lista completa de registros (`agenda`) en este archivo. Esto permite preservar permanentemente los datos incluso después de que se cierra la aplicación.

Esta forma de manejar información es importante porque nos ayuda a entender cómo almacenar y recuperar datos complejos (como una lista de listas) en archivos, lo cual es fundamental para crear aplicaciones más robustas e interactivas.

```python
import pickle
agenda = []

while True:
  print("Selecciona una opcion: ")
  print("1.-Insertar un registro")
  print("2.-Leer registros")
  print("3.-Guardar registros")
  opcion = int(input("Opción escogida: "))
  if opcion == 1:
    # Insertar
    nombre = input("Dime tu nombre: ")
    apellidos = input("Dime tus apellidos: ")
    email = input("Dime tu email: ")
    telefono = input("Dime tu teléfono: ")
    agenda.append([nombre,apellidos,email,telefono])
  elif opcion == 2:
    # Imprimir
    print(agenda)
  elif opcion == 3:
    # Guardar
    archivo = open("agenda.bin",'wb')
    pickle.dump(agenda,archivo)
    archivo.close()
  
  
  
```

### Actividades propuestas

It looks like you have a series of Python code snippets that cover different aspects of data handling and user interaction. Here's an overview and analysis of each file:

1. **001-simple.py**:
   - A simple print statement to display "Hola Mundo".
   
2. **002-variables.py**:
   - Declares variables `a`, `b`, and `c` with integer values.
   - Prints the values of these variables.

3. **003-sinopsis.py**:
   - Defines strings `title`, `director`, and `year`.
   - Uses string formatting to print a synopsis.

4. **004-copia.py**:
   - Declares a list `data` with numbers.
   - Makes an incorrect shallow copy of the list, which will affect both references if modified.
   
5. **005-deepcopy.py**:
   - Uses `deepcopy` from `copy` module to create a true copy of a nested list.

6. **006-herencia.py**:
   - Demonstrates inheritance with two classes `A` and `B`.
   
7. **007-inicializar.py**:
   - Shows how to initialize variables during class instantiation.
   
8. **008-lista-y-tupla.py**:
   - Compares lists (`list`) and tuples (`tuple`) in terms of mutability.

9. **009-herencia2.py**:
   - Expands on inheritance with a base class `Person` and derived classes `Student`.

10. **010-agenda-con-pickle.py**:
    - Uses the `pickle` module to serialize and save an agenda (list of contacts).

11. **011-archivo-y-metodo-close.py**:
    - Demonstrates file handling with `open()` and `close()` methods.

12. **012-lista.py**:
    - A complex nested list structure representing a physical storage layout.

13. **014-pickle para guardar.py**:
    - Continues the agenda example, saving to a binary file using `pickle`.

14. **015-conversiones de datos conocidas.py**:
    - Converts string data to integer type.

15. **016-conversiones no posibles.py**:
    - Shows an error when attempting to convert non-numeric strings to integers.

16. **017-tipo.py**:
    - Demonstrates checking the type of variables (`list` vs `tuple`).

17. **018-cambio de tipo de dato.py**:
    - Converts between list and tuple types dynamically.
    
18. **019-parto.py**:
    - Combines agenda creation, printing, and saving to a file using pickle.

19. **020-menu.py**:
    - Implements a simple menu-driven application for managing an agenda (add, view, save).

Here’s how you might integrate these snippets into a cohesive program:

### Example Agenda Application

```python
import pickle

def guardar_agenda(agenda):
    archivo = open("agenda.bin", 'wb')
    pickle.dump(agenda, archivo)
    archivo.close()

def leer_registros():
    try:
        with open("agenda.bin", "rb") as archivo:
            return pickle.load(archivo)
    except FileNotFoundError:
        return []

def agregar_registro(agenda):
    nombre = input("Dime tu nombre: ")
    apellidos = input("Dime tus apellidos: ")
    email = input("Dime tu email: ")
    telefono = input("Dime tu teléfono: ")
    agenda.append([nombre, apellidos, email, telefono])
    return agenda

def mostrar_menu():
    print("Selecciona una opción:")
    print("1.- Insertar un registro")
    print("2.- Leer registros")
    print("3.- Guardar registros")
    print("4.- Salir")

def main():
    agenda = leer_registros()
    
    while True:
        mostrar_menu()
        opcion = input("Opción escogida: ")
        
        if opcion == '1':
            agenda = agregar_registro(agenda)
        elif opcion == '2':
            for registro in agenda:
                print(f"Nombre: {registro[0]}, Apellidos: {registro[1]}, Email: {registro[2]}, Teléfono: {registro[3]}")
        elif opcion == '3':
            guardar_agenda(agenda)
        elif opcion == '4':
            break
        else:
            print("Opción no válida. Por favor, selecciona una opción del menú.")

if __name__ == "__main__":
    main()
```

This code integrates the agenda management system with a user menu and file persistence using `pickle`. The program allows users to add new contacts, view existing ones, save changes, and exit gracefully.


<a id="genericidad"></a>
## Genericidad

### Introducción a los ejercicios

Esta carpeta contiene una serie de ejercicios en Python que se enfocan en el concepto de genericidad y manejo de errores. Los problemas trabajan con listas que contienen diferentes tipos de datos (números enteros, cadenas no numéricas) para enseñar cómo procesar estos elementos de manera eficiente y segura. Se practica la conversión de tipo de datos, el uso de funciones genéricas para operaciones matemáticas sobre los números, y manejo de excepciones para lidiar con errores durante la ejecución del programa. Los ejercicios progresan desde una simple impresión de listas hasta situaciones más complicadas que requieren búsqueda en tablas adicionales o reporte de errores no manejados previamente.

### genericidad en python

#### Explicación

Este código crea una lista llamada `numeros` que contiene cuatro elementos: dos números enteros (`1` y `2`) y dos datos que representan un número, pero en forma de cadena (string) y otro entero (`"3"` y `4`). La inclusión tanto de enteros como de una cadena con un número puede causar problemas si se intenta realizar operaciones matemáticas con todos los elementos de la lista sin tener en cuenta sus tipos. Al imprimir la lista completa utilizando `print(numeros)`, el programa muestra la representación textual de la lista tal y como ha sido definida, incluyendo tanto números enteros como la cadena que parece ser un número. Es importante entender este código porque ayuda a reconocer cómo las diferentes tipos de datos pueden coexistir en una misma estructura de datos, pero también subraya la importancia de verificar los tipos de datos antes de operar con ellos para evitar errores o comportamientos inesperados.

```python
numeros = [
  1,
  2,
  "3",
  4
]

print(numeros)
```

### funcion doble

#### Explicación

Este código es un ejemplo sencillo de cómo iterar sobre una lista en Python y realizar operaciones con sus elementos. La lista `numeros` contiene cuatro elementos: tres números enteros (1, 2, 4) y una cadena que representa el número "3". El objetivo del programa es imprimir cada elemento de la lista multiplicado por dos.

La función `calculaDoble()` recorre la lista `numeros` utilizando un bucle for. Dentro del bucle, se intenta multiplicar cada elemento por 2 y luego imprimirlo. Sin embargo, hay un problema importante: el tercer elemento de la lista es una cadena (la palabra "3"), no un número. Al tratar de multiplicar esta cadena por 2, el programa generará un error porque Python no puede realizar operaciones matemáticas con cadenas.

Este código subraya la importancia de asegurarse de que todos los elementos en una lista sean del mismo tipo cuando planeas realizar operaciones como la multiplicación. En este caso específico, para evitar errores, sería necesario convertir el elemento "3" a un número entero antes de intentar hacer cualquier cálculo con él.

```python
numeros = [
  1,
  2,
  "3",
  4
]

print(numeros)

def calculaDoble():
  for numero in numeros:
    print(numero*2)

calculaDoble()
```

### arreglo de genericidad

#### Explicación

Este código Python muestra una forma básica de trabajar con listas que contienen diferentes tipos de datos y cómo manipularlos. La lista `numeros` contiene cuatro elementos, pero el tercer elemento es una cadena ("3") en lugar de un número entero. Luego se llama a la función `calculaDoble()`, que itera sobre cada elemento de la lista `numeros`. Dentro del bucle, intenta convertir cada valor en un entero y luego imprime el doble de ese valor.

Es importante destacar que cuando se convierte "3" a un entero dentro del bucle, solo afecta al valor local de la variable `numero` durante esa iteración. Los demás elementos de la lista original no cambian; por lo tanto, si intentas acceder directamente a los valores en `numeros` después de ejecutar esta función, verás que el tercer elemento sigue siendo una cadena.

Este código tiene un problema importante: se espera que todos los elementos sean números para poder calcular su doble, pero la lista contiene un valor no numérico. Esto puede provocar errores si intentas convertir otros tipos de datos a enteros, además de ser ineficiente al tener que comprobar y corregir el tipo de dato en cada iteración del bucle.

```python
numeros = [1,2,"3",4]

print(numeros)

def calculaDoble():
  for numero in numeros:
    numero = int(numero)   # Convierto en entero
    print(numero*2)

calculaDoble()
```

### meto un poco de presion

#### Explicación

Este código es una pequeña función que muestra cómo trabajar con listas y tipos de datos diferentes en Python. Primero, se crea una lista llamada `numeros` que contiene tanto números enteros como un número escrito en palabras ("cinco"). Luego, la función `calculaDoble()` recorre cada elemento de esta lista. Para cada elemento, intenta convertirlo a un entero y, si es posible, imprime el doble del número (es decir, multiplica por dos). Sin embargo, hay un problema: al tratar de convertir "cinco" en un entero usando `int("cinco")`, obtendrás un error porque no se puede convertir una cadena como texto ("cinco") a un número entero directamente. Este código ilustra la importancia de verificar y manejar correctamente los tipos de datos al realizar operaciones matemáticas en Python, para evitar errores inesperados.

```python
numeros = [1,2,"3",4,"cinco"]

print(numeros)

def calculaDoble():
  for numero in numeros:
    numero = int(numero)   # Convierto en entero
    print(numero*2)

calculaDoble()
```

### try except

#### Explicación

Este código es un ejemplo de cómo manejar errores comunes en Python utilizando la estructura `try-except`. En este caso, el objetivo del programa es tomar una lista que contiene diferentes tipos de datos (números y texto) y tratar de duplicar cada número. Sin embargo, cuando encuentra un valor no numérico, como "cinco", intenta convertirlo a un entero usando `int()`, lo cual genera un error porque solo funciona con números.

El programa imprime primero la lista original para que se pueda ver claramente qué valores contiene. Luego, define una función llamada `calculaDoble()` que recorre cada elemento de la lista `numeros`. Dentro del bucle, el código intenta convertir cada valor en un número entero y luego imprimir su doble (es decir, multiplicarlo por 2). Si el proceso de conversión a entero falla debido a un valor no numérico como "cinco", el bloque `except` se activa y simplemente imprime "(no válido)".

Este tipo de manejo de excepciones es muy importante porque permite que tu programa siga funcionando incluso cuando encuentra errores inesperados, proporcionando retroalimentación útil al usuario en lugar de detenerse abruptamente.

```python
numeros = [1,2,"3",4,"cinco"]

print(numeros)

def calculaDoble():
  for numero in numeros:
    try:
      numero = int(numero)   # Convierto en entero
      print(numero*2)
    except:
      print("(no válido)")

calculaDoble()
```

### estructura de datos

#### Explicación

Este código es una pequeña aplicación que demuestra cómo manejar diferentes tipos de datos en Python, principalmente números y cadenas. El objetivo principal del programa es tomar cada elemento en la lista `numeros`, que contiene tanto números enteros como cadenas de texto que representan números o palabras, y tratar de calcular el doble (el número multiplicado por dos) para cada uno.

Lo primero que hace el código es imprimir la lista original de `numeros` para visualizar los elementos que contiene. Luego define una función llamada `calculaDoble()`. Dentro de esta función, se recorre cada elemento en la lista `numeros`. Para cada elemento, el programa intenta convertirlo a un número entero usando la función `int()` dentro del bloque `try`. Si el elemento es un número como "3" o "cinco", esto funciona bien y luego imprime el doble de ese número. Sin embargo, si el elemento no puede ser convertido en un número (como cuando es una palabra), se produce una excepción que captura el bloque `except`.

En este bloque de error, el código busca la posición del valor en la lista `numeros_etiquetas` y luego imprime el doble de esa posición. Esto demuestra cómo manejar datos no esperados o mixtos (números y cadenas) en una estructura de datos como una lista.

Este tipo de manejo de excepciones es importante porque permite que tu programa siga funcionando incluso cuando se encuentran situaciones inesperadas, evitando interrupciones completas del flujo de trabajo.

```python
numeros = [1,2,"3",4,"cinco"]

print(numeros)
numeros_etiquetas = ["cero","uno","dos","tres","cuatro","cinco"]
def calculaDoble():
  for numero in numeros:
    try:                    # Primero intenta convertir
      numero = int(numero)
      print(numero * 2)
    except:                 # Si no puedes
      # Intenta busca el valor en la lista de numeros
      for i in range(0,len(numeros_etiquetas)):
        if numero == numeros_etiquetas[i]:
          print(i*2)
        
calculaDoble()
```

### la volvemos a fastidiar

#### Explicación

Este código es un ejemplo de cómo manejar diferentes tipos de datos en una misma lista y realizar operaciones con ellos. La variable `numeros` contiene una mezcla de números enteros, cadenas que representan números (como "3" y "cinco"), y una cadena no numérica ("patata"). El objetivo del código es imprimir el doble de cada número en la lista.

La función `calculaDoble()` itera sobre cada elemento en la lista `numeros`. Para cada elemento, intenta convertirlo a un número entero usando `int()`. Si se puede hacer esta conversión (es decir, si el elemento es "3" o "4"), simplemente imprime su doble.

Si la conversión falla, lo que significa que el elemento no es numérico y por tanto no se puede convertir a un entero, el código busca en otra lista llamada `numeros_etiquetas` para ver si hay alguna correspondencia con los elementos de la primera lista. Si encuentra una coincidencia (por ejemplo, "cinco"), imprime el doble del índice donde se encuentra esta coincidencia.

Este tipo de manejo de excepciones y búsqueda en listas es útil cuando tienes datos que no son uniformes y necesitas aplicar operaciones específicas dependiendo del tipo de dato. Es importante para aprender a gestionar errores (o excepciones) en el código y hacer que este sea más robusto y capaz de lidiar con diferentes situaciones.

```python
numeros = [1,2,"3",4,"cinco","patata"]

print(numeros)
numeros_etiquetas = ["cero","uno","dos","tres","cuatro","cinco"]
def calculaDoble():
  for numero in numeros:
    try:                    # Primero intenta convertir
      numero = int(numero)
      print(numero * 2)
    except:                 # Si no puedes
      # Intenta busca el valor en la lista de numeros
      for i in range(0,len(numeros_etiquetas)):
        if numero == numeros_etiquetas[i]:
          print(i*2)
        
calculaDoble()
```

### atrapamos el caso patata

#### Explicación

Este código Python es una aplicación práctica de la gestión y manipulación de datos en diferentes formatos. La lista `numeros` contiene un conjunto mixto de números enteros y cadenas que representan tanto números como texto innecesario ("patata"). El objetivo del programa es procesar cada elemento de esta lista, intentando convertirlo a un número entero para luego duplicarlo.

Si el elemento no puede ser convertido (por ejemplo, porque es una cadena que representa texto no numérico), el programa busca esa cadena en otra lista `numeros_etiquetas`, la cual contiene nombres y etiquetas de números. Si encuentra una coincidencia, imprime el doble del índice correspondiente en lugar del número duplicado. Si ni siquiera puede encontrar una coincidencia en esta segunda lista, simplemente informa que no pudo realizar la operación.

Este código es importante porque demuestra cómo manejar errores y datos inesperados de manera eficiente. Aprender a utilizar excepciones (`try`/`except`) y ciclos anidados ayuda a los estudiantes a escribir programas más robustos y capaces de lidiar con una amplia variedad de entradas, sin caer en errores o detenerse abruptamente cuando se encuentran con datos no esperados.

```python
numeros = [1,2,"3",4,"cinco","patata"]

print(numeros)
numeros_etiquetas = ["cero","uno","dos","tres","cuatro","cinco"]
def calculaDoble():
  for numero in numeros:
    try:                    # Primero intenta convertir
      numero = int(numero)
      print(numero * 2)
    except:                 # Si no puedes
      centinela = False
      # Intenta busca el valor en la lista de numeros
      for i in range(0,len(numeros_etiquetas)):
        if numero == numeros_etiquetas[i]:
          print(i*2)
          centinela = True
      if centinela == False:
        print("Mira tio lo he intentado pero no he podido")
        
calculaDoble()
```

### Actividades propuestas

### Actividad 1: Conversión de Tipos y Generación de Salida

**Descripción:** Los estudiantes deben crear una función que reciba una lista mixta (números enteros, cadenas numéricas) y genere la salida del doble de cada número. Se espera que los estudiantes comprendan cómo manejar diferentes tipos de datos dentro de listas en Python.

### Actividad 2: Manejo de Excepciones Simples

**Descripción:** Los alumnos deben escribir una función que itere sobre una lista mixta (numérica y no numérica) y use un bloque `try-except` para manejar errores cuando intentan convertir cadenas no numéricas a enteros.

### Actividad 3: Generación de Listas Etiquetadas

**Descripción:** Se requiere que los estudiantes creen una lista de etiquetas (strings representando números) y usen esta lista para manipular el índice correspondiente del string en lugar de convertir directamente al número entero.

### Actividad 4: Manejo de Excepciones Mejorado

**Descripción:** Los alumnos deben mejorar la función `calculaDoble` para que, en caso de no poder convertir un elemento a entero ni encontrarlo en una lista etiquetada, imprima un mensaje personalizado indicando el error.

### Actividad 5: Generación de Listas Dinámicas

**Descripción:** Los estudiantes deben generar dinámicamente listas mixtas (numéricas y no numéricas) con valores ingresados por consola y luego aplicar las funciones aprendidas para procesarlas correctamente.

### Actividad 6: Comparación Entre Bucles For e If Else

**Descripción:** Se pide que los alumnos modifiquen la función `calculaDoble` para utilizar una estructura condicional (`if-else`) en lugar de un bucle `for`, comparando rendimiento y claridad del código.

### Actividad 7: Funciones Lambda y Listas Comprensivas

**Descripción:** Los estudiantes deben aplicar funciones lambda dentro de listas comprensivas para procesar las listas mixtas que manejan la conversión a enteros y generación del doble.

### Actividad 8: Integración de Módulos Externos

**Descripción:** Aunque se ha limitado el uso exclusivamente a Python estándar, los estudiantes pueden explorar cómo integrar módulos externos como `logging` para mejorar la trazabilidad y registro de errores en sus funciones.


<a id="cadenas-de-caracteres-expresiones-regulares"></a>
## Cadenas de caracteres. Expresiones regulares

### Introducción a los ejercicios

En esta carpeta, encontrarás una serie de ejercicios destinados a mejorar tus habilidades con las cadenas de caracteres y expresiones regulares en Python. Los problemas abarcan desde la manipulación básica de strings, como acceder a sus elementos individuales o recorrerlas caracter por caracter, hasta tareas más avanzadas que incluyen el uso de métodos para dividir y unir cadenas, así como limpiar datos. También se trabajará en la lectura y procesamiento de archivos CSV, convirtiendo los datos en estructuras más manejables.

Además, varios ejercicios están dedicados a introducirte en el mundo de las expresiones regulares, enseñándote cómo validar formatos específicos como correos electrónicos o direcciones postales utilizando patrones complejos. Estas actividades te permitirán desarrollar una comprensión sólida tanto del manejo de texto en Python como de la capacidad de resolver problemas que requieren el uso de expresiones regulares para verificar la validez y limpieza de datos de entrada.

Estos ejercicios no solo mejorarán tus habilidades técnicas, sino que también te prepararán para situaciones reales donde es necesario trabajar con grandes cantidades de texto y asegurar su formato correcto.

### las strings realmente son colecciones

#### Explicación

Este fragmento de código es sencillo pero fundamental para entender cómo trabajar con texto en Python. Primero, se declara una variable llamada `nombre` que contiene el string "Jose Vicente". Un string es simplemente una secuencia de caracteres encerrados entre comillas, y aquí estamos guardando este string en la variable `nombre`.

Luego, el código imprime el contenido de la variable `nombre`, mostrando por pantalla "Jose Vicente".

Finalmente, el código muestra cómo acceder a un carácter específico dentro del string. Al imprimir `nombre[0]`, se obtiene y muestra solo el primer carácter del string que es 'J'. En Python, los strings son tratados como colecciones de caracteres, donde cada caracter tiene una posición indexada que comienza desde 0.

Este código es importante porque demuestra cómo almacenar texto en variables y cómo acceder a partes específicas de ese texto. Es fundamental para manipular cadenas de caracteres en la programación, ya que permite realizar operaciones más complejas como buscar, reemplazar o dividir textos en base a sus posiciones individuales.

```python
nombre = "Jose Vicente"
print(nombre)

print(nombre[0])
```

### recorrer una cadena

#### Explicación

Este fragmento de código es una forma sencilla de recorrer cada caracter de una cadena en Python. En este caso, la variable `nombre` almacena el texto "Jose Vicente". El bucle `for` itera sobre cada letra dentro del string que hemos guardado en `nombre`. Durante cada iteración, la variable `letra` toma el valor de un carácter a la vez desde la cadena, comenzando por la primera letra y terminando con la última. La función `print(letra)` muestra en pantalla cada uno de estos caracteres por separado.

Este código es importante porque te enseña cómo trabajar con cadenas de texto caracter por caracter, lo que puede ser útil cuando necesitas procesar o analizar el contenido de una cadena en partes más pequeñas.

```python
nombre = "Jose Vicente"
for letra in nombre:
    print(letra)
```

### longitud de la cadena

#### Explicación

Este código en Python muestra cómo obtener y mostrar la longitud de una cadena de caracteres. En este caso, la variable `nombre` almacena el texto "Jose Vicente". La función `len()` se utiliza para calcular cuántos caracteres tiene esta cadena, incluyendo espacios si los hay. Al imprimir `len(nombre)`, se muestra en pantalla el número 12, que es la cantidad de letras y espacios que contiene el nombre "Jose Vicente".

Es importante entender esto porque nos permite trabajar con texto de manera más efectiva, por ejemplo, para verificar cuántos caracteres tiene un campo de entrada antes de procesarlo o para asegurarnos de que una cadena cumple con ciertas longitudes específicas requeridas en diferentes situaciones.

```python
nombre = "Jose Vicente"
print("La longitud del nombre:")
print(len(nombre))
```

### explotar

#### Explicación

Este fragmento de código está trabajando con cadenas de caracteres en Python. La variable `nombre` almacena una cadena que contiene un nombre completo, como "Jose Vicente". La función `split()` se utiliza para dividir esta cadena en dos partes separadas cada vez que encuentra un espacio (" "). Como resultado, la cadena original se convierte en una lista donde cada elemento es uno de los nombres separados por el espacio. En este caso, `explotado` será una lista con dos elementos: ['Jose', 'Vicente']. Finalmente, `print(explotado)` muestra esta lista en la pantalla.

Esta técnica es útil cuando necesitas manejar partes individuales de un texto largo que está compuesto por varias piezas separadas (como nombres completos o direcciones). Permite a los programadores acceder fácilmente a cada parte del texto para usarla según sea necesario.

```python
nombre = "Jose Vicente"
explotado = nombre.split(" ")
print(explotado)
```

### ejemplo csv

#### Explicación

Este código es sencillo pero muy útil para entender cómo trabajar con cadenas de texto en Python. En primer lugar, tenemos una cadena que contiene varios números separados por comas: "uno,dos,tres,cuatro,cinco,seis". El programa primero imprime esta cadena completa.

Luego, utiliza el método `split(",")` para dividir la cadena original cada vez que encuentra una coma. Esto crea una lista de palabras, donde cada palabra es uno de los números separados en la cadena original. Al final, se imprime la nueva lista resultante.

Esta operación es importante porque nos permite tomar texto largo y complicado (como un archivo CSV, que significa "valores separados por comas") y convertirlo en algo más fácil de manejar y trabajar con él, como una lista. Esto facilita el procesamiento y análisis de datos en formatos textuales estándar.

```python
datos = "uno,dos,tres,cuatro,cinco,seis"

# Primero imprimo la cadena
print(datos)
# Ahora la parto
partido = datos.split(",")
# Ahora imprimo el partido
print(partido)
```

### unir

#### Explicación

Este código muestra cómo trabajar con cadenas de texto en Python utilizando métodos como `split()` y `join()`. Primero, la variable `datos` almacena una cadena que contiene varios números separados por comas. El primer paso es imprimir esta cadena original para ver su contenido inicial.

Luego, se utiliza el método `split(",")`, lo cual divide la cadena en múltiples subcadenas basándose en la coma como delimitador y guarda los resultados en una lista llamada `partido`. Esto significa que cada número de la cadena original ahora es un elemento separado dentro de esta nueva lista.

Finalmente, el código utiliza `join()` para juntar nuevamente todos los elementos de la lista `partido`, pero en lugar de usar una coma como antes, se usan barras verticales (`|`) para separar cada uno. Esto crea una nueva cadena unificada que es impresa al final.

Esta operación es importante porque te permite manipular fácilmente cadenas de texto dividiéndolas y combinándolas según sea necesario, lo cual es útil en muchas situaciones donde necesitas procesar datos en formato CSV (Comma Separated Values) o realizar cambios estructurales en el texto.

```python
datos = "uno,dos,tres,cuatro,cinco,seis"

# Primero imprimo la cadena
print(datos)
# Ahora la parto
partido = datos.split(",")
# Ahora imprimo el partido
print(partido)
# Ahora quiero unirlo todo de nuevo
nueva_cadena = "|".join(partido)
print(nueva_cadena)
```

### leer archivo csv

#### Explicación

Este fragmento de código en Python se utiliza para leer y procesar un archivo CSV (valores separados por comas) llamado "clientes.csv". En primer lugar, el programa abre el archivo en modo lectura. Luego, lee todas las líneas del archivo y las almacena en una lista llamada `lineas`. Finalmente, recorre cada línea del archivo utilizando un bucle `for`, donde cada línea se separa en sus campos individuales usando la coma como delimitador y luego imprime estos campos. Esto es útil cuando necesitas analizar o manipular los datos contenidos en el archivo CSV, permitiéndote trabajar con cada registro de forma independiente para realizar operaciones específicas según sea necesario.

```python
archivo = open("clientes.csv","r")

lineas = archivo.readlines()

for linea in lineas:
	partido = linea.split(",")
	print(partido)
```

### convierto a matriz multidimensional

#### Explicación

Este código es una secuencia que lee un archivo llamado "clientes.csv" y lo convierte en una matriz (también conocida como lista de listas) en Python. Primero, el programa abre el archivo CSV para leer su contenido. Luego, divide cada línea del archivo en partes basándose en la coma (","), que es comúnmente usado como separador entre datos en archivos CSV. Cada una de estas divisiones se añade a una lista llamada `conjunto_datos`. Al finalizar, imprime el conjunto completo de datos estructurados en una matriz multidimensional.

Esta transformación del archivo CSV en una matriz de Python facilita trabajar con los datos dentro de un programa, ya que permite acceder y manipular fácilmente cada dato individual o grupo de datos. Por ejemplo, podrías buscar clientes específicos, calcular totales de compra para diferentes grupos de clientes, o incluso guardar nuevos cambios de vuelta al CSV después de realizar operaciones sobre estos datos.

Es importante tener en cuenta este tipo de procesamiento ya que los archivos CSV son muy comunes cuando se trabaja con bases de datos simples o importación/exportación de datos entre distintos programas y sistemas.

```
archivo = open("clientes.csv","r")

lineas = archivo.readlines()

conjunto_datos = []

for linea in lineas:
	partido = linea.split(",")
	conjunto_datos.append(partido)

print(conjunto_datos)
```

### reemplazar

#### Explicación

Este código Python muestra cómo reemplazar una parte de un texto por otra utilizando la función `replace()`. En primer lugar, se declara una variable llamada `cadena` que contiene el texto "Hoy es martes". Luego, con la función `replace`, se cambia la palabra "martes" dentro del texto por la palabra "miercoles", guardando el resultado en otra variable llamada `reemplazado`. Finalmente, se imprime el nuevo texto utilizando la función `print()`. Esta operación es útil cuando necesitas modificar textos de manera sencilla y directa, permitiéndote cambiar palabras o frases específicas dentro de una cadena de caracteres.

```python
cadena = "Hoy es martes"

reemplazado = cadena.replace("martes","miercoles")

print(reemplazado)
```

### quitar saltos de linea

#### Explicación

Este código está trabajando con cadenas de texto en Python para eliminar un caracter específico. La línea `linea_con_salto = "Esto es una prueba \n"` crea una variable que contiene una cadena de texto, la cual incluye al final un salto de línea representado por `\n`. El objetivo del código es quitar ese salto de línea indeseado para tener una cadena limpia y útil. Para lograr esto, se utiliza el método `replace()` en la línea `limpiado = linea_con_salto.replace("\n","")`, que reemplaza todas las ocurrencias del carácter `\n` (salto de línea) con nada (es decir, lo elimina). Al final, la variable `limpiado` contiene la cadena original sin el salto de línea al final. Este tipo de manipulación es muy común cuando se trabaja con archivos de texto o datos que deben procesarse y limpiarse antes del uso posterior en aplicaciones.

```python
# Esta cadena tiene algo que no quiero (\n)
linea_con_salto = "Esto es una prueba \n"
# Lo que quiero es QUITAR algo
# Quito |n con "nada"
limpiado = linea_con_salto.replace("\n","")
```

### expresiones regulares

#### Explicación

Este fragmento de código está diseñado para validar la estructura de una dirección de correo electrónico utilizando expresiones regulares en Python. La expresión regular `patron` define un patrón que describe cómo debe ser una dirección de correo válida según ciertas reglas específicas. 

El patrón comienza con el símbolo `^`, lo que significa que la validación del correo electrónico empieza desde el inicio de la cadena, y termina con `$`, indicando que toda la cadena debe cumplir con este patrón hasta su final.

Dentro del patrón, `[a-zA-Z0-9_.+-]+` permite cualquier combinación de letras mayúsculas y minúsculas, números, guiones bajos (_), puntos (.), más (+) y guiones (-) antes del caracter `@`. Esto corresponde a la parte local del correo electrónico. Después del `@`, el patrón `[a-zA-Z0-9-]+` asegura que hay una serie de letras o números seguida por un punto, `\.` y luego otra secuencia similar para representar el dominio completo (como `.com`, `.org`).

El código entonces utiliza la función `re.match()` para comprobar si los ejemplos `email_mal` e `email_bien` cumplen con este patrón. En este caso, imprime `None` para la cadena no válida y un objeto de coincidencia para la dirección de correo electrónico correcta, indicando que esta última cumple con las condiciones especificadas por el patrón.

Este tipo de validación es importante en aplicaciones web o software donde se requiere asegurar que los datos ingresados por los usuarios tienen el formato esperado antes de ser procesados.

```python

"""
Explicación del patrón:

^
    Indica el inicio de la cadena. La validación comienza desde el principio.

[a-zA-Z0-9_.+-]+
    Parte local del correo (antes de '@').
    Permite:
        - letras mayúsculas y minúsculas (a-zA-Z)
        - números (0-9)
        - guion bajo (_)
        - punto (.)
        - signo más (+)
        - guion (-)
    El símbolo '+' indica uno o más caracteres válidos.

@
    Caracter obligatorio que separa el usuario del dominio.

[a-zA-Z0-9-]+
    Nombre del dominio principal sin subdominios.
    Permite letras, números y guiones.
    Requiere al menos un carácter.

\.
    Un punto literal que separa el dominio del TLD.
    El backslash escapa el carácter '.' para que no actúe como comodín.

[a-zA-Z0-9-.]+
    Parte final del dominio (TLD o subdominios), por ejemplo:
        .com
        .co.uk
        .org
    Permite letras, números, guiones y puntos.
    El símbolo '+' indica uno o más caracteres.

$
    Indica el final de la cadena. La validación termina aquí.
"""
import re

patron = r'^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$'

email_mal = "algo"
email_bien = "info@jocarsa.com"

print(re.match(patron, email_mal))

print(re.match(patron, email_bien))
```

### regex direccion postal

#### Explicación

Este código es una aplicación práctica que utiliza expresiones regulares en Python para verificar la validez de una dirección postal española. La importancia del patrón radica en que define con precisión cómo debe estructurarse una dirección para ser considerada válida, asegurando que contenga elementos como el nombre de la calle, un número de portal (que puede incluir una letra opcional) y el código postal.

El patrón regular `patron` se compone de varias partes:

1. **Nombre de la calle:** Permite letras mayúsculas y minúsculas, incluyendo acentos y 'ñ', junto con espacios entre palabras.
2. **Número de portal:** Se espera un número seguido opcionalmente por una letra (como 10A).
3. **Código postal:** Debe consistir en cinco dígitos.

La función `re.match(patron, direccion)` se utiliza para verificar si la dirección proporcionada (`direccion_mal` o `direccion_bien`) cumple con el patrón establecido. En caso de que coincida correctamente, retornará un objeto match; en caso contrario, devolverá None. Esto es útil para validar formularios web donde los usuarios deben ingresar direcciones y asegurarse de que se ajusten a una estructura estándar.

El código prueba este patrón con dos cadenas: `direccion_mal` (que falta un número de portal) e `direccion_bien` (que tiene la estructura adecuada). Esto ilustra cómo el patrón regular puede distinguir entre direcciones válidas e inválidas.

```python
import re

patron = r'^[A-Za-zÁÉÍÓÚÜÑáéíóúüñ\s]+ \d+[A-Za-z]? \d{5}$'
"""
Explicación del patrón:

^
    Inicio de la cadena.

[A-Za-zÁÉÍÓÚÜÑáéíóúüñ\s]+
    Nombre de la calle o vía.
    Permite:
        - letras mayúsculas y minúsculas
        - letras acentuadas y 'ñ'
        - espacios
    '+' indica uno o más caracteres.

␣ (espacio)
    Separador obligatorio.

\d+
    Número de portal.
    '\d' representa un dígito.
    '+' indica uno o más dígitos.
    Ejemplo: 5, 23, 104

[A-Za-z]?
    Letra opcional en el número (como 10B o 23A).
    '?' indica que puede aparecer cero o una vez.

␣ (espacio)
    Separador obligatorio.

\d{5}
    Código postal español estándar de 5 dígitos.

$
    Final de la cadena.
"""

direccion_mal = "Calle Mayor"
direccion_bien = "Calle Mayor 10 46001"

print(re.match(patron, direccion_mal))
print(re.match(patron, direccion_bien))
```

### validar telefono

#### Explicación

Parece que no has proporcionado el fragmento de código específico para analizar y explicar. ¿Podrías por favor compartir el bloque de código que deseas que explique? Una vez que lo hagas, con gusto te ayudaré a entenderlo paso a paso.

```python

```

### ollama

#### Explicación

Este fragmento de código es una guía para instalar y verificar el software llamado "ollama" en un sistema operativo basado en Linux. Primero, se indica cómo usar el gestor de paquetes `apt` para descargar e instalar la herramienta `curl`, que es necesaria si no está presente en tu sistema. Luego, mediante `curl`, descargas y ejecutas directamente desde una URL un script de instalación proporcionado por ollama.com.

Después de la instalación, el código muestra cómo verificar que la versión correcta de ollama se ha instalado correctamente usando el comando `ollama --version`. También ofrece una alternativa para instalar ollama utilizando `snap`, otro sistema de gestión de aplicaciones en Linux. Finalmente, proporciona instrucciones sobre cómo listar los modelos disponibles en tu instalación con el comando `ollama list`.

Este proceso es importante porque asegura que tienes acceso a la última versión de ollama y te permite conocer fácilmente todos los recursos que se han instalado junto con él.

```markdown
# Descargamos la instalacion de ollama

sudo apt install curl (si no tenéis curl)

curl -fsSL https://ollama.com/install.sh | sh

# Comprobar la versión instalada

ollama --version

Alternativa con snap:
sudo snap install ollama

# Quiero saber los modelos que tengo instalados

ollama list
```

### instalar un modelo

#### Explicación

Este fragmento de código no es realmente una línea de código ejecutable, sino más bien una instrucción que se podría usar en un entorno de línea de comandos o terminal para descargar o instalar un modelo específico llamado "qwen2.5:3b-instruct". En el contexto del archivo al que pertenece este fragmento (que trata sobre la instalación de modelos), esta línea indica cómo se puede obtener un modelo pre-entrenado para usar en aplicaciones relacionadas con inteligencia artificial y lenguaje natural, como responder a preguntas o generar texto. El comando `ollama pull` es utilizado por el software Ollama para descargar e instalar los modelos que son necesarios para su funcionamiento.

Es importante destacar que este tipo de comandos facilitan la incorporación de tecnologías avanzadas en proyectos, permitiendo a los estudiantes y desarrolladores trabajar con modelos complejos sin tener que preocuparse por el entrenamiento desde cero. Esto es especialmente útil en entornos educativos donde se busca acercar tecnologías modernas a estudiantes de diferentes niveles.

```markdown
ollama pull qwen2.5:3b-instruct
```

### ejecutar ollama

#### Explicación

Este fragmento de código es una instrucción escrita en Markdown que se utiliza para ejecutar un comando específico en un entorno de línea de comandos o script. La función de esta línea es invocar a un modelo llamado `qwen2.5:3b-instruct` mediante un servicio llamado `ollama run`. En este contexto, `ollama` parece ser una herramienta que permite ejecutar modelos de inteligencia artificial, y `qwen2.5:3b-instruct` es el nombre del modelo específico que se está invocando. Este comando es importante porque facilita la interacción con modelos avanzados de procesamiento del lenguaje natural para tareas como generar respuestas a preguntas o realizar tareas basadas en texto.

Este tipo de instrucciones son comunes cuando trabajas con herramientas y servicios que requieren ejecutar modelos preentrenados, especialmente en el campo de la inteligencia artificial y el procesamiento del lenguaje natural.

```markdown
ollama run qwen2.5:3b-instruct
```

### lista de modelos de ejemplo

#### Explicación

Este fragmento de código es una lista desordenada en formato Markdown que enumera diferentes modelos y tipos de sistemas de inteligencia artificial (IA) utilizados principalmente para tareas relacionadas con el procesamiento del lenguaje natural. Los modelos están organizados según sus características principales, como la capacidad de procesar imágenes, especialización en código o manejo de audio.

La lista comienza destacando diferentes familias de modelos como LLaMA y Meta, Mistral/Mixtral, Phi/Microsoft y Qwen/Alibaba, entre otros. Cada una de estas familias tiene submodelos específicos, por ejemplo, bajo la familia "LLaMA / Meta" se encuentran los modelos "llama2", "llama3", etc.

Además, el código incluye categorías que agrupan a estos modelos según sus capacidades: modelos con habilidad visual (procesamiento de imágenes), especialización en código, manejo de audio y generación de embeddings. Estas categorías ayudan a los estudiantes y desarrolladores a entender mejor cómo pueden utilizar cada modelo para diferentes aplicaciones prácticas en proyectos de IA.

Es importante destacar que esta lista no solo sirve como un recurso informativo, sino también como una guía práctica para la implementación y elección de modelos adecuados según las necesidades del proyecto.

```markdown
LLaMA / Meta

llama2

llama3

llama3.1

llama3.2

llama3.2-vision

codellama

Mistral / Mixtral

mistral

mistral-small

mistral-large (community ports)

mixtral-8x7b

mixtral-8x22b (community)

open-mistral-nemo (NVIDIA)

Phi / Microsoft

phi

phi2

phi3

phi3-mini

phi3-small

phi3-medium

Qwen / Alibaba

qwen

qwen2

qwen2.5

qwen2.5-coder

qwen2-audio

qwen2-vision

Nous Research

nous-hermes

nous-hermes-2-mistral

neural-chat

Gemma / Google

gemma

gemma2

Tiny / Lightweight models

tinyllama

orca-mini

dolphin-phi

stablelm-zephyr

✅ Vision-capable Models

(models that process images)

llama3.2-vision

qwen2-vision

moondream

bakllava

llava

llava-phi

chocovision (community)

✅ Code-specialized Models

codellama

granite-code

qwen2.5-coder

deepseek-coder

starcoder2

mistral-coder (community)

✅ Audio / Speech Models

whisper (speech-to-text)

qwen2-audio

salmonn (community)

✅ Embedding Models

nomic-embed-text

bge-base

bge-large

instructor-xl

✅ Tool / Function-calling Models

(many LLMs support tools depending on prompt)

No separate engine, but strongest:

llama3.1

llama3.2

qwen2.5

mixtral-8x7b
```

### ejecutar ollama desde python

#### Explicación

Este código es una pequeña aplicación que utiliza la biblioteca `requests` para enviar solicitudes HTTP a un servidor web y recibir una respuesta. En específico, el programa envía una petición POST a una URL local (`http://localhost:11434/api/generate`) con datos de entrada en formato JSON. Los datos enviados incluyen detalles sobre qué modelo de inteligencia artificial usar (en este caso, "qwen2.5:3b-instruct") y la pregunta que se desea responder ("Explica qué es una lista en Python con un ejemplo. Responde en español."). La respuesta del servidor llega en formato JSON, que el programa procesa para extraer y mostrar únicamente la parte de la respuesta que interesa. Este tipo de código es útil cuando necesitas utilizar servicios web o APIs (interfaces de programación de aplicaciones) para obtener información o realizar tareas específicas desde un script Python.

```python
import requests
import json

url = "http://localhost:11434/api/generate"

payload = {
    "model": "qwen2.5:3b-instruct",
    "prompt": "Explica qué es una lista en Python con un ejemplo. Responde en español.",
    "stream": False
}

response = requests.post(url, json=payload)

data = response.json()
print(data["response"])
```

### clientes

#### Explicación

Este fragmento de código es en realidad un archivo CSV (Coma Separated Values) que almacena información sobre clientes. En este caso, cada línea representa los datos detallados de un cliente y está separada por comas. Las primeras líneas indican el nombre de las columnas: "id", "nombre", "apellidos", "correo", "telefono", "direccion", "ciudad", "provincia", "codigo_postal", "empresa" y "NIF". A partir de la segunda línea, se presentan datos específicos para cada cliente. Por ejemplo, el primer cliente tiene un ID de 1, su nombre es Laura García López, su correo electrónico es `laura.garcia@example.com`, etc.

Esta estructura de archivo CSV es muy común en la programación y las bases de datos porque permite almacenar información tabular de manera simple y legible. Es importante aprender a trabajar con archivos CSV ya que son utilizados ampliamente para intercambiar datos entre diferentes aplicaciones o sistemas.

```
id,nombre,apellidos,correo,telefono,direccion,ciudad,provincia,codigo_postal,empresa,NIF
1,Laura,García López,laura.garcia@example.com,612345678,Calle Mayor 12,Valencia,Valencia,46001,TecnoSol S.L.,B12345678
2,Miguel,Pérez Sánchez,miguel.perez@example.com,678901234,Avenida del Puerto 45,Madrid,Madrid,28002,InnovaWeb S.A.,A87654321
3,Ana,Martínez Ruiz,ana.martinez@example.com,634567890,Plaza España 3,Sevilla,Sevilla,41005,Servicon S.L.,B11223344
4,Carlos,Hernández Torres,carlos.hernandez@example.com,699112233,Calle Gran Vía 78,Barcelona,Barcelona,08010,SoftMarket S.L.,B99887766
5,Elena,Romero Díaz,elena.romero@example.com,622334455,Calle San Vicente 5,Zaragoza,Zaragoza,50004,ConsultingPro S.L.,B44556677
6,Javier,Navarro Gómez,javier.navarro@example.com,645667788,Avenida Constitución 23,Murcia,Murcia,30008,DataPlus S.A.,A33445566
7,María,Fuentes Ortega,maria.fuentes@example.com,633889900,Calle Sol 18,Málaga,Málaga,29007,Mercaplus S.L.,B22114455
8,Sergio,Rey Delgado,sergio.rey@example.com,671223344,Calle Libertad 9,Alicante,Alicante,03003,Logística Express S.L.,B77889900
9,Isabel,Vidal Castro,isabel.vidal@example.com,699554433,Paseo Colón 14,Bilbao,Bizkaia,48009,EcoEner S.A.,A99001122
10,Pablo,Santos Molina,pablo.santos@example.com,611223344,Calle Real 2,Valladolid,Valladolid,47003,Formática S.L.,B66778899
```

### Actividades propuestas

### Actividades Propuestas:

#### **Actividad 1: Acceso y Manipulación de Cadenas**
**Descripción:** Los estudiantes deberán acceder a una cadena dada para extraer su primer carácter, último carácter e imprimir la longitud total. Se pretende que aprendan sobre indexado en cadenas y uso de funciones como `len()`.

#### **Actividad 2: Recorrido y Visualización de Cadenas**
**Descripción:** Los estudiantes deben recorrer una cadena usando bucles para imprimir cada caracter individualmente, lo que les permitirá entender la estructura secuencial de las cadenas en Python.

#### **Actividad 3: Split y Join de Cadenas CSV**
**Descripción:** Se propone a los alumnos separar un texto CSV (como "uno,dos,tres") en sus componentes individuales usando `split()`, e invertir el proceso con `join()` para formar nuevamente la cadena, enseñándoles cómo manejar datos estructurados.

#### **Actividad 4: Lectura y Procesamiento de Archivos CSV**
**Descripción:** Los estudiantes leerán un archivo CSV proporcionado (clientes.csv) utilizando funciones como `readlines()`, separar cada línea en sus componentes con `split()` y guardar los resultados en una lista o matriz multidimensional.

#### **Actividad 5: Reemplazo de Texto en Cadenas**
**Descripción:** Se les pedirá a los alumnos que realicen un reemplazo de texto dentro de cadenas utilizando la función `replace()`, lo cual permite familiarizarse con el manejo de caracteres y subcadenas.

#### **Actividad 6: Limpieza de Texto**
**Descripción:** Los estudiantes deben eliminar caracteres especiales o inútiles (como salto de línea `\n`) dentro de una cadena, utilizando `replace()`, para aprender a manipular texto antes de su uso en otros contextos.

#### **Actividad 7: Introducción a Expresiones Regulares**
**Descripción:** Los estudiantes trabajarán con expresiones regulares básicas para validar formatos como direcciones de correo electrónico y direcciones postales, lo que ayuda a entender la sintaxis y utilidades de `re.match()`.

#### **Actividad 8: Validación Compleja con Expresiones Regulares**
**Descripción:** Los alumnos validarán cadenas más complejas utilizando expresiones regulares para comprobar formatos específicos (como direcciones postales), profundizando en las capacidades de validación y filtrado de texto.

#### **Actividad 9: Integración de Datos CSV con Procesamiento**
**Descripción:** Se les solicitará a los estudiantes que integren la lectura del archivo CSV, el procesamiento de cada línea separada por `split()`, y su almacenamiento en una estructura adecuada (matriz o lista) para preparar datos para uso posterior.


<a id="colecciones-listas-conjuntos-y-diccionarios"></a>
## Colecciones Listas, Conjuntos y Diccionarios

### Introducción a los ejercicios

Esta carpeta contiene una serie de ejercicios diseñados para ayudarte a entender y practicar el uso de estructuras de datos como listas, tuplas, diccionarios en Python. Los ejemplos van desde la creación básica de estas estructuras hasta su combinación compleja, pasando por la manipulación de archivos JSON y la lectura de argumentos desde la línea de comandos. A través de estos ejercicios, aprenderás a organizar datos de manera eficiente, acceder a ellos de formas diversas y utilizar bibliotecas adicionales como argparse para manejar entradas más complejas en tus programas.

### diccionarios

#### Explicación

Este código sirve para mostrar la diferencia entre listas y tuplas en Python, que son dos tipos diferentes de estructuras de datos utilizadas para almacenar colecciones de elementos. En primer lugar, se crea una lista llamada `lista` con tres frutas: "platano", "manzana" y "fresa". Luego, accedemos a los elementos de esta lista mediante su índice, es decir, posicionándonos en la primera fruta (índice 0) y en la segunda fruta (índice 1).

A continuación, se crea una tupla llamada `tupla` con los mismos elementos que la lista. La diferencia principal entre listas y tuplas es que las tuplas son inmutables, lo que significa que no puedes cambiar sus valores después de crearlas, mientras que en las listas sí es posible añadir o modificar elementos.

Este fragmento es importante porque ayuda a entender cómo trabajar con diferentes tipos de estructuras de datos, cada una con sus propias características y usos específicos. En situaciones donde necesites almacenar datos que no van a cambiar durante la ejecución del programa, usarás tuplas; si, por otro lado, los datos pueden variar, utilizarás listas.

```python
# Repaso de listas y tuplas
lista = ["platano","manzana","fresa"]

lista[0] # platano
lista[1] # manzana

tupla = ("platano","manzana","fresa")

tupla[0] # platano
tupla[1] # manzana 
```

### diccionarios ahora si

#### Explicación

Este fragmento de código muestra cómo se puede representar la misma información, en este caso los datos personales de una persona, usando dos estructuras de datos diferentes: listas y diccionarios. Al principio, los datos están almacenados como una lista simple, donde cada elemento representa un detalle específico del individuo: el nombre es el primer elemento, los apellidos son el segundo, etc.

Sin embargo, para hacer más legible y fácil de entender este conjunto de datos, se utiliza luego un diccionario. En el diccionario, cada dato está asociado con una clave que identifica claramente qué información representa (por ejemplo, "nombre", "apellidos", "correo" y "edad"). Esto facilita mucho la consulta y modificación de los datos, ya que en lugar de recordar las posiciones de elementos específicos dentro de una lista, simplemente buscas por el nombre del dato que necesitas.

Esta transformación es importante porque hace que el código sea más fácil de leer y mantener, especialmente cuando se trabaja con grandes conjuntos de información o múltiples datos relacionados.

```python
# Esto sigue siendo una lista
persona = [
  "Jose Vicente",
  "Carratalá Sanchis",
  "info@jocarsa.com",
  47
]

# Ahora en formato diccionario

persona = {
	"nombre":"Jose Vicente",
  "apellidos":"Carratalá Sanchis",
  "correo":"info@jocarsa.com",
  "edad":47
}
```

### lista en diccionario

#### Explicación

Este código está creando un diccionario en Python que almacena información sobre una persona. Un diccionario es como un contenedor especial donde puedes guardar datos y acceder a ellos usando claves únicas, algo parecido a cómo buscas palabras en un libro de diccionario por su significado. En este caso, las claves son cadenas de texto que describen diferentes aspectos de la persona: "nombre", "apellidos", "correo", "edad" y "telefonos". Cada clave tiene asociada una valor específico, como el nombre "Jose Vicente", los apellidos "Carratalá Sanchis", etc. Es importante notar que para "telefonos", se utiliza otra estructura de datos llamada lista, lo cual permite almacenar múltiples números telefónicos bajo la misma clave en lugar de tener una entrada separada para cada uno.

Este tipo de estructura es útil porque facilita el manejo y acceso a información compleja o jerárquica de manera simple y clara. Por ejemplo, puedes consultar rápidamente cuál es el correo electrónico de Jose Vicente sin necesidad de recorrer un montón de datos innecesarios.

```python
persona = {
	"nombre":"Jose Vicente",
  "apellidos":"Carratalá Sanchis",
  "correo":"info@jocarsa.com",
  "edad":47,
  "telefonos":[
  	96345678,
    87654321
  ]
}
```

### lista de diccionarios en diccionario

#### Explicación

Este fragmento de código crea un diccionario en Python llamado `persona` que almacena diferentes detalles sobre una persona, como su nombre, apellidos y correo electrónico. Lo interesante aquí es que también incluye una lista dentro del diccionario para almacenar varios teléfonos de la persona. En esta lista se encuentran dos más pequeños diccionarios, cada uno con sus propias claves (`tipo` y `número`) que representan el tipo de teléfono (fijo o móvil) y el número correspondiente.

El código final imprime todo este contenido en pantalla usando la función `print(persona)`. Esto es útil porque muestra cómo se estructuran los datos anidados, permitiendo almacenar información más compleja y relacionada dentro de un solo diccionario. Es importante para entender cómo manejar datos estructurados que puedan necesitar varios niveles de detalles.

Este tipo de estructura es muy práctica en programación ya que permite representar claramente relaciones entre diferentes tipos de datos, como la relación entre una persona y sus teléfonos.

```python
persona = {
	"nombre":"Jose Vicente",
  "apellidos":"Carratalá Sanchis",
  "correo":"info@jocarsa.com",
  "edad":47,
  "telefonos":[
  	{	
      "tipo":"fijo",
    	"número":96123455
    },
    {	
      "tipo":"movil",
    	"número":65456546
    }
  ]
}

print(persona)
```

### no argumentos archivo

#### Explicación

Este fragmento de código solicita al usuario que introduzca su edad mediante el teclado y luego realiza algunas operaciones con ese dato. Primero, el programa utiliza la función `input()` para leer lo que el usuario escribe cuando se le pregunta "Dime tu edad: ". Lo que se ingresa se guarda como una cadena de texto (o string) en la variable `edad`. Luego, esta cadena se convierte en un número entero usando la función `int()`, y este número entero se almacena en la variable `entero`.

Finalmente, el programa multiplica ese número por 2 y guarda el resultado en una nueva variable llamada `doble`. Al final, muestra el doble de la edad introducida por el usuario utilizando la función `print()`. Este tipo de código es importante porque demuestra cómo interactuar con datos proporcionados por los usuarios, convertir tipos de datos (por ejemplo, de texto a número), y realizar operaciones matemáticas básicas en Python.

```python
edad = input("Dime tu edad: ")
entero = int(edad)
doble = entero*2
print(doble)
```

### ahora con argumentos

#### Explicación

Este fragmento de código es muy sencillo pero muy útil para entender cómo manejar parámetros que se pasan directamente desde la línea de comandos en un programa Python. La primera línea `import sys` sirve para incluir el módulo `sys`, que proporciona acceso a algunas variables y funciones relacionadas con el intérprete del sistema.

Luego, cuando se ejecuta este código (`print(sys.argv)`), lo que hace es imprimir la lista llamada `argv`. Esta lista contiene todos los argumentos de línea de comandos pasados al script Python. El primer elemento de esta lista siempre será el nombre del archivo de Python en sí mismo (por ejemplo, si el archivo se llama `ejemplo.py`, entonces `sys.argv[0]` va a ser `"ejemplo.py"`). Los demás elementos son los argumentos que vienen después.

Es importante porque permite que un programa interactúe con el usuario o sistemas externos de una manera más flexible y poderosa, permitiendo configurar la ejecución del script según las necesidades específicas en cada momento.

```python
import sys

print(sys.argv)
```

### doble edad con argumentos

#### Explicación

Este fragmento de código es un programa en Python que toma un número como entrada a través de la línea de comandos y luego calcula el doble de ese número. Aquí está cómo funciona paso a paso: 

1. El programa importa el módulo `sys`, que permite acceder a variables y funciones mantenidas por el intérprete Python, incluyendo una lista llamada `argv` que contiene los argumentos pasados al script desde la línea de comandos.

2. Luego, se toma el segundo argumento proporcionado en la línea de comandos (el primero sería el nombre del script) y lo guarda en la variable `edad`. Asegura que este valor es un número entero usando la función `int()` y guarda el resultado en la variable `entero`.

3. El código multiplica esta edad por 2 y almacena el resultado en una variable llamada `doble`.

4. Finalmente, imprime el doble de la edad en la consola.

Este programa es importante porque demuestra cómo Python puede interactuar con argumentos proporcionados desde fuera del script, lo que permite a los usuarios especificar entradas para scripts de manera flexible y poderosa.

```python
import sys

argumentos = sys.argv
edad = argumentos[1]
entero = int(edad)
doble = entero*2
print(doble)
```

### ejemplo con dos argumentos

#### Explicación

Este fragmento de código en Python se utiliza para recibir y procesar información que el usuario introduce desde la línea de comandos cuando ejecuta el script. La primera parte del código importa un módulo llamado `sys`, que nos permite acceder a variables y funciones específicas del intérprete de Python, entre ellas, `argv`. Esta variable es una lista que contiene todos los argumentos pasados al programa desde la línea de comandos.

Luego, el código toma los primeros dos argumentos (después del nombre del script) y los asigna a las variables `nombre` y `edad`, respectivamente. La edad se convierte en un número entero para permitir cálculos matemáticos con ella. En este caso, el programa duplica la edad obtenida y luego imprime un mensaje amigable que incluye el nombre del usuario y su edad duplicada.

Este tipo de código es útil cuando necesitas interactuar directamente con los usuarios a través de la línea de comandos para recoger información específica antes de ejecutar una función o proceso más complejo en tu programa.

```python
import sys

argumentos = sys.argv
nombre = argumentos[1]
edad = argumentos[2]
entero = int(edad)
doble = entero*2
print("Hola, "+nombre+" tienes "+str(doble)+" años")
```

### argumentos con nombre

#### Explicación

Este código es una pequeña aplicación en Python que utiliza el módulo `argparse` para manejar argumentos de línea de comandos. Lo que hace básicamente es permitirte pasar dos argumentos al ejecutar este script: uno llamado `--nombre` y otro llamado `--apellidos`. Estos argumentos se utilizan para almacenar información del usuario, como su nombre y apellidos.

El código crea un objeto llamado `parser`, que se encarga de interpretar los argumentos proporcionados al ejecutar el script. Luego, el programa utiliza la función `parse_args()` para obtener estos argumentos y guardarlos en una variable `args`. Finalmente, la línea `diccionario = vars(args)` convierte esa información en un diccionario que es más fácil de manipular.

Imprimir este diccionario al final te muestra qué valores obtuvo el programa a partir de los argumentos proporcionados. Esto puede ser muy útil para scripts que requieren configuraciones o entradas personalizables desde la línea de comandos, permitiendo una interacción flexible y potencialmente automatizada con tu aplicación.

```python
import argparse

parser = argparse.ArgumentParser()
parser.add_argument("--nombre")
parser.add_argument("--apellidos")

args = parser.parse_args()

diccionario = vars(args)
print(diccionario)
```

### instalar y usar ffmpeg

#### Explicación

Este fragmento de código en Markdown proporciona instrucciones sobre cómo instalar el programa `ffmpeg` en un sistema operativo basado en Debian, como Ubuntu. La línea `sudo apt install ffmpeg` es un comando que se ejecuta en la terminal para instalar `ffmpeg`, una herramienta muy popular y versátil para manipular archivos de audio y video. Antes de ejecutar este comando, debes tener privilegios de administrador (por eso usamos `sudo`). Una vez instalado, puedes invocar `ffmpeg` directamente desde la terminal como se indica con "LLamarlo: ffmpeg". Esto es importante porque `ffmpeg` te permite realizar una amplia gama de tareas relacionadas con multimedia que son fundamentales en el desarrollo web y aplicaciones multimedia.

```markdown
sudo apt install ffmpeg

LLamarlo: ffmpeg
```

### acceder a diccionario

#### Explicación

Este código crea un diccionario en Python llamado `persona` que almacena información personal sobre una persona, como su nombre, apellidos y correo electrónico. Además del correo, también incluye la edad de la persona y una lista de dos diccionarios que contienen los tipos de teléfono y sus números asociados.

El diccionario `persona` se imprime por pantalla para mostrar todos los datos almacenados en él. Luego, el código accede específicamente al primer número telefónico del fijo de la persona utilizando la sintaxis `persona["telefonos"][0]["número"]`. Esto es importante porque muestra cómo anidar estructuras de datos y acceder a valores específicos dentro de una lista que está contenida en un diccionario.

Este tipo de estructura permite almacenar información compleja de manera organizada, facilitando el acceso a diferentes campos según sea necesario para las aplicaciones.

```python
persona = {
	"nombre":"Jose Vicente",
  "apellidos":"Carratalá Sanchis",
  "correo":"info@jocarsa.com",
  "edad":47,
  "telefonos":[
  	{	
      "tipo":"fijo",
    	"número":96123455
    },
    {	
      "tipo":"movil",
    	"número":65456546
    }
  ]
}

print(persona)
print(persona["telefonos"][0]["número"])
```

### diagrama

#### Explicación

Este código JSON representa la estructura de un diagrama de flujo o proceso, que es una herramienta común en el diseño y análisis de sistemas. En este caso, se está utilizando para describir las relaciones entre diferentes elementos del sistema.

El archivo JSON comienza con una lista llamada "formas", donde cada elemento dentro de esta lista representa un objeto gráfico diferente en el diagrama. Cada forma tiene atributos como un ID único (por ejemplo, "forma-1"), un tipo que indica si es un rectángulo o un círculo, y su posición en la pantalla (izquierda y arriba). Además, cada elemento tiene un texto asociado que describe brevemente el propósito de esa forma en el diagrama.

La segunda parte del JSON se llama "flechas", donde se especifican las conexiones entre estas formas. Cada flecha está definida por dos IDs de formas (uno que indica dónde comienza y otro donde termina) y un tipo, que en este caso es siempre "simple". Estas flechas representan los flujos o relaciones lógicas entre diferentes partes del sistema.

Este tipo de estructura JSON es importante porque permite a las herramientas computacionales leer e interpretar el diagrama automáticamente, facilitando la creación y la modificación de los mismos.

```json
{
  "formas": [
    {
      "id": "forma-1",
      "tipo": "rectangle",
      "left": "389.188px",
      "top": "312px",
      "width": "",
      "height": "",
      "texto": "programa"
    },
    {
      "id": "forma-2",
      "tipo": "circle",
      "left": "356.135px",
      "top": "187px",
      "width": "",
      "height": "",
      "texto": "in"
    },
    {
      "id": "forma-3",
      "tipo": "circle",
      "left": "498.521px",
      "top": "187.333px",
      "width": "",
      "height": "",
      "texto": "out"
    },
    {
      "id": "forma-4",
      "tipo": "rectangle",
      "left": "378.521px",
      "top": "49.3229px",
      "width": "",
      "height": "",
      "texto": "html"
    }
  ],
  "flechas": [
    {
      "idInicio": "forma-2",
      "idFin": "forma-1",
      "tipo": "simple"
    },
    {
      "idInicio": "forma-1",
      "idFin": "forma-3",
      "tipo": "simple"
    },
    {
      "idInicio": "forma-4",
      "idFin": "forma-2",
      "tipo": "simple"
    },
    {
      "idInicio": "forma-3",
      "idFin": "forma-4",
      "tipo": "simple"
    }
  ]
}
```

### Actividades propuestas

### Actividad 1: Introducción a Listas y Diccionarios

**Descripción:** Los estudiantes deben convertir una lista simple en un diccionario, aprendiendo cómo organizar datos de forma más estructurada. Se espera que comprendan la diferencia entre listas y diccionarios.

---

### Actividad 2: Creación de Datos Personales con Diccionarios

**Descripción:** Los estudiantes deben crear un diccionario que almacene información personal (nombre, apellidos, correo electrónico, edad) para varios individuos. Se espera que aprendan a estructurar datos complejos utilizando diccionarios.

---

### Actividad 3: Integración de Listas dentro de Diccionarios

**Descripción:** Los estudiantes deben integrar listas dentro de un diccionario para almacenar información adicional como teléfonos móviles y fijos. Se espera que aprendan a manejar datos jerárquicos.

---

### Actividad 4: Uso de Argumentos con Python

**Descripción:** Los estudiantes deben utilizar argumentos del sistema para procesar la edad del usuario e imprimir su doble, utilizando el módulo `sys`. Se espera que aprendan cómo pasar y recibir información en scripts Python.

---

### Actividad 5: Manipulación Avanzada de Diccionarios

**Descripción:** Los estudiantes deben acceder a datos anidados dentro de diccionarios (como teléfonos) e imprimirlos. Se espera que dominen la manipulación y acceso a estructuras de datos complejas.

---

### Actividad 6: Uso del Módulo argparse para Argumentos

**Descripción:** Los estudiantes deben implementar el uso del módulo `argparse` para recibir argumentos con nombre (como --nombre y --apellidos) y almacenarlos en un diccionario. Se espera que comprendan cómo estructurar interfaces de línea de comandos avanzadas.

---

### Actividad 7: Integración de Listas de Diccionarios

**Descripción:** Los estudiantes deben integrar listas de diccionarios dentro de un diccionario principal para representar datos complejos (como múltiples contactos con teléfonos). Se espera que aprendan a manejar estructuras de datos anidadas.

---

### Actividad 8: Creación de Programa Interactivo

**Descripción:** Los estudiantes deben crear un programa interactivo que solicite al usuario información personal y la guarde en un diccionario. Luego, el programa debe permitir al usuario acceder a esta información. Se espera que aprendan a manejar entradas interactivas del usuario.

---

### Actividad 9: Análisis de Estructuras Complejas

**Descripción:** Los estudiantes deben analizar e implementar un diccionario anidado complejo (como el proporcionado en los ejemplos), y realizar operaciones como imprimir la edad o acceder a datos teléfonicos específicos. Se espera que comprendan cómo trabajar con estructuras de datos multidimensionales.

---

### Actividad 10: Integración Completa de Diccionarios

**Descripción:** Los estudiantes deben integrar todas las habilidades aprendidas en una actividad práctica, creando un programa que permite al usuario almacenar y acceder a información personal compleja utilizando diccionarios y listas. Se espera que demuestren su capacidad para manejar datos estructurados de manera eficiente.

---

Estas actividades están diseñadas para ayudar a los estudiantes a dominar la manipulación de estructuras de datos en Python, desde listas simples hasta diccionarios anidados complejos y argumentos del sistema.


<a id="operaciones-agregadas-filtrado-reduccion-y-recoleccion"></a>
## Operaciones agregadas filtrado, reducción y recolección

### Introducción a los ejercicios

En esta carpeta de ejercicios, trabajaremos con la estructura de datos conocida como conjunto en Python. Los conjuntos son colecciones desordenadas y sin duplicados que nos permiten realizar operaciones eficientes de agregación, filtrado y recolección de elementos. A lo largo de los 14 ejercicios propuestos, empezarás con la creación básica de conjuntos y su comprobación de igualdad hasta llegar a la implementación de un generador de sudokus completos utilizando técnicas como fuerza bruta y backtracking.

Estos ejercicios te ayudarán a practicar la manipulación de datos sin duplicados, el uso de operaciones matemáticas con conjuntos (como intersecciones, uniones), la creación de aplicaciones web simples con Flask para mostrar resultados y técnicas avanzadas como resolución de problemas mediante backtracking.

### conjuntos

#### Explicación

Este fragmento de código Python te muestra cómo crear y trabajar con conjuntos, que son una estructura de datos utilizada para almacenar elementos únicos sin importar el orden. En primer lugar, se crea un conjunto llamado `frutas` que contiene tres elementos: "manzanas", "peras" y "platanos". Luego, se imprime este conjunto utilizando la función `print(frutas)`, lo que mostrará los elementos del conjunto en la consola, aunque el orden puede variar cada vez que ejecutes el programa. Finalmente, se utiliza la función `type()` para imprimir el tipo de dato que es `frutas`, confirmando así que efectivamente es un conjunto (`set` en Python). Esto es importante porque los conjuntos son útiles cuando necesitas asegurarte de que no hay duplicados en tus datos y cuando deseas realizar operaciones matemáticas como la intersección o la diferencia entre dos grupos de elementos.

```python
frutas = {"manzanas","peras","platanos"}
print(frutas)
print(type(frutas))
```

### no repeticiones

#### Explicación

Este fragmento de código te muestra cómo trabajar con conjuntos en Python, que son una estructura de datos muy útil. En el código, se crea un conjunto llamado `frutas` que contiene varios tipos de frutas como manzanas, peras y plátanos. Importante destacar que aunque intentamos añadir "manzanas" dos veces al conjunto, debido a las características del conjunto en Python, no permite duplicados por lo que solo aparecerá una vez.

El código imprime el contenido del conjunto `frutas` y también muestra qué tipo de estructura es (en este caso, un conjunto). Los conjuntos son útiles cuando necesitas almacenar elementos sin importarte el orden ni los duplicados. Este ejemplo ilustra cómo Python automáticamente elimina cualquier elemento repetido en la creación del conjunto.

Es importante entender estos conceptos ya que las características únicas de los conjuntos pueden simplificar mucho tu trabajo, especialmente en tareas que involucran filtrar o eliminar duplicados de una lista de elementos.

```python
# No se aplica el concepto de orden
# No se pueden reordenar
# No admiten duplicados

frutas = {"manzanas","peras","platanos","manzanas"}
print(frutas)
print(type(frutas))
```

### dos conjuntos

#### Explicación

Este código está trabajando con conjuntos en Python, que son estructuras de datos únicas y muy específicas. Los conjuntos almacenan elementos de manera desordenada, lo cual significa que no puedes estar seguro del orden en el que los elementos se mostrarán. Además, un conjunto no permite tener elementos duplicados ni te permite cambiar el orden de sus elementos después de crearlo.

En este caso, se crean dos conjuntos: `frutas1` y `frutas2`, ambos conteniendo las mismas frutas pero en diferentes órdenes. A pesar del cambio en el orden de los elementos, Python reconoce que estos conjuntos son iguales debido a la naturaleza desordenada y sin duplicados de los conjuntos. El programa compara estos dos conjuntos usando un `if` para ver si son iguales o no. Si son iguales (como es este caso), imprime "Son iguales"; en otro caso, imprimiría "Son diferentes".

Este tipo de operaciones es importante porque te permite realizar comparaciones precisas sin tener que preocuparte por el orden exacto de los elementos, lo cual puede ser muy útil cuando trabajas con datos no estructurados o no secuenciales.

```python
# No se aplica el concepto de orden
# No se pueden reordenar
# No admiten duplicados

frutas1 = {"manzanas","peras","platanos"}

frutas2 = {"peras","platanos","manzanas"}

if frutas1 == frutas2:
  print("Son iguales")
else:
  print("Son diferentes")
```

### comprobacion numeros

#### Explicación

Este fragmento de código está verificando si dos conjuntos de números son iguales. Los conjuntos en Python son estructuras de datos que almacenan elementos únicos y no ordenados. En este caso, `patron` contiene los dígitos del 1 al 9, mientras que `prueba` también tiene exactamente los mismos números aunque estén en un orden diferente. El código compara estos dos conjuntos usando el operador de igualdad (`==`). Si ambos conjuntos contienen exactamente los mismos elementos (sin importar el orden), se imprime "Se cumple la condición". De lo contrario, si alguno de los números falta o hay un número extra en `prueba`, el programa imprimirá "no se cumple la condición".

Esta comparación es útil cuando necesitas asegurarte de que un conjunto dado contenga exactamente los mismos elementos que otro conjunto específico. En contextos prácticos, esto puede ser relevante para validar datos o comprobar condiciones en aplicaciones donde la integridad del conjunto de datos es crucial.

```python
patron = {1,2,3,4,5,6,7,8,9}

prueba = {6,4,3,5,7,8,2,1,9}

if prueba == patron:
  print("Se cumple la condicion")
else:
  print("no se cumple la condición")
```

### aleatorio

#### Explicación

Este código Python realiza una serie de operaciones relacionadas con conjuntos y listas para verificar si un conjunto generado aleatoriamente es igual a un patrón especificado. Primero, el programa importa la biblioteca `random` que se utiliza para generar números enteros al azar. Luego, define un conjunto llamado `patron` que contiene los números del 1 al 9.

A continuación, crea una lista vacía y usa un bucle for para llenarla con nueve números aleatorios entre el 1 y el 9. Después de generar la lista, imprime tanto el patrón original como la lista generada aleatoriamente.

El código luego convierte esta lista en un conjunto llamado `conjunto`, eliminando así cualquier duplicidad que pudiera haberse generado al llenar la lista con números aleatorios. Finalmente, compara este nuevo conjunto con el patrón inicial utilizando una declaración if. Si ambos conjuntos son iguales (es decir, contienen los mismos elementos sin importar el orden), imprime "El conjunto es correcto"; en caso contrario, imprime "El conjunto no es correcto".

Esta operación es útil para entender cómo manejar y verificar datos en estructuras de almacenamiento como listas y conjuntos en Python.

```python
import random

patron = {1,2,3,4,5,6,7,8,9}

lista = []
for i in range(1,10):
	lista.append(random.randint(1,9))
print(patron)
print(lista)
conjunto = set(lista)
print(conjunto)

if conjunto == patron:
  print("El conjunto es correcto")
else:
  print("El conjunto no es correcto")
```

### fuerza bruta

#### Explicación

Este fragmento de código está diseñado para demostrar un concepto llamado "fuerza bruta", que en programación significa intentar todas las posibilidades hasta encontrar una solución. Aquí, el objetivo es generar listas aleatorias compuestas por números del 1 al 9 y comprobar si estos números forman exactamente el conjunto {1,2,3,4,5,6,7,8,9}.

El código comienza importando la función `random` para generar números enteros aleatorios. Luego, se define un conjunto llamado `patron`, que contiene los números del 1 al 9. El programa entra en un bucle infinito (`while True:`) donde, en cada iteración, genera una lista de nueve elementos con valores aleatorios entre 1 y 9.

Después, convierte esta lista en un conjunto llamado `conjunto` para eliminar cualquier duplicidad y luego compara este conjunto con el conjunto `patron`. Si ambos conjuntos son iguales (es decir, si la lista generada contiene exactamente los números del 1 al 9 sin repeticiones), se imprime un mensaje indicando que el conjunto es correcto, junto con el contenido de ambas estructuras y el bucle finaliza (`break`).

Este tipo de enfoque es útil cuando necesitas comprobar todas las posibles combinaciones hasta encontrar una solución específica, aunque puede ser menos eficiente para problemas más grandes.

```python
import random

patron = {1,2,3,4,5,6,7,8,9}

while True:
  lista = []
  for i in range(1,10):
    lista.append(random.randint(1,9))
    
  conjunto = set(lista)
  print(lista)
  
  if conjunto == patron:
    print("El conjunto es correcto")
    print(conjunto)
    print(lista)
    break # Fuerzo la finalizazión del bucle infinito
    

  
```

### elimino un numero

#### Explicación

Este fragmento de código en Python tiene como objetivo crear una lista aleatoria que contiene los números del 1 al 9 y luego verificar si esta lista, cuando se convierte en un conjunto (eliminando duplicados), es igual a otro conjunto predefinido. Si la condición se cumple, el programa imprime tanto el conjunto correcto como la lista original. Luego, selecciona aleatoriamente una posición de la lista y reemplaza el número en esa posición con un carácter especial "_", mostrando la lista modificada finalmente.

La parte crucial del código es el bucle `while True`, que asegura que se generará una nueva lista hasta que su conjunto coincida exactamente con el conjunto predefinido. Una vez que esto ocurre, el programa continúa eliminando un número aleatorio de la lista y termina el bucle. Esta técnica es útil para practicar conceptos como conjuntos, listas y cómo manejar datos estructurados en Python.

Esta práctica es importante porque muestra cómo utilizar funciones del módulo `random` para generar datos, cómo trabajar con tipos de datos de colección diferentes (listas y conjuntos), y cómo comparar estos tipos de datos para realizar operaciones condicionales.

```python
import random

patron = {1,2,3,4,5,6,7,8,9}

while True:
  lista = []
  for i in range(1,10):
    lista.append(random.randint(1,9))
  conjunto = set(lista)
  if conjunto == patron:
    print("El conjunto es correcto")
    print(conjunto)
    print(lista)
    # Ahora elimino un numero
    indice = random.randint(1,9)
    lista[indice] = "_"
    print(lista)
    break # Fuerzo la finalizazión del bucle infinito
    

  
```

### elimino X numeros

#### Explicación

Este código es una pequeña aplicación que genera listas de números aleatorios y verifica si contienen todos los dígitos del 1 al 9. Comienza importando el módulo `random` para generar números aleatorios. Luego, define un conjunto llamado `patron` que contiene los números del 1 al 9.

El código entra en un bucle infinito (`while True:`) donde se genera una lista de nueve elementos llenos de números aleatorios entre 1 y 9. Después, esta lista se convierte en un conjunto para comprobar si coincide exactamente con el `patron`. Si la condición se cumple (es decir, la lista contiene todos los dígitos del 1 al 9 sin repetir ninguno), imprime que el conjunto es correcto y muestra tanto el conjunto como la lista original.

Luego, para añadir un poco de complejidad, el código selecciona aleatoriamente cinco elementos de la lista y los reemplaza con un guion bajo (`_`), efectivamente eliminando esos números. Finalmente, imprime la lista modificada e interrumpe el bucle infinito.

Este ejercicio es útil para entender cómo trabajar con conjuntos en Python, verificar si dos conjuntos son iguales, y manipular listas de diversas maneras, incluyendo reemplazar elementos específicos.

```python
import random

patron = {1,2,3,4,5,6,7,8,9}

while True:
  lista = []
  for i in range(1,10):
    lista.append(random.randint(1,9))
  conjunto = set(lista)
  if conjunto == patron:
    print("El conjunto es correcto")
    print(conjunto)
    print(lista)
    for i in range(1,5):
      # Ahora elimino un numero
      indice = random.randint(0,8)
      lista[indice] = "_" # Escoge un indice al azar y reemplaza su valor
    print(lista)
    break # Fuerzo la finalizazión del bucle infinito
    

  
```

### repito 9 veces

#### Explicación

Este código Python está diseñado para verificar si se puede generar una lista de nueve números aleatorios entre 1 y 9 que, cuando se convierten en un conjunto (que elimina duplicados), resultan en el conjunto {1,2,3,4,5,6,7,8,9}. El código utiliza un bucle infinito (`while True`) para generar continuamente listas hasta encontrar una lista cuyos elementos formen exactamente ese conjunto. Una vez que se encuentra la combinación correcta, el programa imprime tanto el conjunto como la lista correspondiente y sale del bucle.

La importancia de este código radica en cómo muestra la generación aleatoria de datos y el uso de estructuras de control como los bucles para realizar verificaciones repetidas hasta alcanzar un objetivo específico. Es una demostración práctica de cómo usar conjuntos en Python, que son útiles cuando necesitas trabajar con colecciones sin duplicados.

```python
import random

patron = {1,2,3,4,5,6,7,8,9}

for celda in range(1,10):
  while True:
    lista = []
    for i in range(1,10):
      lista.append(random.randint(1,9))
    conjunto = set(lista)
    if conjunto == patron:
      print("El conjunto es correcto")
      print(conjunto)
      print(lista)
      break # Fuerzo la finalizazión del bucle infinito
    

  
```

### matriz bidimensional

#### Explicación

Este código está diseñado para generar una matriz bidimensional de 9x9 que simula un tablero de Sudoku, aunque no garantiza que sea un tablero válido según las reglas de Sudoku. La estructura principal es la creación de nueve listas de nueve elementos cada una. Para hacerlo, el programa utiliza un bucle anidado: el exterior itera nueve veces para crear cada fila del tablero, y dentro de este bucle hay otro bucle que llena esta lista con números aleatorios entre 1 y 9.

Lo importante es que en cada iteración interna se genera una lista de nueve números, pero antes de añadirla a la matriz principal (`sudoku`), el código verifica si estos nueve números forman un conjunto que contiene exactamente los números del 1 al 9. Esto significa que no hay duplicados ni faltantes entre los números generados. Si se cumple esta condición, la lista es añadida a `sudoku`. En caso contrario, el bucle interior vuelve a intentarlo hasta conseguirlo.

Este proceso asegura que cada fila de nuestra matriz bidimensional contenga todos y solo los dígitos del 1 al 9 en algún orden aleatorio. Es un paso crucial para crear una estructura inicial válida desde la cual podrías luego aplicar las reglas específicas de Sudoku, como colocar números de forma que no se repitan en columnas ni en submatrices 3x3.

```python
import random

patron = {1,2,3,4,5,6,7,8,9}
sudoku = []
for celda in range(1,10):
  while True:
    lista = []
    for i in range(1,10):
      lista.append(random.randint(1,9))
    conjunto = set(lista)
    if conjunto == patron:
      sudoku.append(lista)
      break # Fuerzo la finalizazión del bucle infinito
    
print(sudoku)
  
```

### flask

#### Explicación

Este fragmento de código está diseñado para generar una página web simple usando Flask, un marco web en Python. La aplicación crea un Sudoku (un juego numérico) generando una matriz cuadrada de 9x9 números aleatorios que cumplen ciertas condiciones.

Primero, el código importa las bibliotecas necesarias: `random` para generar números al azar y `Flask`, junto con `render_template` desde Flask, para manejar la parte web. Se crea una instancia de aplicación Flask llamada `app`.

El corazón del código está en la función `inicio()`. Esta función genera un conjunto de números patrón `{1,2,3,4,5,6,7,8,9}` que representa los valores permitidos en el Sudoku. Luego, utiliza un bucle para llenar una matriz llamada `sudoku` con listas (filas del Sudoku) generadas hasta que cada fila contiene exactamente estos números de 1 a 9 sin repetir ninguno.

El proceso de generar estas filas es iterativo y puede ser lento porque el código genera numeros aleatorios hasta encontrar una lista que coincide con el conjunto patrón. Esto garantiza que cada fila del Sudoku sea válida, aunque no verifica las restricciones globales del Sudoku como la ausencia de duplicados en columnas o regiones.

Finalmente, la función `inicio()` utiliza `render_template` para devolver un archivo HTML llamado "index.html", pasándole los datos generados (la matriz `sudoku`) que luego se pueden usar en el diseño web para mostrar el Sudoku.

```python
import random
from flask import Flask,render_template

app = Flask(__name__)

@app.route("/")
def inicio():
  patron = {1,2,3,4,5,6,7,8,9}
  sudoku = []
  for celda in range(1,10):
    while True:
      lista = []
      for i in range(1,10):
        lista.append(random.randint(1,9))
      conjunto = set(lista)
      if conjunto == patron:
        sudoku.append(lista)
        break # Fuerzo la finalizazión del bucle infinito

  return render_template("index.html",datos=sudoku)

if __name__ == "__main__":
  app.run(debug=True)
  
```

### flask con contador

#### Explicación

Este código es una aplicación simple utilizando Flask para generar una página web que muestra un Sudoku generado aleatoriamente. La aplicación crea un cuadro de 9x9 donde cada fila contiene los números del 1 al 9 sin repetirse, lo cual simula las reglas básicas del Sudoku.

El programa comienza creando una instancia de la clase Flask y define una ruta para el inicio del sitio web (`@app.route("/")`). Dentro de esta función, se inicializa un contador que lleva la cuenta de cuántas veces ha intentado generar cada fila con los números correctos. Se genera una lista llamada `sudoku` donde irán almacenándose las filas generadas.

Para cada fila del Sudoku (que son 9 en total), el código entra en un bucle infinito (`while True`) que genera aleatoriamente nueve números entre 1 y 9 y los guarda en una lista. Luego, verifica si esta lista contiene exactamente los mismos números que el conjunto `patron` sin repetir ninguno (es decir, {1, 2, 3, 4, 5, 6, 7, 8, 9}). Si la verificación es correcta, la fila se añade a la lista `sudoku`, y si no lo es, el programa intentará de nuevo generar una nueva fila. El bucle termina cuando cada fila cumple con esta condición.

Finalmente, después de haber generado todas las filas necesarias para completar un Sudoku, el código imprime cuántos intentos tuvo que hacer para lograrlo y luego renderiza una plantilla HTML llamada "index.html" pasándole la matriz `sudoku` generada como dato.

Este tipo de enfoque es útil para aprender cómo generar contenido dinámico con Flask y entender el uso de estructuras de control como bucles anidados y condicionales para resolver problemas complejos, aunque en un Sudoku real se necesitarían algoritmos más sofisticados para garantizar que las reglas del juego también se cumplan entre filas, columnas y cuadrantes.

```python
import random
from flask import Flask, render_template

app = Flask(__name__)

@app.route("/")
def inicio():
    contador = 0
    patron = {1, 2, 3, 4, 5, 6, 7, 8, 9}
    sudoku = []

    for celda in range(1, 10):
        while True:
            contador += 1
            lista = []
            for i in range(1, 10):
                lista.append(random.randint(1, 9))
            conjunto = set(lista)
            if conjunto == patron:
                sudoku.append(lista)
                break  # Fuerzo la finalización del bucle infinito

    print("He necesitado, con fuerza bruta, " + str(contador) + " intentos")
    return render_template("index.html", datos=sudoku)

if __name__ == "__main__":
    app.run(debug=True)
```

### calculo completo

#### Explicación

Este fragmento de código es un programa en Python que utiliza la biblioteca Flask para crear una aplicación web simple. El objetivo principal del programa es generar un tablero aleatorio de Sudoku válido, asegurando que todas las filas y columnas contengan los números del 1 al 9 exactamente una vez.

El proceso comienza creando una matriz 9x9 (un tablero de Sudoku) llenándola con filas generadas aleatoriamente. Para generar cada fila, se crea un rango de números del 1 al 9 y luego se mezcla ese orden aleatoriamente. Luego, el programa comprueba si todas las filas y columnas son válidas utilizando funciones específicas (`filas_validas` y `columnas_validas`). Si alguna fila o columna no cumple con los requisitos (es decir, falta algún número del 1 al 9), se genera otro tablero aleatorio hasta que todos los criterios sean satisfechos.

Una vez obtenido un tablero válido, el programa lo convierte en una representación de bloques de 3x3 utilizando la función `sudoku_a_bloques`. Esta transformación es necesaria para mostrar el Sudoku en una página web de manera estructurada y fácil de leer. Finalmente, los datos del tablero son pasados a un archivo HTML (`index.html`) que renderiza visualmente el tablero de Sudoku en la página web.

Este código es importante porque demuestra cómo combinar conceptos de programación como generación aleatoria, validación de estructuras complejas y manipulación de matrices con el uso de frameworks web para crear una aplicación funcional.

```python
import random
from flask import Flask, render_template

app = Flask(__name__)

PATRON = set(range(1, 10))  # {1,2,3,4,5,6,7,8,9}


def generar_fila():
    """Genera una permutación aleatoria de 1..9."""
    fila = list(range(1, 10))
    random.shuffle(fila)
    return fila


def filas_validas(sudoku):
    """Todas las filas contienen exactamente los números 1..9."""
    for fila in sudoku:
        if set(fila) != PATRON:
            return False
    return True


def columnas_validas(sudoku):
    """Todas las columnas contienen exactamente los números 1..9."""
    for c in range(9):
        columna = [sudoku[f][c] for f in range(9)]
        if set(columna) != PATRON:
            return False
    return True


def sudoku_a_bloques(sudoku):
    """
    Convierte el sudoku (9 filas x 9 columnas) en 9 bloques 3x3.
    Cada bloque es una lista de 9 números, en orden de lectura.
    """
    bloques = []
    for br in range(3):          # bloque fila
        for bc in range(3):      # bloque columna
            bloque = []
            for r in range(br * 3, br * 3 + 3):
                for c in range(bc * 3, bc * 3 + 3):
                    bloque.append(sudoku[r][c])
            bloques.append(bloque)
    return bloques


@app.route("/")
def inicio():
    intentos = 0

    # Fuerza bruta: generar tableros al azar hasta que filas y columnas sean válidas
    while True:
        intentos += 1
        sudoku = [generar_fila() for _ in range(9)]

        if filas_validas(sudoku) and columnas_validas(sudoku):
            break

    print(f"He necesitado, con fuerza bruta, {intentos} intentos")

    # Adaptamos a tu HTML: 9 bloques 3x3
    datos = sudoku_a_bloques(sudoku)

    return render_template("index.html", datos=datos)


if __name__ == "__main__":
    app.run(debug=True)
```

### mas eficiente

#### Explicación

Este código es una aplicación web en Python que genera un Sudoku completo y lo muestra en la página principal. Utiliza el framework Flask para crear la interfaz web, y las funciones principales son:

1. **Función `es_valido(grid, fila, col, num)`**: Esta función verifica si se puede colocar un número (`num`) en una posición específica (`fila`, `col`) de la cuadrícula (`grid`). Comprueba que el número no está ya en la misma fila, columna o bloque 3x3.

2. **Función `resolver_sudoku(grid)`**: Implementa el algoritmo de backtracking para resolver un Sudoku dado. Empieza por buscar una celda vacía (representada como 0) y prueba a colocar los números del 1 al 9 en esa posición, verificando si es válido cada número hasta encontrar uno que cumpla las reglas. Si no se puede resolver, retrocede a la celda anterior y prueba otro número.

3. **Función `generar_sudoku_completo()`**: Genera una cuadrícula de Sudoku completa (9x9) válida utilizando la función `resolver_sudoku()`. Esta función esencialmente llena la cuadrícula con números que satisfacen las reglas del Sudoku.

4. **Función `sudoku_a_bloques(sudoku)`**: Convierte un tablero de Sudoku en una lista de 9 bloques de 3x3, cada bloque siendo una lista de 9 elementos (números).

Finalmente, la aplicación web tiene una ruta principal (`/`) que genera un Sudoku completo y lo convierte a formatos de bloques para ser mostrados en una plantilla HTML llamada `index2.html`. La línea `app.run(debug=True)` inicializa el servidor Flask con depuración activada para facilitar la resolución de problemas durante el desarrollo.

Este código es importante porque demuestra cómo combinar algoritmos de resolución de problemas complejos (como Sudoku) con tecnologías web como Flask, permitiendo a los usuarios interactuar con soluciones matemáticas y lógicas de forma visual e interactiva.

```python
import random
from flask import Flask, render_template

app = Flask(__name__)


def es_valido(grid, fila, col, num):
    """Comprueba si `num` puede ponerse en grid[fila][col]."""

    # Fila
    if num in grid[fila]:
        return False

    # Columna
    for f in range(9):
        if grid[f][col] == num:
            return False

    # Bloque 3x3
    bloque_fila = (fila // 3) * 3
    bloque_col = (col // 3) * 3
    for f in range(bloque_fila, bloque_fila + 3):
        for c in range(bloque_col, bloque_col + 3):
            if grid[f][c] == num:
                return False

    return True


def resolver_sudoku(grid):
    """
    Backtracking: intenta rellenar la cuadrícula.
    Devuelve True si se ha podido resolver, False si no.
    """

    # Buscar la siguiente celda vacía (0)
    for fila in range(9):
        for col in range(9):
            if grid[fila][col] == 0:
                # Probamos números del 1 al 9 en orden aleatorio
                candidatos = list(range(1, 10))
                random.shuffle(candidatos)

                for num in candidatos:
                    if es_valido(grid, fila, col, num):
                        grid[fila][col] = num
                        if resolver_sudoku(grid):
                            return True
                        # backtrack
                        grid[fila][col] = 0

                # Si ningún número sirve, devolvemos False
                return False

    # Si no quedan celdas vacías, está resuelto
    return True


def generar_sudoku_completo():
    """Genera un sudoku completo válido (9x9) usando backtracking."""
    grid = [[0 for _ in range(9)] for _ in range(9)]
    resolver_sudoku(grid)
    return grid


def sudoku_a_bloques(sudoku):
    """
    Convierte el sudoku (9x9) en 9 bloques 3x3.
    Cada bloque es una lista de 9 números.
    """
    bloques = []
    for br in range(3):          # bloque fila
        for bc in range(3):      # bloque columna
            bloque = []
            for r in range(br * 3, br * 3 + 3):
                for c in range(bc * 3, bc * 3 + 3):
                    bloque.append(sudoku[r][c])
            bloques.append(bloque)
    return bloques


@app.route("/")
def inicio():
    sudoku = generar_sudoku_completo()
    datos = sudoku_a_bloques(sudoku)
    return render_template("index2.html", datos=datos)


if __name__ == "__main__":
    app.run(debug=True)
```

### Actividades propuestas

### Actividades para Estudiantes de Formación Profesional (FP)

1. **Introducción a los Conjuntos**
   - **Descripción:** Crea un programa que lea una lista de elementos y guarde estos en dos conjuntos diferentes, mostrando finalmente si ambos conjuntos son iguales o no.
   - **Objetivo:** Aprender cómo trabajar con estructuras de datos no ordenadas como los conjuntos.

2. **Verificación de Patrones**
   - **Descripción:** Implementa un programa que genere una lista aleatoria y verifique si esta cumple con el patrón establecido (conjunto {1, 2, ..., 9}). 
   - **Objetivo:** Entender la importancia de las pruebas condicionales en la validación de datos.

3. **Generador Aleatorio Mejorado**
   - **Descripción:** Desarrolla un programa que genere aleatoriamente una lista de números del 1 al 9 y verifique si se asemeja exactamente al patrón establecido, utilizando bucles infinitos.
   - **Objetivo:** Familiarizarse con la implementación de bucles controlados por condiciones.

4. **Modificación de Datos**
   - **Descripción:** Escribe un programa que genere una lista aleatoria y cambie aleatoriamente uno o más elementos, luego verifica si aún sigue siendo válido.
   - **Objetivo:** Aprender a manipular datos en listas utilizando indices aleatorios.

5. **Iteración Compleja**
   - **Descripción:** Crea un programa que genere múltiples iteraciones de 9 números aleatorios hasta encontrar una lista que cumpla con el patrón dado.
   - **Objetivo:** Practicar la manipulación de listas y conjuntos dentro de bucles anidados.

6. **Matriz Bidimensional**
   - **Descripción:** Implementa un programa que genere una matriz bidimensional (9x9) donde cada fila sea una lista aleatoria de números del 1 al 9.
   - **Objetivo:** Familiarizarse con las matrices en Python y la manipulación de filas y columnas.

7. **Despliegue Web Sencillo**
   - **Descripción:** Desarrolla un programa que genere una matriz bidimensional y la despliegue en una página web simple usando Flask.
   - **Objetivo:** Introducir conceptos básicos del desarrollo web con Python (Flask).

8. **Contador de Intentos**
   - **Descripción:** Modifica el programa anterior para que cuente los intentos necesarios para generar correctamente la matriz y muestre este dato en la página web.
   - **Objetivo:** Combinar lógica de programación con interacción con usuarios a través del desarrollo web.

---

Estas actividades están diseñadas para proporcionar una progresión natural desde conceptos básicos hasta aplicaciones prácticas, adaptándose al nivel y habilidades típicamente esperados en ciclos formativos de FP.



<a id="utilizacion-avanzada-de-clases"></a>
# Utilización avanzada de clases

<a id="repaso"></a>
## Repaso

### Introducción a los ejercicios

Los archivos que has proporcionado describen una relación entre distintos componentes de un sistema de software y sus relaciones en forma de diagrama visual y en código Python. A continuación, se detallará el análisis:

### Diagramas

#### `diagrama.svg`
El archivo SVG contiene un dibujo con cuatro rectángulos que representan diferentes elementos del sistema:
1. **Python**: Ubicado en las coordenadas (x: 133.4375, y: 168.7).
2. **Flask**: Ubicado en las coordenadas (x: 133, y: 128.5).
3. **HTML (en/)**: Ubicado en las coordenadas (x: 40, y: 41).
4. **JSON (/api)**: Ubicado en las coordenadas (x: 214, y: 40).

Además de los rectángulos, hay tres líneas que representan conexiones entre estos elementos:
- Una línea conecta "Python" con "HTML".
- Otra línea conecta "Python" con "JSON".
- La tercera línea conecta "JSON" con "HTML".

#### `diagrama.html`
El archivo HTML contiene un SVG similar al anterior. No hay cambios significativos en las conexiones entre los elementos.

#### `diagrama.json`
Este archivo proporciona una descripción estructurada del diagrama:
- **Formas (shapes)**: Lista de rectángulos y sus posiciones.
- **Flechas (arrows)**: Describen la conexión entre las formas utilizando el concepto de "desde" hasta".

### Código Python

El archivo `diagrama.py` define clases que representan diferentes entidades del sistema, junto con relaciones clave:
```python
from dataclasses import dataclass
from typing import Optional

@dataclass
class Cliente:
    id: Optional[int] = None
    nombre: Optional[str] = None
    apellidos: Optional[str] = None

@dataclass
class Producto:
    id: Optional[int] = None
    nombre: Optional[str] = None
    precio: Optional[str] = None

@dataclass
class Pedido:
    id: Optional[int] = None
    fecha: Optional[str] = None
    cliente_id: Optional[int] = None

    # FK1: cliente_id -> cliente.id

@dataclass
class Lineaspedido:
    id: Optional[int] = None
    fecha: Optional[str] = None
    pedido_id: Optional[int] = None
    producto_id: Optional[int] = None
    cantidad: Optional[str] = None

    # FK1: pedido_id -> pedido.id
    # FK2: producto_id -> producto.id
```
- **Cliente**: Contiene información sobre un cliente.
- **Producto**: Define una entidad de producto con atributos como nombre y precio.
- **Pedido**: Representa el pedido realizado por un cliente. Tiene una relación clave foránea (FK1) hacia `Cliente`.
- **Lineaspedido** (o detalle del pedido): Incluye información sobre la cantidad del producto en cada línea del pedido, relacionándose con ambas entidades `Pedido` y `Producto`.

### Relaciones Entidad-Relación

Las relaciones entre las clases se pueden resumir de la siguiente manera:
- **Cliente -> Pedido**: Un cliente puede realizar varios pedidos.
- **Producto -> Lineaspedido**: Un producto puede estar en varias líneas del pedido.
- **Pedido -> Lineaspedido**: Un pedido contiene múltiples líneas que relacionan los productos con cantidades.

Estos archivos proporcionan una representación visual y lógica de cómo funcionaría un sistema en términos de sus componentes interconectados, incluyendo el modelo relacional entre las entidades principales.

### Npc

#### Explicación

Este código crea una clase llamada `Npc` que representa a un personaje no jugable (Non-Playable Character o NPC) en un juego. La función `__init__` es el constructor de la clase y se utiliza para inicializar los atributos del objeto cuando se crea un nuevo NPC, como su posición en el mapa (`x`, `y`). 

En el código, creamos dos instancias (objetos) de la clase `Npc`: `personaje1` con las coordenadas `(4,3)` y `personaje2` con las coordenadas `(5,4)`. Al final, se imprime cada uno de estos objetos en la consola usando el comando `print()`, aunque no hemos definido cómo debe imprimirse un objeto Npc, por lo que Python mostrará información técnica sobre los objetos.

Es importante entender este código porque forma parte del proceso básico para crear y manipular objetos en una clase en Python. Aprender a trabajar con clases te permitirá organizar mejor tu código cuando estés creando juegos o aplicaciones más complejas.

```python
# Non Playable Character

class Npc():
  def __init__(self,x,y):
    self.posx = x
    self.posy = y
    
personaje1 = Npc(4,3)
personaje2 = Npc(5,4)

print(personaje1)
print(personaje2)
```

### lista de npc

#### Explicación

Este fragmento de código está diseñado para crear personajes no controlados por el jugador, conocidos como NPCs (Non Playable Characters), en un entorno de programación. La clase `Npc` es definida con dos atributos: `posx` y `posy`, que representan la posición x e y del NPC respectivamente. Cuando se crea un objeto `Npc`, estos valores se inicializan a través del método especial `__init__`.

Después de definir la clase, creamos una lista vacía llamada `personajes`. Luego añadimos dos NPCs a esta lista con diferentes coordenadas: uno en las coordenadas (4,3) y otro en (3,4). Finalmente, imprimimos la lista `personajes`, lo que mostrará los objetos de NPC dentro de ella, aunque no serán fácilmente legibles sin métodos adicionales para representar visualmente estos objetos.

Esta práctica es importante porque nos permite entender cómo trabajar con clases y objetos en Python, además de introducirnos a la creación de listas de objetos personalizados que pueden usarse, por ejemplo, en juegos o simulaciones.

```python
# Non Playable Character

class Npc():
  def __init__(self,x,y):
    self.posx = x
    self.posy = y
    
personajes = []

personajes.append(Npc(4,3))
personajes.append(Npc(3,4))

print(personajes)
```

### ahora muchos personajes

#### Explicación

Este código crea una lista de personajes no jugables, también conocidos como NPCs (Non-Player Characters), en un juego o simulación. Primero, define una clase llamada `Npc` que tiene un método especial `__init__`. Este método se ejecuta automáticamente cuando creamos un nuevo NPC y establece su posición inicial en el mapa (`posx`, `posy`). En este caso, todos los NPCs creados tienen las mismas coordenadas (4, 3).

Luego, el código crea una lista vacía llamada `personajes` y define la variable `numero_personajes` que contiene el número total de NPCs que queremos generar. A continuación, se utiliza un bucle `for` para agregar 50 instancias de la clase `Npc` a la lista `personajes`, con cada NPC teniendo las mismas coordenadas (4, 3). Finalmente, se imprime la lista completa de NPCs.

Este enfoque es importante porque permite gestionar fácilmente múltiples entidades del juego que comparten características similares y nos permite modificarlas o acceder a ellas individualmente si fuera necesario.

```python
# Non Playable Character

class Npc():
  def __init__(self,x,y):
    self.posx = x
    self.posy = y
    
personajes = []
numero_personajes = 50

for i in range(0,numero_personajes):
	personajes.append(Npc(4,3))

print(personajes)
```

### posicion aleatoria

#### Explicación

Este código crea un conjunto de personajes virtuales (también conocidos como Non Playable Characters o NPC por sus siglas en inglés) con posiciones aleatorias en una pantalla virtual, que se representa mediante coordenadas x e y. Comenzamos importando el módulo `random` para generar números enteros al azar.

La clase `Npc` es definida con un método especial llamado `__init__`, que establece las posiciones iniciales del personaje cuando se crea una nueva instancia de la clase. Este método recibe dos parámetros, `x` y `y`, que representan la posición en el eje horizontal (izquierda-derecha) y vertical (arriba-abajo), respectivamente.

Después, se inicializa una lista vacía llamada `personajes`. Luego, mediante un bucle `for`, se generan 50 NPCs. Dentro del bucle, dos variables (`xaleatoria` y `yaleatoria`) reciben valores aleatorios entre 0 y 500, que representan las coordenadas x e y respectivamente para cada NPC. Estos NPCs son creados usando la clase `Npc` con estas posiciones aleatorias, y después se añaden a la lista `personajes`.

Finalmente, el código imprime en pantalla toda la lista de NPCs generados junto con sus posiciones. Esto es útil para visualizar cómo las instancias de la clase `Npc` han sido creadas y almacenadas.

Este tipo de estructura es común en desarrollo de juegos o aplicaciones gráficas donde se necesita crear múltiples entidades con características únicas, como posición, que pueden variar aleatoriamente.

```python
# Non Playable Character
import random

class Npc():
  def __init__(self,x,y):
    self.posx = x
    self.posy = y
    
personajes = []
numero_personajes = 50

for i in range(0,numero_personajes):
	xaleatoria = random.randint(0,500)
	yaleatoria = random.randint(0,500)
	personajes.append(Npc(xaleatoria,yaleatoria))

print(personajes)
```

### imprimo como json

#### Explicación

Este código crea un programa en Python que simula la generación de personajes (NPCs) con posiciones aleatorias y luego convierte esos personajes a formato JSON para imprimirlos. 

En primer lugar, se importan las bibliotecas necesarias: `random` para generar números aleatorios y `json` para trabajar con datos en formato JSON. Luego, se define una clase llamada `Npc`, que tiene un método de inicialización (`__init__`) que recibe dos parámetros (posiciones x e y) y los almacena como atributos del objeto.

La clase también incluye un método llamado `to_dict` que convierte el objeto en un diccionario Python, lo cual es útil para convertirlo a JSON posteriormente. 

Después de definir la clase, se crea una lista vacía llamada `personajes`. El código genera 50 NPCs con posiciones x e y aleatorias dentro del rango de 0 a 500. Cada NPC generado es añadido a la lista `personajes`.

Finalmente, usando comprensión de listas en Python, se aplica el método `to_dict` a cada objeto en la lista `personajes`, convirtiendo todos los NPCs a sus representaciones diccionario. Estos diccionarios son luego convertidos a una cadena JSON formateada y se imprimen en pantalla con un espacio de dos niveles para facilitar su lectura.

Este proceso es importante porque permite almacenar y compartir fácilmente información sobre múltiples personajes utilizando el estándar JSON, que es ampliamente utilizado en desarrollo web y aplicaciones.

```python
import random
import json

class Npc():
    def __init__(self, x, y):
        self.posx = x
        self.posy = y

    # Método para convertir el objeto en diccionario
    def to_dict(self):
        return {"posx": self.posx, "posy": self.posy}

personajes = []
numero_personajes = 50

for i in range(0, numero_personajes):
    xaleatoria = random.randint(0, 500)
    yaleatoria = random.randint(0, 500)
    personajes.append(Npc(xaleatoria, yaleatoria))

# Convertimos todos los NPC a diccionarios
personajes_json = [p.to_dict() for p in personajes]

# Lo imprimimos formateado
print(json.dumps(personajes_json, indent=2))
```

### flask

#### Explicación

Este código es una aplicación web simple creada usando Flask, un framework de Python que permite crear páginas web con facilidad. En primer lugar, se importan las librerías necesarias y se define la clase `Npc` (Non-Player Character), que representa los personajes no controlados por el usuario en un juego. Cada NPC tiene una posición inicial definida al crearlo.

Luego, se genera un conjunto de 50 NPCs cuyas posiciones x e y son aleatorias dentro del rango de 0 a 500. Estos NPCs se convierten luego en diccionarios para ser fácilmente manipulados o transmitidos por la web.

Finalmente, la aplicación Flask está configurada para ofrecer dos puntos finales (endpoints): uno que sirve una página HTML llamada "juego.html" y otro que proporciona un JSON con los datos de todos los NPCs generados. La aplicación corre en modo depuración, lo cual es útil durante el desarrollo ya que ofrece información detallada sobre errores.

Este código es importante porque demuestra cómo combinar clases personalizadas con la manipulación de datos y la presentación web, permitiendo a los estudiantes comprender cómo estructurar aplicaciones más complejas que integran múltiples componentes.

```python
import random
import json
from flask import Flask,render_template

class Npc():
    def __init__(self, x, y):
        self.posx = x
        self.posy = y

    # Método para convertir el objeto en diccionario
    def to_dict(self):
        return {"posx": self.posx, "posy": self.posy}
# Preparo los personajes

personajes = []
numero_personajes = 50

for i in range(0, numero_personajes):
    xaleatoria = random.randint(0, 500)
    yaleatoria = random.randint(0, 500)
    personajes.append(Npc(xaleatoria, yaleatoria))

personajes_json = [p.to_dict() for p in personajes]

# Lanzo una web

app = Flask(__name__)

@app.route("/")
def inicio():
  return render_template("juego.html")

@app.route("/api")
def api():
  return json.dumps(personajes_json, indent=2)
  
if __name__ == "__main__":
  app.run(debug=True)
```

### nuevo parametro

#### Explicación

Este código es una pequeña aplicación web que utiliza Flask y crea personajes aleatorios (NPCs) con características específicas. En primer lugar, se importan las bibliotecas necesarias: `random` para generar números aleatorios, `json` para manejar datos en formato JSON, y `Flask` junto con `render_template` para crear la aplicación web.

La clase `Npc` define un personaje no jugable (NPC) con tres atributos: posición x (`posx`), posición y (`posy`) y radio. La función `to_dict()` convierte el objeto NPC en un diccionario, lo que facilita su uso en la aplicación web.

Después de definir la clase, se genera una lista de 50 NPCs con posiciones y radios aleatorios dentro del rango especificado. Estos personajes son almacenados en una lista y luego convertidos a formato JSON usando el método `to_dict()` para cada NPC.

Finalmente, se crea un servidor web simple con Flask que tiene dos rutas: la ruta principal que devuelve una página HTML llamada "juego.html" y la ruta "/api" que proporciona los datos de los NPCs en formato JSON. Esto permite a otros sistemas o páginas web consumir estos datos fácilmente.

Este código es importante porque demuestra cómo combinar clases personalizadas, generación de datos aleatorios y creación de una API simple para compartir datos entre diferentes partes de un sistema o con otras aplicaciones.

```python
import random
import json
from flask import Flask,render_template

class Npc():
    def __init__(self, x, y,radio):
        self.posx = x
        self.posy = y
        self.radio = radio

    # Método para convertir el objeto en diccionario
    def to_dict(self):
        return {"posx": self.posx, "posy": self.posy,"radio":self.radio}
# Preparo los personajes

personajes = []
numero_personajes = 50

for i in range(0, numero_personajes):
    xaleatoria = random.randint(0, 500)
    yaleatoria = random.randint(0, 500)
    radioaleatorio = random.randint(10, 30)
    personajes.append(Npc(xaleatoria, yaleatoria,radioaleatorio))

personajes_json = [p.to_dict() for p in personajes]

# Lanzo una web

app = Flask(__name__)

@app.route("/")
def inicio():
  return render_template("juego.html")

@app.route("/api")
def api():
  return json.dumps(personajes_json, indent=2)
  
if __name__ == "__main__":
  app.run(debug=True)
```

### muevo personajes

#### Explicación

Este código es una pequeña aplicación web que utiliza Flask para gestionar y mostrar la posición de personajes en un juego. La clase `Npc` (Non-Player Character) define cómo se crean los personajes, almacenando sus coordenadas X e Y y un radio de influencia. También incluye dos métodos: `to_dict()`, que convierte el objeto Npc a un diccionario para facilitar la manipulación y envío de datos; y `mover()`, que actualiza aleatoriamente las posiciones X e Y del personaje.

El código crea una lista de 50 objetos `Npc` con posiciones y radios aleatorios. Luego, define dos rutas en Flask: la primera (`/`) sirve un archivo HTML llamado "juego.html", que probablemente muestra el juego al usuario; la segunda ruta (`/api`) actualiza las posiciones de todos los personajes usando el método `mover()`, convierte la lista de objetos Npc a una lista de diccionarios y devuelve estos datos en formato JSON. Esto permite que otra parte del programa o cliente web interactúe con este servidor para obtener información actualizada sobre dónde están los personajes.

Esta estructura es crucial porque permite separar claramente el código lógico del juego (cómo se mueven los personajes) de la presentación en un navegador, facilitando tanto la modificación futura como la integración con otros componentes.

```python
import random
import json
from flask import Flask,render_template

class Npc():
	def __init__(self, x, y,radio):
		self.posx = x
		self.posy = y
		self.radio = radio

	def to_dict(self):
		return {"posx": self.posx, "posy": self.posy,"radio":self.radio}
	def mover(self):
		self.posx += random.randint(-5,5)	# Muevete un poco en X
		self.posy += random.randint(-5,5)	# Muevete un poco en Y
# Preparo los personajes

personajes = []
numero_personajes = 50

for i in range(0, numero_personajes):
	xaleatoria = random.randint(0, 500)
	yaleatoria = random.randint(0, 500)
	radioaleatorio = random.randint(10, 30)
	personajes.append(Npc(xaleatoria, yaleatoria,radioaleatorio))



# Lanzo una web

app = Flask(__name__)

@app.route("/")
def inicio():
  return render_template("juego.html")

@app.route("/api")
def api():
  # Primero muevo todos los personajes
  for personaje in personajes:	
    personaje.mover()
  personajes_json = [p.to_dict() for p in personajes]
  return json.dumps(personajes_json, indent=2)
  
if __name__ == "__main__":
  app.run(debug=True)
  
  
  
  
```

### Muevo personajes pero con trigonometria

#### Explicación

Este fragmento de código es una aplicación web sencilla que controla el movimiento de un conjunto de entidades virtuales llamadas NPCs (Personajes No Jugadores) utilizando Flask, un framework popular en Python para crear aplicaciones web. El código crea y mantiene la posición y dirección de 50 personajes aleatorios dentro de una área definida.

Cada NPC tiene propiedades como posiciones x e y (`posx` y `posy`), un radio que podría representar el tamaño del personaje, y una dirección angular que determina hacia dónde se mueve. La clase `Npc` incluye métodos para inicializar estos atributos y para mover los NPCs basándose en la trigonometría: las nuevas posiciones x e y se calculan usando funciones como `math.cos()` y `math.sin()`, lo cual permite que el personaje se desplace según su dirección angular.

La aplicación web tiene dos rutas principales: una para mostrar un archivo HTML (`/`) y otra que devuelve los datos JSON de todos los NPCs actuales (`/api`). Cuando accedes a la ruta `/api`, cada personaje es movido en función del ángulo dado, lo que simula su movimiento continuo. El código finalmente convierte estos objetos `Npc` a diccionarios y los envía como un JSON, permitiendo una fácil visualización o interacción con los datos de la aplicación desde el navegador.

Este tipo de implementación es importante para entender cómo se pueden combinar conceptos matemáticos simples (como la trigonometría) con programación web y bases de datos en tiempo real para crear entornos dinámicos y interactivos, típicamente utilizados en juegos o simulaciones.

```python
import random
import json
from flask import Flask,render_template
import math # Para poder hacer trigonometria

class Npc():
	def __init__(self, x, y,radio,direccion):
		self.posx = x
		self.posy = y
		self.radio = radio
		self.direccion = direccion # NUEVO

	def to_dict(self):
		return {
      "posx": self.posx, 
      "posy": self.posy,
      "radio": self.radio,
    	"direccion": self.direccion # NUEVO
    }
	def mover(self):
		self.posx += math.cos(self.direccion) # NUEVO
		self.posy += math.sin(self.direccion) # NUEVO
# Preparo los personajes

personajes = []
numero_personajes = 50

for i in range(0, numero_personajes):
	xaleatoria = random.randint(0, 500)
	yaleatoria = random.randint(0, 500)
	radioaleatorio = random.randint(10, 30)
	direccionaleatoria = random.random()*math.pi*2  # NUEVO
	personajes.append(
    Npc(xaleatoria, yaleatoria,radioaleatorio,direccionaleatoria) # NUEVO
  )



# Lanzo una web

app = Flask(__name__)

@app.route("/")
def inicio():
  return render_template("juego.html")

@app.route("/api")
def api():
  # Primero muevo todos los personajes
  for personaje in personajes:	
    personaje.mover()
  personajes_json = [p.to_dict() for p in personajes]
  return json.dumps(personajes_json, indent=2)
  
if __name__ == "__main__":
  app.run(debug=True)
  
  
  
  
```

### creamos velocidad

#### Explicación

Este código Python crea un pequeño programa web que simula el movimiento de personajes en una página web. Primero, importa las bibliotecas necesarias y define una clase llamada `Npc` (Non-Player Character) que representa a cada personaje. Esta clase almacena la posición (`x`, `y`), tamaño (`radio`), dirección y velocidad del personaje. La función `mover()` actualiza la posición de un personaje basándose en su dirección y velocidad, usando cálculos trigonométricos (coseno y seno).

Luego, el código genera una lista con 50 objetos `Npc`, cada uno con posiciones, tamaños, direcciones y velocidades aleatorias. Estos personajes son los que se moverán en la simulación web.

Finalmente, utilizando Flask, un framework de desarrollo web para Python, crea rutas (`/` y `/api`) que manejan las peticiones del navegador. La ruta principal (`/`) muestra una página HTML (que no está incluida en este fragmento), mientras que la ruta `/api` actualiza el movimiento de los personajes llamando a `mover()` para cada uno y luego devuelve sus datos actualizados en formato JSON.

Este código es importante porque combina varios conceptos clave como clases, cálculos trigonométricos, generación aleatoria de números, manejo de listas y frameworks web Flask, ofreciendo una aplicación práctica para estudiantes que quieran aprender a desarrollar sitios web dinámicos.

```python
import random
import json
from flask import Flask,render_template
import math # Para poder hacer trigonometria

class Npc():
	def __init__(self, x, y,radio,direccion,velocidad): # NUEVO
		self.posx = x
		self.posy = y
		self.radio = radio
		self.direccion = direccion 
		self.velocidad = velocidad # NUEVO

	def to_dict(self):
		return {
      "posx": self.posx, 
      "posy": self.posy,
      "radio": self.radio,
    	"direccion": self.direccion 
    }
	def mover(self):
		self.posx += math.cos(self.direccion)*self.velocidad # NUEVO
		self.posy += math.sin(self.direccion)*self.velocidad # NUEVO
# Preparo los personajes

personajes = []
numero_personajes = 50

for i in range(0, numero_personajes):
	xaleatoria = random.randint(0, 500)
	yaleatoria = random.randint(0, 500)
	radioaleatorio = random.randint(10, 30)
	direccionaleatoria = random.random()*math.pi*2 
	velocidadaleatoria = random.random()*5 # NUEVO
	personajes.append(
    Npc(
      xaleatoria, 
      yaleatoria,
      radioaleatorio,
      direccionaleatoria,
      velocidadaleatoria # NUEVO
    ) 
  )



# Lanzo una web

app = Flask(__name__)

@app.route("/")
def inicio():
  return render_template("juego.html")

@app.route("/api")
def api():
  # Primero muevo todos los personajes
  for personaje in personajes:	
    personaje.mover()
  personajes_json = [p.to_dict() for p in personajes]
  return json.dumps(personajes_json, indent=2)
  
if __name__ == "__main__":
  app.run(debug=True)
  
  
  
  
```

### angulo cambia random

#### Explicación

Este código es una aplicación web simple que simula el movimiento de personajes en un juego. Primero, importa varias bibliotecas necesarias y define una clase llamada `Npc` (Non-Player Character), la cual representa a cada personaje en el juego. Cada personaje tiene propiedades como posición (`x`, `y`), radio, dirección y velocidad. La función `to_dict()` convierte estos datos del personaje en un formato de diccionario que es fácilmente serializable.

El método `mover()` actualiza la posición del personaje basándose en su dirección y velocidad actuales, además de añadir una pequeña variación aleatoria a la dirección para darles movimiento más realista. Esto implica el uso de funciones trigonométricas como `math.cos` y `math.sin`.

Después, se crean 50 personajes con posiciones y propiedades iniciales generadas al azar. La aplicación web utiliza Flask (una biblioteca popular para crear aplicaciones web en Python) y tiene dos rutas principales: una para el índice (`/`) que renderiza un archivo HTML llamado `juego.html`, y otra ruta (`/api`) que se encarga de mover a los personajes, actualizar sus posiciones y devolverlos como JSON codificado para que otros programas puedan interpretarlo fácilmente.

Este código es importante porque permite simular un entorno interactivo en el que múltiples objetos (personajes) pueden moverse independientemente basándose en parámetros dados, lo cual es una base fundamental para juegos y aplicaciones similares.

```python
import random
import json
from flask import Flask,render_template
import math # Para poder hacer trigonometria

class Npc():
	def __init__(self, x, y,radio,direccion,velocidad): 
		self.posx = x
		self.posy = y
		self.radio = radio
		self.direccion = direccion 
		self.velocidad = velocidad 

	def to_dict(self):
		return {
      "posx": self.posx, 
      "posy": self.posy,
      "radio": self.radio,
    	"direccion": self.direccion 
    }
	def mover(self):
		# Aplicamos variacion de la direccion con el tiempo
		self.direccion += (random.random() - 0.5) * 0.2  # NUEVO
		self.posx += math.cos(self.direccion)*self.velocidad
		self.posy += math.sin(self.direccion)*self.velocidad 
# Preparo los personajes

personajes = []
numero_personajes = 50

for i in range(0, numero_personajes):
	xaleatoria = random.randint(0, 500)
	yaleatoria = random.randint(0, 500)
	radioaleatorio = random.randint(10, 30)
	direccionaleatoria = random.random()*math.pi*2 
	velocidadaleatoria = random.random()*5 
	personajes.append(
    Npc(
      xaleatoria, 
      yaleatoria,
      radioaleatorio,
      direccionaleatoria,
      velocidadaleatoria 
    ) 
  )



# Lanzo una web

app = Flask(__name__)

@app.route("/")
def inicio():
  return render_template("juego.html")

@app.route("/api")
def api():
  # Primero muevo todos los personajes
  for personaje in personajes:	
    personaje.mover()
  personajes_json = [p.to_dict() for p in personajes]
  return json.dumps(personajes_json, indent=2)
  
if __name__ == "__main__":
  app.run(debug=True)
  
  
  
  
```

### colision

#### Explicación

Este fragmento de código es un ejemplo de cómo implementar la lógica y visualización en una aplicación web simple utilizando Flask. La aplicación maneja a personajes (NPCs, por sus siglas en inglés) que se mueven dentro de un espacio definido por coordenadas x e y.

El código comienza definiendo una clase `Npc` con atributos como posición (`posx`, `posy`), radio, dirección y velocidad. La función `mover()` ajusta la dirección del personaje aleatoriamente y verifica si ha colisionado con los límites de un área cuadrada (0-500 en ambos ejes). Si el NPC choca contra una pared, gira para moverse hacia otra dirección.

Luego, se crean 50 NPCs con posiciones y propiedades iniciales aleatorias. Estos personajes son almacenados en la lista `personajes`.

La parte final del código configura un servidor web simple usando Flask que tiene dos rutas: "/" (la página inicial) y "/api". La ruta "/api" es importante porque actualiza las posiciones de todos los NPCs llamando a su método `mover()` y luego devuelve sus datos en formato JSON, permitiendo así una interacción continua entre el cliente web y la lógica del servidor.

Este tipo de código es crucial para desarrollar juegos simples o aplicaciones que requieren animación y respuestas dinámicas basadas en las interacciones de los personajes dentro de un escenario virtual.

```python
import random
import json
from flask import Flask,render_template
import math # Para poder hacer trigonometria

class Npc():
	def __init__(self, x, y,radio,direccion,velocidad): 
		self.posx = x
		self.posy = y
		self.radio = radio
		self.direccion = direccion 
		self.velocidad = velocidad 

	def to_dict(self):
		return {
      "posx": self.posx, 
      "posy": self.posy,
      "radio": self.radio,
    	"direccion": self.direccion 
    }
	def mover(self):
		# Aplicamos variacion de la direccion con el tiempo
		self.direccion += (random.random() - 0.5) * 0.2
    # Colision con paredes en mover
		if self.posx > 500 or self.posx < 0 or self.posy > 500 or self.posy < 0: # NUEVO
      	# El personaje se da la vuelta
				self.direccion += math.pi # NUEVO
		self.posx += math.cos(self.direccion)*self.velocidad
		self.posy += math.sin(self.direccion)*self.velocidad 
# Preparo los personajes

personajes = []
numero_personajes = 50

for i in range(0, numero_personajes):
	xaleatoria = random.randint(0, 500)
	yaleatoria = random.randint(0, 500)
	radioaleatorio = random.randint(10, 30)
	direccionaleatoria = random.random()*math.pi*2 
	velocidadaleatoria = random.random()*5 
	personajes.append(
    Npc(
      xaleatoria, 
      yaleatoria,
      radioaleatorio,
      direccionaleatoria,
      velocidadaleatoria 
    ) 
  )



# Lanzo una web

app = Flask(__name__)

@app.route("/")
def inicio():
  return render_template("juego.html")

@app.route("/api")
def api():
  # Primero muevo todos los personajes
  for personaje in personajes:	
    personaje.mover()
  personajes_json = [p.to_dict() for p in personajes]
  return json.dumps(personajes_json, indent=2)
  
if __name__ == "__main__":
  app.run(debug=True)
  
  
  
  
```

### diagrama (1)

#### Explicación

Este fragmento de código define cuatro clases que representan diferentes entidades en una base de datos o sistema de gestión de pedidos y productos. Las clases son `Cliente`, `Producto`, `Pedido` y `Lineaspedido`. Cada clase tiene un método `__init__` que inicializa los atributos de la entidad, como el ID, nombre, fecha, etc., y un método `__repr__` que proporciona una representación en cadena legible para imprimir objetos de esas clases.

En las definiciones de las clases se utilizan parámetros opcionales (`Optional[int]`, `Optional[str]`) para permitir la inicialización flexible de los objetos sin necesidad de especificar todos los valores al crearlos. Esto ayuda a manejar casos donde algunos atributos puedan no estar disponibles en el momento de la creación.

Es importante notar que cada clase tiene comentarios indicando las relaciones entre ellas (FK significa "Foreign Key" o clave foránea), lo cual es crucial para entender cómo se conectan estos objetos entre sí en un sistema más amplio. Por ejemplo, `Pedido.cliente_id` está relacionado con `Cliente.id`, y `Lineaspedido.pedido_id` y `product_id` están relacionados con `Pedido.id` y `Producto.id`, respectivamente.

Este código es fundamental para comprender cómo se estructura una base de datos orientada a objetos y cómo las clases pueden representar tablas en una base de datos relacional, manteniendo la integridad referencial entre ellas.

```python
from typing import Optional

class Cliente:
    def __init__(self, id: Optional[int] = None, nombre: Optional[str] = None, apellidos: Optional[str] = None):
        self.id = id
        self.nombre = nombre
        self.apellidos = apellidos

    def __repr__(self):
        return f"Cliente(id={self.id!r}, nombre={self.nombre!r}, apellidos={self.apellidos!r})"

class Producto:
    def __init__(self, id: Optional[int] = None, nombre: Optional[str] = None, precio: Optional[str] = None):
        self.id = id
        self.nombre = nombre
        self.precio = precio

    def __repr__(self):
        return f"Producto(id={self.id!r}, nombre={self.nombre!r}, precio={self.precio!r})"

class Pedido:
    def __init__(self, id: Optional[int] = None, fecha: Optional[str] = None, cliente_id: Optional[int] = None):
        self.id = id
        self.fecha = fecha
        self.cliente_id = cliente_id

    def __repr__(self):
        return f"Pedido(id={self.id!r}, fecha={self.fecha!r}, cliente_id={self.cliente_id!r})"

    # FK1: cliente_id -> cliente.id

class Lineaspedido:
    def __init__(self, id: Optional[int] = None, fecha: Optional[str] = None, pedido_id: Optional[int] = None, producto_id: Optional[int] = None, cantidad: Optional[str] = None):
        self.id = id
        self.fecha = fecha
        self.pedido_id = pedido_id
        self.producto_id = producto_id
        self.cantidad = cantidad

    def __repr__(self):
        return f"Lineaspedido(id={self.id!r}, fecha={self.fecha!r}, pedido_id={self.pedido_id!r}, producto_id={self.producto_id!r}, cantidad={self.cantidad!r})"

    # FK1: pedido_id -> pedido.id
    # FK2: producto_id -> producto.id
```

### diagrama

#### Explicación

Este código HTML crea una página web que representa un diagrama simple utilizando clases y estilos CSS. La estructura principal del documento está definida por la etiqueta `<html>` con el atributo `lang="es"`, lo que indica que el contenido de la página está en español. Dentro del bloque `<head>`, se especifican los metadatos como la codificación de caracteres y el título de la página, además de incluir un bloque `<style>` donde se definen las reglas CSS para diseñar elementos visuales.

El cuerpo (`<body>`) contiene un contenedor principal con la clase `.page` que establece una apariencia básica con un borde, sombreado y dimensiones específicas. Dentro de este contenedor, hay varios elementos rectangulares representados por la clase `.shape rectangle`, cada uno con estilos personalizados para posicionarlos y darles tamaños precisos según su contenido.

Además, se incluyen flechas (`<div class="arrow">`) que conectan estos cuadrados rectangulares, creando una visualización de flujo entre diferentes componentes del sistema (como Python, Flask, HTML y JSON). Estas flechas tienen transformaciones CSS aplicadas para hacerlas apuntar en direcciones específicas.

Este tipo de código es útil para estudiantes de programación ya que muestra cómo combinar HTML con CSS para crear diseños complejos y presentables, especialmente cuando se necesita visualizar relaciones entre diferentes componentes o servicios en un sistema.

```html
<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>Diagrama exportado</title>
<style>
body {
  margin: 0;
  padding: 20px;
  background: #f3f3f7;
  font-family: system-ui, -apple-system, "Segoe UI", sans-serif;
}
.page {
  position: relative;
  background: #ffffff;
  border: 1px solid #d1d5db;
  box-shadow: 0 2px 4px rgba(0,0,0,.1);
  width: 374px;
  height: 248.69998168945307px;
  overflow: visible;
}

/* formas básicas */
.shape {
  position: absolute;
  min-width: 120px;
  min-height: 40px;
  padding: 6px 10px;
  background: #ffffff;
  border-radius: 4px;
  border: 1px solid #9ca3af;
  box-shadow: 0 1px 2px rgba(0,0,0,0.15);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 13px;
}

.shape.rectangle {
  border-radius: 4px;
}

.shape.pill {
  border-radius: 999px;
}

.shape.circle {
  border-radius: 999px;
  width: 80px;
  height: 80px;
  padding: 0;
  justify-content: center;
}

/* base de datos */
.shape.db {
  min-width: 120px;
  min-height: 60px;
  padding-top: 20px;
  border-radius: 60px / 16px;
  background: linear-gradient(180deg, #e5e7eb 0%, #ffffff 40%, #e5e7eb 100%);
  position: absolute;
  overflow: hidden;
  text-align: center;
}
.shape.db::before {
  content: "";
  position: absolute;
  top: 0;
  left: 8px;
  right: 8px;
  height: 18px;
  border-radius: 999px;
  border: 1px solid #9ca3af;
  background: radial-gradient(circle at 50% 30%, #ffffff 0%, #e5e7eb 70%);
}
.shape.db::after {
  content: "";
  position: absolute;
  bottom: 0;
  left: 8px;
  right: 8px;
  height: 18px;
  border-radius: 999px;
  border: 1px solid rgba(156, 163, 175, 0.6);
  border-top: none;
  background: radial-gradient(circle at 50% 70%, #e5e7eb 0%, #d1d5db 70%);
}

/* entidades ER */
.shape.entity {
  width: 220px;
  min-height: 80px;
  background: #ffffff;
  border: 2px solid #111827;
  border-radius: 4px;
  box-shadow: 0 2px 4px rgba(0,0,0,.15);
  display: flex;
  flex-direction: column;
  font-size: 13px;
  overflow: hidden;
  padding: 0;
}
.entity-header {
  background: #f3f4f6;
  padding: 4px 8px;
  font-weight: 600;
  text-align: center;
  border-bottom: 1px solid #e5e7eb;
}
.entity-properties {
  flex: 1;
  padding: 4px 4px 0 4px;
}
.entity-property {
  display: grid;
  grid-template-columns: 14px 1fr 14px;
  align-items: center;
  column-gap: 4px;
  padding: 2px 0;
}
.entity-property .property-name {
  padding: 2px 4px;
  border-radius: 3px;
}

/* puertos */
.port {
  width: 9px;
  height: 9px;
  border-radius: 50%;
  border: 1px solid #111827;
  background: #ffffff;
}
.port-left { justify-self: start; }
.port-right { justify-self: end; }

/* flechas rectas */
.arrow {
  position: absolute;
  height: 2px;
  background: #111827;
  transform-origin: 0 50%;
}
.arrow::after {
  content: "";
  position: absolute;
  right: 0;
  top: 50%;
  transform: translateY(-50%);
  border-top: 5px solid transparent;
  border-bottom: 5px solid transparent;
  border-left: 8px solid #111827;
}
.arrow-double::before {
  content: "";
  position: absolute;
  left: 0;
  top: 50%;
  transform: translateY(-50%) rotate(180deg);
  border-top: 5px solid transparent;
  border-bottom: 5px solid transparent;
  border-left: 8px solid #111827;
}

/* flechas ortogonales */
.ortho-arrow {
  position: absolute;
  left: 0;
  top: 0;
}
.ortho-arrow .ortho-seg {
  position: absolute;
  background: #111827;
}
.ortho-seg.seg-horizontal { height: 2px; }
.ortho-seg.seg-vertical { width: 2px; }
.ortho-arrowhead {
  position: absolute;
  width: 0;
  height: 0;
}
.ortho-arrowhead.dir-right {
  border-top: 5px solid transparent;
  border-bottom: 5px solid transparent;
  border-left: 8px solid #111827;
}
.ortho-arrowhead.dir-left {
  border-top: 5px solid transparent;
  border-bottom: 5px solid transparent;
  border-right: 8px solid #111827;
}
.ortho-arrowhead.dir-down {
  border-left: 5px solid transparent;
  border-right: 5px solid transparent;
  border-top: 8px solid #111827;
}
.ortho-arrowhead.dir-up {
  border-left: 5px solid transparent;
  border-right: 5px solid transparent;
  border-bottom: 8px solid #111827;
}
</style>
</head>
<body>
<div class="page">

<div class="shape rectangle" style="left:133.43749999999994px;top:168.69998168945307px;width:119.99999999999994px;height:39.999999999999986px;">python</div>
<div class="shape rectangle" style="left:132.99999999999994px;top:128.49999999999994px;width:119.99999999999994px;height:39.99998855590819px;">flask</div>
<div class="shape rectangle" style="left:40px;top:41px;width:119.99999999999994px;height:39.999999999999986px;">html (en/)</div>
<div class="shape rectangle" style="left:214px;top:40px;width:119.99999999999994px;height:39.999999999999986px;">json (/api)</div>
<div class="arrow" style="left:171.742861834468px;top:128.49999999999994px;width:69.31852335628878px;transform:rotate(-2.386656011696309rad);"></div>
<div class="arrow" style="left:211.30508069216717px;top:128.49999999999994px;width:65.74729885991071px;transform:rotate(-0.829617075591497rad);"></div>
<div class="arrow" style="left:214px;top:60.34482758620686px;width:54.00089178811781px;transform:rotate(3.1358455904265896rad);"></div>
</div>
</body>
</html>
```

### diagrama

#### Explicación

Este fragmento de código es un archivo JSON que describe el diseño de una página web o diagrama en el que se representan diferentes formas y las relaciones entre ellas. En esta estructura, tienes cuatro rectángulos identificados por IDs como "forma-1", "forma-2", etc., cada uno con coordenadas específicas (posición y tamaño) y texto dentro del recuadro. Por ejemplo, la primera forma ("forma-1") es un rectángulo que contiene el texto "python" y está ubicada en las coordenadas 466px a la izquierda y 287.2px hacia arriba.

Además de los rectángulos, el JSON también incluye tres flechas que conectan algunos de estos rectángulos entre sí, indicando una relación o flujo. Por ejemplo, hay una flecha que va desde "forma-2" (que contiene "flask") hasta "forma-3" (con "html (en/)"), sugiriendo que el contenido relacionado con Flask interactúa con HTML en algún sentido.

Este tipo de estructura es útil para visualizar la arquitectura o flujo de datos en aplicaciones web, ayudando a los desarrolladores a entender cómo las diferentes partes del sistema se comunican y dependen unas de otras. Es importante porque facilita el diseño y la documentación de sistemas complejos, permitiendo una comprensión más clara de sus componentes internos y externos.

```json
{
  "formas": [
    {
      "id": "forma-1",
      "tipo": "rectangle",
      "left": "466px",
      "top": "287.2px",
      "width": "",
      "height": "",
      "texto": "python"
    },
    {
      "id": "forma-2",
      "tipo": "rectangle",
      "left": "465.563px",
      "top": "247px",
      "width": "",
      "height": "",
      "texto": "flask"
    },
    {
      "id": "forma-3",
      "tipo": "rectangle",
      "left": "372.563px",
      "top": "159.5px",
      "width": "",
      "height": "",
      "texto": "html (en/)"
    },
    {
      "id": "forma-4",
      "tipo": "rectangle",
      "left": "546.563px",
      "top": "158.5px",
      "width": "",
      "height": "",
      "texto": "json (/api)"
    }
  ],
  "flechas": [
    {
      "desde": {
        "shapeId": "forma-2",
        "propId": null,
        "side": null
      },
      "hasta": {
        "shapeId": "forma-3",
        "propId": null,
        "side": null
      },
      "tipo": "simple",
      "estilo": "straight"
    },
    {
      "desde": {
        "shapeId": "forma-2",
        "propId": null,
        "side": null
      },
      "hasta": {
        "shapeId": "forma-4",
        "propId": null,
        "side": null
      },
      "tipo": "simple",
      "estilo": "straight"
    },
    {
      "desde": {
        "shapeId": "forma-4",
        "propId": null,
        "side": null
      },
      "hasta": {
        "shapeId": "forma-3",
        "propId": null,
        "side": null
      },
      "tipo": "simple",
      "estilo": "straight"
    }
  ]
}
```

### diagrama

#### Explicación

Este código está utilizando la biblioteca `dataclasses` de Python para definir cuatro clases diferentes que representan entidades en una base de datos o un sistema empresarial. Cada clase tiene atributos (o campos) específicos y valores por defecto opcionales.

- La clase `Cliente` representa a un cliente con atributos como id, nombre y apellidos.
- La clase `Producto` se utiliza para representar un producto en el inventario, que incluye su identificador, nombre y precio.
- La clase `Pedido` define la estructura de un pedido hecho por un cliente. Tiene campos para el identificador del pedido, la fecha del pedido y el id del cliente asociado al pedido.

La última clase es `Lineaspedido`, que representa una línea en un pedido específico. Esto incluye detalles como la fecha, el identificador del pedido al que pertenece, el identificador del producto vendido y la cantidad de ese producto en esa línea del pedido.

Es importante notar las referencias a "FK1" y "FK2", que son abreviaturas para claves foráneas (foreign keys en inglés). Estas indican cómo se relacionan estas clases entre sí: por ejemplo, `pedido_id` en la clase `Lineaspedido` hace referencia al `id` de la clase `Pedido`. Esto es crucial para entender las relaciones entre los diferentes objetos del sistema.

```python
from dataclasses import dataclass
from typing import Optional

@dataclass
class Cliente:
    id: Optional[int] = None
    nombre: Optional[str] = None
    apellidos: Optional[str] = None

@dataclass
class Producto:
    id: Optional[int] = None
    nombre: Optional[str] = None
    precio: Optional[str] = None

@dataclass
class Pedido:
    id: Optional[int] = None
    fecha: Optional[str] = None
    cliente_id: Optional[int] = None

    # FK1: cliente_id -> cliente.id

@dataclass
class Lineaspedido:
    id: Optional[int] = None
    fecha: Optional[str] = None
    pedido_id: Optional[int] = None
    producto_id: Optional[int] = None
    cantidad: Optional[str] = None

    # FK1: pedido_id -> pedido.id
    # FK2: producto_id -> producto.id
```

### diagrama

#### Explicación

Este fragmento de código es una representación en SVG (Scalable Vector Graphics) de un diagrama que muestra la interacción entre diferentes elementos tecnológicos. En el centro del diagrama, puedes ver varios rectángulos con bordes y rellenos específicos, cada uno etiquetado con nombres como "python", "flask", "html" y "json". Estos rectángulos representan componentes o servicios en un sistema de software.

Además de los rectángulos, hay líneas curvas (definidas por el elemento `<path>`) que conectan estos rectángulos. Cada línea tiene una flecha al final que indica la dirección del flujo o interacción entre los elementos. Estas líneas y sus flechas ayudan a entender cómo se relacionan entre sí los componentes mostrados en el diagrama.

Este tipo de representación gráfica es importante porque proporciona una visión clara y simplificada de sistemas complejos, lo que facilita su comprensión para estudiantes y desarrolladores.

```
<svg xmlns="http://www.w3.org/2000/svg" width="374" height="248.69998168945307" viewBox="0 0 374 248.69998168945307">

  <defs>
    <style>
      text { font-family: system-ui, -apple-system, "Segoe UI", sans-serif; font-size: 12px; fill: #111827; }
      .shape-rect { fill: #ffffff; stroke: #9ca3af; stroke-width: 1; }
      .shape-entity { fill: #ffffff; stroke: #111827; stroke-width: 2; }
      .shape-circle { fill: #ffffff; stroke: #9ca3af; stroke-width: 1; }
      .shape-pill { fill: #ffffff; stroke: #9ca3af; stroke-width: 1; }
      .shape-db { fill: #ffffff; stroke: #9ca3af; stroke-width: 1; }
      .conn { stroke: #111827; stroke-width: 2; fill: none; }
    </style>
    <marker id="arrow-end" markerWidth="10" markerHeight="7" refX="10" refY="3.5"
            orient="auto" markerUnits="strokeWidth">
      <polygon points="0 0, 10 3.5, 0 7" fill="#111827"/>
    </marker>
    <marker id="arrow-start" markerWidth="10" markerHeight="7" refX="0" refY="3.5"
            orient="auto" markerUnits="strokeWidth">
      <polygon points="10 0, 0 3.5, 10 7" fill="#111827"/>
    </marker>
  </defs>
        
<rect class="shape-rect" x="133.43749999999994" y="168.69998168945307" width="119.99999999999994" height="39.999999999999986" rx="4" ry="4" />
<text x="193.43749999999991" y="192.69998168945307" text-anchor="middle">python</text>
<rect class="shape-rect" x="132.99999999999994" y="128.49999999999994" width="119.99999999999994" height="39.99998855590819" rx="4" ry="4" />
<text x="192.99999999999991" y="152.49999427795404" text-anchor="middle">flask</text>
<rect class="shape-rect" x="40" y="41" width="119.99999999999994" height="39.999999999999986" rx="4" ry="4" />
<text x="99.99999999999997" y="65" text-anchor="middle">html (en/)</text>
<rect class="shape-rect" x="214" y="40" width="119.99999999999994" height="39.999999999999986" rx="4" ry="4" />
<text x="274" y="63.99999999999999" text-anchor="middle">json (/api)</text>
<path class="conn" d="M 171.742861834468 128.49999999999994 L 121.25714424724976 80.99999999999997" marker-end="url(#arrow-end)" />
<path class="conn" d="M 211.30508069216717 128.49999999999994 L 255.69491407070575 79.99999999999997" marker-end="url(#arrow-end)" />
<path class="conn" d="M 214 60.34482758620686 L 160 60.65517241379308" marker-end="url(#arrow-end)" />
</svg>
```

### Actividades propuestas

Aquí tienes una revisión y explicación de los archivos proporcionados:

### Diagrama HTML (diagrama.html)
El archivo `diagrama.html` contiene un diagrama simple con cuatro cuadrados que representan diferentes tecnologías o elementos del sistema:
1. **Python**: Situado en la parte inferior derecha.
2. **Flask**: Sobre el bloque de Python.
3. **HTML (en/)**: En la parte izquierda inferior.
4. **JSON (/api)**: A la derecha y un poco más arriba que HTML.

### Diagrama JSON (diagrama.json)
El archivo `diagrama.json` contiene una representación en formato JSON del mismo diagrama:
- **Formas**: Representan los bloques cuadrados.
- **Flechas**: Indican las conexiones entre estos elementos. 

La estructura es bastante simple y lineal.

### Diagrama SVG (diagrama.svg)
El archivo `diagrama.svg` contiene un diagrama en formato vectorial que muestra los mismos cuatro elementos con flechas de conexión:
1. **Python**
2. **Flask** 
3. **HTML (en/)** 
4. **JSON (/api)**
   
Las conexiones entre estos elementos están representadas mediante líneas de diferentes direcciones.

### Diagrama Python (diagrama.py)
El archivo `diagrama.py` contiene definiciones de clases que representan una base de datos simple:

- **Cliente**: Tiene atributos `id`, `nombre`, y `apellidos`.
- **Producto**: Contiene `id`, `nombre`, y `precio`.
- **Pedido**: Incluye `id`, `fecha`, y un campo `cliente_id` con una clave foránea que referencia al cliente.
- **Lineaspedido** (o "líneas de pedido"): Tiene atributos como `id`, `fecha`, `pedido_id`, y `producto_id`. Este último es una clave foránea que se asocia a la tabla Producto, mientras que `pedido_id` se refiere a un Pedido.

### Descripción del Modelo
- **Cliente** y **Producto**: Son entidades básicas con información de identificación.
- **Pedido**: Relacionado directamente con el Cliente a través de una clave foránea (`cliente_id`).
- **Lineaspedido**: Representa las líneas individuales dentro de un pedido, relacionada tanto con Pedidos como con Productos.

### Conclusión
El conjunto de archivos proporcionados incluye representaciones gráficas del sistema (HTML, JSON, SVG) y una implementación básica en Python que es semánticamente coherente con estas representaciones. El modelo de clases define cómo podrían estructurarse los datos en un sistema que usa esta arquitectura.

Este conjunto de archivos parece ser la base para el desarrollo de un pequeño sistema web que maneja pedidos, productos y clientes, probablemente usando Flask (o alguna otra biblioteca o marco similar) como framework backend.


<a id="composicion-de-clases"></a>
## Composición de clases

### una primera clase

```python
class Alumno():
  def __init__(self,nombre,apellidos,email):
    self.nombre = nombre
    self.apellidos = apellidos
    self.email = email
    
alumno1 = Alumno("Jose Vicente","Carratala","info@jocarsa.com")
print(alumno1)
```

### una segunda clase

```python
class Profesor():
  def __init__(self,nombre,apellidos,email):
    self.nombre = nombre
    self.apellidos = apellidos
    self.email = email

class Alumno():
  def __init__(self,nombre,apellidos,email):
    self.nombre = nombre
    self.apellidos = apellidos
    self.email = email
    
alumno1 = Alumno("Jose Vicente","Carratala","info@jocarsa.com")
print(alumno1)

profesor1 = Profesor("Juan","Garcia","juan@jocarsa.com")
print(profesor1)
```

### polimorfismo basico

```python
class Profesor():
  def __init__(self,nombre,apellidos,email):
    self.nombre = nombre
    self.apellidos = apellidos
    self.email = email
  def dameDatos(self):
    return self.nombre+self.apellidos

class Alumno():
  def __init__(self,nombre,apellidos,email):
    self.nombre = nombre
    self.apellidos = apellidos
    self.email = email
  def dameDatos(self):
    return self.nombre+self.apellidos
    
alumno1 = Alumno("Jose Vicente","Carratala","info@jocarsa.com")
print(alumno1.dameDatos())

profesor1 = Profesor("Juan","Garcia","juan@jocarsa.com")
print(profesor1.dameDatos())
```

### superclase

```python
class Persona():
  def __init__(self,nombre,apellidos,email,direccion):
    self.nombre = nombre
    self.apellidos = apellidos
    self.email = email
    self.direccion = direccion
  def dameDatos(self):
    return self.nombre+self.apellidos

class Profesor(Persona):
  def __init__(self,nombre,apellidos,email,direccion):
  	super().__init__(nombre, apellidos, email,direccion)
  
class Alumno(Persona):
  def __init__(self,nombre,apellidos,email,direccion):
    super().__init__(nombre, apellidos, email,direccion)
  
    
alumno1 = Alumno("Jose Vicente","Carratala","info@jocarsa.com","Direccion")
print(alumno1.dameDatos())

profesor1 = Profesor("Juan","Garcia","juan@jocarsa.com","Direccion")
print(profesor1.dameDatos())
```

### subclases

```python
class Persona():
  def __init__(self,nombre,apellidos,email,direccion):
    self.nombre = nombre
    self.apellidos = apellidos
    self.email = email
    self.direccion = direccion
  def dameDatos(self):
    return self.nombre+self.apellidos

class Profesor(Persona):
  def __init__(self,nombre,apellidos,email,direccion):
  	super().__init__(nombre, apellidos, email,direccion)
  
class Alumno(Persona):
  def __init__(self,nombre,apellidos,email,direccion):
    super().__init__(nombre, apellidos, email,direccion)

class AlumnoOnline(Alumno):
  def __init__(self,nombre,apellidos,email,direccion):
    super().__init__(nombre, apellidos, email,direccion)

class AlumnoPresencial(Alumno):
  def __init__(self,nombre,apellidos,email,direccion):
    super().__init__(nombre, apellidos, email,direccion)
    
alumno1 = Alumno("Jose Vicente","Carratala","info@jocarsa.com","Direccion")
print(alumno1.dameDatos())

profesor1 = Profesor("Juan","Garcia","juan@jocarsa.com","Direccion")
print(profesor1.dameDatos())
```

### diagrama

```html
<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>Diagrama exportado</title>
<style>
body {
  margin: 0;
  padding: 20px;
  background: #f3f3f7;
  font-family: system-ui, -apple-system, "Segoe UI", sans-serif;
}
.page {
  position: relative;
  background: #ffffff;
  border: 1px solid #d1d5db;
  box-shadow: 0 2px 4px rgba(0,0,0,.1);
  width: 590.5375332302516px;
  height: 305.56251525878895px;
  overflow: visible;
}

/* formas básicas */
.shape {
  position: absolute;
  min-width: 120px;
  min-height: 40px;
  padding: 6px 10px;
  background: #ffffff;
  border-radius: 4px;
  border: 1px solid #9ca3af;
  box-shadow: 0 1px 2px rgba(0,0,0,0.15);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 13px;
}

.shape.rectangle {
  border-radius: 4px;
}

.shape.pill {
  border-radius: 999px;
}

.shape.circle {
  border-radius: 999px;
  width: 80px;
  height: 80px;
  padding: 0;
  justify-content: center;
}

/* base de datos */
.shape.db {
  min-width: 120px;
  min-height: 60px;
  padding-top: 20px;
  border-radius: 60px / 16px;
  background: linear-gradient(180deg, #e5e7eb 0%, #ffffff 40%, #e5e7eb 100%);
  position: absolute;
  overflow: hidden;
  text-align: center;
}
.shape.db::before {
  content: "";
  position: absolute;
  top: 0;
  left: 8px;
  right: 8px;
  height: 18px;
  border-radius: 999px;
  border: 1px solid #9ca3af;
  background: radial-gradient(circle at 50% 30%, #ffffff 0%, #e5e7eb 70%);
}
.shape.db::after {
  content: "";
  position: absolute;
  bottom: 0;
  left: 8px;
  right: 8px;
  height: 18px;
  border-radius: 999px;
  border: 1px solid rgba(156, 163, 175, 0.6);
  border-top: none;
  background: radial-gradient(circle at 50% 70%, #e5e7eb 0%, #d1d5db 70%);
}

/* entidades ER */
.shape.entity {
  width: 220px;
  min-height: 80px;
  background: #ffffff;
  border: 2px solid #111827;
  border-radius: 4px;
  box-shadow: 0 2px 4px rgba(0,0,0,.15);
  display: flex;
  flex-direction: column;
  font-size: 13px;
  overflow: hidden;
  padding: 0;
}
.entity-header {
  background: #f3f4f6;
  padding: 4px 8px;
  font-weight: 600;
  text-align: center;
  border-bottom: 1px solid #e5e7eb;
}
.entity-properties {
  flex: 1;
  padding: 4px 4px 0 4px;
}
.entity-property {
  display: grid;
  grid-template-columns: 14px 1fr 14px;
  align-items: center;
  column-gap: 4px;
  padding: 2px 0;
}
.entity-property .property-name {
  padding: 2px 4px;
  border-radius: 3px;
}

/* puertos */
.port {
  width: 9px;
  height: 9px;
  border-radius: 50%;
  border: 1px solid #111827;
  background: #ffffff;
}
.port-left { justify-self: start; }
.port-right { justify-self: end; }

/* flechas rectas */
.arrow {
  position: absolute;
  height: 2px;
  background: #111827;
  transform-origin: 0 50%;
}
.arrow::after {
  content: "";
  position: absolute;
  right: 0;
  top: 50%;
  transform: translateY(-50%);
  border-top: 5px solid transparent;
  border-bottom: 5px solid transparent;
  border-left: 8px solid #111827;
}
.arrow-double::before {
  content: "";
  position: absolute;
  left: 0;
  top: 50%;
  transform: translateY(-50%) rotate(180deg);
  border-top: 5px solid transparent;
  border-bottom: 5px solid transparent;
  border-left: 8px solid #111827;
}

/* flechas ortogonales */
.ortho-arrow {
  position: absolute;
  left: 0;
  top: 0;
}
.ortho-arrow .ortho-seg {
  position: absolute;
  background: #111827;
}
.ortho-seg.seg-horizontal { height: 2px; }
.ortho-seg.seg-vertical { width: 2px; }
.ortho-arrowhead {
  position: absolute;
  width: 0;
  height: 0;
}
.ortho-arrowhead.dir-right {
  border-top: 5px solid transparent;
  border-bottom: 5px solid transparent;
  border-left: 8px solid #111827;
}
.ortho-arrowhead.dir-left {
  border-top: 5px solid transparent;
  border-bottom: 5px solid transparent;
  border-right: 8px solid #111827;
}
.ortho-arrowhead.dir-down {
  border-left: 5px solid transparent;
  border-right: 5px solid transparent;
  border-top: 8px solid #111827;
}
.ortho-arrowhead.dir-up {
  border-left: 5px solid transparent;
  border-right: 5px solid transparent;
  border-bottom: 8px solid #111827;
}
</style>
</head>
<body>
<div class="page">

<div class="shape rectangle" style="left:184.43754408094605px;top:40px;width:119.99994913736974px;height:39.999999999999986px;">Persona</div>
<div class="shape rectangle" style="left:40px;top:134.4625091552734px;width:120.00002543131505px;height:39.999999999999986px;">Profesor</div>
<div class="shape rectangle" style="left:310.5500115288627px;top:137.77502271864145px;width:119.99999999999996px;height:39.999999999999986px;">Alumno</div>
<div class="shape rectangle" style="left:226.10004001193568px;top:225.56251525878898px;width:126.11246744791661px;height:39.999999999999986px;">AlumnoPresencial</div>
<div class="shape rectangle" style="left:430.5375332302516px;top:220.54998609754765px;width:119.99999999999996px;height:39.999999999999986px;">AlumnoOnline</div>
<div class="arrow" style="left:213.85660200331301px;top:79.99999999999997px;width:99.50378162339078px;transform:rotate(2.5624087757364773rad);"></div>
<div class="arrow" style="left:270.23398268976405px;top:79.99999999999997px;width:94.29272924232689px;transform:rotate(0.6594975025112086rad);"></div>
<div class="arrow" style="left:352.00665519464565px;top:177.77502271864145px;width:65.16714600671723px;transform:rotate(2.3184201262342294rad);"></div>
<div class="arrow" style="left:399.5412709153853px;top:177.77502271864145px;width:75.32806834248883px;transform:rotate(0.6038902262109669rad);"></div>
</div>
</body>
</html>
```

### diagrama

```json
{
  "formas": [
    {
      "id": "forma-1",
      "tipo": "rectangle",
      "left": "530.842px",
      "top": "204.043px",
      "width": "",
      "height": "",
      "texto": "Persona"
    },
    {
      "id": "forma-2",
      "tipo": "rectangle",
      "left": "386.408px",
      "top": "298.5px",
      "width": "",
      "height": "",
      "texto": "Profesor"
    },
    {
      "id": "forma-3",
      "tipo": "rectangle",
      "left": "656.954px",
      "top": "301.824px",
      "width": "",
      "height": "",
      "texto": "Alumno"
    },
    {
      "id": "forma-4",
      "tipo": "rectangle",
      "left": "572.504px",
      "top": "389.603px",
      "width": "",
      "height": "",
      "texto": "AlumnoPresencial"
    },
    {
      "id": "forma-5",
      "tipo": "rectangle",
      "left": "776.939px",
      "top": "384.599px",
      "width": "",
      "height": "",
      "texto": "AlumnoOnline"
    }
  ],
  "flechas": [
    {
      "desde": {
        "shapeId": "forma-1",
        "propId": null,
        "side": null
      },
      "hasta": {
        "shapeId": "forma-2",
        "propId": null,
        "side": null
      },
      "tipo": "simple",
      "estilo": "straight"
    },
    {
      "desde": {
        "shapeId": "forma-1",
        "propId": null,
        "side": null
      },
      "hasta": {
        "shapeId": "forma-3",
        "propId": null,
        "side": null
      },
      "tipo": "simple",
      "estilo": "straight"
    },
    {
      "desde": {
        "shapeId": "forma-3",
        "propId": null,
        "side": null
      },
      "hasta": {
        "shapeId": "forma-4",
        "propId": null,
        "side": null
      },
      "tipo": "simple",
      "estilo": "straight"
    },
    {
      "desde": {
        "shapeId": "forma-3",
        "propId": null,
        "side": null
      },
      "hasta": {
        "shapeId": "forma-5",
        "propId": null,
        "side": null
      },
      "tipo": "simple",
      "estilo": "straight"
    }
  ]
}
```

### diagrama

```
<svg xmlns="http://www.w3.org/2000/svg" width="590.5375332302516" height="305.56251525878895" viewBox="0 0 590.5375332302516 305.56251525878895">

  <defs>
    <style>
      text { font-family: system-ui, -apple-system, "Segoe UI", sans-serif; font-size: 12px; fill: #111827; }
      .shape-rect { fill: #ffffff; stroke: #9ca3af; stroke-width: 1; }
      .shape-entity { fill: #ffffff; stroke: #111827; stroke-width: 2; }
      .shape-circle { fill: #ffffff; stroke: #9ca3af; stroke-width: 1; }
      .shape-pill { fill: #ffffff; stroke: #9ca3af; stroke-width: 1; }
      .shape-db { fill: #ffffff; stroke: #9ca3af; stroke-width: 1; }
      .conn { stroke: #111827; stroke-width: 2; fill: none; }
    </style>
    <marker id="arrow-end" markerWidth="10" markerHeight="7" refX="10" refY="3.5"
            orient="auto" markerUnits="strokeWidth">
      <polygon points="0 0, 10 3.5, 0 7" fill="#111827"/>
    </marker>
    <marker id="arrow-start" markerWidth="10" markerHeight="7" refX="0" refY="3.5"
            orient="auto" markerUnits="strokeWidth">
      <polygon points="10 0, 0 3.5, 10 7" fill="#111827"/>
    </marker>
  </defs>
        
<rect class="shape-rect" x="184.43754408094605" y="40" width="119.99994913736974" height="39.999999999999986" rx="4" ry="4" />
<text x="244.43751864963093" y="63.99999999999999" text-anchor="middle">Persona</text>
<rect class="shape-rect" x="40" y="134.4625091552734" width="120.00002543131505" height="39.999999999999986" rx="4" ry="4" />
<text x="100.00001271565753" y="158.4625091552734" text-anchor="middle">Profesor</text>
<rect class="shape-rect" x="310.5500115288627" y="137.77502271864145" width="119.99999999999996" height="39.999999999999986" rx="4" ry="4" />
<text x="370.5500115288627" y="161.77502271864145" text-anchor="middle">Alumno</text>
<rect class="shape-rect" x="226.10004001193568" y="225.56251525878898" width="126.11246744791661" height="39.999999999999986" rx="4" ry="4" />
<text x="289.156273735894" y="249.56251525878898" text-anchor="middle">AlumnoPresencial</text>
<rect class="shape-rect" x="430.5375332302516" y="220.54998609754765" width="119.99999999999996" height="39.999999999999986" rx="4" ry="4" />
<text x="490.5375332302516" y="244.54998609754765" text-anchor="middle">AlumnoOnline</text>
<path class="conn" d="M 213.85660200331301 79.99999999999997 L 130.58092936197556 134.4625091552734" marker-end="url(#arrow-end)" />
<path class="conn" d="M 270.23398268976405 79.99999999999997 L 344.7535474887296 137.77502271864145" marker-end="url(#arrow-end)" />
<path class="conn" d="M 352.00665519464565 177.77502271864145 L 307.69963007011097 225.56251525878898" marker-end="url(#arrow-end)" />
<path class="conn" d="M 399.5412709153853 177.77502271864145 L 461.54627384372895 220.54998609754765" marker-end="url(#arrow-end)" />
</svg>
```


<a id="herencia-y-polimorfismo"></a>
## Herencia y polimorfismo

### herencia simple

```python
class Persona():
  def __init__(self,nombre,apellidos):
    self.nombre = nombre
    self.apellidos = apellidos
  def dameDatos(self):
    return self.nombre+self.apellidos

class Profesor(Persona):
  def __init__(self,nombre,apellidos):
  	super().__init__(nombre, apellidos)
  
class Alumno(Persona):
  def __init__(self,nombre,apellidos,email,direccion):
    super().__init__(nombre, apellidos)

    
alumno1 = Alumno("Jose Vicente","Carratala")
print(alumno1.dameDatos())

profesor1 = Profesor("Juan","Garcia")
print(profesor1.dameDatos())
```

### polimorfismo basico

```python
class Persona():
  def __init__(self,nombre,apellidos):
    self.nombre = nombre
    self.apellidos = apellidos
  def dameDatos(self):
    return self.nombre+self.apellidos

class Profesor(Persona):
  def __init__(self,nombre,apellidos):
  	super().__init__(nombre, apellidos)
  def dameDatos(self):
    return "Profesor: "+self.nombre+" "+self.apellidos
  
class Alumno(Persona):
  def __init__(self,nombre,apellidos):
    super().__init__(nombre, apellidos)
  def dameDatos(self):
    return "Alumno: "+self.nombre+" "+self.apellidos

    
alumno1 = Alumno("Jose Vicente","Carratala")
print(alumno1.dameDatos())

profesor1 = Profesor("Juan","Garcia")
print(profesor1.dameDatos())
```


<a id="jerarquia-de-clases-superclases-y-subclases"></a>
## Jerarquía de clases Superclases y subclases


<a id="clases-y-metodos-abstractos-y-finales"></a>
## Clases y métodos abstractos y finales


<a id="interfaces"></a>
## Interfaces


<a id="sobreescritura-de-metodos"></a>
## Sobreescritura de métodos


<a id="constructores-y-herencia"></a>
## Constructores y herencia



<a id="mantenimiento-de-la-persistencia-de-los-objetos"></a>
# Mantenimiento de la persistencia de los objetos

<a id="bases-de-datos-orientadas-a-objetos"></a>
## Bases de datos orientadas a objetos


<a id="caracteristicas-de-las-bases-de-datos-orientadas-a-objetos"></a>
## Características de las bases de datos orientadas a objetos


<a id="instalacion-del-gestor-de-bases-de-datos"></a>
## Instalación del gestor de bases de datos


<a id="creacion-de-bases-de-datos"></a>
## Creación de bases de datos


<a id="mecanismos-de-consulta"></a>
## Mecanismos de consulta


<a id="el-lenguaje-de-consultas-sintaxis-expresiones-operadores"></a>
## El lenguaje de consultas sintaxis, expresiones, operadores


<a id="recuperacion-modificacion-y-borrado-de-informacion"></a>
## Recuperación, modificación y borrado de información


<a id="tipos-de-datos-objeto-atributos-y-metodos"></a>
## Tipos de datos objeto; atributos y métodos


<a id="tipos-de-datos-coleccion"></a>
## Tipos de datos colección



<a id="gestion-de-bases-de-datos"></a>
# Gestión de bases de datos

<a id="acceso-a-bases-de-datos-estandares-caracteristicas"></a>
## Acceso a bases de datos. Estándares. Características


<a id="establecimiento-de-conexiones"></a>
## Establecimiento de conexiones

### Introducción a los ejercicios

En esta sección de ejercicios, te enfocarás en el establecimiento de conexiones con bases de datos utilizando lenguajes de programación como Python o PHP. El objetivo principal es que comprendas cómo configurar y abrir una conexión a una base de datos, manejar errores relacionados con la conexión y finalmente cerrarla adecuadamente. A través de este ejercicio, mejorarás tus habilidades en la gestión de bases de datos, lo que incluye la importancia de las buenas prácticas para asegurar la seguridad y eficiencia del sistema.

### ejercicio

#### Explicación

El fragmento de código que has proporcionado no contiene realmente ninguna instrucción o bloque de código específico para analizar, solo una etiqueta "Ejercicio" en formato Markdown. Esto probablemente es el título o la cabecera de un ejercicio dentro de un archivo de texto estructurado con Markdown. En este contexto, es importante entender que Markdown es un lenguaje ligero de marcado utilizado principalmente para dar estilo a documentos y páginas web sin necesidad de utilizar HTML. Aquí, "Ejercicio" simplemente indica que el contenido posterior a esta línea va a ser parte del desarrollo o explicación de algún ejercicio relacionado con la gestión de bases de datos y establecimiento de conexiones en el contexto del archivo mencionado.

En un entorno de aprendizaje como el DAM (Desarrollo de Aplicaciones Multiplataforma), este tipo de estructura ayuda a los estudiantes a organizar su trabajo, identificando claramente las diferentes secciones o partes de tareas que deben completar. Es fundamental para la planificación y ejecución ordenada del trabajo en proyectos relacionados con bases de datos y programación web.

```markdown
Ejercicio
```

### Actividades propuestas

### Actividad 1: Conexión a una Base de Datos Simulada
**Descripción:** Los estudiantes deben crear y probar una conexión con una base de datos simulada o local. Se espera que aprendan cómo establecer correctamente las credenciales, manejar excepciones y verificar la conexión.

### Actividad 2: Consulta Básica en SQL
**Descripción:** A través de un ejercicio práctico, los estudiantes realizarán consultas básicas en una base de datos existente. El objetivo es familiarizarse con el uso de comandos SELECT y entender cómo recuperar datos desde la base de datos.

### Actividad 3: Creación y Uso de Tablas
**Descripción:** Los alumnos deben crear tablas nuevas en una base de datos, definir sus columnas e insertar registros. Esta actividad busca que comprendan las estructuras de tabla y los tipos de datos en SQL.

### Actividad 4: Manejo de Excepciones durante Conexiones
**Descripción:** A partir de ejemplos proporcionados, los estudiantes tendrán que identificar y resolver problemas comunes relacionados con la conexión a una base de datos, como errores de autenticación o falta de recursos. Esto les permitirá mejorar su capacidad para depurar.

### Actividad 5: Ejecución de Consultas Parametrizadas
**Descripción:** Se les pedirá que utilicen consultas parametrizadas para prevenir la inyección SQL y manipular los datos seguramente en una base de datos. Los estudiantes aprenderán a proteger sus aplicaciones web contra ataques.

### Actividad 6: Cierre Correcto de Conexiones
**Descripción:** El objetivo es que los alumnos aprendan cómo cerrar adecuadamente las conexiones con la base de datos para liberar recursos y evitar problemas de rendimiento. Se enfatizará la importancia del manejo correcto de objetos.

### Actividad 7: Creación de Procedimientos Almacenados
**Descripción:** Los estudiantes crearán procedimientos almacenados en una base de datos, combinando múltiples sentencias SQL y operaciones CRUD (Create, Read, Update, Delete). Esto les ayudará a dominar la programación orientada a bases de datos.

### Actividad 8: Uso de Librerías de Conexión
**Descripción:** A través del uso de librerías específicas para conectarse con bases de datos SQL en un entorno de desarrollo, los estudiantes aprenderán cómo configurar y utilizar estas herramientas para facilitar el trabajo con las bases de datos.

### Actividad 9: Pruebas Unitarias para Conexiones
**Descripción:** Se pide a los alumnos que escriban pruebas unitarias básicas para asegurar la correcta conexión y operación en una base de datos. Esto les permitirá entender cómo verificar el funcionamiento de sus aplicaciones.

### Actividad 10: Documentación del Código Relacionado con Bases de Datos
**Descripción:** Los estudiantes deben documentar su código relacionado con la gestión de bases de datos, incluyendo procedimientos y consultas SQL. Esto les ayudará a mejorar sus habilidades de documentación y a mantener un código claro para otros desarrolladores.


<a id="almacenamiento-recuperacion-actualizacion-y-eliminacion-de-informacion-en-bases-de-datos"></a>
## Almacenamiento, recuperación, actualización y eliminación de información en bases de datos



<a id="programacion-en-el-lado-del-servidor"></a>
# Programación en el lado del servidor

<a id="fundamentos"></a>
## Fundamentos

### Introducción a los ejercicios

Este conjunto de ejercicios está diseñado para introducirte al mundo del lado servidor en programación, con un énfasis en PHP. Los problemas abarcan desde la creación básica de archivos PHP que contienen HTML hasta el uso de estructuras más complejas como arrays multidimensionales y clases. A través de estos ejercicios, aprenderás a manipular datos dinámicamente, utilizar operadores lógicos y condicionales, y definir funciones con parámetros. La práctica te permitirá adquirir una comprensión sólida sobre cómo interactuar entre HTML y PHP en un entorno servidor para generar contenido web interactivos.

### diagrama

#### Explicación

Este código es un archivo JSON que describe la estructura de una representación visual, probablemente un diagrama o dibujo hecho en software como Lucidchart o Draw.io. El archivo contiene dos tipos principales de elementos: formas y flechas.

Las formas son rectángulos o círculos que contienen diferentes tecnologías web (como PHP, HTML, JS) y están posicionadas en una cuadrícula con medidas precisas para definir su ubicación exacta en el diagrama. Cada forma tiene un identificador único ("id"), un tipo de figura ("tipo") y coordenadas "left" y "top". Además, algunas formas también tienen texto asociado que indica qué tecnología web representa cada cuadro.

Las flechas son líneas simples que conectan dos formas específicas entre sí, indicando una relación o flujo. Cada flecha tiene un punto de partida ("desde") que se refiere a la identificación única de una forma y un punto de llegada ("hasta"), también con su respectiva identificación. Las flechas son representadas como líneas rectas en este caso.

Este tipo de archivo es importante porque permite a los desarrolladores o diseñadores compartir diagramas complejos de manera clara y estructurada, sin tener que preocuparse por cómo se dibujan las formas y las flechas. Esto facilita la colaboración y el intercambio de ideas en proyectos web y de programación.

```json
{
  "formas": [
    {
      "id": "forma-1",
      "tipo": "rectangle",
      "left": "366.413px",
      "top": "203.832px",
      "width": "",
      "height": "",
      "texto": "PHP"
    },
    {
      "id": "forma-2",
      "tipo": "rectangle",
      "left": "366.566px",
      "top": "162.493px",
      "width": "",
      "height": "",
      "texto": "HTML"
    },
    {
      "id": "forma-3",
      "tipo": "rectangle",
      "left": "545.524px",
      "top": "330.509px",
      "width": "",
      "height": "",
      "texto": "PHP"
    },
    {
      "id": "forma-4",
      "tipo": "rectangle",
      "left": "547.995px",
      "top": "129.995px",
      "width": "",
      "height": "",
      "texto": "HTML"
    },
    {
      "id": "forma-5",
      "tipo": "rectangle",
      "left": "548.352px",
      "top": "169.63px",
      "width": "",
      "height": "",
      "texto": "JS"
    },
    {
      "id": "forma-6",
      "tipo": "circle",
      "left": "546.189px",
      "top": "229.623px",
      "width": "",
      "height": "",
      "texto": "JSON"
    }
  ],
  "flechas": [
    {
      "desde": {
        "shapeId": "forma-3",
        "propId": null,
        "side": null
      },
      "hasta": {
        "shapeId": "forma-6",
        "propId": null,
        "side": null
      },
      "tipo": "simple",
      "estilo": "straight"
    },
    {
      "desde": {
        "shapeId": "forma-6",
        "propId": null,
        "side": null
      },
      "hasta": {
        "shapeId": "forma-5",
        "propId": null,
        "side": null
      },
      "tipo": "simple",
      "estilo": "straight"
    }
  ]
}
```

### Preparatorio

#### Explicación

Lo siento, pero no has proporcionado ningún fragmento de código para analizar. Por favor, comparte el bloque específico de código que deseas que explique y estaré encantado de ayudarte a entenderlo.

```markdown

```

### cuota de mercado

#### Explicación

Este fragmento de texto en Markdown no contiene código propiamente dicho, sino una descripción comparativa entre Python y PHP desde el punto de vista del uso en programación web. El texto comienza destacando a Python como el lenguaje de programación general más utilizado actualmente, basándose en datos externos que puedes consultar siguiendo los enlaces proporcionados.

Luego, se menciona que aunque Python es muy popular, en el contexto de desarrollo web, PHP ha sido históricamente el lenguaje dominante desde la década de 1990. Sin embargo, también señala algunas críticas hacia PHP y cómo las personas querrían reemplazarlo debido a sus limitaciones percibidas.

Finalmente, se proporciona información sobre la sintaxis básica de PHP: los archivos que contienen código PHP deben tener la extensión ".php". Además, incluye un pequeño detalle histórico indicando que PHP es el acrónimo de "Personal Home Page", lo cual fue su propósito inicial antes de convertirse en un lenguaje ampliamente utilizado para desarrollo web.

```markdown
Python es actualmente el lenguaje de programación general más utilizado
https://www.tiobe.com/tiobe-index/

Resumen: Python es guay

En los servidores web:
PHP reina desde los años 90
Todo el mundo despotrica
Todo el mundo lo quiere matar
Todo el mundo dice que es una mierda
https://w3techs.com/technologies/overview/programming_language

PHP = Personal Home Page

Sintaxis:
Los archivos que contienen PHP, tienen que tener la extensión .php
```

### html en php

#### Explicación

Este fragmento de código no es realmente un bloque de programación en PHP o HTML, sino más bien una explicación textual sobre cómo puede mezclarse el contenido HTML dentro de un archivo con extensión `.php`. Explica que es posible combinar ambos lenguajes en un mismo archivo: puedes tener bloques de código HTML y mostrarlos tal cual en la página web cuando se ejecuta el archivo PHP. El texto también proporciona instrucciones sobre dónde guardar físicamente este tipo de archivos en tu sistema operativo, ya sea Linux o Windows, y cómo acceder a ellos desde un navegador web usando la dirección `http://localhost/`. Esto es importante porque muestra cómo integrar contenido HTML directamente dentro del archivo PHP sin necesidad de usar funciones adicionales para imprimir el HTML.

```
Un archivo PHP puede tener HTML
<p>No, en serio, puede realmente tener HMTL</p>
<p>Un archivo PHP no te obliga a poner PHP</p>

Este archivo debe estar

Linux: /var/www/html/(carpeta que queráis)

Windows: C:/xampp/htdocs/(carpeta que queráis)

Y luego en el navegador:
http://localhost/(carpeta que queráis)

En mi caso concreto:
http://localhost/programaciondam2526/010-Programaci%c3%b3n%20en%20el%20lado%20del%20servidor/001-Fundamentos/101-Ejercicios/003-html%20en%20php.php
```

### Probamos PHP

#### Explicación

Este fragmento de código está escrito en HTML con una inclusión de lenguaje PHP. En la primera línea, se dice explícitamente: "Esto no es PHP", lo cual indica que el texto literal es parte del archivo HTML y no será ejecutado por un motor PHP.

Luego, aparece la directiva `<?php`, que marca el comienzo de una secuencia de código en PHP. Dentro de esta directiva, se utiliza la función `echo` para imprimir la frase "Esto si que es php" en la página web cuando se ejecute. Esto significa que solo este texto será procesado por PHP y aparecerá en la salida del navegador.

Finalmente, después de cerrar el bloque de código PHP con `?>`, cualquier cosa escrita (como "Esto ya no es PHP") volverá a ser considerada como parte del archivo HTML y no será ejecutada por PHP. Es importante entender esta estructura para combinar correctamente contenido estático (HTML) y dinámico (PHP) en un mismo documento.

```
Esto no es PHP

<?php
	echo "Esto si que es php";
?>

Esto ya no es PHP
```

### Que pasa con el repositorio

#### Explicación

Este fragmento de texto proporciona instrucciones sobre cómo manejar los repositorios de código para estudiantes de Formación Profesional. Explica que no es adecuado mover la carpeta del repositorio de GitHub a la carpeta pública, ya que esto podría causar problemas. En su lugar, se sugiere clonar nuevamente el repositorio en la carpeta destinada para publicaciones.

Sin embargo, el texto también indica que esta práctica más correcta no es necesaria inmediatamente y sugiere una solución temporal: trabajar en la carpeta local de Apache durante las clases y copiar el contenido final a su ubicación real al terminar. Esto ayuda a mantener el flujo del trabajo sin complicaciones técnicas mientras se aprenden conceptos básicos.

Esta guía es importante porque enseña a los estudiantes sobre buenas prácticas en control de versiones y manejo de archivos, aunque inicialmente se les permite seguir un camino más sencillo para centrarse en la programación básica antes de introducir complejidades adicionales.

```markdown
Todos estáis queriendo meter vuestro repositorio 
en la carpeta de publicación

Eso me parece muy bien

No debéis mover la carpeta de GitHub, porque a GitHub no le gustará
Deberíais romper el clon, y volver a clonar de nuevo en la carpeta de publicación

Eso es deseable a largo plazo, pero no ahora mismo

De momento hoy:
Trabajad en la carpeta de apache
Al final de la clase copiais el contenido a vuestra carpeta real

Y estos proximos dias, lo hacemos "bien"
```

### comentarios en php

#### Explicación

Este fragmento de código es una introducción básica a la programación con PHP, que se utiliza para crear páginas web dinámicas. La función principal del código es mostrar el texto "Hola mundo en PHP" cuando la página se carga en un navegador. En PHP, `echo` es una instrucción que permite imprimir o mostrar texto en pantalla, similar a cómo funciona `print` en Python.

El código también incluye dos tipos de comentarios: uno de línea simple y otro de múltiples líneas. Los comentarios son importantes porque ayudan al programador a entender el propósito del código más tarde o a otros desarrolladores que puedan trabajar con él. Un comentario de una sola línea se inicia con `//`, mientras que los comentarios de varias líneas comienzan con `/*` y terminan con `*/`. En este ejemplo, los comentarios explican brevemente cómo funciona el comando `echo` en PHP y dan ejemplos de cómo usar los dos tipos de comentarios.

```
<?php
	echo "Hola mundo en PHP"; 
  // echo en PHP es como print en Python
  // Esto es un comentario de una única línea
  
  /*
  	Esto es una linea de comentario
    Esto tambien es una linea de comentario
  */
?>
```

### operadores

#### Explicación

Este fragmento de código está escrito en PHP y se encuentra dentro de un archivo llamado `007-operadores.php`. El código muestra el uso básico de varios operadores matemáticos. Cuando este script se ejecuta, imprimirá los resultados de diferentes operaciones aritméticas que involucran los números 4 y 3.

Primero, utiliza la suma (`+`) para sumar 4 y 3, lo que produce 7. Luego resta (`-`) 3 de 4, resultando en 1. A continuación, multiplica (`*`) 4 por 3, dando como resultado 12. Después, divide (`/`) 4 entre 3, produciendo un valor aproximado de 1.33 (dependiendo del formato puede ser exactamente `1.3333` dependiendo de cómo PHP maneje la división). Finalmente, calcula el residuo de dividir 4 por 3 usando el operador módulo (`%`), lo que resulta en un 1, ya que es el resto después de realizar la división.

Este código es importante porque demuestra los fundamentos del cálculo matemático dentro de PHP y ayuda a entender cómo se pueden manipular números para realizar diversas tareas en programación.

```
<?php
	echo 4+3;
  echo 4-3;
  echo 4*3;
  echo 4/3;
  echo 4%3;
?>
```

### romper linea

#### Explicación

Este fragmento de código combina HTML y PHP en un archivo con extensión `.php`. La línea `Esto es HTML<br>` se muestra como contenido puro de HTML, ya que no está entre etiquetas o bloques específicos de PHP. Luego, el código cambia a PHP cuando aparecen las líneas `<<?php echo "Esto es PHP<br>"; ?>`, donde la función `echo` imprime en pantalla el texto "Esto es PHP" seguido de un salto de línea (`<br>`). Después del bloque PHP, vuelve a mostrar contenido HTML con `Esto vuelve a ser HTML<br>`. Es importante entender cómo integrar diferentes lenguajes y marcas de inicio y fin para PHP, ya que esto permite mezclar el contenido dinámico generado por PHP con el estático de HTML en una misma página web.

```
Esto es HTML<br>
<?php
	echo "Esto es PHP<br>";
?>	
Esto vuelve a ser HTML<br>
```

### operadores de comparacion

#### Explicación

Este código es una parte del lenguaje de programación PHP y está diseñado para mostrar cómo funcionan los operadores de comparación. Estos operadores se utilizan para comparar dos valores numéricos o variables y devuelven un resultado que puede ser verdadero (1) o falso (0). En este caso, el código compara el número 4 con el número 3 usando diferentes tipos de operaciones.

Primero, el código muestra si 4 es menor que 3 (`echo 4<3;`), lo cual resulta en un resultado falso porque 4 no es menor a 3. Luego, comprueba si 4 es menor o igual a 3 (`echo 4<=3;`), otra vez devolviendo falso ya que 4 es mayor.

Después, evalúa si 4 es mayor que 3 (`echo 4>3;`) y esto devuelve verdadero. También se comprueba si 4 es mayor o igual a 3 (`echo 4>=3;`), lo cual también resulta en verdadero porque sí cumple la condición.

Finalmente, el código verifica si 4 es exactamente igual a 3 (`echo 4==3;`) y esto devuelve falso ya que los números no son iguales. Por último, se comprueba si 4 es diferente de 3 (`echo 4!=3;`), lo cual resulta en verdadero porque sí hay una diferencia entre ellos.

Este tipo de código es fundamental para entender cómo PHP maneja las comparaciones y es crucial cuando se está desarrollando cualquier lógica que requiera tomar decisiones basadas en la relación entre diferentes valores.

```
<?php
	echo 4<3;
  echo 4<=3;
  echo 4>3;
  echo 4>=3;
  echo 4==3;
  echo 4!=3;
?>
```

### operadores booleanos

#### Explicación

Este código PHP está usando operadores booleanos para evaluar y mostrar resultados en la pantalla. Los operadores que se utilizan son el `&&` (AND) y el `||` (OR). 

En las primeras líneas, cuando todos los valores de comparación con `==` dan verdadero (como 4 igual a 4, 3 igual a 3 y 2 igual a 2), la expresión completa es verdadera. Sin embargo, si un solo operador de comparación da falso en una cadena conectada por `&&`, todo el resultado será falso.

En las líneas siguientes que usan `||` (OR), sólo se necesita que al menos una parte sea verdadera para que la expresión completa sea verdadera. Esto demuestra cómo estas operaciones booleanas permiten combinar múltiples condiciones en una única evaluación, lo cual es útil cuando necesitas tomar decisiones basadas en varios criterios simultáneamente.

Este tipo de código es importante porque te ayuda a entender cómo las aplicaciones web pueden hacer decisiones complejas basándose en varias condiciones lógicas.

```
<?php
	echo 4 == 4 && 3 == 3 && 2 == 2; // Verdadero
  echo 4 == 4 && 3 == 3 && 2 == 1; // Falso
  
  echo 4 == 4 || 3 == 3 || 2 == 2; // Verdadero
  echo 4 == 4 || 3 == 3 || 2 == 1; // Verdadero
  echo 4 == 4 || 3 == 2 || 2 == 1; // Verdadero
  echo 4 == 3 || 3 == 2 || 2 == 1; // Falso
?>
```

### variables

#### Explicación

Este código es un ejemplo sencillo en PHP que muestra cómo declarar, imprimir y modificar una variable. En primer lugar, se declara una variable llamada `$edad` e inicializa su valor con el número `47`. Luego, utiliza la función `echo` para mostrar este valor en pantalla. A continuación, se usa el código HTML `<br>` para insertar un salto de línea, lo que ayuda a separar visualmente los valores mostrados en la página web. Finalmente, el valor de `$edad` cambia a `48`, y nuevamente se imprime este nuevo valor con `echo`. Este ejemplo demuestra cómo las variables pueden ser modificadas fácilmente durante la ejecución del código, lo cual es fundamental para realizar cálculos y manipulaciones dinámicas en programas de servidor.

```
<?php
	$edad = 47; // Las variables se declaran con dolar
  echo $edad; // Podemos hacer echo de variables
  echo "<br>"; // salto de linea
  $edad = 48; // Podemos cambiar el valor de una variable
  echo $edad;
?>
```

### estructura for y calendario

#### Explicación

Este fragmento de código combina HTML y PHP para crear un calendario visual simple que muestra los días del mes. La estructura principal es una página web con estilos básicos definidos en la etiqueta `<style>` dentro de la sección `<head>`. Estos estilos aplican bordes, padding y dimensiones específicas a elementos HTML con la clase "dia", haciendo que cada día aparezca como un cuadrado pequeño.

En el cuerpo del documento (`<body>`), hay una porción de código PHP que usa un bucle `for` para generar 30 cajas (divs) representando los días del mes. Este bucle comienza con `$dia = 1`, y en cada iteración, incrementa $dia hasta llegar a 31 (pero no llega al 31 porque el bucle termina cuando `$dia` es igual o mayor que 31). En cada paso del bucle, PHP imprime un `div` con la clase "dia" y dentro de este div coloca el número correspondiente al día actual en el ciclo.

Esta combinación de HTML y PHP permite generar dinámicamente una representación visual básica del calendario, mostrando los días del mes como elementos separados que pueden ser estilizados fácilmente. Es importante porque demuestra cómo integrar programación en lado del servidor (PHP) con la presentación del contenido web (HTML), permitiendo mayor flexibilidad y control sobre el diseño de sitios web dinámicos.

```
<!doctype html>
<html>
	<head>
  	<style>
    	.dia{border:1px solid black;padding:10px;width:50px;
      height:50px;display:inline-block;}
    </style>
  </head>
  <body>
    <?php
      // El signo de encadenamiento es el . (y eso es superguay)

      for($dia = 1;$dia < 31;$dia++){
        echo "<div class='dia'>".$dia."</div>";
      }
    ?>
  </body>
</html>
```

### if

#### Explicación

Este código es una pequeña parte de un programa en PHP que verifica la edad de una persona y muestra un mensaje diferente dependiendo del resultado. Primero, se establece una variable llamada `$edad` con el valor 47. Luego, utiliza una estructura de control `if` para comprobar si esta edad es menor a 30 años. Si la condición dentro del `if` es verdadera (es decir, si `$edad` fuera por ejemplo 25), entonces imprimiría en pantalla el mensaje "Eres un joven". En este caso específico, como la edad es 47, el programa no mostrará ningún mensaje porque la condición establecida ($edad < 30) no se cumple.

Esta estructura `if` es fundamental en programación ya que permite tomar decisiones basadas en diferentes condiciones durante la ejecución del programa. Es un ejemplo sencillo de cómo controlar el flujo del código según las circunstancias.

```
<?php

	$edad = 47;
  if($edad < 30){
  	echo "Eres un joven";
  }
  
?>
```

### else

#### Explicación

Este fragmento de código es una simple secuencia que evalúa la edad de una persona y muestra un mensaje en consecuencia. En PHP, el lenguaje utilizado aquí, se inicializa una variable llamada `$edad` con el valor 47. Luego, utiliza una estructura condicional `if-else` para comprobar si esta edad es menor a 30 años. Si la condición dentro del `if` (es decir, que la edad sea menor a 30) se cumple, entonces imprimirá "Eres un joven". Sin embargo, en este caso específico, como la edad es mayor o igual a 30 años, el código ejecuta lo que está dentro de la cláusula `else`, y por tanto imprime "Ya no eres un joven". Este tipo de estructura condicional es fundamental en programación para tomar decisiones basadas en diferentes condiciones.

```
<?php

	$edad = 47;
  if($edad < 30){
  	echo "Eres un joven";
  }else{
  	echo "Ya no eres un joven";
  }
  
?>
```

### else if

#### Explicación

Este fragmento de código en PHP es una secuencia lógica que determina la categoría etaria de una persona basándose en su edad. Primero, se establece que la variable `$edad` tiene un valor de 47 años. Luego, el programa evalúa condiciones usando estructuras `if`, `else if` y `else`.

El código comienza preguntando si la edad es menor a 10 años; en ese caso, imprimiría "Eres un niño". Si esta condición no se cumple, el programa pasa al siguiente bloque de `else if` que verifica si la edad está entre 10 y menos de 20 años, en cuyo caso imprime "Eres un adolescente".

Si ninguna de las condiciones anteriores es verdadera, hay otro bloque de `else if` para comprobar si la persona tiene entre 20 y menos de 30 años. Si esto se cumple, el código mostrará "Eres un joven". Finalmente, si todas las condiciones previas son falsas (es decir, que la edad es 30 o más), el programa imprimirá "Ya no eres joven".

Esta estructura ayuda a categorizar claramente diferentes etapas de vida según la edad dada, proporcionando una respuesta específica para cada rango. Es importante porque permite tomar decisiones basadas en rangos específicos de valores y es útil cuando se necesita clasificar datos en varias categorías.

```
<?php

	$edad = 47;
  
  if($edad < 10){
  	echo "Eres un niño";
  }else if($edad >= 10 && $edad < 20){
  	echo "Eres un adolescente";
  }else if($edad >= 20 && $edad < 30){
  	echo "Eres un joven";
  }else{
  	echo "Ya no eres joven";
  }
  
?>
```

### switch

#### Explicación

Este fragmento de código PHP se utiliza para imprimir un mensaje diferente dependiendo del día de la semana especificado en la variable `$dia_de_la_semana`. La estructura `switch` es una herramienta muy útil cuando necesitas comparar la misma variable con múltiples valores posibles. En este caso, el código verifica qué día de la semana ha sido asignado a `$dia_de_la_semana`, y luego imprime un mensaje apropiado para ese día.

Por ejemplo, si `$dia_de_la_semana` es "martes", el código imprimirá: "hoy es el segundo peor día de la semana". Si fuera "viernes", se imprimiría "Por fin es viernes". Esta técnica permite manejar múltiples casos con una estructura clara y concisa, evitando tener que escribir muchas sentencias `if` uno tras otro.

Esta forma de programación es importante porque ayuda a organizar el código de manera lógica y fácil de leer, especialmente cuando hay varias condiciones posibles para evaluar.

```
<?php
	$dia_de_la_semana = "martes";
	switch($dia_de_la_semana){
  	case "lunes":
    	echo "hoy es el peor dia de la semana";
      break;
    case "martes":
    	echo "hoy es el segundo peor día de la semana";
      break;
    case "miercoles":
    	echo "hoy ya estamos a mitad de semana";
      break;
    case "jueves":
    	echo "Ya casi es viernes";
      break;
    case "viernes":
    	echo "Por fin es viernes";
      break;
    case "sábado":
    	echo "Este es el mejor dia de la semana";
      break;
    case "domingo":
    	echo "Parece mentira que mañana ya sea lunes";
      break;
  }

?>
```

### arrays

#### Explicación

Este fragmento de código está escrito en PHP, que es un lenguaje de programación comúnmente utilizado para crear páginas web dinámicas. En este caso, se crea una variable llamada `$frutas` y se le asigna un array (también conocido como lista o conjunto) que contiene tres elementos: 'manzana', 'pera' y 'platano'. El `var_dump()` es una función de PHP que muestra información detallada sobre una variable, incluyendo su tipo y valor. Al ejecutar este código, se mostrará en la página web el contenido del array `$frutas`, lo cual ayuda a los programadores a verificar rápidamente si sus arrays están creados correctamente y contienen los valores esperados.

```
<?php
	$frutas = ['manzana','pera','platano'];
  
  var_dump($frutas);
?>
```

### arrays multidimensionales

#### Explicación

Este código PHP crea una estructura de datos llamada `array multidimensional`, que en este caso es como un cuadro o tabla, pero en formato de datos para el programa. En esta tabla, cada fila representa a una persona y contiene sus nombre, apellido y edad.

El fragmento de código comienza creando la variable `$agenda` con tres subarrays (filas) dentro, donde cada subarray almacena información sobre una persona: su nombre, apellido y edad. Por ejemplo, el primer subarray `["Jose Vicente","Carratala",47]` representa a una persona llamada Jose Vicente Carratala de 47 años.

Después del arreglo se utiliza la función `var_dump()` para mostrar en pantalla toda la información que contiene `$agenda`, incluyendo los tipos de datos y el formato exacto de cómo está estructurado. Esto es muy útil durante la fase de desarrollo para entender claramente cómo estás almacenando tus datos.

Este tipo de estructura de datos es importante porque permite manejar y organizar información compleja de manera eficiente, como cuando necesitas trabajar con listas de contactos o registros de estudiantes que contienen múltiples piezas de información por cada entrada.

```
<?php

	$agenda = [
  	["Jose Vicente","Carratala",47],
    ["Juan","Martinez",45],
    ["Jaime","Lopez",46]
  ];
  
  var_dump($agenda);
  
?>
```

### declarar una funcion

#### Explicación

Este fragmento de código es un ejemplo sencillo en PHP que define una función llamada `diHola`. Una función en programación es como un pequeño programa dentro del programa principal, diseñado para realizar tareas específicas y reutilizables. En este caso, la función `diHola` simplemente muestra el mensaje "Hola como estás" cuando se ejecuta.

La estructura básica de una función en PHP comienza con la palabra clave `function`, seguida por el nombre de la función (`diHola`) y un paréntesis vacío porque no recibe ningún dato. Dentro del bloque de código, entre las llaves `{}`, se encuentra la instrucción `echo "Hola como estás";` que es responsable de imprimir o mostrar el texto en una página web.

Es importante entender funciones como esta porque facilitan organizar y reutilizar pedazos de código que pueden necesitarse varias veces en diferentes partes del programa, mejorando así la eficiencia y mantenibilidad del mismo.

```
<?php
	function diHola(){
  	echo "Hola como estás";
  }
?>
```

### usar la funcion

#### Explicación

Este fragmento de código es un ejemplo sencillo en PHP que muestra cómo se define y utiliza una función. En el lenguaje PHP, las funciones son bloques de código reutilizables que realizan tareas específicas. En este caso, la función `diHola()` no requiere ningún dato para funcionar (no tiene parámetros) y su tarea es muy simple: cuando se llama a ella, imprime en pantalla el texto "Hola como estás". Esto se logra utilizando la función `echo`, que simplemente muestra lo que le indiques entre comillas. Al final del archivo, llamamos a la función `diHola()` con `diHola();` para ejecutar su contenido y ver el mensaje en nuestra página web. Este tipo de estructura es fundamental porque permite organizar el código en partes manejables y reutilizables, lo que hace que las aplicaciones sean más fáciles de mantener y desarrollar.

```
<?php
	function diHola(){
  	echo "Hola como estás";
  }
  
  diHola();
?>
```

### funciones con parametros

#### Explicación

Este fragmento de código es un ejemplo sencillo en PHP que muestra cómo se define y utiliza una función. La función se llama `diHola` y toma un parámetro llamado `$nombre`. Dentro de la función, se usa la instrucción `echo` para mostrar por pantalla el saludo "Hola, [nombre] como estás", donde `[nombre]` es reemplazado por el valor que le pasamos a la función. En este caso, al llamar a la función con `"Jose Vicente"` como argumento, se imprimirá en la página web "Hola, Jose Vicente como estás". Esto demuestra cómo las funciones pueden recibir información y procesarla para generar una salida específica, lo cual es muy útil para organizar el código y reutilizar bloques de código sin tener que repetirlos.

```
<?php
	function diHola($nombre){
  	echo "Hola, ".$nombre." como estás";
  }
  
  diHola("Jose Vicente");
?>
```

### varios parametros

#### Explicación

Este fragmento de código es una función básica en PHP que muestra cómo pasar datos a través de parámetros y utilizarlos dentro de la función. La función se llama `diHola` y recibe dos parámetros: `$nombre`, que representa el nombre de una persona, y `$edad`, que representa su edad. Dentro de la función, se imprime un mensaje personalizado usando estos parámetros para saludar a la persona y mencionar su edad.

Lo importante es entender cómo definir funciones en PHP, pasar información a través de parámetros, e imprimir mensajes utilizando la combinación de texto estático (como "Hola,") con variables que contienen datos dinámicos. Esto permite crear programas más interactivos y personalizados para cada usuario o situación específica.

```
<?php
	function diHola($nombre,$edad){
  	echo "Hola, ".$nombre." tienes ".$edad." años, como estás";
  }
  
  diHola("Jose Vicente",47);
?>
```

### return en la funcion

#### Explicación

Este código es un ejemplo sencillo de cómo funciona una función en PHP. La función se llama `diHola` y recibe dos parámetros: `$nombre`, que es el nombre de la persona, y `$edad`, que indica la edad del mismo individuo. Dentro de la función, se crea un mensaje personalizado que saluda a la persona mencionando su nombre y edad usando una concatenación de cadenas (es decir, combinación de texto y variables).

Cuando llamas a `diHola("Jose Vicente",47)`, estás pasando los valores "Jose Vicente" para el parámetro `$nombre` y 47 para el parámetro `$edad`. La función entonces devuelve una cadena que contiene un saludo amigable y se imprime en la página web gracias a la instrucción `echo`.

Esta práctica es importante porque te enseña cómo definir funciones, pasar argumentos a ellas y devolver valores. Es fundamental para crear scripts más complejos y reutilizables en PHP.

```
<?php
	function diHola($nombre,$edad){
  	return "Hola, ".$nombre." tienes ".$edad." años, como estás";
  }
  
  echo diHola("Jose Vicente",47);
?>
```

### vamos con los gatos

#### Explicación

Este código PHP crea una clase llamada `Gato` que representa a un gato con características como color y edad. La función `__construct` es el constructor de la clase, lo cual se ejecuta cada vez que creamos un nuevo objeto de tipo `Gato`. En este caso, cuando creamos un gato, necesitamos proporcionarle su color y edad.

Después de definir la clase, se crean dos objetos de la clase `Gato`: `$gato1` con el color "Naranja" y 1 año de edad, y `$gato2` con el color "Blanco" y 2 años de edad. La función `var_dump($gato1);` muestra toda la información del objeto `$gato1`, incluyendo su tipo, propiedades y valores.

Este código es importante porque introduce conceptos básicos de orientación a objetos en PHP como clases, objetos, constructores y propiedades de clase. Aprender esto te permitirá crear estructuras más complejas y reutilizables en tus proyectos futuros.

```
<?php

	class Gato{
  	function __construct($color,$edad){
    	$this->color = $color;
      $this->edad = $edad;
    }
  }
  
  $gato1 = new Gato("Naranja",1);
  $gato2 = new Gato("Blanco",2);
  
  var_dump($gato1);

?>
```

### Actividades propuestas

### Actividades Propuestas

#### **Actividad 1: Introducción a PHP**
**Descripción:** Aprender los fundamentos de PHP, incluyendo cómo se ejecuta el código y cómo intercambia información entre HTML. Los estudiantes deben crear un archivo PHP simple que imprima "¡Hola Mundo!" en la página web.

#### **Actividad 2: Uso de Comentarios**
**Descripción:** Aprender a utilizar comentarios tanto para una línea como para múltiples líneas en PHP. Los estudiantes deberán comentar su código y añadir documentación adicional para cada función o bloque de código importante.

#### **Actividad 3: Operaciones Básicas con PHP**
**Descripción:** Practicar operadores aritméticos (suma, resta, multiplicación, división, módulo) en PHP. Los estudiantes deben escribir un programa que realice cálculos básos y los imprima en la página web.

#### **Actividad 4: Condiciones y Control de Flujo**
**Descripción:** Implementar estructuras condicionales (if/else) para manejar lógica compleja. Los estudiantes deben escribir un programa que clasifique a las personas según su edad, usando if, else-if y else.

#### **Actividad 5: Estructura Switch en PHP**
**Descripción:** Utilizar la estructura switch para simplificar el código cuando se necesitan múltiples condiciones de igualdad. Los estudiantes deben crear un programa que identifique el día de la semana basado en una entrada dada.

#### **Actividad 6: Trabajo con Variables**
**Descripción:** Aprender a declarar y manipular variables en PHP. Los estudiantes deberán escribir programas que cambien los valores de las variables y luego impriman dichos cambios.

#### **Actividad 7: Creación de Arrays Simples**
**Descripción:** Introducción a arrays unidimensionales. Los estudiantes deben crear arrays para almacenar listas de elementos (como frutas) e imprimir sus contenidos.

#### **Actividad 8: Trabajo con Arrays Multidimensionales**
**Descripción:** Aprender a trabajar con arrays multidimensionales en PHP, como tablas o matrices. Los estudiantes deberán crear un array que represente una agenda y mostrar su contenido utilizando `var_dump()`.

#### **Actividad 9: Funciones Simples en PHP**
**Descripción:** Crear funciones sin parámetros en PHP para realizar tareas específicas (como imprimir un mensaje). Los estudiantes deben escribir al menos dos funciones simples y llamarlas desde el código principal.

Estas actividades están diseñadas para proporcionar una base sólida sobre los fundamentos de programación en PHP, adaptados al nivel y ritmo adecuado para estudiantes de ciclos formativos.


<a id="get-y-post"></a>
## get y post

### Introducción a los ejercicios

Este conjunto de ejercicios está diseñado para ayudarte a comprender y practicar el manejo de las solicitudes GET y POST en la programación del lado del servidor. A través de una serie de archivos HTML y PHP, aprenderás cómo enviar y recibir datos mediante parámetros en la URL (GET) y formularios (POST), así como cómo validar y procesar esa información de manera segura y eficiente. Los ejercicios también te familiarizarán con el uso de variables superglobales como $_GET y $_POST, y con técnicas básicas de depuración y manejo de errores en PHP.

### repaso de los verbos

#### Explicación

Este fragmento de código no es realmente un código, sino una explicación simplificada de los verbos HTTP más comunes que se utilizan en el desarrollo web. Los verbos HTTP son acciones que indican qué operación debe realizar el servidor cuando recibe una solicitud del cliente.

En este caso, cada verbo HTTP está asociado a una acción específica y a la sentencia SQL correspondiente para manipular datos:

1. **GET**: Este verbo se usa para solicitar información sin modificar los datos existentes en la base de datos. Es como pedir al servidor que te dé algunos datos (SELECT), por ejemplo, obtener detalles sobre un producto.

2. **POST**: Se utiliza para enviar nueva información a ser almacenada en el servidor, es decir, crear un nuevo registro en la base de datos (INSERT). Por ejemplo, cuando envías un formulario con nuevos datos como una nueva cuenta de usuario.

3. **PUT**: Este verbo se emplea para actualizar completamente los datos existentes de un recurso en específico (UPDATE), lo que implica enviar toda la información del objeto al servidor y reemplazar la versión anterior por completo.

4. **DELETE**: Indica que deseas eliminar un recurso específico de la base de datos (DELETE). Por ejemplo, podrías usar este método para borrar permanentemente una cuenta de usuario.

5. **PATCH**: Es similar a PUT pero se utiliza cuando solo necesitas actualizar parte de los datos del objeto en lugar de todo el contenido (UPDATE).

Estos verbos son fundamentales en el desarrollo web ya que permiten interactuar de manera efectiva con los servidores y bases de datos para manejar información de forma segura y eficiente.

```markdown
Los verbos http son:

GET (dame) "SELECT"
POST (toma) "INSERT"
PUT (modificamos) "UPDATE"
DELETE (eliminamos) "DELETE"

PATCH (también modificamos) "UPDATE"
```

### get

#### Explicación

Este código PHP es muy sencillo pero importante para entender cómo manejar información enviada por el usuario desde una página web. Lo que hace este código es esperar que alguien visite esta página con algo llamado "parámetro GET" en la URL, y ese parámetro se llama 'nombre'. En términos simples, si alguien visita tu página con algo como `tuweb.com/002-get.php?nombre=Juan`, el código tomará lo que está después de `?nombre=` (en este caso "Juan") e imprimirá eso en la pantalla. Esto es útil cuando quieres recibir información del usuario sin necesidad de un formulario complicado, simplemente usando la URL.

```
<?php
	// Espera que en la URL haya un parametro llamado nombre
	echo $_GET['nombre'];
?>
```

### formularcion de url

#### Explicación

Este fragmento de texto explica cómo se pueden pasar datos adicionales a una página web a través de su URL. Cuando visitas una página web como `script.php?parametro1=valor1&parametro2=valor2`, estás enviando información extra llamada "parámetros". La parte crucial es que después del signo de interrogación (`?`), cada parámetro está compuesto por una clave y un valor separados por el símbolo `=`. Estos pares clave-valor se utilizan para enviar información específica a la página, como opciones o datos necesarios para su funcionamiento. Los diferentes parámetros se separan entre ellos con el signo ampersand (`&`), permitiendo pasar múltiples piezas de información en una única URL. Esto es muy útil en programación web para enviar datos desde el navegador del usuario al servidor sin tener que usar formularios o métodos más complicados.

```markdown
A una URL se le pueden pasar parámetros

script.php?parametro1=valor1&parametro2=valor2&...

script.php = es el script principal
? = a partir de aqui, empiezan los parámetros
clave=valor = clave es la clave del parámetro, valor es el valor del parámetro
& = espera que te paso más
```

### dos parametros get

#### Explicación

Este fragmento de código es una pequeña parte de un programa en PHP que se utiliza para mostrar información enviada por el cliente a través del método GET en una página web. En concreto, este código imprime dos parámetros: 'nombre' y 'apellidos'. El servidor recoge estos datos desde la URL utilizando la superglobal `$_GET`, que es un array asociativo donde las claves son los nombres de los parámetros enviados por el cliente.

El código primero muestra en pantalla el valor del parámetro 'nombre', luego cambia de línea con `<br>` (un elemento HTML que fuerza un salto de línea), y finalmente muestra el valor del parámetro 'apellidos'. Este tipo de código es importante porque permite a los desarrolladores interactuar directamente con la información enviada por el usuario, lo cual es fundamental para construir formularios o páginas dinámicas en sitios web.

```
<?php
	echo $_GET['nombre'];
  echo "<br>";
  echo $_GET['apellidos'];
?>
```

### formulario

#### Explicación

Este fragmento de código HTML es una forma sencilla donde el usuario puede introducir su nombre. Cuando envías un formulario en un sitio web, este necesita ser procesado por otro archivo PHP (en este caso, "006-post.php") para realizar alguna acción con la información que se ha ingresado.

El método `POST` especifica cómo se enviará la información del formulario al servidor; es más seguro y se utiliza cuando deseas ocultar los datos enviados o cuando estos son grandes. El atributo `name="nombre"` en el elemento `<input>` sirve para identificar qué campo de entrada corresponde al nombre que el usuario ha escrito, permitiendo a "006-post.php" reconocer y manipular ese dato específicamente.

Es importante entender cómo funcionan los formularios y los métodos HTTP como POST porque son fundamentales en la interacción entre el navegador del cliente y el servidor web cuando se recogen datos de los usuarios para almacenarlos o procesarlos.

```html
<form action="006-post.php" method="POST">
  <p>Introduce tu nombre</p>
  <input type="text" name="nombre">
  <input type="submit">
</form>

006-post.php = quien te procesa
POST = como se va a enviar y recibir la informacion
name="nombre" = la clave que se va a enviar
```

### post

#### Explicación

Este fragmento de código PHP muestra cómo recuperar y mostrar información enviada a través del método POST en un formulario web. Cuando los usuarios envían datos mediante un formulario, estos pueden ser enviados usando el método POST, lo cual es más seguro para enviar información sensible como contraseñas o datos personales.

En este caso, `$_POST['nombre']` se utiliza para recuperar el valor que el usuario ingresó en un campo de formulario con el nombre "nombre". Este código simplemente imprime (o muestra) el contenido del campo "nombre" enviado por POST. Es importante usar `$_POST` y no otro método como `$_GET`, ya que la información enviada por GET se muestra en la URL, lo cual puede ser inseguro o no deseable para ciertos tipos de datos.

El uso correcto de `$_POST['clave']` asegura que estás recibiendo exactamente los datos que necesitas desde el formulario HTML correspondiente, y esto es crucial para garantizar que tu programa funcione correctamente y de manera segura.

```
<?php
	echo $_POST['nombre'];
?>

$_POST porque me envían la información por POST
Y la tengo que recoger por la misma vía

'nombre' porque es la clave que se ha enviado desde HTML
```

### autoprocesamiento

#### Explicación

Este código es una pequeña página web en PHP que permite a un usuario introducir su nombre y luego mostrarlo de vuelta. Cuando el usuario completa un formulario con su nombre y presiona "Enviar", la página se actualiza mostrando el nombre que ha escrito.

La parte superior del código (`<?php echo $_POST['nombre']; ?>`) es donde PHP imprime en pantalla el valor que el usuario ingresó en el campo de texto llamado 'nombre'. `$_POST` es una variable especial en PHP que contiene los datos enviados desde un formulario cuando se utiliza el método POST.

El bloque de HTML (`<form>...</form>`) crea un formulario simple donde el usuario puede ingresar su nombre. El formulario tiene dos elementos: un párrafo para dar instrucciones y un campo de texto llamado 'nombre' donde el usuario escribe su nombre. Al final del formulario hay un botón "Enviar" que, cuando se presiona, envía la información al servidor usando el método POST. La parte `action="?"` hace que el formulario se procese en la misma página en la que está.

Este tipo de código es fundamental para entender cómo interactúan los formularios HTML con PHP y cómo enviar datos a través del navegador web. Es importante porque permite crear interfaces interactivas donde los usuarios pueden proporcionar información que luego puedes utilizar en tu programa web.

```
<?php
	echo $_POST['nombre'];
?>

<form action="?" method="POST">
  <p>Introduce tu nombre</p>
  <input type="text" name="nombre">
  <input type="submit">
</form>
```

### php.ini

#### Explicación

Este fragmento de código es una guía sobre cómo localizar y modificar el archivo `php.ini`, que es crucial para configurar las opciones del lenguaje PHP en tu servidor. Dependiendo del sistema operativo (Windows o Linux), la ubicación del archivo `php.ini` varía: en Windows, está en `C:/xampp/php/php.ini`, mientras que en Ubuntu se encuentra en `/etc/php/8.3/apache2/php.ini`. La guía también proporciona una solución para aquellos que no pueden editar el archivo usando gedit (un editor de texto), sugiriendo usar nano mediante el comando `sudo nano /etc/php/8.3/apache2/php.ini`.

Es importante destacar cómo modificar la línea `display_errors = On` para activar la visualización de errores en tiempo real, lo cual es muy útil para depurar código PHP y resolver problemas rápidamente. Una vez que has realizado cambios en el archivo `php.ini`, debes reiniciar el servicio Apache con el comando `sudo service apache2 restart` para que los ajustes tengan efecto.

Esta configuración es vital para cualquier desarrollador de PHP, ya que permite un control preciso sobre cómo PHP se comporta y ejecuta en tu entorno de desarrollo o producción.

```markdown
php.ini en Windows:
C:/xampp/php/php.ini
(Espero que no sea vuestro caso)

En Ubuntu está en:
/etc/php/8.3/apache2/php.ini

Si no os deja modificar con gedit

sudo nano /etc/php/8.3/apache2/php.ini

Comandos:
(Parece que si que deja hacer scroll)
Control + W = Buscar (where)
Control + O = Guardar
Control + X = Salir
Tenéis la ayuda bajo del editor

display_errors = On (cambiad de Off a On)

Cuando se toca el php.ini hay que reiniciar apache

sudo service apache2 restart
```

### comprobacion

#### Explicación

Este fragmento de código es una plantilla PHP que contiene una línea de texto en lugar de un comando válido. La frase "esto da error si o si" no es ninguna instrucción válida en el lenguaje PHP, por lo que provocará un error cuando se intente ejecutar este archivo. En resumen, esta línea está mal escrita y debe ser corregida para que el código funcione correctamente. Es importante detectar estos errores temprano durante la fase de desarrollo para evitar problemas más adelante en el proyecto.

```
<?php
	esto da error si o si
?>
```

### retomamos

#### Explicación

Este código es una combinación de PHP y HTML que permite a un usuario introducir su nombre en un formulario web y luego muestra el nombre introducido por pantalla. La parte del código que está dentro de las etiquetas `<?php ?>` es escrita en PHP, un lenguaje de programación utilizado para generar contenido dinámico en páginas web. En este caso, la línea `echo $_POST['nombre'];` muestra en pantalla el valor almacenado en la variable `$_POST['nombre']`, que contiene el dato enviado por el formulario.

El formulario HTML dentro del código tiene un método especificado como "POST", lo que significa que cuando se envía el formulario, los datos se enviarán a través de este método POST. Esto es importante porque permite enviar información sensible sin mostrarla en la URL (como sucede con GET). El formulario solicita al usuario que introduzca su nombre y después de pulsar el botón "submit", el valor introducido en el campo "nombre" será mostrado por pantalla gracias a la línea PHP `echo $_POST['nombre'];`.

Esta técnica es fundamental para interactuar con los usuarios, permitiéndoles enviar información desde una página web hacia un servidor para procesarla y luego devolver una respuesta. Es particularmente útil para formularios de contacto, registro o inicio de sesión en sitios web.

```
<?php
	echo $_POST['nombre'];
?>

<form action="?" method="POST">
  <p>Introduce tu nombre</p>
  <input type="text" name="nombre">
  <input type="submit">
</form>
```

### comprobacion de existencia

#### Explicación

Este código PHP y HTML está diseñado para comprobar si un formulario enviado por el usuario ha proporcionado una entrada específica. En este caso, el formulario solicita al usuario que introduzca su nombre en un campo de texto. Cuando se envía el formulario mediante el método POST, la página PHP revisa si existe el dato 'nombre' entre los datos enviados.

La línea `if(isset($_POST['nombre']))` comprueba si realmente el usuario ha ingresado un valor en el campo 'nombre'. Si el campo no está vacío (o más precisamente, si se envió con un valor), PHP mostrará ese nombre usando la línea `echo $_POST['nombre']`. Esto es importante porque evita errores y permite que el programa solo haga algo cuando realmente hay datos para trabajar.

Esta práctica de comprobación previa de los valores enviados por el formulario (usando `isset()`) ayuda a asegurar que tu código no trate datos inexistentes o vacíos, lo cual podría causar problemas o errores en la aplicación web.

```
<?php
	// Comprobación de existencia isset
	if(isset($_POST['nombre'])){
		echo $_POST['nombre'];
  }
?>

<form action="?" method="POST">
  <p>Introduce tu nombre</p>
  <input type="text" name="nombre">
  <input type="submit">
</form>
```

### preguntas y respuestas

#### Explicación

Este fragmento de código es un archivo HTML que sirve como una página web simple para permitir a los usuarios introducir preguntas y respuestas. La página tiene una estructura básica con encabezados (`header`), contenido principal (`main`) y pie de página (`footer`). 

En el cuerpo del documento, hay un formulario (`<form>`) que se envía usando el método POST (esto significa que los datos ingresados por el usuario no aparecerán en la URL). El formulario contiene dos campos de entrada: uno para introducir una pregunta y otro para introducir su respuesta. Al enviar el formulario, estos datos serían procesados por el mismo archivo PHP (`preguntas y respuestas.php`), ya que la acción del formulario es "?"

Esta página es importante porque enseña cómo estructurar un diseño básico con CSS (especificado dentro de una etiqueta `<style>` en la cabecera) y cómo crear un formulario que permita a los usuarios enviar datos al servidor para su procesamiento, lo cual es fundamental en el desarrollo web.

```
<!doctype html>
<html>
	<head>
  	<style>
    	body,html{width:100%;height:100%;padding:0px;margin:0px;}
      body{
      	display:flex;align-items:center;justify-content:center;
        background:lightgray;flex-direction:column;}
      header,footer,main{
      	width:400px;padding:20px;background:white;
        text-align:center;
        }
      form{display:flex;flex-direction:column;gap:10px;}
      input{padding:10px;}
    </style>
  </head>
  <body>
  	<header>
  		<h1>Preguntas y respuestas</h1>
    </header>
    <main>
    	<form action="?" method="POST">
      	<label for="pregunta">Introduce la pregunta</label>
      	<input type="text" name="pregunta" id="pregunta">
        <label for="respuesta">Introduce la respuesta</label>
      	<input type="text" name="respuesta" id="respuesta">
        <input type="submit">
      </form>
    </main>
    <footer>
    	(c) 2025 Jose Vicente Carratala
    </footer>
  </body>
</html>
```

### atrapamos la informacion

#### Explicación

Este fragmento de código es una página web simple que utiliza HTML y un poco de PHP para permitir a los usuarios enviar preguntas y respuestas al servidor. La estructura básica del documento incluye estilos CSS integrados en el `<head>` para darle diseño a la página, con elementos centrados y algunos colores básicos.

El corazón del código es un formulario HTML que solicita al usuario que introduzca una pregunta y su respuesta. Cuando se envía este formulario (mediante clic en el botón de "submit"), los datos enviados son recibidos por el mismo archivo PHP gracias a la línea `method="POST"`. Esto significa que los valores ingresados para las preguntas y respuestas se almacenan en el array global `$_POST` de PHP, del cual se extraen los valores específicos mediante `$_POST['pregunta']` y `$_POST['respuesta']`.

Finalmente, la información recibida se imprime directamente en la página web en la parte inferior, dentro del bloque `<footer>`, utilizando comandos PHP que simplemente imprimen (`echo`) el contenido de los campos enviados. Esta práctica es útil para aprender cómo procesar y mostrar datos enviados desde formularios HTML en una página web dinámica, lo cual es crucial para la programación web.

```
<!doctype html>
<html>
	<head>
  	<style>
    	body,html{width:100%;height:100%;padding:0px;margin:0px;}
      body{
      	display:flex;align-items:center;justify-content:center;
        background:lightgray;flex-direction:column;}
      header,footer,main{
      	width:400px;padding:20px;background:white;
        text-align:center;
        }
      form{display:flex;flex-direction:column;gap:10px;}
      input{padding:10px;}
    </style>
  </head>
  <body>
  	<header>
  		<h1>Preguntas y respuestas</h1>
    </header>
    <main>
    	<form action="?" method="POST">
      	<label for="pregunta">Introduce la pregunta</label>
      	<input type="text" name="pregunta" id="pregunta">
        <label for="respuesta">Introduce la respuesta</label>
      	<input type="text" name="respuesta" id="respuesta">
        <input type="submit">
      </form>
    </main>
    <footer>
    	(c) 2025 Jose Vicente Carratala
      <?php
      	echo $_POST['pregunta'];
        echo "<br>";
        echo $_POST['respuesta'];
      ?>
    </footer>
  </body>
</html>
```

### isset

#### Explicación

Este código es una página web simple que permite a los usuarios introducir una pregunta y una respuesta, las cuales se muestran debajo del formulario cuando el usuario envía la información. La página utiliza HTML para estructurar la interfaz de usuario y CSS para darle estilo y hacerla más atractiva.

En el código PHP dentro de la etiqueta `<footer>`, hay un bloque que verifica si los datos enviados por el formulario (con nombre "pregunta" y "respuesta") están presentes en la variable `$_POST`. Si ambos campos están llenos, el código muestra lo que el usuario escribió en cada campo. Esta verificación es crucial para asegurarse de que solo se muestren los datos si realmente fueron enviados por el formulario.

Este tipo de lógica es importante porque permite a las páginas web interactuar con sus usuarios y responder adecuadamente según la entrada que reciban, proporcionando una experiencia más dinámica y personalizada.

```
<!doctype html>
<html>
	<head>
  	<style>
    	body,html{width:100%;height:100%;padding:0px;margin:0px;}
      body{
      	display:flex;align-items:center;justify-content:center;
        background:lightgray;flex-direction:column;}
      header,footer,main{
      	width:400px;padding:20px;background:white;
        text-align:center;
        }
      form{display:flex;flex-direction:column;gap:10px;}
      input{padding:10px;}
    </style>
  </head>
  <body>
  	<header>
  		<h1>Preguntas y respuestas</h1>
    </header>
    <main>
    	<form action="?" method="POST">
      	<label for="pregunta">Introduce la pregunta</label>
      	<input type="text" name="pregunta" id="pregunta">
        <label for="respuesta">Introduce la respuesta</label>
      	<input type="text" name="respuesta" id="respuesta">
        <input type="submit">
      </form>
    </main>
    <footer>
    	(c) 2025 Jose Vicente Carratala
      <?php
      	if(isset($_POST['pregunta']) && isset($_POST['respuesta'])){
          echo $_POST['pregunta'];
          echo "<br>";
          echo $_POST['respuesta'];
        }
      ?>
    </footer>
  </body>
</html>
```

### Actividades propuestas

### Actividad 1: Manejo de Parámetros GET
**Descripción:** Los estudiantes deben crear una página PHP que reciba dos parámetros por URL y los muestre en la página. Este ejercicio les ayudará a comprender cómo manejar datos enviados mediante el método GET.

### Actividad 2: Creación de Formularios HTML con Envío POST
**Descripción:** Los estudiantes deben diseñar un formulario que recoja información del usuario y la envíe utilizando el método POST. Esto permitirá que los alumnos comprendan cómo enviar datos sensibles sin mostrarlos en la URL.

### Actividad 3: Procesamiento de Formularios Autoprocesados
**Descripción:** Los estudiantes deben crear una página PHP con un formulario autoprocesado que recoge y muestra información del usuario sin redirigirse. Esto les enseñará sobre el uso del método POST en formularios.

### Actividad 4: Validación de Datos Recibidos por POST
**Descripción:** Se requiere que los estudiantes validen la existencia de datos enviados mediante POST antes de procesarlos, utilizando la función `isset()`. Esto les ayudará a manejar errores comunes y mejorar la robustez del código.

### Actividad 5: Integración HTML y PHP para Formularios Complejos
**Descripción:** Los estudiantes deben crear una página que contenga un formulario complejo con varios campos de entrada, procesados por PHP. El objetivo es combinar HTML y PHP para manejar datos entrantes de manera efectiva.

### Actividad 6: Configuración del Ambiente de Desarrollo (php.ini)
**Descripción:** Los estudiantes deben aprender a configurar el archivo php.ini en su entorno local de desarrollo, especialmente cómo activar la visualización de errores. Esto les ayudará a depurar problemas técnicos con mayor facilidad.

### Actividad 7: Manejo de Errores y Excepciones
**Descripción:** Los estudiantes deben identificar y corregir un ejemplo dado que contiene errores lógicos en PHP. El objetivo es mejorar la capacidad para detectar y solucionar problemas comunes en el desarrollo web.

### Actividad 8: Integración de Formularios Dinámicos con Validaciones
**Descripción:** Los estudiantes deben crear formularios dinámicos utilizando HTML5 y CSS3, que validan automáticamente los datos del usuario antes de enviarlos al servidor para procesamiento. Esto les enseñará a mejorar la experiencia del usuario y reducir el trabajo en el lado del servidor.

### Actividad 9: Creación de Preguntas y Respuestas Interactivas
**Descripción:** Los estudiantes deben implementar un sistema sencillo que permita introducir preguntas y respuestas mediante formularios, mostrándolas al finalizar. Esto ayudará a comprender cómo integrar múltiples campos en un formulario.

### Actividad 10: Uso de isset para Validar Datos Complejos
**Descripción:** Los estudiantes deben crear una página que recibe varios datos por POST y utiliza `isset()` para validar cada uno de ellos antes de procesarlo. Esto les ayudará a manejar formularios complejos y evitar errores lógicos en el código.


<a id="persistencia"></a>
## Persistencia

### Introducción a los ejercicios

En esta carpeta, encontrarás una serie de ejercicios que te permitirán aprender y practicar la persistencia en el lado del servidor mediante PHP. Los ejercicios abordan temas como la manipulación de archivos y permisos en sistemas UNIX/Linux, así como la interacción con formularios HTML para guardar datos en archivos JSON o texto plano. Estos ejercicios te ayudarán a mejorar tus habilidades en la gestión de datos dinámicos, el manejo de estructuras de datos como arrays asociativos y su conversión a formatos como JSON, además de aprender cómo controlar permisos de archivos para garantizar la seguridad del sistema.

### escribir texto

#### Explicación

Este fragmento de código es una pequeña porción de un programa en PHP que se utiliza para escribir información en un archivo existente o crear uno nuevo si no existe. El código comienza abriendo el archivo llamado "archivo.txt" con la función `fopen()` y especificando que queremos añadir contenido al final del archivo utilizando el modo "a". Luego, con la función `fwrite()`, se escribe una nueva línea de texto ("Nuevo texto escrito desde PHP") en ese archivo. Finalmente, para asegurarse de que todos los cambios se han guardado y cerrar adecuadamente el archivo, se utiliza `fclose()`.

Este tipo de operación es importante porque permite a un programa interactuar con archivos del sistema, permitiendo almacenamiento persistente de datos. En contextos web, esto puede ser útil para guardar información como comentarios de usuarios, logs de errores o cualquier otra cosa que necesite mantenerse después de que el usuario cierre la página.

```
<?php
  $archivo = fopen("archivo.txt", "a"); // "a" = append
  fwrite($archivo, "Nuevo texto escrito desde PHP\n");
  fclose($archivo);
?>
```

### voy a hacer una barbaridad

#### Explicación

Este fragmento de código describe cómo se pueden cambiar los permisos de una carpeta en un sistema operativo basado en Unix, como Linux o macOS. La línea `sudo chmod 777 -R /var/www/html/programaciondam2526` es la instrucción específica que permite al usuario (con privilegios administrativos) modificar los accesos a todos los archivos y subdirectorios dentro del directorio `/var/www/html/programaciondam2526`. Al usar `777`, se otorgan permisos completos de lectura, escritura y ejecución para el propietario, grupo y otros usuarios.

Es importante entender que asignar permisos 777 a una carpeta es una práctica generalmente no recomendada en entornos de producción debido a los riesgos de seguridad. En su lugar, se sugieren configuraciones más restrictivas como `755` o `644`, donde solo el propietario tiene acceso completo y otros usuarios tienen permisos limitados para leer y ejecutar archivos, pero no para escribir en ellos. Estos ajustes ayudan a proteger los datos sensibles sin comprometer la funcionalidad necesaria del sistema.

```markdown
Terminal:

sudo chmod 777 -R /var/www/html/programaciondam2526

sudo = Realizo acción como administrador

chmod = cambio permisos

777 = le doy permiso a todo el mundo

-R = Lo quiero aplicar recursivo (a todo el contenido)

/var/www.... = la carpeta afectada

En el sistema de permisos UNIX (Linux,macOS)

1 numero para el usuario
1 numero para el grupo al que pertenece el usuario
1 numero para todo el resto


0 - ningún permiso
1 = solo ejectar
2 = solo escribir
3 = escribir y ejecutar
4 = solo leer
5 = leer y ejecutar
6 = leer y escribir
7 = leer, escribir y ejecutar

777 = permisible en tu maquina, no recomendable en produccion
usuario leer, escribir y ejecutar
grupo leer, escribir y ejecutar
todo el mundo leer, escribir y ejecutar

755 = posible para produccion
usuario leer, escribir y ejecutar
grupo leer y ejecutar
todo el mundo leer y ejecutar

644 = mas restrictivo para produccion
usuario leer y escribir
grupo solo leer
todo el mundo solo leer
```

### leer

#### Explicación

Este fragmento de código PHP se utiliza para leer el contenido de un archivo llamado "archivo.txt" y mostrarlo en la página web. Empezamos abriendo el archivo con `fopen`, especificando que queremos abrirlo solo para lectura ("r"). Luego, utilizamos la función `fread` para leer todo el contenido del archivo. Para esto, necesitamos saber cuántos bytes contiene el archivo, lo cual se obtiene con `filesize("archivo.txt")`. Finalmente, mostramos en pantalla el contenido leído usando `echo`, y cerramos el archivo con `fclose` para liberar los recursos.

Este tipo de código es importante porque permite a las páginas web interactuar con archivos en el servidor, lo que puede ser útil para mostrar datos almacenados o gestionar información del usuario de manera persistente.

```
<?php
  $archivo = fopen("archivo.txt", "r"); // "r" = leer/read
  
  // Parámetros 1.-Lo que lees 2.-Longitud de lo que lees
  $contenido = fread($archivo,filesize("archivo.txt"));
  
  echo $contenido;
  fclose($archivo);
?>
```

### array nombrado en php

#### Explicación

Este código es una pequeña parte de un programa que se usa para almacenar información sobre un cliente utilizando PHP, un lenguaje de programación muy popular en el desarrollo web. En este caso específico, estamos trabajando con arrays asociativos, que son estructuras de datos que nos permiten guardar y acceder a información usando nombres de campos más descriptivos que números.

El código comienza creando una variable llamada `$cliente` que es un array vacío. Luego, se añaden tres elementos al array: el nombre del cliente (`"Jose Vicente"`), los apellidos del cliente (`"Carratala Sanchis"`), y el correo electrónico del cliente (`"info@jocarsa.com"`). Estos datos están siendo almacenados con claves o nombres de campos como `'nombre'`, `'apellidos'` y `'email'`. Al final, se usa la función `var_dump()` para mostrar en pantalla toda la información que ha sido guardada en el array `$cliente`.

Este tipo de estructura es muy útil porque permite manejar fácilmente datos complejos como registros de usuarios o productos en una tienda online, sin tener que preocuparse por los índices numéricos.

```
<?php
  $cliente = [];
  $cliente['nombre'] = "Jose Vicente";
  $cliente['apellidos'] = "Carratala Sanchis";
  $cliente['email'] = "info@jocarsa.com";
  
  var_dump($cliente);
?>
```

### saco el array como json

#### Explicación

Este fragmento de código en PHP está diseñado para crear un array asociativo que representa información sobre un cliente y luego convertir ese array a formato JSON, lo cual es muy útil cuando necesitas enviar datos desde el servidor al navegador o a otros servicios web. El código comienza creando un array vacío llamado `$cliente`. Luego, se añaden tres pares clave-valor al array: nombre, apellidos y email del cliente. Después de completar este array con la información del cliente, se utiliza la función `json_encode()` para convertir el array en una cadena JSON. Finalmente, esta cadena JSON es enviada directamente a la página web actual mediante la función `echo`, permitiendo que otros scripts o navegadores puedan leer fácilmente los datos como JSON.

Esta conversión de arrays PHP a JSON es crucial en desarrollo web porque permite que diferentes partes del sistema (como bases de datos, servidores y aplicaciones cliente) compartan información de manera uniforme.

```
<?php
  $cliente = [];
  $cliente['nombre'] = "Jose Vicente";
  $cliente['apellidos'] = "Carratala Sanchis";
  $cliente['email'] = "info@jocarsa.com";
  
  $json = json_encode($cliente);
  echo $json;  
?>
```

### recuperamos el formulario

#### Explicación

Este código es un ejemplo de una página web simple que permite a los usuarios ingresar preguntas y respuestas en un formulario. Cuando el usuario envía el formulario, la información se convierte en formato JSON y se muestra en la parte inferior de la página. El archivo HTML incluye estilos CSS para darle una apariencia整洁的回复应该是：

---

这段代码是一个简单的网页示例，允许用户通过表单输入问题和答案。当用户提交表单时，页面底部会显示提交信息的JSON格式。HTML文件中包含了CSS样式来美化页面布局。

具体来说，表单部分包括两个文本输入框（一个问题和一个答案）以及一个用于提交表单的按钮。当表单通过POST方法被提交后，PHP代码块获取到`$_POST`变量中的数据，并将其转换为JSON格式字符串。然后将这个JSON字符串输出在页面底部。

该示例展示了前端表单与服务器端处理结合的基本原理，帮助学生理解如何从用户界面收集数据并在服务器上进行简单的展示或进一步的业务逻辑操作。这对于学习web开发的基础流程非常有帮助。

---

如果你需要更详细的解释或者其他特定方面的说明，请告诉我！

```
<!doctype html>
<html>
	<head>
  	<style>
    	body,html{width:100%;height:100%;padding:0px;margin:0px;}
      body{
      	display:flex;align-items:center;justify-content:center;
        background:lightgray;flex-direction:column;}
      header,footer,main{
      	width:400px;padding:20px;background:white;
        text-align:center;
        }
      form{display:flex;flex-direction:column;gap:10px;}
      input{padding:10px;}
    </style>
  </head>
  <body>
  	<header>
  		<h1>Preguntas y respuestas</h1>
    </header>
    <main>
    	<form action="?" method="POST">
      	<label for="pregunta">Introduce la pregunta</label>
      	<input type="text" name="pregunta" id="pregunta">
        <label for="respuesta">Introduce la respuesta</label>
      	<input type="text" name="respuesta" id="respuesta">
        <input type="submit">
      </form>
    </main>
    <footer>
    	(c) 2025 Jose Vicente Carratala
      <?php
      	$json = json_encode($_POST); 	// Convierte post a JSON
        echo $json;										// Y lo saca por pantalla
      ?>
    </footer>
  </body>
</html>
```

### y lo guardamos en el disco

#### Explicación

Este fragmento de código es una página web simple que permite a los usuarios introducir una pregunta y su respuesta, y luego guarda estos datos en un archivo JSON en el servidor. La parte principal del código se encuentra dentro de la etiqueta `<footer>`, donde está implementado el lenguaje de programación PHP.

Cuando alguien rellena el formulario en la página web e introduce tanto una pregunta como una respuesta, los datos viajan al servidor usando el método POST y son recibidos por PHP. En este punto, el código verifica si se ha enviado algún dato a través del formulario (específicamente si existe un campo llamado 'respuesta'). Si es así, convierte los datos enviados en formato JSON utilizando la función `json_encode()`. Luego, crea un nuevo archivo en el servidor con un nombre basado en una marca de tiempo actual (que se asegura de que cada archivo sea único), y guarda el contenido JSON dentro del archivo recién creado. Finalmente, cierra el archivo para liberar los recursos.

Este código es importante porque demuestra cómo capturar datos desde un formulario web y almacenarlos permanentemente en archivos individuales en el servidor, lo cual puede ser útil para guardar información de usuario o cualquier otro tipo de datos que necesiten persistir a largo plazo.

```
<!doctype html>
<html>
	<head>
  	<style>
    	body,html{width:100%;height:100%;padding:0px;margin:0px;}
      body{
      	display:flex;align-items:center;justify-content:center;
        background:lightgray;flex-direction:column;}
      header,footer,main{
      	width:400px;padding:20px;background:white;
        text-align:center;
        }
      form{display:flex;flex-direction:column;gap:10px;}
      input{padding:10px;}
    </style>
  </head>
  <body>
  	<header>
  		<h1>Preguntas y respuestas</h1>
    </header>
    <main>
    	<form action="?" method="POST">
      	<label for="pregunta">Introduce la pregunta</label>
      	<input type="text" name="pregunta" id="pregunta">
        <label for="respuesta">Introduce la respuesta</label>
      	<input type="text" name="respuesta" id="respuesta">
        <input type="submit">
      </form>
    </main>
    <footer>
    	(c) 2025 Jose Vicente Carratala
      <?php
      	if(isset($_POST['respuesta'])){
          $json = json_encode($_POST); 	// Convierte post a JSON
          $archivo = fopen(date('U').".json",'w');	// Abre un arhivo
          fwrite($archivo,$json);										// Guarda el json
          fclose($archivo);													// Cierra el archivo
        }
      ?>
    </footer>
  </body>
</html>
```

### 1764753558

#### Explicación

El fragmento de código que has proporcionado es un array vacío en formato JSON. En términos sencillos, esto significa que estás creando una lista en la que, por ahora, no hay ningún elemento guardado dentro de ella. Es como tener una caja sin nada en su interior. Aunque parezca simple, este tipo de estructura es fundamental porque puedes ir añadiendo elementos a esta lista conforme sea necesario o según los requerimientos del programa.

En el contexto de un proyecto web o un sistema de gestión de datos, usar un array vacío puede ser útil cuando estás preparando la estructura para recibir información que todavía no has recopilado. Por ejemplo, si estás creando una página web donde los usuarios pueden añadir comentarios y deseas tener listo el formato en el que almacenarás esos comentarios antes de que se hagan las primeras contribuciones. Esto es importante porque permite una estructura clara y preparada para futuras actualizaciones o entradas de datos, asegurando que todo está bien organizado desde el principio.

```json
[]
```

### 1764753566

#### Explicación

Este fragmento de código es un ejemplo simple en formato JSON (JavaScript Object Notation). JSON es una manera común y legible por humanos de transmitir datos estructurados entre sistemas, como entre el cliente y el servidor web. En este caso, el código representa un objeto JSON que contiene dos propiedades: "pregunta" y "respuesta". La propiedad "pregunta" tiene el valor "que dia es hoy", y la propiedad "respuesta" tiene el valor "miercoles".

Este formato de datos es importante porque permite a las aplicaciones web intercambiar información de manera sencilla y estándar. En contextos educativos, este tipo de código puede ayudarte a entender cómo se maneja la comunicación entre diferentes partes de una aplicación web, como el servidor que almacena los datos y el cliente que los solicita o muestra.

En resumen, este bloque básico de JSON es útil para comprender cómo se estructuran y transmiten pequeñas cantidades de información en aplicaciones basadas en web.

```json
{"pregunta":"que dia es hoy","respuesta":"miercoles"}
```

### archivo

#### Explicación

El fragmento de código que has proporcionado es muy breve y no incluye ninguna estructura específica o instrucciones claras. Sin embargo, parece que el texto se está generando dentro de un script PHP, que es comúnmente usado en páginas web para interactuar con bases de datos y manejar información del usuario.

En este caso, "Nuevo texto escrito desde PHP" podría ser parte de una operación donde PHP está escribiendo contenido directamente a un archivo o mostrándolo como salida en la página web. Sin más contexto, es difícil detallar cómo funciona exactamente el código, pero generalmente, cuando se trabaja con archivos en PHP (como el que mencionas: /var/www/html/programaciondam2526/010-Programación en el lado del servidor/003-Persistencia/101-Ejercicios/archivo.txt), puedes usar comandos como `file_put_contents()` para escribir datos en él o similar al mostrar contenido en la página web.

Es importante entender cómo PHP interactúa con archivos y bases de datos porque permite a los programadores guardar, recuperar y manipular información de manera eficiente en aplicaciones web.

```
Nuevo texto escrito desde PHP
```

### Actividades propuestas

### Actividades Propuestas:

1. **Escritura de Texto en Archivo**
   - **Descripción:** Los alumnos deben escribir un texto proporcionado por ellos mismos en un archivo `.txt` usando PHP y comprobar que el contenido se ha guardado correctamente. Se espera que aprendan cómo utilizar `fopen`, `fwrite` y `fclose`.

2. **Lectura de Archivo**
   - **Descripción:** Los alumnos tendrán que leer el contenido del archivo `.txt` creado en la actividad anterior utilizando PHP. La tarea consiste en mostrar el texto leído por pantalla con `echo`. Se espera que comprendan cómo usar `fread` y manejar archivos.

3. **Manejo de Permisos**
   - **Descripción:** Los estudiantes deben crear un script en línea de comandos (bash) que cambie los permisos del archivo `.txt` a 755, lo cual permite la lectura, escritura y ejecución para el propietario y sólo lectura y ejecución para otros. Se espera que aprendan sobre el sistema de permisos UNIX.

4. **Array Nombrado en PHP**
   - **Descripción:** Los alumnos deben crear un array nombrado con información personal (nombre, apellidos, email) utilizando PHP y mostrar los datos usando `var_dump`. Se espera que comprendan cómo definir e imprimir arrays asociativos en PHP.

5. **Serialización de Datos a JSON**
   - **Descripción:** Los estudiantes deben convertir el array creado en la actividad anterior a formato JSON con `json_encode` y mostrarlo por pantalla. Se espera que entiendan cómo serializar datos complejos a texto plano para almacenamiento o transmisión.

6. **Formulario Simple en PHP**
   - **Descripción:** Cada estudiante debe crear un formulario HTML básico que envíe los datos del usuario a un script PHP, el cual mostrará la información enviada en formato JSON. Se espera que aprendan cómo manejar formularios y procesar datos de entrada en PHP.

7. **Guardado de Datos en Archivo**
   - **Descripción:** Los alumnos deben modificar el formulario para guardar los datos recibidos en un archivo `.json` con nombres únicos basados en la fecha actual. Se espera que comprendan cómo escribir datos JSON directamente en archivos desde PHP.

8. **Lectura y Mostrado de Datos JSON**
   - **Descripción:** Los estudiantes deben leer el contenido del último archivo `.json` guardado por su formulario y mostrar los datos en una página web usando PHP. Se espera que aprendan a leer archivos JSON y manipular sus contenidos para presentación.

9. **Manejo de Formularios Avanzado**
   - **Descripción:** Los alumnos deben crear un sistema básico que permita agregar, listar y borrar entradas del formulario anteriormente creado en una única página PHP. Se espera que comprendan cómo gestionar múltiples operaciones CRUD (Crear, Leer, Actualizar, Borrar) con archivos.

10. **Refactorización de Códigos**
    - **Descripción:** Los estudiantes deben analizar y mejorar el código existente de varias actividades anteriores para mejor estilo y estructura, incluyendo la adición de funciones personalizadas y comentarios descriptivos. Se espera que aprendan a refactorizar código PHP existente para mejor mantenibilidad y legibilidad.

Estas actividades están diseñadas para ayudar a los estudiantes de Formación Profesional a mejorar sus habilidades en programación web, manejo de archivos, uso de JSON y desarrollo básico con PHP.


<a id="proyecto-ana"></a>
## Proyecto Ana

### Introducción a los ejercicios

En esta carpeta se encuentran una serie de ejercicios que te ayudarán a familiarizarte con la implementación y configuración de un proyecto web en el lado del servidor utilizando tecnologías como HTML, CSS, JavaScript y Python (Flask). El objetivo principal es desarrollar un entorno interactivo donde los usuarios puedan escribir código y ver los resultados en tiempo real. Estos ejercicios te permitirán aprender cómo crear interfaces de usuario simples con HTML y CSS, añadir funcionalidad interactiva mediante JavaScript, y finalmente, implementar una API backend que reciba y ejecute el código enviado por el cliente.

A través de estos problemas, practicarás competencias clave como la creación de interfaces web dinámicas, manejo del estado de sesiones en aplicaciones web, procesamiento de solicitudes HTTP POST, y ejecución segura de código Python.

### Analisis de tecnologias

#### Explicación

Este fragmento de código no es realmente un código de programación, sino más bien una lista de notas y consideraciones para el desarrollo web. En él se discute qué tecnologías son necesarias para un proyecto (HTML, CSS, JS y PHP) y las implicaciones que tienen estas tecnologías en la elección del alojamiento del sitio web.

La parte relevante es cuando menciona "Necesitamos PHP - GitHub pages descartado". Esto indica que el proyecto requiere PHP, pero GitHub Pages no soporta este lenguaje. Por eso se plantea la necesidad de buscar un servicio de alojamiento que sí lo permita.

Finalmente, sugiere opciones como Hostinger o Render, que son servicios que proporcionan hosting y soluciones en la nube para sitios web dinámicos que requieren PHP y otras tecnologías mencionadas. Es importante elegir correctamente el alojamiento porque afectará la funcionalidad del sitio web y su capacidad para ejecutar scripts como los de PHP.

```markdown
Necesitamos 
HTML, CSS, JS - Esto sin problema

Necesitamos PHP - GitHub pages descartado
Solución?

Contratación de un alojamiento (hosting) que tenga soporte para
HTML
CSS
JS
PHP

Ejemplo: hostinger
Via Render - servicio en la nube que os dé soporte o bien para 
```

### front

#### Explicación

Este fragmento de código es una página HTML básica que define la estructura fundamental de un sitio web. La etiqueta `<!doctype html>` al inicio indica que se trata de un documento HTML5, lo cual es importante para que los navegadores interpreten correctamente el contenido.

Dentro del bloque principal `<html lang="es">`, tenemos tres secciones principales: `<head>`, `<body>`, y las etiquetas que definen la estructura visual del sitio web. La sección `<body>` contiene elementos como `<header>`, `<main>`, y `<footer>`. Estos elementos son esenciales para proporcionar una organización clara de los contenidos, facilitando así su diseño y accesibilidad.

En el bloque principal (`<main>`), hay un div con la id "terminal" que tiene el atributo `contenteditable=true`. Esto significa que cualquier texto o contenido dentro de este div puede ser editado directamente por el usuario a través del navegador. Este tipo de interactividad es útil para crear interfaces más dinámicas, como una simulación de terminal en línea.

En resumen, este código proporciona un marco básico y estructurado para la página web, permitiendo que ciertas partes sean modificables directamente por el usuario, lo cual puede ser muy útil en aplicaciones interactivas.

```html
<!doctype html>
<html lang="es">
  <head>
  </head>
  <body>
    	<header>
    </header>
    <main>
      <div id="terminal" contenteditable=true>
      </div>
    </main>
    <footer>
    </footer>
  </body>
</html>
```

### estilizamos un poco

#### Explicación

Este código HTML crea una página web simple que simula un entorno de desarrollo básico para programación. En la sección `<head>`, el estilo CSS define cómo deben aparecer varios elementos en la página, como dos áreas principales y un botón. La área con el id `editor` es donde los usuarios podrán escribir código (pueden hacerlo porque tiene el atributo `contenteditable=true`) y está diseñada para parecerse a una ventana de edición con líneas monoespaciadas, fondo claro y borde redondeado. Por otro lado, la área con id `terminal` simula un terminal o consola donde podría mostrar el resultado del código escrito en el editor, pero también es editable y tiene un fondo negro como los típicos terminales de texto.

El botón "Compilar" se utiliza para representar una acción que usualmente compila el código (aunque en este ejemplo está solo estéticamente y no hace ninguna función real). Los elementos CSS `.ventana` aplican sombreado y bordes a ambas áreas, haciendo que parezcan ventanas de aplicación. Este tipo de diseño ayuda a los estudiantes o programadores a visualizar mejor su código y resultados como si estuvieran trabajando en un entorno de desarrollo integrado (IDE) simplificado.

```html
<!doctype html>
<html lang="es">
  <head>
    <style>
      #editor{
      	font-family:monospace;
        background:lightgray;color:black;padding:20px;
        width:400px;
        height:100px;margin:auto;
        margin-bottom:10px;
      }
      #terminal{
      	font-family:monospace;
        background:black;color:white;padding:20px;
        width:400px;
        height:50px;margin:auto;
      }
      .ventana{
      	border:1px solid grey;
        border-top:30px solid grey;
        border-radius:5px;
        box-shadow:0px 5px 10px rgba(0,0,0,0.3);
      }
      button{
        margin:auto;background:green;
        color:white;padding:10px;border-radius:5px;border:none;
      margin:auto;margin-bottom:10px;display:block;}
    </style>
  </head>
  <body>
    	<header>
    </header>
    <main>
      <div id="editor" contenteditable=true class="ventana"></div>
      <button>Compilar</button>
      <div id="terminal" contenteditable=true class="ventana"></div>
    </main>
    <footer>
    </footer>
  </body>
</html>
```

### javascript

#### Explicación

Este código HTML crea una página web muy básica que permite escribir y ejecutar pequeños bloques de código, simular un entorno de terminal básico y enviar el contenido escrito a un servidor (en este caso, solo imprime en la consola del navegador). La parte relevante para los estudiantes es cómo se usa JavaScript para interactuar con elementos HTML.

En la sección `<style>`, hay varias reglas CSS que definen el aspecto de dos áreas importantes: una área donde puedes escribir código (llamada "editor") y otra que simula un terminal o consola (llamada "terminal"). Estas áreas tienen bordes, sombreados y colores para hacerlas más visibles. Además, hay reglas específicas para los botones.

En la sección `<script>`, el código JavaScript selecciona un botón en particular usando `document.querySelector("button")` y le asigna una función de clic que, cuando el usuario hace clic en el botón, muestra por consola ("console.log") un mensaje indicando que "Vamos a enviar algo al servidor". Luego, esta función también captura el texto escrito dentro del editor (el área con id="editor").

Este tipo de código es importante porque demuestra cómo las páginas web pueden ser interactivas, permitiendo a los usuarios escribir y ejecutar bloques de código directamente desde la interfaz del navegador. Es un paso inicial hacia entender cómo se construyen aplicaciones web más complejas que interactúan con servidores y bases de datos.

```html
<!doctype html>
<html lang="es">
  <head>
    <style>
      #editor{
      	font-family:monospace;
        background:lightgray;color:black;padding:20px;
        width:400px;
        height:100px;margin:auto;
        margin-bottom:10px;
      }
      #terminal{
      	font-family:monospace;
        background:black;color:white;padding:20px;
        width:400px;
        height:50px;margin:auto;
      }
      .ventana{
      	border:1px solid grey;
        border-top:30px solid grey;
        border-radius:5px;
        box-shadow:0px 5px 10px rgba(0,0,0,0.3);
      }
      button{
        margin:auto;background:green;
        color:white;padding:10px;border-radius:5px;border:none;
      margin:auto;margin-bottom:10px;display:block;}
    </style>
  </head>
  <body>
    	<header>
    </header>
    <main>
      <div id="editor" contenteditable=true class="ventana"></div>
      <button>Compilar</button>
      <div id="terminal" contenteditable=true class="ventana"></div>
    </main>
    <footer>
    </footer>
    <script>
      let boton = document.querySelector("button")
      boton.onclick = function(){
      	console.log("Vamos a enviar algo al servidor")
        let codigo = document.querySelector("#editor").textContent
        console.log(codigo)
      }
    </script>
  </body>
</html>
```

### flask

#### Explicación

Este fragmento de código es una aplicación básica creada con la biblioteca Flask en Python. Lo que hace este código es establecer un servidor web muy simple que puede mostrar contenido creado con plantillas HTML cuando se accede a él desde un navegador.

En primer lugar, el programa importa las funciones necesarias de Flask y crea una instancia del objeto `Flask`, llamado `app`. Este objeto actúa como el corazón central de nuestra aplicación web. Luego, mediante la decoración `@app.route("/")`, especificamos que cuando alguien visite la dirección base del sitio web (también conocida como ruta raíz), se ejecutará la función `inicio()`. Esta función carga un archivo HTML llamado "frente.html" usando `render_template("frente.html")` y muestra este contenido en el navegador.

Finalmente, el bloque `if __name__ == "__main__":` asegura que nuestra aplicación solo corra si se ejecuta directamente (es decir, no importada como módulo en otro script), y la línea `app.run(debug=True)` arranca el servidor web con modo de depuración activado, lo cual es muy útil para detectar errores durante el desarrollo porque mostrará mensajes detallados sobre posibles problemas.

En resumen, este código te permite crear rápidamente un sitio web sencillo y realizar pruebas en tiempo real mientras estás programando.

```python
from flask import Flask, render_template 

app = Flask(__name__)

@app.route("/")
def inicio():
  return render_template("frente.html")

if __name__ == "__main__":
  app.run(debug=True)
```

### nuevo endpoint

#### Explicación

Este código está configurando un servidor web simple usando Flask, que es una biblioteca de Python muy popular para crear aplicaciones web. El archivo se encarga de manejar dos rutas diferentes: la ruta principal ("/") y otra llamada "/api". 

Cuando alguien accede a la ruta principal del sitio (por ejemplo, en su navegador), el servidor ejecuta la función `inicio()`, que renderiza un archivo HTML llamado "frente.html" para mostrarlo al usuario. Esto es útil cuando quieres presentar una página web estructurada y estilizada.

Por otro lado, si alguien visita la ruta "/api", se ejecuta la función `api()`. Esta función imprime el mensaje "He recibido algo" en el servidor (útil para saber que ha habido un intento de acceso a esa ruta) y simplemente devuelve la palabra "ok". Este tipo de configuración es típica cuando estás desarrollando una API, que es una forma en que las aplicaciones web pueden comunicarse entre sí enviando datos.

El código finaliza ejecutando el servidor Flask en modo de depuración (debug=True), lo cual ayuda a los desarrolladores porque muestra mensajes más detallados sobre errores y recarga automáticamente el servidor cuando se hace un cambio en el código. Esto es especialmente útil durante la fase inicial del desarrollo para detectar y corregir problemas rápidamente.

Esta estructura básica es fundamental para cualquier proyecto web que requiera manejar múltiples rutas y funcionalidades diferentes dentro de una misma aplicación.

```python
from flask import Flask, render_template 

app = Flask(__name__)

@app.route("/")
def inicio():
  return render_template("frente.html")

@app.route("/api")
def api():
  print("He recibido algo")
  return "ok"

if __name__ == "__main__":
  app.run(debug=True)
```

### estamos obligados a metodo

#### Explicación

Este código es una aplicación web simple creada usando Flask, un framework de Python muy popular para desarrollar aplicaciones web. La aplicación tiene dos funciones principales: mostrar el inicio de la página y ejecutar código que le envíen los usuarios a través de solicitudes POST.

En primer lugar, cuando un usuario accede al sitio web (ruta "/"), se carga una plantilla HTML llamada "frente.html" que probablemente contiene un formulario para enviar código. La segunda función importante está en la ruta "/api", donde espera recibir solicitudes POST que contienen código Python que los usuarios quieren ejecutar.

Cuando recibe un código, el programa intenta ejecutarlo (usando `exec`), pero antes redirige cualquier salida de texto (como impresiones) a un buffer especial (`io.StringIO`). Esto permite capturar todo lo que se imprime mientras se ejecuta el código para devolverlo más tarde al usuario. Si ocurre algún error durante la ejecución del código, como una sintaxis incorrecta o alguna excepción no controlada, se captura y devuelve directamente como respuesta con un código de estado HTTP 400 (Bad Request), indicando que algo salió mal.

Este tipo de aplicación es útil para permitir a los usuarios experimentar con Python en línea sin tener que configurar su propio entorno de desarrollo. Sin embargo, hay que tener cuidado porque ejecutar código desconocido puede ser peligroso si no se controla adecuadamente.

```python
from flask import Flask, render_template, request
import io
import contextlib


app = Flask(__name__)

@app.route("/")
def inicio():
  return render_template("frente.html")

@app.route("/api", methods=['POST'])
def api():
    codigo = request.data.decode("utf-8")

    buffer = io.StringIO()
    try:
        # Ejecuta el código y captura todo lo que se imprima
        with contextlib.redirect_stdout(buffer):
            exec(codigo, {})   # entorno global vacío (peligroso igualmente si no controlas el código)
    except Exception as e:
        return str(e), 400

    salida = buffer.getvalue()
    # Si no ha habido nada por pantalla, puedes devolver algo por defecto
    return salida if salida else "OK"

if __name__ == "__main__":
  app.run(debug=True)
```

### soporte multilinea

#### Explicación

Este fragmento de código es una aplicación web simple que utiliza Flask, un framework muy popular para crear aplicaciones web en Python. La aplicación tiene dos rutas principales: la página principal (`/`) y una API (`/api`). Cuando se accede a la ruta principal, se carga un archivo HTML llamado "frente.html" usando el método `render_template` de Flask.

La parte más interesante es la ruta `/api`, donde el código recibe datos enviados por POST (un tipo de solicitud HTTP). Estos datos son supuestamente un bloque de código Python que el usuario desea ejecutar. Para manejar esto, el programa usa una estructura de control `try-except` para capturar cualquier error que pueda ocurrir durante la ejecución del código proporcionado.

Dentro del bloque `try`, se utiliza `contextlib.redirect_stdout(buffer)` para redirigir todas las salidas estándar (como los mensajes de impresión) a un buffer en memoria (`io.StringIO`). Luego, el programa usa `exec(codigo, {})` para ejecutar el código recibido. Si ocurre algún error durante la ejecución del código, se captura y se devuelve como texto con un código de estado HTTP 400 (Bad Request), lo que indica al cliente que algo salió mal. Si no hay errores, cualquier salida generada por `print` dentro del código ejecutado es recuperada desde el buffer y devuelta como respuesta.

Esta implementación es útil para crear una especie de entorno interactivo en línea donde los usuarios pueden escribir y ejecutar bloques de código Python simples sin necesidad de tener un entorno local de desarrollo. Sin embargo, hay que tener cuidado con la seguridad ya que ejecutar código proporcionado por el usuario puede ser peligroso si no se controla adecuadamente.

```python
from flask import Flask, render_template, request
import io
import contextlib

app = Flask(__name__)

@app.route("/")
def inicio():
    return render_template("frente.html")

@app.route("/api", methods=['POST'])
def api():
    codigo = request.data.decode("utf-8")

    buffer = io.StringIO()
    try:
        # Ejecuta el código y captura todo lo que se imprima
        with contextlib.redirect_stdout(buffer):
            exec(codigo, {})
    except Exception as e:
        # devolvemos el error como texto y código 400
        return str(e), 400

    salida = buffer.getvalue()
    return salida if salida else "OK"

if __name__ == "__main__":
    app.run(debug=True)
```

### ampliaciones

#### Explicación

Este fragmento de código es una aplicación web sencilla creada con Flask que permite ejecutar y evaluar código Python enviado a través de la red. La aplicación tiene dos rutas principales: "/" y "/api".

La ruta "/" simplemente muestra un archivo HTML llamado "frenteampliado.html" al usuario cuando se abre el sitio en su navegador.

La ruta "/api" es donde ocurre toda la magia. Cuando un cliente envía una solicitud POST a "/api", esta función recibe los datos enviados, que incluyen el código Python que se desea ejecutar y las entradas que este código esperaría recibir de un usuario (como por ejemplo mediante la función input()). La aplicación prepara un entorno seguro para ejecutar ese código. Para hacer esto, reemplaza la función "input" del sistema con una versión personalizada que permite simular cómo el código interactuaría con un usuario real proporcionando las entradas necesarias.

Después de configurar este entorno seguro y preparado, se utiliza exec() para ejecutar el código en ese entorno. Si todo sale bien, la salida generada por el código se captura y se devuelve al cliente que hizo la solicitud. En caso de error durante la ejecución del código (como un error de sintaxis o una excepción no controlada), el error también se captura y se envía de vuelta al cliente con un código HTTP 400 indicando que hubo un problema.

Esta aplicación es útil para situaciones donde se desea permitir a los usuarios ejecutar pequeños trozos de código (por ejemplo, en un entorno seguro y controlado) sin poner en riesgo el sistema.

```python
from flask import Flask, render_template, request
import io
import contextlib
import traceback

app = Flask(__name__)

@app.route("/")
def inicio():
    return render_template("frenteampliado.html")

@app.route("/api", methods=['POST'])
def api():
    data = request.get_json(force=True)
    codigo = data.get("code", "")
    entradas = data.get("inputs", "")

    # Preparamos las líneas de entrada para input()
    input_lines = iter(entradas.splitlines())

    buffer = io.StringIO()

    def custom_input(prompt=""):
        # Mostrar el prompt en la salida
        print(prompt, end="", file=buffer)
        try:
            linea = next(input_lines)
            # Mostrar lo que "escribe" el usuario en la misma terminal
            print(linea, file=buffer)
            return linea
        except StopIteration:
            # No quedan más líneas de entrada
            print("\n[AVISO] No quedan más líneas de entrada (stdin). Se devuelve cadena vacía.", file=buffer)
            return ""

    # Entorno de ejecución
    global_env = {
        "__name__": "__main__",
        "input": custom_input,
    }

    try:
        with contextlib.redirect_stdout(buffer):
            with contextlib.redirect_stderr(buffer):
                exec(codigo, global_env)
    except Exception:
        error_text = traceback.format_exc()
        return error_text, 400

    salida = buffer.getvalue()
    return salida if salida else "OK"

if __name__ == "__main__":
    app.run(debug=True)
```

### mejoras

#### Explicación

Lo siento, pero no has proporcionado un fragmento de código para analizar y explicar. Por favor, comparte el bloque de código que deseas que explique en detalle. Una vez que lo hagas, estaré encantado de ayudarte a entender cómo funciona, qué hace y por qué es importante para tu proyecto o aprendizaje en programación.

```

```

### mejoras

#### Explicación

Este código es una aplicación web simple creada con Flask en Python que permite ejecutar y monitorear la ejecución de programas Python a través de una API. La idea principal es proporcionar una interfaz para enviar un programa Python, ejecutarlo línea por línea, leer su salida y finalmente cerrarlo cuando se acaba.

En primer lugar, el código importa varias bibliotecas necesarias y define una aplicación Flask llamada `app`. También hay una clase llamada `PythonSession` que maneja la creación de un proceso Python para ejecutar el código proporcionado. Esta clase guarda temporalmente el código en un archivo, lo lanza utilizando `subprocess.Popen`, y mantiene un hilo separado para leer cualquier salida del programa (tanto estándar como de error) y colocarlo en una cola.

La aplicación Flask tiene varias rutas definidas:
- `/api/start`: Esta ruta recibe el código Python a través de una solicitud POST, lo guarda temporalmente, y luego ejecuta ese código. Devuelve un ID de sesión único para que las demás solicitudes puedan referirse al mismo programa en ejecución.
- `/api/write`: Recibe una línea de código adicional a través de la solicitud POST e intenta enviarla al proceso Python asociado con el ID de sesión proporcionado.
- `/api/read`: Devuelve cualquier salida capturada del programa (por ejemplo, prints) y actualiza si el proceso aún está vivo.

La aplicación también tiene un hilo que lee continuamente cualquier salida del programa en ejecución y la guarda para ser recuperada por solicitudes futuras. Esto es importante porque permite una interacción suave con programas largos sin bloquear la web o perder datos de salida.

En resumen, esta pieza de código ofrece una forma fácil de ejecutar código Python a través de un navegador y ver en tiempo real los resultados de la ejecución, lo cual es muy útil para el aprendizaje interactivo de programación.

```python
from flask import Flask, render_template, request, jsonify
import subprocess
import threading
import queue
import uuid
import os
import tempfile

app = Flask(__name__)

# Almacenar sesiones de procesos
sessions = {}

class PythonSession:
    def __init__(self, code: str):
        # Guardamos el código en un archivo temporal
        fd, path = tempfile.mkstemp(suffix=".py", prefix="compilador_")
        os.write(fd, code.encode("utf-8"))
        os.close(fd)

        self.path = path
        self.proc = subprocess.Popen(
            ["python3", self.path],
            stdin=subprocess.PIPE,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            bufsize=1,  # line-buffered
        )
        self.queue = queue.Queue()
        self.alive = True

        # Hilo que lee stdout + stderr y los mete en la cola
        self.thread = threading.Thread(target=self._reader_thread, daemon=True)
        self.thread.start()

    def _reader_thread(self):
        try:
            for line in self.proc.stdout:
                self.queue.put(line)
            # cuando stdout se cierra, leemos también stderr restante
            err = self.proc.stderr.read()
            if err:
                self.queue.put(err)
        finally:
            self.proc.wait()
            self.alive = False
            # limpiar archivo temporal
            try:
                os.remove(self.path)
            except OSError:
                pass

    def write(self, data: str):
        if not self.alive:
            return
        try:
            self.proc.stdin.write(data + "\n")
            self.proc.stdin.flush()
        except Exception:
            self.alive = False

    def read_all(self) -> str:
        chunks = []
        while not self.queue.empty():
            try:
                chunks.append(self.queue.get_nowait())
            except queue.Empty:
                break
        return "".join(chunks)

    def is_alive(self) -> bool:
        return self.alive and self.proc.poll() is None


@app.route("/")
def inicio():
    return render_template("frentemasampliado.html")


@app.route("/api/start", methods=["POST"])
def api_start():
    data = request.get_json(force=True)
    code = data.get("code", "")

    session_id = str(uuid.uuid4())
    sessions[session_id] = PythonSession(code)

    return jsonify({"session_id": session_id})


@app.route("/api/write", methods=["POST"])
def api_write():
    data = request.get_json(force=True)
    session_id = data.get("session_id")
    line = data.get("line", "")

    sess = sessions.get(session_id)
    if not sess:
        return jsonify({"error": "Sesión no encontrada"}), 404

    sess.write(line)
    return jsonify({"ok": True})


@app.route("/api/read", methods=["GET"])
def api_read():
    session_id = request.args.get("session_id")
    sess = sessions.get(session_id)
    if not sess:
        return jsonify({"error": "Sesión no encontrada"}), 404

    output = sess.read_all()
    alive = sess.is_alive()

    # Si el proceso ha terminado y no queda nada que leer, limpiar la sesión
    if not alive and not output:
        sessions.pop(session_id, None)

    return jsonify({"output": output, "alive": alive})


if __name__ == "__main__":
    app.run(debug=True)
```

### Actividades propuestas

### Actividades Propuestas para Estudiantes de Formación Profesional

#### 1. **Configuración del Entorno de Desarrollo**
- **Descripción:** Configura un entorno de desarrollo que permita ejecutar código HTML, CSS y JavaScript localmente. Además, instala y configura Flask (Python) para implementar una aplicación web básica.
- **Objetivo:** Aprender a configurar correctamente el entorno de trabajo y entender cómo funcionan los servidores locales.

#### 2. **Desarrollo Front-end Básico**
- **Descripción:** Desarrolla un front-end básico que permita al usuario escribir código en un editor y ver la salida en una consola virtual.
- **Objetivo:** Familiarizarse con HTML, CSS y JavaScript para crear interfaces web interactivas.

#### 3. **Estilización de Elementos Web**
- **Descripción:** Mejora el diseño del front-end implementado anteriormente agregando estilos adicionales utilizando CSS.
- **Objetivo:** Aprender a utilizar selectores CSS y propiedades para mejorar la presentación visual de una página web.

#### 4. **Integración de JavaScript en HTML**
- **Descripción:** Agrega funcionalidades interactivas al front-end mediante el uso de JavaScript, como enviar datos del editor a un div terminal.
- **Objetivo:** Comprender cómo interactuar con elementos HTML desde scripts JS y manipular eventos básicos.

#### 5. **Conexión Front-end y Back-end Básica**
- **Descripción:** Implementa una conexión básica entre el front-end (HTML, CSS, JavaScript) y el back-end (Flask en Python), permitiendo al usuario enviar código a través de un endpoint.
- **Objetivo:** Aprender los fundamentos de comunicación entre el servidor y el cliente utilizando métodos HTTP.

#### 6. **Manejo de Métodos HTTP**
- **Descripción:** Modifica la aplicación Flask para manejar diferentes métodos HTTP (GET, POST) en función del endpoint.
- **Objetivo:** Comprender cómo los diferentes métodos HTTP son utilizados para realizar operaciones CRUD básicas.

#### 7. **Ejecución de Código Python desde un Servidor Web**
- **Descripción:** Implementa una funcionalidad que permita ejecutar código Python enviado por el cliente a través del servidor Flask.
- **Objetivo:** Aprender a utilizar Flask para procesar y responder solicitudes POST con datos dinámicos.

#### 8. **Manejo de Entradas en Códigos Ejecutables**
- **Descripción:** Mejora la funcionalidad existente permitiendo que el código ejecutable enviado por el cliente reciba entradas especificadas.
- **Objetivo:** Aprender a gestionar las entradas y salidas del servidor cuando se ejecuta código externo.

#### 9. **Mejoras en la Interactividad**
- **Descripción:** Desarrolla una interfaz que permita al usuario interactuar en tiempo real con el código Python ejecutado en el servidor.
- **Objetivo:** Aprender a utilizar hilos y colas para manejar interacciones asíncronas entre el cliente y el servidor.

#### 10. **Implementación de Sesiones Persistentes**
- **Descripción:** Implementa una funcionalidad que permita crear sesiones persistentes en la aplicación Flask, donde cada usuario pueda interactuar con su propio código Python.
- **Objetivo:** Comprender cómo gestionar múltiples conexiones simultáneas y mantener el estado de las mismas en un entorno de desarrollo.


<a id="includes"></a>
## includes

### contacto

```
<?php include "bloques/cabecera.php"; ?>
<p>Aqui solo pongo el contenido de la pagina de contacto</p>
<?php include "bloques/pie.php"; ?>
```

### index

```
<?php include "bloques/cabecera.php"; ?>
<p>Aqui solo pongo el contenido de la pagina principal</p>
<?php include "bloques/pie.php"; ?>
```

### sobremi

```
<?php include "bloques/cabecera.php"; ?>
<p>Aqui solo pongo el contenido de la página de sobre mi</p>
<?php include "bloques/pie.php"; ?>
```


<a id="repasito-de-cosas-de-github"></a>
## Repasito de cosas de GitHub


<a id="bloques"></a>
## Bloques

### paneldecontrol

```

```



<a id="git"></a>
# .git

<a id="branches"></a>
## branches


<a id="hooks"></a>
## hooks


<a id="info"></a>
## info


<a id="logs"></a>
## logs


<a id="objects"></a>
## objects


<a id="refs"></a>
## refs
